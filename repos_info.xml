<repo>
	<id>1</id>
	<name>grit</name>
	<description>**Grit is no longer maintained. Check out libgit2/rugged.** Grit gives you object oriented read/write access to Git repositories via Ruby.</description>n	<owner>mojombo</owner>
	<main_language>Ruby</main_language>
	<created_at>2007-10-29T14:37:16Z</created_at>
	<updated_at>2014-03-03T11:19:13Z</updated_at>
	<clone_url>https://github.com/mojombo/grit.git</clone_url>
	<languages>
		<language>Ruby</language>
	</languages>
	<branches>
		<branch>master</branch>
		<branch>no_raw_git</branch>
		<branch>patch-id</branch>
	</branches>
	<contributors>
		<contributor>mojombo</contributor>
		<contributor>schacon</contributor>
		<contributor>rtomayko</contributor>
		<contributor>technoweenie</contributor>
		<contributor>defunkt</contributor>
		<contributor>pjhyett</contributor>
		<contributor>rsanheim</contributor>
		<contributor>js</contributor>
		<contributor>tmm1</contributor>
		<contributor>therealadam</contributor>
		<contributor>chapados</contributor>
		<contributor>halorgium</contributor>
		<contributor>dkowis</contributor>
		<contributor>davetron5000</contributor>
		<contributor>peff</contributor>
		<contributor>Voker57</contributor>
		<contributor>hans</contributor>
		<contributor>cristibalan</contributor>
		<contributor>koraktor</contributor>
		<contributor>dysinger</contributor>
		<contributor>vmg</contributor>
		<contributor>bkeepers</contributor>
		<contributor>cho45</contributor>
		<contributor>bobbywilson0</contributor>
		<contributor>darwin</contributor>
		<contributor>cehoffman</contributor>
		<contributor>dustin</contributor>
		<contributor>franckverrot</contributor>
		<contributor>hiroshi</contributor>
		<contributor>igorw</contributor>
	</contributors>
	<commits>
		<commit>
			<sha>5608567286e64a1c55c5e7fcd415364e04f8986e</sha>
			<message>Merge pull request #183 from bkeepers/unmaintained

Clearly state the project status</message>
			<author_name>Brandon Keepers</author_name>
			<author_date>2014-02-03T19:24:07Z</author_date>
			<author_email>bkeepers@github.com</author_email>
			<committer_name>Brandon Keepers</committer_name>
			<committer_date>2014-02-03T19:24:07Z</committer_date>
			<committer_email>bkeepers@github.com</committer_email>
			<files>
				<file>
					<file_name>README.md</file_name>
					<diff>@@ -1,6 +1,8 @@
 Grit
 ====
 
+**Grit is no longer maintained. Check out [rugged](https://github.com/libgit2/rugged).**
+
 Grit gives you object oriented read/write access to Git repositories via Ruby.
 The main goals are stability and performance. To this end, some of the
 interactions with Git repositories are done by shelling out to the system's</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>83d3124f8dc2fbd5542041d1f84e6153612d5ed9</sha>
			<message>clarify status</message>
			<author_name>Brandon Keepers</author_name>
			<author_date>2014-01-28T19:04:39Z</author_date>
			<author_email>brandon@opensoul.org</author_email>
			<committer_name>Brandon Keepers</committer_name>
			<committer_date>2014-01-28T19:04:39Z</committer_date>
			<committer_email>brandon@opensoul.org</committer_email>
			<files>
				<file>
					<file_name>README.md</file_name>
					<diff>@@ -1,6 +1,8 @@
 Grit
 ====
 
+**Grit is no longer maintained. Check out [rugged](https://github.com/libgit2/rugged).**
+
 Grit gives you object oriented read/write access to Git repositories via Ruby.
 The main goals are stability and performance. To this end, some of the
 interactions with Git repositories are done by shelling out to the system's</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>b49a6ff4ccd169eef6671263ccb29d3ead957697</sha>
			<message>Fix Tempfile usage under ruby 1.8.7

There's no third argument to Tempfile#open under 1.8.7. The default
mode is w+ which should be fine and there's no encoding support so
the binary flag doesn't matter.</message>
			<author_name>Ryan Tomayko</author_name>
			<author_date>2013-02-23T22:36:43Z</author_date>
			<author_email>rtomayko@gmail.com</author_email>
			<committer_name>Ryan Tomayko</committer_name>
			<committer_date>2013-02-23T22:36:43Z</committer_date>
			<committer_email>rtomayko@gmail.com</committer_email>
			<files>
				<file>
					<file_name>lib/grit/git-ruby/internal/loose.rb</file_name>
					<diff>@@ -64,18 +64,23 @@ def get_raw_object(buf)
         # write an object to a temporary file, then atomically rename it
         # into place; this ensures readers never see a half-written file
         def safe_write(path, content)
-          Tempfile.open("tmp_obj_", File.dirname(path), :opt = "wb") do |f|
+          f =
+            if RUBY_VERSION = '1.9'
+              Tempfile.open("tmp_obj_", File.dirname(path), :opt = "wb")
+            else
+              Tempfile.open("tmp_obj_", File.dirname(path))
+            end
+          begin
             f.write content
             f.fsync
-            f.close
-            begin
-              File.link(f.path, path)
-            rescue Errno::EEXIST
-              # The path already exists; we raced with another process,
-              # but it's OK, because by definition the content is the
-              # same. So we can just ignore the error.
-            end
+            File.link(f.path, path)
+          rescue Errno::EEXIST
+            # The path already exists; we raced with another process,
+            # but it's OK, because by definition the content is the
+            # same. So we can just ignore the error.
+          ensure
             f.unlink
+            f.close
           end
         end
 </diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>58621d933b4aa846e87f943b48f3f91b65dfb191</sha>
			<message>Merge pull request #157 from github/atomic-object-writes

Atomic object writes</message>
			<author_name>Ryan Tomayko</author_name>
			<author_date>2013-02-23T21:53:16Z</author_date>
			<author_email>rtomayko@gmail.com</author_email>
			<committer_name>Ryan Tomayko</committer_name>
			<committer_date>2013-02-23T21:53:16Z</committer_date>
			<committer_email>rtomayko@gmail.com</committer_email>
			<files>
				<file>
					<file_name>lib/grit/git-ruby/internal/loose.rb</file_name>
					<diff>@@ -12,6 +12,7 @@
 require 'zlib'
 require 'digest/sha1'
 require 'grit/git-ruby/internal/raw_object'
+require 'tempfile'
 
 module Grit
   module GitRuby
@@ -60,6 +61,24 @@ def get_raw_object(buf)
           return RawObject.new(type, content)
         end
 
+        # write an object to a temporary file, then atomically rename it
+        # into place; this ensures readers never see a half-written file
+        def safe_write(path, content)
+          Tempfile.open("tmp_obj_", File.dirname(path), :opt = "wb") do |f|
+            f.write content
+            f.fsync
+            f.close
+            begin
+              File.link(f.path, path)
+            rescue Errno::EEXIST
+              # The path already exists; we raced with another process,
+              # but it's OK, because by definition the content is the
+              # same. So we can just ignore the error.
+            end
+            f.unlink
+          end
+        end
+
         # currently, I'm using the legacy format because it's easier to do
         # this function takes content and a type and writes out the loose object and returns a sha
         def put_raw_object(content, type)
@@ -76,9 +95,7 @@ def put_raw_object(content, type)
             content = Zlib::Deflate.deflate(store)
 
             FileUtils.mkdir_p(@directory+'/'+sha1[0...2])
-            File.open(path, 'wb') do |f|
-              f.write content
-            end
+            safe_write(path, content)
           end
           return sha1
         end</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>cdf0fdb3e19237a2fe8a2667d774a25b5fa46e76</sha>
			<message>fsync loose objects before moving into place

When we write a loose object to disk, we simply close the
file object before moving it into place. If the machine
crashes shortly after our write, the contents may not have
been committed to disk (depending your filesystem, usually
the metadata is, and you end up with a corrupt, zero-length
loose object file).

This is especially bad because we report that the object is
successfully written, which means we may have updated refs
to point to it. A corrupt object at that point means not
only does the operation fail, but the repository is left in
a corrupted and unusable state.

We can fix this by calling fsync on the object file before
linking it into place. Between this and the previous commit,
our object writing should now behave exactly like git's
internal routines.</message>
			<author_name>Jeff King</author_name>
			<author_date>2013-02-22T02:50:07Z</author_date>
			<author_email>peff@peff.net</author_email>
			<committer_name>Jeff King</committer_name>
			<committer_date>2013-02-22T02:50:07Z</committer_date>
			<committer_email>peff@peff.net</committer_email>
			<files>
				<file>
					<file_name>lib/grit/git-ruby/internal/loose.rb</file_name>
					<diff>@@ -66,6 +66,7 @@ def get_raw_object(buf)
         def safe_write(path, content)
           Tempfile.open("tmp_obj_", File.dirname(path), :opt = "wb") do |f|
             f.write content
+            f.fsync
             f.close
             begin
               File.link(f.path, path)</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>00a00543a7df025b6503de66b3b5aca4ddaa799b</sha>
			<message>make object writes atomic

When Grit writes a loose object via the LooseStorage class,
it just opens the object file and starts writing. This works
most of the time, but can be a problem in some corner cases,
including:

  1. If another process tries to write the same object
     simultaneously, the writes may be interleaved and the
     object can be corrupted.

  2. If another process tries to read the object
     simultaneously, it may see the object in a half-written
     state.

  3. If the process or machine crashes during the write, we
     may leave a half-written corrupt object.

This can be solved by writing the object to a temporary file
and linking it into place. This is the same strategy used by
git itself.</message>
			<author_name>Jeff King</author_name>
			<author_date>2013-02-22T02:40:24Z</author_date>
			<author_email>peff@peff.net</author_email>
			<committer_name>Jeff King</committer_name>
			<committer_date>2013-02-22T02:49:53Z</committer_date>
			<committer_email>peff@peff.net</committer_email>
			<files>
				<file>
					<file_name>lib/grit/git-ruby/internal/loose.rb</file_name>
					<diff>@@ -12,6 +12,7 @@
 require 'zlib'
 require 'digest/sha1'
 require 'grit/git-ruby/internal/raw_object'
+require 'tempfile'
 
 module Grit
   module GitRuby
@@ -60,6 +61,23 @@ def get_raw_object(buf)
           return RawObject.new(type, content)
         end
 
+        # write an object to a temporary file, then atomically rename it
+        # into place; this ensures readers never see a half-written file
+        def safe_write(path, content)
+          Tempfile.open("tmp_obj_", File.dirname(path), :opt = "wb") do |f|
+            f.write content
+            f.close
+            begin
+              File.link(f.path, path)
+            rescue Errno::EEXIST
+              # The path already exists; we raced with another process,
+              # but it's OK, because by definition the content is the
+              # same. So we can just ignore the error.
+            end
+            f.unlink
+          end
+        end
+
         # currently, I'm using the legacy format because it's easier to do
         # this function takes content and a type and writes out the loose object and returns a sha
         def put_raw_object(content, type)
@@ -76,9 +94,7 @@ def put_raw_object(content, type)
             content = Zlib::Deflate.deflate(store)
 
             FileUtils.mkdir_p(@directory+'/'+sha1[0...2])
-            File.open(path, 'wb') do |f|
-              f.write content
-            end
+            safe_write(path, content)
           end
           return sha1
         end</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>75cf040563bc691a25002e4fc268243e89797772</sha>
			<message>Merge pull request #149 from shepmaster/patch-1

Correct spelling of "represent"</message>
			<author_name>Zach Holman</author_name>
			<author_date>2012-12-17T04:32:55Z</author_date>
			<author_email>zach@zachholman.com</author_email>
			<committer_name>Zach Holman</committer_name>
			<committer_date>2012-12-17T04:32:55Z</committer_date>
			<committer_email>zach@zachholman.com</committer_email>
			<files>
				<file>
					<file_name>lib/grit/repo.rb</file_name>
					<diff>@@ -399,7 +399,7 @@ def fast_forwardable?(to, from)
     # The Commits objects that are newer than the specified date.
     # Commits are returned in chronological order.
     #   +start+ is the branch/commit name (default 'master')
-    #   +since+ is a string represeting a date/time
+    #   +since+ is a string representing a date/time
     #   +extra_options+ is a hash of extra options
     #
     # Returns Grit::Commit[] (baked)</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>1e70a6902ebb0e3542cc365110ce2228e2f0a9fc</sha>
			<message>Correct spelling of "represent"</message>
			<author_name>Jake Goulding</author_name>
			<author_date>2012-12-02T16:06:51Z</author_date>
			<author_email>shepmaster@mac.com</author_email>
			<committer_name>Jake Goulding</committer_name>
			<committer_date>2012-12-02T16:06:51Z</committer_date>
			<committer_email>shepmaster@mac.com</committer_email>
			<files>
				<file>
					<file_name>lib/grit/repo.rb</file_name>
					<diff>@@ -399,7 +399,7 @@ def fast_forwardable?(to, from)
     # The Commits objects that are newer than the specified date.
     # Commits are returned in chronological order.
     #   +start+ is the branch/commit name (default 'master')
-    #   +since+ is a string represeting a date/time
+    #   +since+ is a string representing a date/time
     #   +extra_options+ is a hash of extra options
     #
     # Returns Grit::Commit[] (baked)</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>4cdb531daea7551d8e69e52744f75187c51cfa80</sha>
			<message>Merge pull request #140 from sbryant/fix_rev_parse

Fix an edge case in rev_parse.</message>
			<author_name>Ryan Tomayko</author_name>
			<author_date>2012-09-04T21:54:08Z</author_date>
			<author_email>rtomayko@gmail.com</author_email>
			<committer_name>Ryan Tomayko</committer_name>
			<committer_date>2012-09-04T21:54:08Z</committer_date>
			<committer_email>rtomayko@gmail.com</committer_email>
			<files>
				<file>
					<file_name>lib/grit/git-ruby.rb</file_name>
					<diff>@@ -75,7 +75,10 @@ def rev_list(options, *refs)
     def rev_parse(options, string)
       raise RuntimeError, "invalid string: #{string.inspect}" unless string.is_a?(String)
 
-      if string =~ /\.\./
+      # Split ranges, but don't split when specifying a ref:path.
+      # Don't split HEAD:some/path/in/repo..txt
+      # Do split sha1..sha2
+      if string !~ /:/ && string =~ /\.\./
         (sha1, sha2) = string.split('..')
         return [rev_parse({}, sha1), rev_parse({}, sha2)]
       end</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>3811d8137e361a3874db514eeda1e4ea5cdbe062</sha>
			<message>Fix an edge case in rev_parse.

Make sure we don't split on a `ref:path' revision.</message>
			<author_name>Sean Bryant</author_name>
			<author_date>2012-09-02T20:31:12Z</author_date>
			<author_email>sbryant@github.com</author_email>
			<committer_name>Sean Bryant</committer_name>
			<committer_date>2012-09-02T20:31:12Z</committer_date>
			<committer_email>sbryant@github.com</committer_email>
			<files>
				<file>
					<file_name>lib/grit/git-ruby.rb</file_name>
					<diff>@@ -75,7 +75,10 @@ def rev_list(options, *refs)
     def rev_parse(options, string)
       raise RuntimeError, "invalid string: #{string.inspect}" unless string.is_a?(String)
 
-      if string =~ /\.\./
+      # Split ranges, but don't split when specifying a ref:path.
+      # Don't split HEAD:some/path/in/repo..txt
+      # Do split sha1..sha2
+      if string !~ /:/ && string =~ /\.\./
         (sha1, sha2) = string.split('..')
         return [rev_parse({}, sha1), rev_parse({}, sha2)]
       end</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>83658e5a82f70e6dedbc12cb9a20d02a18338efe</sha>
			<message>Merge pull request #111 from pda/patch-2

Minor typo fix in documentation: “buy” → “by”.</message>
			<author_name>Aman Gupta</author_name>
			<author_date>2012-08-01T18:26:36Z</author_date>
			<author_email>aman@tmm1.net</author_email>
			<committer_name>Aman Gupta</committer_name>
			<committer_date>2012-08-01T18:26:36Z</committer_date>
			<committer_email>aman@tmm1.net</committer_email>
			<files>
				<file>
					<file_name>lib/grit/git-ruby.rb</file_name>
					<diff>@@ -3,7 +3,7 @@
 module Grit
 
   # the functions in this module intercept the calls to git binary
-  # made buy the grit objects and attempts to run them in pure ruby
+  # made by the grit objects and attempts to run them in pure ruby
   # if it will be faster, or if the git binary is not available (!!TODO!!)
   module GitRuby
 </diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>27d113314a448e844cba874641079c3e5cd53a83</sha>
			<message>Minor typo fix: “buy” → “by”.</message>
			<author_name>Paul Annesley</author_name>
			<author_date>2012-04-27T04:49:54Z</author_date>
			<author_email>paul@annesley.cc</author_email>
			<committer_name>Paul Annesley</committer_name>
			<committer_date>2012-04-27T04:49:54Z</committer_date>
			<committer_email>paul@annesley.cc</committer_email>
			<files>
				<file>
					<file_name>lib/grit/git-ruby.rb</file_name>
					<diff>@@ -3,7 +3,7 @@
 module Grit
 
   # the functions in this module intercept the calls to git binary
-  # made buy the grit objects and attempts to run them in pure ruby
+  # made by the grit objects and attempts to run them in pure ruby
   # if it will be faster, or if the git binary is not available (!!TODO!!)
   module GitRuby
 </diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>7219ef6f98808069617fc0ac9e80f3bdfc68e990</sha>
			<message>Release 2.5.0</message>
			<author_name>Tom Preston-Werner</author_name>
			<author_date>2012-04-22T07:02:35Z</author_date>
			<author_email>tom@mojombo.com</author_email>
			<committer_name>Tom Preston-Werner</committer_name>
			<committer_date>2012-04-22T07:02:35Z</committer_date>
			<committer_email>tom@mojombo.com</committer_email>
			<files>
				<file>
					<file_name>History.txt</file_name>
					<diff>@@ -1,4 +1,4 @@
-== HEAD
+== 2.5.0 / 2012-04-22
   * Minor Enhancements
     * 100% Git-compliant actor creation.
     * Handle newlines in author/committer.</diff>
				</file>
				<file>
					<file_name>grit.gemspec</file_name>
					<diff>@@ -4,8 +4,8 @@ Gem::Specification.new do |s|
   s.rubygems_version = '1.3.5'
 
   s.name              = 'grit'
-  s.version           = '2.4.1'
-  s.date              = '2011-01-13'
+  s.version           = '2.5.0'
+  s.date              = '2012-04-22'
   s.rubyforge_project = 'grit'
 
   s.summary     = "Ruby Git bindings."</diff>
				</file>
				<file>
					<file_name>lib/grit.rb</file_name>
					<diff>@@ -49,7 +49,7 @@
 require 'grit/merge'
 
 module Grit
-  VERSION = '2.4.1'
+  VERSION = '2.5.0'
 
   class  self
     # Set +debug+ to true to log all git calls and responses</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>3dd591fe4007fa9b4aaa062e082a86e1cbf4bbf7</sha>
			<message>Update History.</message>
			<author_name>Tom Preston-Werner</author_name>
			<author_date>2012-04-22T06:58:44Z</author_date>
			<author_email>tom@mojombo.com</author_email>
			<committer_name>Tom Preston-Werner</committer_name>
			<committer_date>2012-04-22T06:58:44Z</committer_date>
			<committer_email>tom@mojombo.com</committer_email>
			<files>
				<file>
					<file_name>History.txt</file_name>
					<diff>@@ -1,8 +1,18 @@
-== git
+== HEAD
+  * Minor Enhancements
+    * 100% Git-compliant actor creation.
+    * Handle newlines in author/committer.
+    * Grit::Git check_applies/patch related methods take command hash.
+    * Tags api now resty.
+    * Remove all the grit jruby hacks in favor of updated posix-spawn.
+    * Add Grit::Commit#patch_id.
+    * Support large packfiles with index v2.
   * Bug Fixes
     * Fix Loose Objects with non-ASCII content in Ruby 1.9
     * Fix bugs in Grit::Repo #objects, #commit_objects, and #diff_objects
       due to passing multiple arguments in a single argv element.
+    * ruby rev_list passes --verify to native rev_parse in fallback.
+    * Git ls-tree raises on non-zero exit.
 
 == 2.4.1 / 2011-01-13
   * Minor Enhancements</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>f87da75a4ab2f2de7201370c9e8b1da99e703eef</sha>
			<message>omg grit why do you try to be as slow as possible with everything</message>
			<author_name>Ryan Tomayko</author_name>
			<author_date>2012-04-22T06:54:55Z</author_date>
			<author_email>ryan@github.com</author_email>
			<committer_name>Aman Gupta</committer_name>
			<committer_date>2012-04-22T06:54:55Z</committer_date>
			<committer_email>aman@tmm1.net</committer_email>
			<files>
				<file>
					<file_name>lib/grit/commit.rb</file_name>
					<diff>@@ -60,7 +60,7 @@ def initialize(repo, id, parents, tree, author, authored_date, committer, commit
       @committer = committer
       @committed_date = committed_date
       @message = message.join("\n")
-      @short_message = message.select { |x| !x.strip.empty? }[0] || ''
+      @short_message = message.find { |x| !x.strip.empty? } || ''
     end
 
     def id_abbrev</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>51f8fc1eb8d4340a258eb722787addb4972e6bd5</sha>
			<message>Grit::Blame can load lines from cache</message>
			<author_name>Ryan Tomayko</author_name>
			<author_date>2012-04-22T06:54:41Z</author_date>
			<author_email>ryan@github.com</author_email>
			<committer_name>Aman Gupta</committer_name>
			<committer_date>2012-04-22T06:54:41Z</committer_date>
			<committer_email>aman@tmm1.net</committer_email>
			<files>
				<file>
					<file_name>lib/grit/blame.rb</file_name>
					<diff>@@ -4,12 +4,16 @@ class Blame
 
     attr_reader :lines
 
-    def initialize(repo, file, commit)
+    def initialize(repo, file, commit, lines=nil)
       @repo = repo
       @file = file
       @commit = commit
-      @lines = []
-      load_blame
+      if lines.nil?
+        @lines = []
+        load_blame
+      else
+        @lines = lines
+      end
     end
 
     def load_blame</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>3fc864f3c637e06e2fa7a81f6b48a5df58a9bc5b</sha>
			<message>git ls-tree raises on non-zero exit</message>
			<author_name>Simon Rozet</author_name>
			<author_date>2012-01-27T01:05:32Z</author_date>
			<author_email>simon@rozet.name</author_email>
			<committer_name>Simon Rozet</committer_name>
			<committer_date>2012-01-27T01:05:32Z</committer_date>
			<committer_email>simon@rozet.name</committer_email>
			<files>
				<file>
					<file_name>lib/grit/tree.rb</file_name>
					<diff>@@ -15,7 +15,7 @@ class Tree
     #
     # Returns Grit::Tree (baked)
     def self.construct(repo, treeish, paths = [])
-      output = repo.git.ls_tree({}, treeish, *paths)
+      output = repo.git.ls_tree({:raise = true}, treeish, *paths)
       self.allocate.construct_initialize(repo, treeish, output)
     end
 </diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>8b5449e559879d74224bce3c9c52b0d17bbc0b4b</sha>
			<message>Merge pull request #103 from peff/master

support large packfiles with index v2</message>
			<author_name>Ryan Tomayko</author_name>
			<author_date>2011-12-29T23:25:44Z</author_date>
			<author_email>rtomayko@gmail.com</author_email>
			<committer_name>Ryan Tomayko</committer_name>
			<committer_date>2011-12-29T23:25:44Z</committer_date>
			<committer_email>rtomayko@gmail.com</committer_email>
			<files>
				<file>
					<file_name>lib/grit/git-ruby/internal/pack.rb</file_name>
					<diff>@@ -30,6 +30,7 @@ class PackStorage
         SHA1Size = 20
         IdxOffsetSize = 4
         OffsetSize = 4
+        ExtendedOffsetSize = 8
         CrcSize = 4
         OffsetStart = FanOutCount * IdxOffsetSize
         SHA1Start = OffsetStart + OffsetSize
@@ -214,6 +215,12 @@ def find_object_in_index(idx, sha1)
               else
                 pos = OffsetStart + (@size * (SHA1Size + CrcSize)) + (mid * OffsetSize)
                 offset = idx[pos, OffsetSize].unpack('N')[0]
+                if offset & 0x80000000  0
+                  offset &= 0x7fffffff
+                  pos = OffsetStart + (@size * (SHA1Size + CrcSize + OffsetSize)) + (offset * ExtendedOffsetSize)
+                  words = idx[pos, ExtendedOffsetSize].unpack('NN')
+                  offset = (words[0]  32) | words[1]
+                end
                 return offset
               end
             else</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>7b5c49eff7c7f12866e5ff3ca554635fed5c7c11</sha>
			<message>support large packfiles with index v2

Grit has known about the "v2" pack index format for a while.
However, it never actually handled the extended offsets that
we get when indexing packfiles that are larger than 2
gigabytes.

When an object is at an offset smaller than 2G, its byte
offset into the packfile is placed in the first table of
4-byte offset values. If it's past that, then the MSB is set
on its offset in the 4-byte table, and the rest of the
4-byte integer specifies an offset into an 8-byte table that
follows.

With this patch, grit should handle arbitrarily large packs
(limited only by the pack format itself).

A few notes on the patch itself:

  - I unpack using two "N" formats instead of "Q", because
    "Q" is not available in ruby  1.9.3

  - No automated test is included, because you need a
    packfile that is greater than 2G. I did test it by hand.</message>
			<author_name>Jeff King</author_name>
			<author_date>2011-12-23T08:09:50Z</author_date>
			<author_email>peff@peff.net</author_email>
			<committer_name>Jeff King</committer_name>
			<committer_date>2011-12-23T08:16:04Z</committer_date>
			<committer_email>peff@peff.net</committer_email>
			<files>
				<file>
					<file_name>lib/grit/git-ruby/internal/pack.rb</file_name>
					<diff>@@ -30,6 +30,7 @@ class PackStorage
         SHA1Size = 20
         IdxOffsetSize = 4
         OffsetSize = 4
+        ExtendedOffsetSize = 8
         CrcSize = 4
         OffsetStart = FanOutCount * IdxOffsetSize
         SHA1Start = OffsetStart + OffsetSize
@@ -214,6 +215,12 @@ def find_object_in_index(idx, sha1)
               else
                 pos = OffsetStart + (@size * (SHA1Size + CrcSize)) + (mid * OffsetSize)
                 offset = idx[pos, OffsetSize].unpack('N')[0]
+                if offset & 0x80000000  0
+                  offset &= 0x7fffffff
+                  pos = OffsetStart + (@size * (SHA1Size + CrcSize + OffsetSize)) + (offset * ExtendedOffsetSize)
+                  words = idx[pos, ExtendedOffsetSize].unpack('NN')
+                  offset = (words[0]  32) | words[1]
+                end
                 return offset
               end
             else</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>ff015074ef35bd94cba943f9c0f98e161ab5851c</sha>
			<message>100% Git-compliant actor creation

Some more tweaks here:

	- Do not use `strftime`, because it's not assured
	to be cross-platform

	- Use C-like string formatting for Great Glory
	When Printing Numbers.

	- Always print an email address -- even if we don't
	have one. A missing email field will crash `fsck`.</message>
			<author_name>Vicent Marti</author_name>
			<author_date>2011-08-20T05:46:50Z</author_date>
			<author_email>tanoku@gmail.com</author_email>
			<committer_name>Vicent Marti</committer_name>
			<committer_date>2011-08-20T05:50:25Z</committer_date>
			<committer_email>tanoku@gmail.com</committer_email>
			<files>
				<file>
					<file_name>lib/grit/actor.rb</file_name>
					<diff>@@ -34,11 +34,13 @@ def self.from_string(str)
     #
     # Returns a String.
     def output(time)
-      out = @name.to_s.dup
-      if @email
-        out  " #{@email}"
-      end
-      out  time.strftime(" %s %z")
+      offset = time.utc_offset / 60
+      "%s %s %d %+.2d%.2d" % [
+        @name,
+        @email || "null",
+        time.to_i,
+        offset / 60,
+        offset.abs % 60]
     end
 
     # Pretty object inspection</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>e33fad9e988f6014d9872c264e4f342941d9f6a6</sha>
			<message>Properly print time offsets</message>
			<author_name>Vicent Marti</author_name>
			<author_date>2011-08-16T23:16:12Z</author_date>
			<author_email>tanoku@gmail.com</author_email>
			<committer_name>Chris Wanstrath</committer_name>
			<committer_date>2011-08-17T19:03:40Z</committer_date>
			<committer_email>chris@ozmm.org</committer_email>
			<files>
				<file>
					<file_name>lib/grit/actor.rb</file_name>
					<diff>@@ -38,9 +38,7 @@ def output(time)
       if @email
         out  " #{@email}"
       end
-      hours = (time.utc_offset.to_f / 3600).to_i # 60 * 60, seconds to hours
-      rem   = time.utc_offset.abs % 3600
-      out  " #{time.to_i} #{hours = 0 ? :+ : :-}#{hours.abs.to_s.rjust(2, '0')}#{rem.to_s.rjust(2, '0')}"
+      out  time.strftime(" %s %z")
     end
 
     # Pretty object inspection</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>a9dbc43a2f8b82ce7698fa118466177a2929e45e</sha>
			<message>handle newlines in author / committer

This shouldn't technically be allowed but we've seen a few cases of
it in existing repositories on github.com so let's just deal with
it.</message>
			<author_name>Ryan Tomayko</author_name>
			<author_date>2011-07-10T21:24:38Z</author_date>
			<author_email>rtomayko@gmail.com</author_email>
			<committer_name>Ryan Tomayko</committer_name>
			<committer_date>2011-07-10T22:27:04Z</committer_date>
			<committer_email>rtomayko@gmail.com</committer_email>
			<files>
				<file>
					<file_name>lib/grit/commit.rb</file_name>
					<diff>@@ -148,8 +148,13 @@ def self.list_from_string(repo, text)
         parents = []
         parents  lines.shift.split.last while lines.first =~ /^parent/
 
-        author, authored_date = self.actor(lines.shift)
-        committer, committed_date = self.actor(lines.shift)
+        author_line = lines.shift
+        author_line  lines.shift if lines[0] !~ /^committer /
+        author, authored_date = self.actor(author_line)
+
+        committer_line = lines.shift
+        committer_line  lines.shift if lines[0] && lines[0] != '' && lines[0] !~ /^encoding/
+        committer, committed_date = self.actor(committer_line)
 
         # not doing anything with this yet, but it's sometimes there
         encoding = lines.shift.split.last if lines.first =~ /^encoding/</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>568935ddda3168ddbe876163ace842eeb3d62e0a</sha>
			<message>Merge pull request #78 from kevinsawicki/patch-1

Fix typo in tree method doc</message>
			<author_name>Aman Gupta</author_name>
			<author_date>2011-07-01T23:02:45Z</author_date>
			<author_email>aman@tmm1.net</author_email>
			<committer_name>Aman Gupta</committer_name>
			<committer_date>2011-07-01T23:02:45Z</committer_date>
			<committer_email>aman@tmm1.net</committer_email>
			<files>
				<file>
					<file_name>lib/grit/repo.rb</file_name>
					<diff>@@ -480,7 +480,7 @@ def diff_objects(commit_sha, parents = true)
 
     # The Tree object for the given treeish reference
     #   +treeish+ is the reference (default 'master')
-    #   +paths+ is an optional Array of directory paths to restrict the tree (deafult [])
+    #   +paths+ is an optional Array of directory paths to restrict the tree (default [])
     #
     # Examples
     #   repo.tree('master', ['lib/'])</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>8e2715471201a764bb172775dd9892e469c6fc28</sha>
			<message>Fix typo in tree method doc</message>
			<author_name>Kevin Sawicki</author_name>
			<author_date>2011-07-01T16:59:50Z</author_date>
			<author_email>kevin@github.com</author_email>
			<committer_name>Kevin Sawicki</committer_name>
			<committer_date>2011-07-01T16:59:50Z</committer_date>
			<committer_email>kevin@github.com</committer_email>
			<files>
				<file>
					<file_name>lib/grit/repo.rb</file_name>
					<diff>@@ -480,7 +480,7 @@ def diff_objects(commit_sha, parents = true)
 
     # The Tree object for the given treeish reference
     #   +treeish+ is the reference (default 'master')
-    #   +paths+ is an optional Array of directory paths to restrict the tree (deafult [])
+    #   +paths+ is an optional Array of directory paths to restrict the tree (default [])
     #
     # Examples
     #   repo.tree('master', ['lib/'])</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>cb2644c4e8b472b7d4021ccf6e6d5496a29269b0</sha>
			<message>remove tests for stuff @schacon removed</message>
			<author_name>Ryan Tomayko</author_name>
			<author_date>2011-06-22T07:00:02Z</author_date>
			<author_email>rtomayko@gmail.com</author_email>
			<committer_name>Ryan Tomayko</committer_name>
			<committer_date>2011-06-22T07:00:02Z</committer_date>
			<committer_email>rtomayko@gmail.com</committer_email>
			<files>
				<file>
					<file_name>test/test_blame_tree.rb</file_name>
					<diff>@@ -1,33 +0,0 @@
-require File.dirname(__FILE__) + '/helper'
-require 'pp'
-
-class TestBlameTree  Test::Unit::TestCase
-
-  def setup
-    @git = Git.new(File.join(File.dirname(__FILE__), *%w[dot_git]))
-  end
-
-  def test_blame_tree
-    commit = '2d3acf90f35989df8f262dc50beadc4ee3ae1560'
-    tree = @git.blame_tree(commit)
-    last_commit_sha = tree['History.txt']
-    assert_equal last_commit_sha, '7bcc0ee821cdd133d8a53e8e7173a334fef448aa'
-  end
-
-  def test_blame_tree_path
-    commit = '2d3acf90f35989df8f262dc50beadc4ee3ae1560'
-    tree = @git.blame_tree(commit, 'lib')
-    last_commit_sha = tree['lib/grit.rb']
-    assert_equal last_commit_sha, '5a0943123f6872e75a9b1dd0b6519dd42a186fda'
-    last_commit_sha = tree['lib/grit']
-    assert_equal last_commit_sha, '2d3acf90f35989df8f262dc50beadc4ee3ae1560'
-  end
-
-  def test_blame_tree_multi_path
-    commit = '2d3acf90f35989df8f262dc50beadc4ee3ae1560'
-    tree = @git.blame_tree(commit, 'lib/grit')
-    last_commit_sha = tree['lib/grit/diff.rb']
-    assert_equal last_commit_sha, '22825175e37f22c9418d756ca69b574d75602994'
-  end
-
-end
\ No newline at end of file</diff>
				</file>
				<file>
					<file_name>test/test_file_index.rb</file_name>
					<diff>@@ -1,56 +0,0 @@
-require File.dirname(__FILE__) + '/helper'
-
-class TestFileIndex  Test::Unit::TestCase
-
-  def setup_a
-    @findex = Grit::GitRuby::FileIndex.new(File.join(File.dirname(__FILE__), *%w[dot_git]))
-    @commit = 'c12f398c2f3c4068ca5e01d736b1c9ae994b2138'
-  end
-
-  def test_count_all
-    setup_a
-    assert_equal 107, @findex.count_all
-  end
-
-  def test_count
-    setup_a
-    assert_equal 20, @findex.count(@commit)
-  end
-
-  def test_files
-    setup_a
-    files = @findex.files(@commit)
-    assert_equal 4, files.size
-    assert_equal "lib/grit/blob.rb", files.first
-  end
-
-  def test_commits_for
-    setup_a
-    commits = @findex.commits_for('lib/grit/blob.rb')
-    assert commits.include?('3e0955045cb189a7112015c26132152a94f637bf')
-    assert_equal 8, commits.size
-  end
-
-  def test_last_commits_array
-    setup_a
-    arr = @findex.last_commits(@commit, ['lib/grit/git.rb', 'lib/grit/actor.rb', 'lib/grit/commit.rb'])
-    assert_equal '74fd66519e983a0f29e16a342a6059dbffe36020', arr['lib/grit/git.rb']
-    assert_equal @commit, arr['lib/grit/commit.rb']
-    assert_equal nil, arr['lib/grit/actor.rb']
-  end
-
-  def test_last_commits_pattern
-    setup_a
-    arr = @findex.last_commits(@commit, /lib\/grit\/[^\/]*$/)
-    assert_equal 10, arr.size
-    assert_equal @commit, arr['lib/grit/commit.rb']
-    assert_equal nil, arr['lib/grit/actor.rb']
-  end
-
-  def test_last_commits_array
-    setup_a
-    arr = @findex.last_commits(@commit, ['lib/grit.rb', 'lib/grit/'])
-    assert_equal @commit, arr['lib/grit/']
-  end
-
-end
\ No newline at end of file</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>e1160265209b7add18657e5e19841aec6b07853c</sha>
			<message>Grit::Git check_applies / patch related methods take command hash

This lets us pass an :env so we can use GIT_ALTERNATE_OBJECT_DIRECTORIES
to check if a commit applies across repositories.</message>
			<author_name>Ryan Tomayko</author_name>
			<author_date>2011-06-22T06:21:47Z</author_date>
			<author_email>rtomayko@gmail.com</author_email>
			<committer_name>Ryan Tomayko</committer_name>
			<committer_date>2011-06-22T06:57:47Z</committer_date>
			<committer_email>rtomayko@gmail.com</committer_email>
			<files>
				<file>
					<file_name>lib/grit/git.rb</file_name>
					<diff>@@ -197,16 +197,23 @@ def commit_from_sha(id)
 
     # Checks if the patch of a commit can be applied to the given head.
     #
+    # options     - grit command options hash
     # head_sha    - String SHA or ref to check the patch against.
     # applies_sha - String SHA of the patch.  The patch itself is retrieved
     #               with #get_patch.
     #
     # Returns 0 if the patch applies cleanly (according to `git apply`), or
     # an Integer that is the sum of the failed exit statuses.
-    def check_applies(head_sha, applies_sha)
+    def check_applies(options={}, head_sha=nil, applies_sha=nil)
+      options, head_sha, applies_sha = {}, options, head_sha if !options.is_a?(Hash)
+      options = options.dup
+      options[:env] &&= options[:env].dup
+
       git_index = create_tempfile('index', true)
-      options   = {:env = {'GIT_INDEX_FILE' = git_index}, :raise = true}
-      status    = 0
+      (options[:env] ||= {}).merge!('GIT_INDEX_FILE' = git_index)
+      options[:raise] = true
+
+      status = 0
       begin
         native(:read_tree, options.dup, head_sha)
         stdin = native(:diff, options.dup, "#{applies_sha}^", applies_sha)
@@ -219,27 +226,38 @@ def check_applies(head_sha, applies_sha)
 
     # Gets a patch for a given SHA using `git diff`.
     #
+    # options     - grit command options hash
     # applies_sha - String SHA to get the patch from, using this command:
     #               `git diff #{applies_sha}^ #{applies_sha}`
     #
     # Returns the String patch from `git diff`.
-    def get_patch(applies_sha)
+    def get_patch(options={}, applies_sha=nil)
+      options, applies_sha = {}, options if !options.is_a?(Hash)
+      options = options.dup
+      options[:env] &&= options[:env].dup
+
       git_index = create_tempfile('index', true)
-      native(:diff, {
-        :env = {'GIT_INDEX_FILE' = git_index}},
-        "#{applies_sha}^", applies_sha)
+      (options[:env] ||= {}).merge!('GIT_INDEX_FILE' = git_index)
+
+      native(:diff, options, "#{applies_sha}^", applies_sha)
     end
 
     # Applies the given patch against the given SHA of the current repo.
     #
+    # options  - grit command hash
     # head_sha - String SHA or ref to apply the patch to.
     # patch    - The String patch to apply.  Get this from #get_patch.
     #
     # Returns the String Tree SHA on a successful patch application, or false.
-    def apply_patch(head_sha, patch)
+    def apply_patch(options={}, head_sha=nil, patch=nil)
+      options, head_sha, patch = {}, options, head_sha if !options.is_a?(Hash)
+      options = options.dup
+      options[:env] &&= options[:env].dup
+      options[:raise] = true
+
       git_index = create_tempfile('index', true)
+      (options[:env] ||= {}).merge!('GIT_INDEX_FILE' = git_index)
 
-      options = {:env = {'GIT_INDEX_FILE' = git_index}, :raise = true}
       begin
         native(:read_tree, options.dup, head_sha)
         native(:apply, options.merge(:cached = true, :input = patch))</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>f19c39b117036834c372f956fd5f466d576120f7</sha>
			<message>tags api now resty</message>
			<author_name>Scott Chacon</author_name>
			<author_date>2011-06-16T23:21:05Z</author_date>
			<author_email>schacon@gmail.com</author_email>
			<committer_name>Ryan Tomayko</committer_name>
			<committer_date>2011-06-22T06:57:39Z</committer_date>
			<committer_email>rtomayko@gmail.com</committer_email>
			<files>
				<file>
					<file_name>lib/grit/git-ruby/git_object.rb</file_name>
					<diff>@@ -291,7 +291,7 @@ def raw_log(sha)
   end
 
   class Tag  GitObject
-    attr_accessor :object, :tag, :tagger, :message
+    attr_accessor :object, :tag, :tagger, :message, :object_type
     attr_writer :type
 
     def self.from_raw(rawobject, repository=nil)
@@ -332,6 +332,7 @@ def self.from_raw(rawobject, repository=nil)
     def initialize(object, type, tag, tagger, message, repository=nil)
       @object = object
       @type = type
+      @object_type = type
       @tag = tag
       @tagger = tagger
       @repository = repository</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>f38eecb1c9a1cd50b5f535a75a5c56e45cd64456</sha>
			<message>start using the GitRuby::GitObject types in the Git data api</message>
			<author_name>Scott Chacon</author_name>
			<author_date>2011-06-16T22:11:15Z</author_date>
			<author_email>schacon@gmail.com</author_email>
			<committer_name>Ryan Tomayko</committer_name>
			<committer_date>2011-06-22T06:57:39Z</committer_date>
			<committer_email>rtomayko@gmail.com</committer_email>
			<files>
				<file>
					<file_name>lib/grit/git-ruby/git_object.rb</file_name>
					<diff>@@ -49,6 +49,7 @@ def to_s
   # base class for all git objects (blob, tree, commit, tag)
   class GitObject
     attr_accessor :repository
+    attr_accessor :sha
 
     def GitObject.from_raw(rawobject, repository = nil)
       case rawobject.type</diff>
				</file>
				<file>
					<file_name>lib/grit/git-ruby/internal/raw_object.rb</file_name>
					<diff>@@ -31,6 +31,13 @@ def initialize(type, content)
         def sha1
           Digest::SHA1.digest("%s %d\0" % [@type, @content.length] + @content)
         end
+
+        def to_hash
+          {
+            :type = @type,
+            :content = @content
+          }
+        end
       end
     end
   end</diff>
				</file>
				<file>
					<file_name>lib/grit/git.rb</file_name>
					<diff>@@ -56,6 +56,10 @@ def get_raw_object(object_id)
       ruby_git.get_raw_object_by_sha1(object_id).content
     end
 
+    def get_git_object(object_id)
+      ruby_git.get_raw_object_by_sha1(object_id).to_hash
+    end
+
     def object_exists?(object_id)
       ruby_git.object_exists?(object_id)
     end</diff>
				</file>
				<file>
					<file_name>lib/grit/repo.rb</file_name>
					<diff>@@ -519,6 +519,14 @@ def lstree(treeish = 'master', options = {})
       revs
     end
 
+    def object(sha)
+      obj = git.get_git_object(sha)
+      raw = Grit::GitRuby::Internal::RawObject.new(obj[:type], obj[:content])
+      object = Grit::GitRuby::GitObject.from_raw(raw)
+      object.sha = sha
+      object
+    end
+
     # The Blob object for the given id
     #   +id+ is the SHA1 id of the blob
     #</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>67fc8d200884709a1ce49d1c752414726e488f4a</sha>
			<message>we are not using these anymore. they are confusing</message>
			<author_name>Scott Chacon</author_name>
			<author_date>2011-06-16T22:04:15Z</author_date>
			<author_email>schacon@gmail.com</author_email>
			<committer_name>Ryan Tomayko</committer_name>
			<committer_date>2011-06-22T06:57:39Z</committer_date>
			<committer_email>rtomayko@gmail.com</committer_email>
			<files>
				<file>
					<file_name>grit.gemspec</file_name>
					<diff>@@ -50,13 +50,11 @@ Gem::Specification.new do |s|
     lib/grit/errors.rb
     lib/grit/git-ruby.rb
     lib/grit/git-ruby/commit_db.rb
-    lib/grit/git-ruby/file_index.rb
     lib/grit/git-ruby/git_object.rb
     lib/grit/git-ruby/internal/file_window.rb
     lib/grit/git-ruby/internal/loose.rb
     lib/grit/git-ruby/internal/pack.rb
     lib/grit/git-ruby/internal/raw_object.rb
-    lib/grit/git-ruby/object.rb
     lib/grit/git-ruby/repository.rb
     lib/grit/git.rb
     lib/grit/index.rb</diff>
				</file>
				<file>
					<file_name>lib/grit/git-ruby.rb</file_name>
					<diff>@@ -1,5 +1,4 @@
 require 'grit/git-ruby/repository'
-require 'grit/git-ruby/file_index'
 
 module Grit
 
@@ -200,21 +199,6 @@ def file_type(ref)
       try_run { ruby_git.cat_file_type(ref).to_s }
     end
 
-    def blame_tree(commit, path = nil)
-      begin
-        path = [path].join('/').to_s + '/' if (path && path != '')
-        path = '' if !path.is_a? String
-        commits = file_index.last_commits(rev_parse({}, commit), looking_for(commit, path))
-        clean_paths(commits)
-      rescue FileIndex::IndexFileNotFound
-        {}
-      end
-    end
-
-    def file_index
-      @git_file_index ||= FileIndex.new(@git_dir)
-    end
-
     def ruby_git
       @ruby_git_repo ||= Repository.new(@git_dir)
     end</diff>
				</file>
				<file>
					<file_name>lib/grit/git-ruby/file_index.rb</file_name>
					<diff>@@ -1,191 +0,0 @@
-# this implements a file-based 'file index', an simple index of
-# all of the reachable commits in a repo, along with the parents
-# and which files were modified during each commit
-#
-# this class looks for a file named '[.git]/file-index', generated via:
-#
-# git log --pretty=oneline --name-only --parents --reverse --all  file-index
-#
-# for this to work properly, you'll want to add the following as a post-receive hook
-# to keep the index up to date
-#
-# git log --pretty=oneline --name-only --parents --reverse [old-rev]..[new-rev]  file-index
-#
-module Grit
-  module GitRuby
-
-  class FileIndex
-
-    class IndexFileNotFound  StandardError
-    end
-
-    class UnsupportedRef  StandardError
-    end
-
-    class  self
-      attr_accessor :max_file_size
-    end
-
-    self.max_file_size = 10_000_000 # ~10M
-
-    # initializes index given repo_path
-    def initialize(repo_path)
-      @index_file = File.join(repo_path, 'file-index')
-      if File.file?(@index_file) && (File.size(@index_file)  Grit::GitRuby::FileIndex.max_file_size)
-        read_index
-      else
-        raise IndexFileNotFound
-      end
-    end
-
-    # returns count of all commits
-    def count_all
-      @sha_count
-    end
-
-    # returns count of all commits reachable from SHA
-    # note: originally did this recursively, but ruby gets pissed about that on
-    # really big repos where the stack level gets 'too deep' (thats what she said)
-    def count(commit_sha)
-      commits_from(commit_sha).size
-    end
-
-    # builds a list of all commits reachable from a single commit
-    def commits_from(commit_sha)
-      raise UnsupportedRef if commit_sha.is_a? Array
-
-      already = {}
-      final = []
-      left_to_do = [commit_sha]
-
-      while commit_sha = left_to_do.shift
-        next if already[commit_sha]
-
-        final  commit_sha
-        already[commit_sha] = true
-
-        commit = @commit_index[commit_sha]
-        commit[:parents].each do |sha|
-          left_to_do  sha
-        end if commit
-      end
-
-      sort_commits(final)
-    end
-
-    def sort_commits(sha_array)
-      sha_array.sort { |a, b| @commit_order[b].to_i = @commit_order[a].to_i }
-    end
-
-    # returns files changed at commit sha
-    def files(commit_sha)
-      @commit_index[commit_sha][:files] rescue nil
-    end
-
-    # returns all commits for a file
-    def commits_for(file)
-      @all_files[file]
-    end
-
-    # returns the shas of the last commits for all
-    # the files in [] from commit_sha
-    # files_matcher can be a regexp or an array
-    def last_commits(commit_sha, files_matcher)
-      acceptable = commits_from(commit_sha)
-
-      matches = {}
-
-      if files_matcher.is_a? Regexp
-        files = @all_files.keys.select { |file| file =~ files_matcher }
-        files_matcher = files
-      end
-
-      if files_matcher.is_a? Array
-        # find the last commit for each file in the array
-        files_matcher.each do |f|
-          @all_files[f].each do |try|
-            if acceptable.include?(try)
-              matches[f] = try
-              break
-            end
-          end if @all_files[f]
-        end
-      end
-
-      matches
-    end
-
-    private
-
-      # read and parse the file-index data
-      def read_index
-        f = File.new(@index_file)
-        @sha_count = 0
-        @commit_index = {}
-        @commit_order = {}
-        @all_files = {}
-        while line = f.gets
-          if /^(\w{40})/.match(line)
-            shas = line.scan(/(\w{40})/)
-            current_sha = shas.shift.first
-            parents = shas.map { |sha| sha.first }
-            @commit_index[current_sha] = {:files = [], :parents = parents }
-            @commit_order[current_sha] = @sha_count
-            @sha_count += 1
-          else
-            file_name = line.chomp
-            tree = ''
-            File.dirname(file_name).split('/').each do |part|
-              next if part == '.'
-              tree += part + '/'
-              @all_files[tree] ||= []
-              @all_files[tree].unshift(current_sha)
-            end
-            @all_files[file_name] ||= []
-            @all_files[file_name].unshift(current_sha)
-            @commit_index[current_sha][:files]  file_name
-          end
-        end
-      end
-
-  end
-
-  end
-end
-
-
-# benchmark testing on big-ass repos
-
-if __FILE__ == $0
-
-  #repo = '/Users/schacon/projects/git/.git'
-  #commit = 'd8933f013a66cc1deadf83a9c24eccb6fee78a35'
-  #file_list = ["builtin-merge-recursive.c", "git-send-email-script", "git-parse-remote.sh", "builtin-add.c", "merge-base.c", "read-cache.c", "fsck.h", "diff.c", "refs.c", "diffcore-rename.c", "epoch.c", "pack-intersect.c", "fast-import.c", "git-applypatch.sh", "git.spec.in", "rpush.c", "git-clone-script", "utf8.c", "git-external-diff-script", "builtin-init-db.c", "pack-redundant.c", "builtin-diff-index.c", "index.c", "update-index.c", "fetch-clone.c", "pager.c", "diff.h", "unpack-trees.c", "git-browse-help.sh", "git-rename-script", "refs.h", "get-tar-commit-id.c", "git-push.sh", "README", "delta.c", "mailsplit.c", "gitweb.cgi", "var.c", "epoch.h", "gsimm.c", "archive.c", "sideband.c", "utf8.h", "local-fetch.c", "git-request-pull-script", "builtin-send-pack.c", "blob.c", "builtin-ls-remote.c", "pretty.c", "git-diff.sh", "diffcore-break.c", "unpack-trees.h", "git-mv.perl", "interpolate.c", "builtin-diff-files.c", "delta.h", "commit-tree.c", "git-diff-script", "decorate.c", "builtin-name-rev.c", "tree-walk.c", "git-revert-script", "git-sh-setup.sh", "transport.c", "gsimm.h", "archive.h", "count-delta.c", "sideband.h", "git-merge.sh", "git-gui.sh", "git-core.spec.in", "cvs2git.c", "blob.h", "git.sh", "http-push.c", "builtin-commit-tree.c", "diff-helper.c", "builtin-push.c", "interpolate.h", "decorate.h", "git-citool", "dotest", "builtin-verify-tag.c", "git-mergetool.sh", "tree-walk.h", "log-tree.c", "name-rev.c", "applypatch", "cat-file.c", "test-delta.c", "server-info.c", "count-delta.h", "write-tree.c", "local-pull.c", "transport.h", "git-rm.sh", "unpack-objects.c", "xdiff-interface.c", "git-repack-script", "commit.c", "hash-object.c", "git-merge-recursive.py", "git-clone-dumb-http", "thread-utils.c", "git-send-email.perl", "git-whatchanged.sh", "log-tree.h", "builtin-annotate.c", "show-index.c", "pkt-line.c", "ident.c", "git-rebase-script", "name-hash.c", "git-archimport.perl", "xdiff-interface.h", "commit.h", "diff-lib.c", "wt-status.c", "base85.c", "builtin-fetch--tool.c", "unpack-file.c", "builtin-diff-stages.c", "merge-index.c", "color.c", "diff-tree.c", "git-checkout.sh", "thread-utils.h", "grep.c", "pkt-line.h", "builtin-help.c", "test-parse-options.c", "show-files.c", "git.sh.in", "pack.h", "wt-status.h", "git-prune-script", "test-sha1.c", "git-octopus.sh", "dump-cache-tree.c", "git-web--browse.sh", "builtin-upload-tar.c", "builtin-clone.c", "copy.c", "color.h", "show-branch.c", "peek-remote.c", "git-merge-recursive-old.py", "cmd-rename.sh", "git-apply-patch-script", "git-export.c", "git-relink-script", "grep.h", "usage.c", "git-fetch-dumb-http", "fsck-objects.c", "update-cache.c", "diff-stages.c", "patch-ids.c", "builtin-rev-list.c", "builtin-bundle.c", "builtin-show-branch.c", "builtin-pack-refs.c", "tree.c", "git.c", "verify_pack.c", "update-ref.c", "builtin-peek-remote.c", "diffcore-pathspec.c", "git-merge-octopus.sh", "git-show-branches-script", "builtin-archive.c", "builtin-unpack-objects.c", "git-rerere.perl", "walker.c", "builtin-mailsplit.c", "convert.c", "builtin-branch.c", "export.c", "patch-ids.h", "check-builtins.sh", "git-pull-script", "tree.h", "alloc.c", "git-commit.sh", "git-lost-found.sh", "mailmap.c", "rsh.c", "exec_cmd.c", "git-compat-util.h", "ws.c", "rev-list.c", "git-verify-tag.sh", "git-ls-remote-script", "mktree.c", "walker.h", "builtin-blame.c", "builtin-fsck.c", "setup.c", "git-cvsimport-script", "git-add.sh", "symlinks.c", "checkout-index.c", "receive-pack.c", "git-merge-one-file-script", "mailmap.h", "git-cvsimport.perl", "builtin-count.c", "exec_cmd.h", "builtin-stripspace.c", "git-grep.sh", "hash.c", "builtin-prune-packed.c", "git-rebase--interactive.sh", "rsh.h", "match-trees.c", "git-format-patch.sh", "git-push-script", "parse-options.c", "git-status-script", "http-walker.c", "pack-write.c", "git-status.sh", "diff-delta.c", "hash.h", "generate-cmdlist.sh", "config-set.c", "builtin-fetch.c", "ll-merge.c", "t1300-config-set.sh", "ls-tree.c", "write_or_die.c", "builtin-check-ref-format.c", "fetch-pack.c", "git-commit-script", "builtin-describe.c", "parse-options.h", "builtin-checkout.c", "prune-packed.c", "fixup-builtins", "http-fetch.c", "test-absolute-path.c", "git-log.sh", "builtin-merge-ours.c", "git-whatchanged", "pull.c", "merge-tree.c", "ll-merge.h", "builtin.h", "Makefile", "cache-tree.c", "builtin-log.c", "merge-cache.c", "fetch-pack.h", "git-shortlog.perl", "git-bisect-script", "git-am.sh", "check-ref-format.c", "git-count-objects-script", "mkdelta.c", "builtin-diff.c", "merge-recursive.c", "builtin-config.c", "gitenv.c", "describe.c", "git-add--interactive.perl", "pull.h", "builtin-apply.c", "diff-index.c", "ssh-pull.c", "builtin-merge-file.c", "strbuf.c", "git-submodule.sh", "repo-config.c", "run-command.c", "git-applymbox.sh", "cache-tree.h", "builtin-clean.c", "cache.h", "git-prune.sh", "fsck-cache.c", "builtin-remote.c", "sha1_file.c", "shallow.c", "merge-recursive.h", "builtin-checkout-index.c", "git-clone.sh", "builtin-mv.c", "builtin-reflog.c", "lockfile.c", "git-octopus-script", ".mailmap", "strbuf.h", "git-p4import.py", "builtin-repo-config.c", "patch-delta.c", "builtin-merge-base.c", "run-command.h", "check-racy.c", "git-filter-branch.sh", "git-branch.sh", "git-merge-stupid.sh", "diff-files.c", "test-sha1.sh", "COPYING", "git-lost+found.sh", "git-tag.sh", "git-branch-script", "check-files.c", "builtin-reset.c", "builtin-ls-files.c", "builtin-fmt-merge-msg.c", "builtin-for-each-ref.c", "csum-file.c", "git-gc.sh", "git-parse-remote-script", "command-list.txt", "builtin-pack-objects.c", "dir.c", "test-date.c", "builtin-grep.c", "list-objects.c", "clone-pack.c", "git-gui", "convert-cache.c", "git-reset-script", "checkout-cache.c", "git-ls-remote.sh", "read-tree.c", "git-instaweb.sh", "progress.c", "rabinpoly.c", "ls-files.c", "mktag.c", "gitMergeCommon.py", "git-merge-ours.sh", "rpull.c", "git-annotate.perl", "csum-file.h", "builtin-shortlog.c", "builtin-commit.c", "http-pull.c", "git-fetch.sh", "apply.c", "git-add-script", "dir.h", "diff-tree-helper.c", "list-objects.h", "rev-tree.c", "builtin-tar-tree.c", "progress.h", "builtin-pickaxe.c", "git-merge-fredrik.py", "path.c", "builtin-diff-tree.c", "rabinpoly.h", "builtin-ls-tree.c", "tar.h", "trace.c", "graph.c", "ssh-fetch.c", "show-diff.c", "sha1-lookup.c", "builtin-revert.c", "builtin-symbolic-ref.c", "builtin-write-tree.c", "git-sh-setup-script", "rev-cache.c", "blame.c", "builtin-mailinfo.c", "git-cherry", "git-resolve-script", "INSTALL", "git-findtags.perl", "diffcore-delta.c", "entry.c", "git-applypatch", "connect.c", "tar-tree.c", "graph.h", "missing-revs.c", "builtin-fast-export.c", "sha1-lookup.h", "rev-parse.c", "configure.ac", "rev-cache.h", "build-rev-cache.c", "reachable.c", "index-pack.c", "git", "send-pack.c", "git-cherry.sh", "git-tag-script", "revision.c", "CREDITS-GEN", "bundle.c", "mailinfo.c", "symbolic-ref.c", "attr.c", "git-archimport-script", "archive-zip.c", "diff-cache.c", "fetch.c", "builtin-gc.c", "git-remote.perl", "path-list.c", "ssh-upload.c", "reachable.h", "diff-no-index.c", "diffcore.h", "send-pack.h", "tree-diff.c", "git-checkout-script", "pack-revindex.c", "show-rev-cache.c", "TODO", "revision.h", "bundle.h", "unresolve.c", "git-deltafy-script", "git-relink.perl", "archive-tar.c", "attr.h", "git-resolve.sh", "config.mak.in", "builtin-update-index.c", "convert-objects.c", "fetch.h", "builtin-runstatus.c", "quote.c", "init-db.c", "git-shortlog", "builtin-prune.c", "builtin-rerere.c", "verify-pack.c", "gitk", "patch-id.c", ".gitattributes", "date.c", "git-format-patch-script", "path-list.h", "pack-revindex.h", "GIT-VERSION-GEN", "combine-diff.c", "environment.c", "git-cvsserver.perl", "git-repack.sh", "diffcore-order.c", "reflog-walk.c", "config.c", "test-match-trees.c", "git-svnimport.perl", "quote.h", "write-blob.c", "diffcore-pickaxe.c", "builtin-update-ref.c", "stripspace.c", "help.c", "pack-objects.c", "branch.c", "git-verify-tag-script", "TEST", "daemon.c", "remote.c", "git-log-script", "git-pull.sh", "git-quiltimport.sh", "git-count-objects.sh", "reflog-walk.h", "git-applymbox", "builtin-show-ref.c", "RelNotes", "git-fmt-merge-msg.perl", "git-rebase.sh", "git-parse-remote", "git-browse--help.sh", "git-stash.sh", "alias.c", "branch.h", "gitweb.pl", "builtin-upload-archive.c", "builtin-cat-file.c", "sha1_name.c", "http.c", "test-chmtime.c", "remote.h", "ssh-push.c", "tag.c", "update-server-info.c", "git-cvsexportcommit.perl", "builtin-check-attr.c", "git-revert.sh", "builtin-verify-pack.c", "object.c", "git-merge-resolve.sh", "shortlog.h", "git-fetch-script", "test-genrandom.c", "shell.c", "builtin-rm.c", "builtin-zip-tree.c", "upload-pack.c", "git-rename.perl", ".gitignore", "tag.h", "http.h", "git-request-pull.sh", "object.h", "git-svn.perl", "builtin-fetch-pack.c", "git-bisect.sh", "pack-check.c", "builtin-rev-parse.c", "object-refs.c", "test-gsimm.c", "builtin-read-tree.c", "git-help--browse.sh", "merge-file.c", "fsck.c", "builtin-tag.c", "builtin-http-fetch.c", "builtin-count-objects.c", "git-reset.sh", "git-clean.sh", "git-merge-one-file.sh", "ctype.c", "git-mktag.c", "imap-send.c"]
-
-  repo = '/Users/schacon/projects/grit/.git'
-  commit = 'c87612bc84c95ba9df17674d911dde10f34fefaa'
-
-  require 'benchmark'
-
-  Benchmark.bm(20) do |x|
-    x.report('index build') do
-      i = Grit::GitRuby::FileIndex.new(repo)
-    end
-    x.report('commit count') do
-      i = Grit::GitRuby::FileIndex.new(repo)
-      i.count(commit)
-    end
-    x.report('commits list') do
-      i = Grit::GitRuby::FileIndex.new(repo)
-      i.commits_from(commit)
-    end
-    x.report('last commits') do
-      i = Grit::GitRuby::FileIndex.new(repo)
-      #arr = i.last_commits(commit, file_list)
-      arr = i.last_commits(commit, /^[^\/]*$/)
-    end
-  end
-end
-
-
-</diff>
				</file>
				<file>
					<file_name>lib/grit/git-ruby/object.rb</file_name>
					<diff>@@ -1,325 +0,0 @@
-#
-# converted from the gitrb project
-#
-# authors:
-#    Matthias Lederhofer matled@gmx.net
-#    Simon 'corecode' Schubert corecode@fs.ei.tum.de
-#    Scott Chacon schacon@gmail.com
-#
-# provides native ruby access to git objects and pack files
-#
-
-# These classes translate the raw binary data kept in the sha encoded files
-# into parsed data that can then be used in another fashion
-require 'stringio'
-
-module Grit
-  module GitRuby
-
-  # class for author/committer/tagger lines
-  class UserInfo
-    attr_accessor :name, :email, :date, :offset
-
-    def initialize(str)
-      m = /^(.*?) (.*) (\d+) ([+-])0*(\d+?)$/.match(str)
-      if !m
-        raise RuntimeError, "invalid header '%s' in commit" % str
-      end
-      @name = m[1]
-      @email = m[2]
-      @date = Time.at(Integer(m[3]))
-      @offset = (m[4] == "-" ? -1 : 1)*Integer(m[5])
-    end
-
-    def to_s
-      "%s %s %s %+05d" % [@name, @email, @date.to_i, @offset]
-    end
-  end
-
-  # base class for all git objects (blob, tree, commit, tag)
-  class Object
-    attr_accessor :repository
-
-    def Object.from_raw(rawobject, repository = nil)
-      case rawobject.type
-      when :blob
-        return Blob.from_raw(rawobject, repository)
-      when :tree
-        return Tree.from_raw(rawobject, repository)
-      when :commit
-        return Commit.from_raw(rawobject, repository)
-      when :tag
-        return Tag.from_raw(rawobject, repository)
-      else
-        raise RuntimeError, "got invalid object-type"
-      end
-    end
-
-    def initialize
-      raise NotImplemented, "abstract class"
-    end
-
-    def type
-      raise NotImplemented, "abstract class"
-    end
-
-    def raw_content
-      raise NotImplemented, "abstract class"
-    end
-
-    def sha1
-      Digest::SHA1.hexdigest("%s %d\0" % \
-                             [self.type, self.raw_content.length] + \
-                             self.raw_content)
-    end
-  end
-
-  class Blob  Object
-    attr_accessor :content
-
-    def self.from_raw(rawobject, repository)
-      new(rawobject.content)
-    end
-
-    def initialize(content, repository=nil)
-      @content = content
-      @repository = repository
-    end
-
-    def type
-      :blob
-    end
-
-    def raw_content
-      @content
-    end
-  end
-
-  class DirectoryEntry
-    S_IFMT  = 00170000
-    S_IFLNK =  0120000
-    S_IFREG =  0100000
-    S_IFDIR =  0040000
-
-    attr_accessor :mode, :name, :sha1
-    def initialize(mode, filename, sha1o)
-      @mode = 0
-      mode.each_byte do |i|
-        @mode = (@mode  3) | (i-'0'[0])
-      end
-      @name = filename
-      @sha1 = sha1o
-      if ![S_IFLNK, S_IFDIR, S_IFREG].include?(@mode & S_IFMT)
-        raise RuntimeError, "unknown type for directory entry"
-      end
-    end
-
-    def type
-      case @mode & S_IFMT
-      when S_IFLNK
-        @type = :link
-      when S_IFDIR
-        @type = :directory
-      when S_IFREG
-        @type = :file
-      else
-        raise RuntimeError, "unknown type for directory entry"
-      end
-    end
-
-    def type=(type)
-      case @type
-      when :link
-        @mode = (@mode & ~S_IFMT) | S_IFLNK
-      when :directory
-        @mode = (@mode & ~S_IFMT) | S_IFDIR
-      when :file
-        @mode = (@mode & ~S_IFMT) | S_IFREG
-      else
-        raise RuntimeError, "invalid type"
-      end
-    end
-
-    def format_type
-      case type
-      when :link
-        'link'
-      when :directory
-        'tree'
-      when :file
-        'blob'
-      end
-    end
-
-    def format_mode
-      "%06o" % @mode
-    end
-
-    def raw
-      "%o %s\0%s" % [@mode, @name, [@sha1].pack("H*")]
-    end
-  end
-
-
-  def self.read_bytes_until(io, char)
-    string = ''
-    if RUBY_VERSION  '1.9'
-      while ((next_char = io.getc) != char) && !io.eof
-        string += next_char
-      end
-    else
-      while ((next_char = io.getc.chr) != char) && !io.eof
-        string += next_char
-      end
-    end
-    string
-  end
-
-
-  class Tree  Object
-    attr_accessor :entry
-
-    def self.from_raw(rawobject, repository=nil)
-      raw = StringIO.new(rawobject.content)
-
-      entries = []
-      while !raw.eof?
-        mode      = Grit::GitRuby.read_bytes_until(raw, ' ')
-        file_name = Grit::GitRuby.read_bytes_until(raw, "\0")
-        raw_sha   = raw.read(20)
-        sha = raw_sha.unpack("H*").first
-
-        entries  DirectoryEntry.new(mode, file_name, sha)
-      end
-      new(entries, repository)
-    end
-
-    def initialize(entries=[], repository = nil)
-      @entry = entries
-      @repository = repository
-    end
-
-    def type
-      :tree
-    end
-
-    def raw_content
-      # TODO: sort correctly
-      #@entry.sort { |a,b| a.name = b.name }.
-      @entry.collect { |e| [[e.format_mode, e.format_type, e.sha1].join(' '), e.name].join("\t") }.join("\n")
-    end
-
-    def actual_raw
-      #@entry.collect { |e| e.raw.join(' '), e.name].join("\t") }.join("\n")
-    end
-  end
-
-  class Commit  Object
-    attr_accessor :author, :committer, :tree, :parent, :message, :headers
-
-    def self.from_raw(rawobject, repository=nil)
-      parent = []
-      tree = author = committer = nil
-
-      headers, message = rawobject.content.split(/\n\n/, 2)
-      all_headers = headers.split(/\n/).map { |header| header.split(/ /, 2) }
-      all_headers.each do |key, value|
-        case key
-        when "tree"
-          tree = value
-        when "parent"
-          parent.push(value)
-        when "author"
-          author = UserInfo.new(value)
-        when "committer"
-          committer = UserInfo.new(value)
-        else
-          warn "unknown header '%s' in commit %s" % \
-            [key, rawobject.sha1.unpack("H*")[0]]
-        end
-      end
-      if not tree && author && committer
-        raise RuntimeError, "incomplete raw commit object"
-      end
-      new(tree, parent, author, committer, message, headers, repository)
-    end
-
-    def initialize(tree, parent, author, committer, message, headers, repository=nil)
-      @tree = tree
-      @author = author
-      @parent = parent
-      @committer = committer
-      @message = message
-      @headers = headers
-      @repository = repository
-    end
-
-    def type
-      :commit
-    end
-
-    def raw_content
-      "tree %s\n%sauthor %s\ncommitter %s\n\n" % [
-        @tree,
-        @parent.collect { |i| "parent %s\n" % i }.join,
-        @author, @committer] + @message
-    end
-
-    def raw_log(sha)
-      output = "commit #{sha}\n"
-      output += @headers + "\n\n"
-      output += @message.split("\n").map { |l| '    ' + l }.join("\n") + "\n\n"
-    end
-
-  end
-
-  class Tag  Object
-    attr_accessor :object, :type, :tag, :tagger, :message
-
-    def self.from_raw(rawobject, repository=nil)
-      headers, message = rawobject.content.split(/\n\n/, 2)
-      headers = headers.split(/\n/).map { |header| header.split(/ /, 2) }
-      headers.each do |key, value|
-        case key
-        when "object"
-          object = value
-        when "type"
-          if !["blob", "tree", "commit", "tag"].include?(value)
-            raise RuntimeError, "invalid type in tag"
-          end
-          type = value.to_sym
-        when "tag"
-          tag = value
-        when "tagger"
-          tagger = UserInfo.new(value)
-        else
-          warn "unknown header '%s' in tag" % \
-            [key, rawobject.sha1.unpack("H*")[0]]
-        end
-        if not object && type && tag && tagger
-          raise RuntimeError, "incomplete raw tag object"
-        end
-      end
-      new(object, type, tag, tagger, repository)
-    end
-
-    def initialize(object, type, tag, tagger, repository=nil)
-      @object = object
-      @type = type
-      @tag = tag
-      @tagger = tagger
-      @repository = repository
-    end
-
-    def raw_content
-      "object %s\ntype %s\ntag %s\ntagger %s\n\n" % \
-        [@object, @type, @tag, @tagger] + @message
-    end
-
-    def type
-      :tag
-    end
-  end
-
-  end
-end</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>b0135670e0002fee8491ea1e15e7308817e9a255</sha>
			<message>ruby rev_list passes --verify to native rev_parse in fallback

Otherwise, the git-rev-parse will return whatever is given as an arg
when the ref doesn't exist. e.g.,

  $ git rev-parse some-bad-ref
  some-bad-ref
  fatal: ambiguous argument 'some-bad-ref': unknown revision or path not in the working tree.

The error message is on stderr and git-rev-parse exits with non-zero
but the ref name is still output.

The problem here is that code often calls rev_list like:

    git.rev_list({}, "some-bad-ref")

Then rev_list tries to convert some-bad-ref to a SHA1, gets back the
ref string, but continues on anyway. This eventually results in the
rev_list failing to look up the object because it assumes its a SHA1
when its really a ref string.</message>
			<author_name>Ryan Tomayko</author_name>
			<author_date>2011-06-15T19:29:14Z</author_date>
			<author_email>rtomayko@gmail.com</author_email>
			<committer_name>Ryan Tomayko</committer_name>
			<committer_date>2011-06-15T19:30:25Z</committer_date>
			<committer_email>rtomayko@gmail.com</committer_email>
			<files>
				<file>
					<file_name>lib/grit/git-ruby.rb</file_name>
					<diff>@@ -64,7 +64,7 @@ def rev_list(options, *refs)
         end
       else
         ref = refs.first
-        aref = rev_parse({}, ref)
+        aref = rev_parse({:verify = true}, ref)
         if aref.is_a? Array
           method_missing('rev-list', options, *refs)
         else</diff>
				</file>
			</files>
		</commit>
	</commits>
	<actual_files>
		<actual_file>
			<filename>.gitignore</filename>
			<content>pkg
.DS_Store
</content>
		</actual_file>
		<actual_file>
			<filename>API.txt</filename>
			<content>== TODO ==

* Add remote branch references (Grit::Remote)
* Add status - what is modified, staged

g.checkout('new_branch')
g.checkout(g.branch('new_branch'))

g.branch(name).merge(branch2)
g.branch(branch2).merge  # merges HEAD with branch2

g.branch(name).in_branch(message) { # add files }  # auto-commits
g.merge('new_branch')
g.merge('origin/remote_branch')
g.merge(b.branch('master'))
g.merge([branch1, branch2])

r = g.add_remote(name, uri)  # Git::Remote
r = g.add_remote(name, Git::Base)  # Git::Remote

g.remotes  # array of Git::Remotes
g.remote(name).fetch
g.remote(name).remove
g.remote(name).merge
g.remote(name).merge(branch)

g.fetch
g.fetch(g.remotes.first)

g.pull
g.pull(Git::Repo, Git::Branch) # fetch and a merge

g.add_tag('tag_name') # returns Git::Tag

g.repack

g.push
g.push(g.remote('name'))
   
g.reset # defaults to HEAD
g.reset_hard(Git::Commit)

g.branch('new_branch') # creates new or fetches existing
g.branch('new_branch').checkout
g.branch('new_branch').delete
g.branch('existing_branch').checkout





require 'mojombo-grit'

include Grit
Grit.debug
Grit.use_pure_ruby

repo = Repo.new("/Users/tom/dev/grit")

= Commit Log

repo.commits('mybranch')
repo.commits('40d3057d09a7a4d61059bca9dca5ae698de58cbe')
repo.commits('v0.1')

repo.log('mybranch', 100, 20)

head = repo.commits.first
head.id
# = "e80bbd2ce67651aa18e57fb0b43618ad4baf7750"
head.parents
# = [#Grit::Commit "91169e1f5fa4de2eaea3f176461f5dc784796769"]
head.tree
# = #Grit::Tree "3536eb9abac69c3e4db583ad38f3d30f8db4771f"
head.author
# = #Grit::Actor "Tom Preston-Werner tom@mojombo.com"
head.authored_date
# = Wed Oct 24 22:02:31 -0700 2007
head.committer
# = #Grit::Actor "Tom Preston-Werner tom@mojombo.com"
head.committed_date
# = Wed Oct 24 22:02:31 -0700 2007
head.message
# = "add Actor inspect"
contents = tree.contents
  # = [#Grit::Blob "4ebc8aea50e0a67e000ba29a30809d0a7b9b2666",
        #Grit::Blob "81d2c27608b352814cbe979a6acd678d30219678",
        #Grit::Tree "c3d07b0083f01a6e1ac969a0f32b8d06f20c62e5",
        #Grit::Tree "4d00fe177a8407dbbc64a24dbfc564762c0922d8"]
blob.id
# = "4ebc8aea50e0a67e000ba29a30809d0a7b9b2666"
blob.name
# = "README.txt"
blob.mode
# = "100644"
blob.size
# = 7726
blob.data

repo.blob("4ebc8aea50e0a67e000ba29a30809d0a7b9b2666")
# = #Grit::Blob "4ebc8aea50e0a67e000ba29a30809d0a7b9b2666"
</content>
		</actual_file>
		<actual_file>
			<filename>benchmarks.rb</filename>
			<content>require 'fileutils'
require 'benchmark'
require 'rubygems'
require 'ruby-prof'
require 'memcache'
require 'pp'


#require 'grit'
require 'lib/grit'

def main
  @wbare = File.expand_path(File.join('test', 'dot_git'))
  
  in_temp_dir do
    #result = RubyProf.profile do

      git = Grit::Repo.new('.')
      puts Grit::VERSION
      
      Grit::GitRuby.use_commit_db = true
      #Grit::GitRuby.cache_client = MemCache.new 'localhost:11211', :namespace = 'grit'
      #Grit.debug = true
    
      #pp Grit::GitRuby.cache_client.stats 
    
      commit1 = '5e3ee1198672257164ce3fe31dea3e40848e68d5'
      commit2 = 'ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a'
    
      Benchmark.bm(8) do |x|
            
        run_code(x, 'packobj') do
          @commit = git.commit('5e3ee1198672257164ce3fe31dea3e40848e68d5')
          @tree = git.tree('cd7422af5a2e0fff3e94d6fb1a8fff03b2841881')
          @blob = git.blob('4232d073306f01cf0b895864e5a5cfad7dd76fce')
          @commit.parents[0].parents[0].parents[0]
        end

        run_code(x, 'commits 1') do
          git.commits.size
        end
              
        run_code(x, 'commits 2') do
          log = git.commits('master', 15)
          log.size
          log.size
          log.first
          git.commits('testing').map { |c| c.message }
        end

        run_code(x, 'big revlist') do
          c = git.commits('master', 200)
        end

        run_code(x, 'log') do
          log = git.log('master')
          log.size
          log.size
          log.first
        end

        run_code(x, 'diff') do
          c = git.diff(commit1, commit2)
        end

        run_code(x, 'commit-diff') do
          c = git.commit_diff(commit1)
        end

        run_code(x, 'heads') do
          c = git.heads.collect { |b| b.commit.id }
        end

       # run_code(x, 'config', 100) do
       #   c = git.config['user.name']
       #   c = git.config['user.email']
       # end

        #run_code(x, 'commit count') do
        #  c = git.commit_count('testing')
        #end


      end
    #end

    #printer = RubyProf::FlatPrinter.new(result)
    #printer.print(STDOUT, 0)
    
  end


end


def run_code(x, name, times = 30)
    x.report(name.ljust(12)) do
      for i in 1..times do
        yield i
      end
    end
  
  #end
  
  # Print a graph profile to text
end

def new_file(name, contents)
  File.open(name, 'w') do |f|
    f.puts contents
  end
end


def in_temp_dir(remove_after = true)
  filename = 'git_test' + Time.now.to_i.to_s + rand(300).to_s.rjust(3, '0')
  tmp_path = File.join("/tmp/", filename)
  FileUtils.mkdir(tmp_path)
  Dir.chdir tmp_path do
    FileUtils.cp_r(@wbare, File.join(tmp_path, '.git'))
    yield tmp_path
  end
  puts tmp_path
  #FileUtils.rm_r(tmp_path) if remove_after
end

main()

##pp Grit::GitRuby.cache_client.stats 
</content>
		</actual_file>
		<actual_file>
			<filename>benchmarks.txt</filename>
			<content>Grit : 
              user     system      total        real
packobj       0.030000   0.270000   1.380000 (  1.507250)
commits 1     0.030000   0.070000   0.390000 (  0.409931)
commits 2     0.110000   0.170000   0.860000 (  0.896371)
log           0.350000   0.130000   0.850000 (  0.875035)
diff          0.190000   0.140000   1.940000 (  2.031911)
commit-diff   0.540000   0.220000   1.390000 (  1.463839)
heads         0.010000   0.070000   0.390000 (  0.413918)


Grit (with GitRuby) : 

              user     system      total        real
packobj       0.050000   0.010000   0.060000 (  0.078318)
commits 1     0.150000   0.010000   0.160000 (  0.174296)
commits 2     0.440000   0.040000   0.480000 (  0.522310)
log           0.490000   0.040000   0.530000 (  0.538128)
diff          0.370000   0.230000   2.250000 (  2.255974)
commit-diff   0.580000   0.260000   1.500000 (  1.553000)
heads         0.020000   0.100000   0.430000 (  0.455464)
</content>
		</actual_file>
		<actual_file>
			<filename>grit.gemspec</filename>
			<content>Gem::Specification.new do |s|
  s.specification_version = 2 if s.respond_to? :specification_version=
  s.required_rubygems_version = Gem::Requirement.new("= 0") if s.respond_to? :required_rubygems_version=
  s.rubygems_version = '1.3.5'

  s.name              = 'grit'
  s.version           = '2.5.0'
  s.date              = '2012-04-22'
  s.rubyforge_project = 'grit'

  s.summary     = "Ruby Git bindings."
  s.description = "Grit is a Ruby library for extracting information from a git repository in an object oriented manner."

  s.authors  = ["Tom Preston-Werner", "Scott Chacon"]
  s.email    = 'tom@github.com'
  s.homepage = 'http://github.com/mojombo/grit'

  s.require_paths = %w[lib]

  s.rdoc_options = ["--charset=UTF-8"]
  s.extra_rdoc_files = %w[README.md LICENSE]

  s.add_dependency('posix-spawn', "~ 0.3.6")
  s.add_dependency('mime-types', "~ 1.15")
  s.add_dependency('diff-lcs', "~ 1.1")

  s.add_development_dependency('mocha')

  # = MANIFEST =
  s.files = %w[
    API.txt
    History.txt
    LICENSE
    PURE_TODO
    README.md
    Rakefile
    benchmarks.rb
    benchmarks.txt
    examples/ex_add_commit.rb
    examples/ex_index.rb
    grit.gemspec
    lib/grit.rb
    lib/grit/actor.rb
    lib/grit/blame.rb
    lib/grit/blob.rb
    lib/grit/commit.rb
    lib/grit/commit_stats.rb
    lib/grit/config.rb
    lib/grit/diff.rb
    lib/grit/errors.rb
    lib/grit/git-ruby.rb
    lib/grit/git-ruby/commit_db.rb
    lib/grit/git-ruby/git_object.rb
    lib/grit/git-ruby/internal/file_window.rb
    lib/grit/git-ruby/internal/loose.rb
    lib/grit/git-ruby/internal/pack.rb
    lib/grit/git-ruby/internal/raw_object.rb
    lib/grit/git-ruby/repository.rb
    lib/grit/git.rb
    lib/grit/index.rb
    lib/grit/lazy.rb
    lib/grit/merge.rb
    lib/grit/ref.rb
    lib/grit/repo.rb
    lib/grit/ruby1.9.rb
    lib/grit/status.rb
    lib/grit/submodule.rb
    lib/grit/tag.rb
    lib/grit/tree.rb
  ]
  # = MANIFEST =

  s.test_files = s.files.select { |path| path =~ /^test\/test_.*\.rb/ }
end
</content>
		</actual_file>
		<actual_file>
			<filename>History.txt</filename>
			<content>== 2.5.0 / 2012-04-22
  * Minor Enhancements
    * 100% Git-compliant actor creation.
    * Handle newlines in author/committer.
    * Grit::Git check_applies/patch related methods take command hash.
    * Tags api now resty.
    * Remove all the grit jruby hacks in favor of updated posix-spawn.
    * Add Grit::Commit#patch_id.
    * Support large packfiles with index v2.
  * Bug Fixes
    * Fix Loose Objects with non-ASCII content in Ruby 1.9
    * Fix bugs in Grit::Repo #objects, #commit_objects, and #diff_objects
      due to passing multiple arguments in a single argv element.
    * ruby rev_list passes --verify to native rev_parse in fallback.
    * Git ls-tree raises on non-zero exit.

== 2.4.1 / 2011-01-13
  * Minor Enhancements
    * Grit::Process is used to implement Grit::Git#check_applies,
      Grit::Git#get_patch, and Grit::Git#apply_patch.

== 2.4.0 / 2011-01-06
  * Major Enhancements
    * Add support for parsing git notes.
    * Add `git cat-file --batch` support with Grit::Repo#batch.
    * Grit::Process is a custom written external command invocation heavily
      optimized for running git commands quickly and efficiently.
    * Grit::Git#native takes an :input option for piping data into git
      commands
    * Grit::Git#native takes an :env option for setting the git child
      process's
      environment without futsing with the parent's environment.
    * Grit::Git#native takes an :chdir option for setting the current working
      directory (PWD) of the git child process.
    * Grit::Git#native takes an :raise = true option that causes an exception
      to be raised when the git child process exits non-zero.
  * Minor Enhancements
    * Grit::Index#commit supports custom committer/author names and dates.
    * Performance enhancements with internal command output buffering.
    * Reduce fork/execs needed to execute a smoke command from between 3-4
      to 1.
    * Git child processes are now properly parented under the grit Ruby
      process instead of being dropped under init.
  * Bug Fixes
    * Zero-Padding issue in Grit::Index was fixed.
    * Fix issue where Repo#diff skips the first diff (#42)
    * Fix Repo.init_bare for repo names not ending in .git (#40)
    * Fix a variety of process hangs when git stderr output or data written
      to stdin exceeded PIPE_BUF bytes.

== 2.3.2 / 2011-01-06
  * Erroneously released. SemVer violation and misc release screwups.

== 2.3.1
  * Skipped for unknown reasons.

== 2.3.0 / 2010-09-29
  * Minor Enhancements
    * Add Grit::Repo.init.
  * Bug Fixes
    * Fix Ruby 1.9 compatibility (#24).

== 2.2.1 / 2010-08-23
  * Bug Fixes
    * Fix minor regression due to the changed default values in
      Grit::Index#commit.

== 2.2.0 / 2010-08-19
  * Minor Enhancements
    * Add Grit::Index#delete to allow deletions of files from the index.

== 2.1.0 / 2010-08-04
  * Major Enhancements
    * Add support for parsing annotated tag objects.
    * Add Grit::Repo#recent_tag_name for getting the latest tag name that is
      reachable in a commit.
    * Grit::Diff tracks renames properly if given the :M option.
    * Grit::Commit#diffs and Grit::Commit.diffs both take a git options hash
      that is passed to `git diff`.
  * Minor Enhancements
    * Allow diff to only take one sha
    * Add merge commit diff support
    * Pass along the options to Real Git on a rev-parse miss
    * Raise NoSuchPath with no tree in ls_tree_path
    * Make pure-ruby `ls-tree -r` work with commits
    * Implement select_existing_objects
    * Switch to RakeGem for build management
  * Bug Fixes
    * Add no_quote option for fixing tag listings.
    * Raise custom exceptions on invalid tree objects.
    * Fix Repo#diff (was throwing an error).

== 2.0.0 / 2009-10-27
  * Major Enhancements
    * All filesystem calls have been moved into Grit::Git to allow proxying
  * Non-code changes
    * Removed all trailing whitespace in code files
  * Bug Fixes
    * Repo.archive_tar_gz now passes -n option to gzip to be idempotent
    * Fix RubyGit's diff to detect additions and deletions
      [github.com/defunkt]

== 1.1.1 / 2009-03-31
  * Changes
    * Don't include test directory in gem package (it's too big)

== 1.1.0 / 2009-03-29
  * Backwards breaking changes
    * Diff#a_commit - Diff#a_blob, Diff#b_commit - Diff#b_blob
  * Major Enhancments
    * Ruby 1.9 compatibility [github.com/chapados, github.com/js]
  * Minor Enhancements
    * Convert readme to markdown
    * Added a shortcut for commit_stats as Commit#stats [github.com/js]
    * Add a #basename method to Submodule, Blob and Tree for retrieving the
      name [github.com/js]
    * Make Grit::Submodule grasp the concept of non-unix lineendings
      [github.com/js]
    * Added Repo#commit_deltas_from [github.com/js]
    * do some mild shell escaping when running commands [github.com/js]
    * Added two shortcut methods to Tree, for picking trees/blobs only
      [github.com/Voker57]
    * Added = method to Blob, needed for sorting tree [github.com/Voker57]
    * Make the number of bytes to be read from git's stdout configurable
      [github.com/josb]
    * Repo.archive_to_file accepts extra parameters making plain zipping
      possible [github.com/darwin]
    * Handle commit stats that summarize commits with binary changes
      [github.com/therealadam]
    * Add a DiffStat class for easy access to diff stats
      [github.com/therealadam]
    * Don't split git logs that contain blank lines into two CommitStats
      [github.com/therealadam]
    * Add DiffStat#net for total change count [github.com/therealadam]

== 1.0.3 / 2009-02-13
  * Minor Enhancements
    * Added Grit::Commit#to_patch for plaintext formatted patches.
    * Fixed Grit::Tag to work with annotated tags.

== 1.0.2 / 2009-02-10
  * Minor Enhancements
    * Implement Grit.version to use VERSION.yml file

== 1.0.1 / 2009-02-10
  * Bug Fixes
    * Add diff-lcs as a dependency

== 1.0.0 / 2009-01-27
  * Tons of awesome in here. Also, we suck at updating the history.
  * Let's do better at that from now on.

== 0.8.3 / 2008-07-07
  * Capture stderr and log if debug is true (rsanheim)

== 0.8.2 / 2008-06-27
  * Allow user provided logger (rsanheim)

== 0.8.0 / 2008-04-24
  * Lots of fixes and additions

== 0.7.0 / 2008-01-07
  * First public release!
</content>
		</actual_file>
		<actual_file>
			<filename>LICENSE</filename>
			<content>(The MIT License)

Copyright (c) 2007-2009 Tom Preston-Werner

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
'Software'), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</content>
		</actual_file>
		<actual_file>
			<filename>PURE_TODO</filename>
			<content>This is a listing of all the places I can find that Grit actually does a
'git' system call.  My goal is to add native Ruby versions of all of them.

Completed
===========================
** lib/grit/blob.rb:36:      @size ||= @repo.git.cat_file({:s = true}, id).chomp.to_i
** lib/grit/blob.rb:43:      @data ||= @repo.git.cat_file({:p = true}, id)
** lib/grit/tree.rb:16:      output = repo.git.ls_tree({}, treeish, *paths)



lib/grit/commit.rb:74:      repo.git.rev_list({}, ref).strip.split("\n").size
lib/grit/commit.rb:92:      output = repo.git.rev_list(actual_options, ref)
lib/grit/commit.rb:94:      output = repo.git.rev_list(actual_options.merge(:all = true))


Next to do
===========================
lib/grit/tag.rb:28:      output = repo.git.for_each_ref(actual_options, "refs/tags")
lib/grit/head.rb:37:      output = repo.git.for_each_ref(actual_options, HEAD_PREFIX)
lib/grit/head.rb:50:        self.new($1, repo.git.rev_parse(options, 'HEAD'))
lib/grit/config.rb:9:      @repo.git.config({}, key, value)
lib/grit/config.rb:40:        @repo.git.config(:list = true).split(/\n/)


May not be fast enough
=============================
lib/grit/blob.rb:58:      data = repo.git.blame({:p = true}, commit, '--', file)


More Difficult
===========================
lib/grit/commit.rb:39:      @id_abbrev ||= @repo.git.rev_parse({:short = true}, self.id).chomp
lib/grit/commit.rb:150:      text = repo.git.diff({:full_index = true}, *paths)
lib/grit/commit.rb:156:        diff = @repo.git.show({:full_index = true, :pretty = 'raw'}, @id)
</content>
		</actual_file>
		<actual_file>
			<filename>Rakefile</filename>
			<content>require 'rubygems'
require 'rake'
require 'date'

#############################################################################
#
# Helper functions
#
#############################################################################

def name
  @name ||= Dir['*.gemspec'].first.split('.').first
end

def version
  line = File.read("lib/#{name}.rb")[/^\s*VERSION\s*=\s*.*/]
  line.match(/.*VERSION\s*=\s*['"](.*)['"]/)[1]
end

def date
  Date.today.to_s
end

def rubyforge_project
  name
end

def gemspec_file
  "#{name}.gemspec"
end

def gem_file
  "#{name}-#{version}.gem"
end

def replace_header(head, header_name)
  head.sub!(/(\.#{header_name}\s*= ').*'/) { "#{$1}#{send(header_name)}'"}
end

#############################################################################
#
# Standard tasks
#
#############################################################################

task :default = :test

require 'rake/testtask'
Rake::TestTask.new(:test) do |test|
  test.libs  'lib'  'test'  '.'
  test.pattern = 'test/**/test_*.rb'
  test.verbose = true
end

desc "Generate RCov test coverage and open in your browser"
task :coverage do
  require 'rcov'
  sh "rm -fr coverage"
  sh "rcov test/test_*.rb"
  sh "open coverage/index.html"
end

require 'rake/rdoctask'
Rake::RDocTask.new do |rdoc|
  rdoc.rdoc_dir = 'rdoc'
  rdoc.title = "#{name} #{version}"
  rdoc.rdoc_files.include('README*')
  rdoc.rdoc_files.include('lib/**/*.rb')
end

desc "Open an irb session preloaded with this library"
task :console do
  sh "irb -rubygems -r ./lib/#{name}.rb"
end

#############################################################################
#
# Custom tasks (add your own tasks here)
#
#############################################################################

desc "Upload site to Rubyforge"
task :site do
  sh "scp -r doc/* mojombo@grit.rubyforge.org:/var/www/gforge-projects/grit"
end

#############################################################################
#
# Packaging tasks
#
#############################################################################

task :release = :build do
  unless `git branch` =~ /^\* master$/
    puts "You must be on the master branch to release!"
    exit!
  end
  sh "git commit --allow-empty -a -m 'Release #{version}'"
  sh "git tag v#{version}"
  sh "git push origin master"
  sh "git push origin v#{version}"
  sh "gem push pkg/#{name}-#{version}.gem"
end

task :build = :gemspec do
  sh "mkdir -p pkg"
  sh "gem build #{gemspec_file}"
  sh "mv #{gem_file} pkg"
end

task :gemspec = :validate do
  # read spec file and split out manifest section
  spec = File.read(gemspec_file)
  head, manifest, tail = spec.split("  # = MANIFEST =\n")

  # replace name version and date
  replace_header(head, :name)
  replace_header(head, :version)
  replace_header(head, :date)
  #comment this out if your rubyforge_project has a different name
  replace_header(head, :rubyforge_project)

  # determine file list from git ls-files
  files = `git ls-files`.
    split("\n").
    sort.
    reject { |file| file =~ /^\./ }.
    reject { |file| file =~ /^(rdoc|pkg|test)/ }.
    map { |file| "    #{file}" }.
    join("\n")

  # piece file back together and write
  manifest = "  s.files = %w[\n#{files}\n  ]\n"
  spec = [head, manifest, tail].join("  # = MANIFEST =\n")
  File.open(gemspec_file, 'w') { |io| io.write(spec) }
  puts "Updated #{gemspec_file}"
end

task :validate do
  libfiles = Dir['lib/*'] - ["lib/#{name}.rb", "lib/#{name}"]
  unless libfiles.empty?
    puts "Directory `lib` should only contain a `#{name}.rb` file and `#{name}` dir."
    exit!
  end
  unless Dir['VERSION*'].empty?
    puts "A `VERSION` file at root level violates Gem best practices."
    exit!
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>README.md</filename>
			<content>Grit
====

**Grit is no longer maintained. Check out [rugged](https://github.com/libgit2/rugged).**

Grit gives you object oriented read/write access to Git repositories via Ruby.
The main goals are stability and performance. To this end, some of the
interactions with Git repositories are done by shelling out to the system's
`git` command, and other interactions are done with pure Ruby
reimplementations of core Git functionality. This choice, however, is
transparent to end users, and you need not know which method is being used.

This software was developed to power GitHub, and should be considered
production ready. An extensive test suite is provided to verify its
correctness.

Grit is maintained by Tom Preston-Werner, Scott Chacon, Chris Wanstrath, and
PJ Hyett.

This documentation is accurate as of Grit 2.3.


## Requirements

* git (http://git-scm.com) tested with 1.7.2.1


## Install

Easiest install is via RubyGems:

    $ gem install grit


## Source

Grit's Git repo is available on GitHub, which can be browsed at:

    http://github.com/mojombo/grit

and cloned with:

    git clone git://github.com/mojombo/grit.git


### Development

You will need these gems to get tests to pass:

* mocha


### Contributing

If you'd like to hack on Grit, follow these instructions. To get all of the dependencies, install the gem first.

1. Fork the project to your own account
1. Clone down your fork
1. Create a thoughtfully named topic branch to contain your change
1. Hack away
1. Add tests and make sure everything still passes by running `rake`
1. If you are adding new functionality, document it in README.md
1. Do not change the version number, I will do that on my end
1. If necessary, rebase your commits into logical chunks, without errors
1. Push the branch up to GitHub
1. Send a pull request for your branch


## Usage

Grit gives you object model access to your Git repositories. Once you have
created a `Repo` object, you can traverse it to find parent commits,
trees, blobs, etc.


### Initialize a Repo object

The first step is to create a `Grit::Repo` object to represent your repo. In
this documentation I include the `Grit` module to reduce typing.

    require 'grit'
    repo = Grit::Repo.new("/Users/tom/dev/grit")

In the above example, the directory `/Users/tom/dev/grit` is my working
directory and contains the `.git` directory. You can also initialize Grit with
a bare repo.

    repo = Repo.new("/var/git/grit.git")


### Getting a list of commits

From the `Repo` object, you can get a list of commits as an array of `Commit`
objects.

    repo.commits
    # = [#Grit::Commit "e80bbd2ce67651aa18e57fb0b43618ad4baf7750",
          #Grit::Commit "91169e1f5fa4de2eaea3f176461f5dc784796769",
          #Grit::Commit "038af8c329ef7c1bae4568b98bd5c58510465493",
          #Grit::Commit "40d3057d09a7a4d61059bca9dca5ae698de58cbe",
          #Grit::Commit "4ea50f4754937bf19461af58ce3b3d24c77311d9"]

Called without arguments, `Repo#commits` returns a list of up to ten commits
reachable by the **master** branch (starting at the latest commit). You can
ask for commits beginning at a different branch, commit, tag, etc.

    repo.commits('mybranch')
    repo.commits('40d3057d09a7a4d61059bca9dca5ae698de58cbe')
    repo.commits('v0.1')

You can specify the maximum number of commits to return.

    repo.commits('master', 100)

If you need paging, you can specify a number of commits to skip.

    repo.commits('master', 10, 20)

The above will return commits 21-30 from the commit list.


### The Commit object

`Commit` objects contain information about that commit.

    head = repo.commits.first

    head.id
    # = "e80bbd2ce67651aa18e57fb0b43618ad4baf7750"

    head.parents
    # = [#Grit::Commit "91169e1f5fa4de2eaea3f176461f5dc784796769"]

    head.tree
    # = #Grit::Tree "3536eb9abac69c3e4db583ad38f3d30f8db4771f"

    head.author
    # = #Grit::Actor "Tom Preston-Werner tom@mojombo.com"

    head.authored_date
    # = Wed Oct 24 22:02:31 -0700 2007

    head.committer
    # = #Grit::Actor "Tom Preston-Werner tom@mojombo.com"

    head.committed_date
    # = Wed Oct 24 22:02:31 -0700 2007

    head.message
    # = "add Actor inspect"

You can traverse a commit's ancestry by chaining calls to `#parents`.

    repo.commits.first.parents[0].parents[0].parents[0]

The above corresponds to **master^^^** or **master~3** in Git parlance.


### The Tree object

A tree records pointers to the contents of a directory. Let's say you want
the root tree of the latest commit on the **master** branch.

    tree = repo.commits.first.tree
    # = #Grit::Tree "3536eb9abac69c3e4db583ad38f3d30f8db4771f"

    tree.id
    # = "3536eb9abac69c3e4db583ad38f3d30f8db4771f"

Once you have a tree, you can get the contents.

    contents = tree.contents
    # = [#Grit::Blob "4ebc8aea50e0a67e000ba29a30809d0a7b9b2666",
          #Grit::Blob "81d2c27608b352814cbe979a6acd678d30219678",
          #Grit::Tree "c3d07b0083f01a6e1ac969a0f32b8d06f20c62e5",
          #Grit::Tree "4d00fe177a8407dbbc64a24dbfc564762c0922d8"]

This tree contains two `Blob` objects and two `Tree` objects. The trees are
subdirectories and the blobs are files. Trees below the root have additional
attributes.

    contents.last.name
    # = "lib"

    contents.last.mode
    # = "040000"

There is a convenience method that allows you to get a named sub-object
from a tree.

    tree / "lib"
    # = #Grit::Tree "e74893a3d8a25cbb1367cf241cc741bfd503c4b2"

You can also get a tree directly from the repo if you know its name.

    repo.tree
    # = #Grit::Tree "master"

    repo.tree("91169e1f5fa4de2eaea3f176461f5dc784796769")
    # = #Grit::Tree "91169e1f5fa4de2eaea3f176461f5dc784796769"


### The Blob object

A blob represents a file. Trees often contain blobs.

    blob = tree.contents.first
    # = #Grit::Blob "4ebc8aea50e0a67e000ba29a30809d0a7b9b2666"

A blob has certain attributes.

    blob.id
    # = "4ebc8aea50e0a67e000ba29a30809d0a7b9b2666"

    blob.name
    # = "README.txt"

    blob.mode
    # = "100644"

    blob.size
    # = 7726

You can get the data of a blob as a string.

    blob.data
    # = "Grit is a library to ..."

You can also get a blob directly from the repo if you know its name.

    repo.blob("4ebc8aea50e0a67e000ba29a30809d0a7b9b2666")
    # = #Grit::Blob "4ebc8aea50e0a67e000ba29a30809d0a7b9b2666"


### Other

There are many more API methods available that are not documented here. Please
reference the code for more functionality.


Copyright
---------

Copyright (c) 2010 Tom Preston-Werner. See LICENSE for details.
</content>
		</actual_file>
		<actual_file>
			<filename>ex_add_commit.rb</filename>
			<content>require '../lib/grit'

count = 1
Dir.chdir("/Users/schacon/projects/atest") do
  r = Grit::Repo.new('.')
  while(count  10) do
    fname = Time.now.to_i.to_s + count.to_s
    File.open(fname, 'w') { |f| f.write('hellor ' + fname) }
    r.add(fname)
    count += 1
  end
  r.commit_index('my commit')
end</content>
		</actual_file>
		<actual_file>
			<filename>ex_index.rb</filename>
			<content>require '../lib/grit'

count = 1
Dir.chdir("/Users/schacon/projects/atest") do
  r = Grit::Repo.new('.')
  i = r.index
  while(count  10) do
    fname = Time.now.to_i.to_s + count.to_s
    i.add(fname, 'hello ' + fname)
    count += 1
  end
  count = 5
  while(count  10) do
    puts "HELLO"
    fname = Time.now.to_i.to_s + count.to_s
    i.add('test/' + fname, 'hello ' + fname)
    count += 1
  end
  puts i.commit('my commit')
  puts i.inspect
end</content>
		</actual_file>
		<actual_file>
			<filename>grit.rb</filename>
			<content>$:.unshift File.dirname(__FILE__) # For use/testing when no gem is installed

# core
require 'fileutils'
require 'time'

# stdlib
require 'timeout'
require 'logger'
require 'digest/sha1'

# third party

begin
  require 'mime/types'
  require 'rubygems'
rescue LoadError
  require 'rubygems'
  begin
    gem "mime-types", "=0"
    require 'mime/types'
  rescue Gem::LoadError = e
    puts "WARNING: Gem LoadError: #{e.message}"
  end
end

# ruby 1.9 compatibility
require 'grit/ruby1.9'

# internal requires
require 'grit/lazy'
require 'grit/errors'
require 'grit/git-ruby'
require 'grit/git' unless defined? Grit::Git
require 'grit/ref'
require 'grit/tag'
require 'grit/commit'
require 'grit/commit_stats'
require 'grit/tree'
require 'grit/blob'
require 'grit/actor'
require 'grit/diff'
require 'grit/config'
require 'grit/repo'
require 'grit/index'
require 'grit/status'
require 'grit/submodule'
require 'grit/blame'
require 'grit/merge'

module Grit
  VERSION = '2.5.0'

  class  self
    # Set +debug+ to true to log all git calls and responses
    attr_accessor :debug
    attr_accessor :use_git_ruby
    attr_accessor :no_quote

    # The standard +logger+ for debugging git calls - this defaults to a plain STDOUT logger
    attr_accessor :logger
    def log(str)
      logger.debug { str }
    end
  end
  self.debug = false
  self.use_git_ruby = true
  self.no_quote = false

  @logger ||= ::Logger.new(STDOUT)

  def self.version
    VERSION
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>actor.rb</filename>
			<content>module Grit

  class Actor
    attr_reader :name
    attr_reader :email

    def initialize(name, email)
      @name = name
      @email = email
    end
    alias_method :to_s, :name

    # Create an Actor from a string.
    #
    # str - The String in this format: 'John Doe jdoe@example.com'
    #
    # Returns Git::Actor.
    def self.from_string(str)
      case str
        when /.+/
          m, name, email = *str.match(/(.*) (.+?)/)
          return self.new(name, email)
        else
          return self.new(str, nil)
      end
    end

    # Outputs an actor string for Git commits.
    #
    #   actor = Actor.new('bob', 'bob@email.com')
    #   actor.output(time) # = "bob bob@email.com UNIX_TIME +0700"
    #
    # time - The Time the commit was authored or committed.
    #
    # Returns a String.
    def output(time)
      offset = time.utc_offset / 60
      "%s %s %d %+.2d%.2d" % [
        @name,
        @email || "null",
        time.to_i,
        offset / 60,
        offset.abs % 60]
    end

    # Pretty object inspection
    def inspect
      %Q{#Grit::Actor "#{@name} #{@email}"}
    end
  end # Actor

end # Grit
</content>
		</actual_file>
		<actual_file>
			<filename>blame.rb</filename>
			<content>module Grit

  class Blame

    attr_reader :lines

    def initialize(repo, file, commit, lines=nil)
      @repo = repo
      @file = file
      @commit = commit
      if lines.nil?
        @lines = []
        load_blame
      else
        @lines = lines
      end
    end

    def load_blame
      output = @repo.git.blame({'p' = true}, @commit, '--', @file)
      process_raw_blame(output)
    end

    def process_raw_blame(output)
      lines, final = [], []
      info, commits = {}, {}

      # process the output
      output.split("\n").each do |line|
        if line[0, 1] == "\t"
          lines  line[1, line.size]
        elsif m = /^(\w{40}) (\d+) (\d+)/.match(line)
          commit_id, old_lineno, lineno = m[1], m[2].to_i, m[3].to_i
          commits[commit_id] = nil if !commits.key?(commit_id)
          info[lineno] = [commit_id, old_lineno]
        end
      end

      # load all commits in single call
      @repo.batch(*commits.keys).each do |commit|
        commits[commit.id] = commit
      end

      # get it together
      info.sort.each do |lineno, (commit_id, old_lineno)|
        commit = commits[commit_id]
        final  BlameLine.new(lineno, old_lineno, commit, lines[lineno - 1])
      end

      @lines = final
    end

    # Pretty object inspection
    def inspect
      %Q{#Grit::Blame "#{@file} #{@commit}"}
    end

    class BlameLine
      attr_accessor :lineno, :oldlineno, :commit, :line
      def initialize(lineno, oldlineno, commit, line)
        @lineno = lineno
        @oldlineno = oldlineno
        @commit = commit
        @line = line
      end
    end

  end # Blame

end # Grit
</content>
		</actual_file>
		<actual_file>
			<filename>blob.rb</filename>
			<content>module Grit

  class Blob
    DEFAULT_MIME_TYPE = "text/plain"

    attr_reader :id
    attr_reader :mode
    attr_reader :name

    # Create an unbaked Blob containing just the specified attributes
    #   +repo+ is the Repo
    #   +atts+ is a Hash of instance variable data
    #
    # Returns Grit::Blob (unbaked)
    def self.create(repo, atts)
      self.allocate.create_initialize(repo, atts)
    end

    # Initializer for Blob.create
    #   +repo+ is the Repo
    #   +atts+ is a Hash of instance variable data
    #
    # Returns Grit::Blob (unbaked)
    def create_initialize(repo, atts)
      @repo = repo
      atts.each do |k, v|
        instance_variable_set("@#{k}".to_sym, v)
      end
      self
    end

    # The size of this blob in bytes
    #
    # Returns Integer
    def size
      @size ||= @repo.git.cat_file({:s = true}, id).chomp.to_i
    end

    # The binary contents of this blob.
    #
    # Returns String
    def data
      @data ||= @repo.git.cat_file({:p = true}, id)
    end

    # The mime type of this file (based on the filename)
    #
    # Returns String
    def mime_type
      guesses = MIME::Types.type_for(self.name) rescue []
      guesses.first ? guesses.first.simplified : DEFAULT_MIME_TYPE
    end

    # The blame information for the given file at the given commit
    #
    # Returns Array: [Grit::Commit, Array: [line]]
    def self.blame(repo, commit, file)
      data = repo.git.blame({:p = true}, commit, '--', file)

      commits = {}
      blames = []
      info = nil

      data.split("\n").each do |line|
        parts = line.split(/\s+/, 2)
        case parts.first
          when /^[0-9A-Fa-f]{40}$/
            case line
              when /^([0-9A-Fa-f]{40}) (\d+) (\d+) (\d+)$/
                _, id, origin_line, final_line, group_lines = *line.match(/^([0-9A-Fa-f]{40}) (\d+) (\d+) (\d+)$/)
                info = {:id = id}
                blames  [nil, []]
              when /^([0-9A-Fa-f]{40}) (\d+) (\d+)$/
                _, id, origin_line, final_line = *line.match(/^([0-9A-Fa-f]{40}) (\d+) (\d+)$/)
                info = {:id = id}
            end
          when /^(author|committer)/
            case parts.first
              when /^(.+)-mail$/
                info["#{$1}_email".intern] = parts.last
              when /^(.+)-time$/
                info["#{$1}_date".intern] = Time.at(parts.last.to_i)
              when /^(author|committer)$/
                info[$1.intern] = parts.last
            end
          when /^filename/
            info[:filename] = parts.last
          when /^summary/
            info[:summary] = parts.last
          when ''
            c = commits[info[:id]]
            unless c
              c = Commit.create(repo, :id = info[:id],
                                      :author = Actor.from_string(info[:author] + ' ' + info[:author_email]),
                                      :authored_date = info[:author_date],
                                      :committer = Actor.from_string(info[:committer] + ' ' + info[:committer_email]),
                                      :committed_date = info[:committer_date],
                                      :message = info[:summary])
              commits[info[:id]] = c
            end
            _, text = *line.match(/^\t(.*)$/)
            blames.last[0] = c
            blames.last[1]  text
            info = nil
        end
      end

      blames
    end

    def basename
      File.basename(name)
    end

    # Pretty object inspection
    def inspect
      %Q{#Grit::Blob "#{@id}"}
    end

    # Compares blobs by name
    def =(other)
      name = other.name
    end
  end # Blob

end # Grit</content>
		</actual_file>
		<actual_file>
			<filename>commit.rb</filename>
			<content>module Grit

  class Commit
    extend Lazy

    attr_reader :id
    attr_reader :repo
    lazy_reader :parents
    lazy_reader :tree
    lazy_reader :author
    lazy_reader :authored_date
    lazy_reader :committer
    lazy_reader :committed_date
    lazy_reader :message
    lazy_reader :short_message

    # Parses output from the `git-cat-file --batch'.
    #
    # repo   - Grit::Repo instance.
    # sha    - String SHA of the Commit.
    # size   - Fixnum size of the object.
    # object - Parsed String output from `git cat-file --batch`.
    #
    # Returns an Array of Grit::Commit objects.
    def self.parse_batch(repo, sha, size, object)
      info, message = object.split("\n\n", 2)

      lines = info.split("\n")
      tree = lines.shift.split(' ', 2).last
      parents = []
      parents  lines.shift[7..-1] while lines.first[0, 6] == 'parent'
      author,    authored_date  = Grit::Commit.actor(lines.shift)
      committer, committed_date = Grit::Commit.actor(lines.shift)

      Grit::Commit.new(
        repo, sha, parents, tree,
        author, authored_date,
        committer, committed_date,
        message.to_s.split("\n"))
    end

    # Instantiate a new Commit
    #   +id+ is the id of the commit
    #   +parents+ is an array of commit ids (will be converted into Commit instances)
    #   +tree+ is the correspdonding tree id (will be converted into a Tree object)
    #   +author+ is the author string
    #   +authored_date+ is the authored Time
    #   +committer+ is the committer string
    #   +committed_date+ is the committed Time
    #   +message+ is an array of commit message lines
    #
    # Returns Grit::Commit (baked)
    def initialize(repo, id, parents, tree, author, authored_date, committer, committed_date, message)
      @repo = repo
      @id = id
      @parents = parents.map { |p| Commit.create(repo, :id = p) }
      @tree = Tree.create(repo, :id = tree)
      @author = author
      @authored_date = authored_date
      @committer = committer
      @committed_date = committed_date
      @message = message.join("\n")
      @short_message = message.find { |x| !x.strip.empty? } || ''
    end

    def id_abbrev
      @id_abbrev ||= @repo.git.rev_parse({}, self.id).chomp[0, 7]
    end

    # Create an unbaked Commit containing just the specified attributes
    #   +repo+ is the Repo
    #   +atts+ is a Hash of instance variable data
    #
    # Returns Grit::Commit (unbaked)
    def self.create(repo, atts)
      self.allocate.create_initialize(repo, atts)
    end

    # Initializer for Commit.create
    #   +repo+ is the Repo
    #   +atts+ is a Hash of instance variable data
    #
    # Returns Grit::Commit (unbaked)
    def create_initialize(repo, atts)
      @repo = repo
      atts.each do |k, v|
        instance_variable_set("@#{k}", v)
      end
      self
    end

    def lazy_source
      self.class.find_all(@repo, @id, {:max_count = 1}).first
    end

    # Count the number of commits reachable from this ref
    #   +repo+ is the Repo
    #   +ref+ is the ref from which to begin (SHA1 or name)
    #
    # Returns Integer
    def self.count(repo, ref)
      repo.git.rev_list({}, ref).size / 41
    end

    # Find all commits matching the given criteria.
    #   +repo+ is the Repo
    #   +ref+ is the ref from which to begin (SHA1 or name) or nil for --all
    #   +options+ is a Hash of optional arguments to git
    #     :max_count is the maximum number of commits to fetch
    #     :skip is the number of commits to skip
    #
    # Returns Grit::Commit[] (baked)
    def self.find_all(repo, ref, options = {})
      allowed_options = [:max_count, :skip, :since]

      default_options = {:pretty = "raw"}
      actual_options = default_options.merge(options)

      if ref
        output = repo.git.rev_list(actual_options, ref)
      else
        output = repo.git.rev_list(actual_options.merge(:all = true))
      end

      self.list_from_string(repo, output)
    rescue Grit::GitRuby::Repository::NoSuchShaFound
      []
    end

    # Parse out commit information into an array of baked Commit objects
    #   +repo+ is the Repo
    #   +text+ is the text output from the git command (raw format)
    #
    # Returns Grit::Commit[] (baked)
    #
    # really should re-write this to be more accepting of non-standard commit messages
    # - it broke when 'encoding' was introduced - not sure what else might show up
    #
    def self.list_from_string(repo, text)
      lines = text.split("\n")

      commits = []

      while !lines.empty?
        id = lines.shift.split.last
        tree = lines.shift.split.last

        parents = []
        parents  lines.shift.split.last while lines.first =~ /^parent/

        author_line = lines.shift
        author_line  lines.shift if lines[0] !~ /^committer /
        author, authored_date = self.actor(author_line)

        committer_line = lines.shift
        committer_line  lines.shift if lines[0] && lines[0] != '' && lines[0] !~ /^encoding/
        committer, committed_date = self.actor(committer_line)

        # not doing anything with this yet, but it's sometimes there
        encoding = lines.shift.split.last if lines.first =~ /^encoding/

        lines.shift

        message_lines = []
        message_lines  lines.shift[4..-1] while lines.first =~ /^ {4}/

        lines.shift while lines.first && lines.first.empty?

        commits  Commit.new(repo, id, parents, tree, author, authored_date, committer, committed_date, message_lines)
      end

      commits
    end

    # Show diffs between two trees.
    #
    # repo    - The current Grit::Repo instance.
    # a       - A String named commit.
    # b       - An optional String named commit.  Passing an array assumes you
    #           wish to omit the second named commit and limit the diff to the
    #           given paths.
    # paths   - An optional Array of paths to limit the diff.
    # options - An optional Hash of options.  Merged into {:full_index = true}.
    #
    # Returns Grit::Diff[] (baked)
    def self.diff(repo, a, b = nil, paths = [], options = {})
      if b.is_a?(Array)
        paths = b
        b     = nil
      end
      paths.unshift("--") unless paths.empty?
      paths.unshift(b)    unless b.nil?
      paths.unshift(a)
      options = {:full_index = true}.update(options)
      text    = repo.git.diff(options, *paths)
      Diff.list_from_string(repo, text)
    end

    def show
      if parents.size  1
        diff = @repo.git.native(:diff, {:full_index = true}, "#{parents[0].id}...#{parents[1].id}")
      else
        diff = @repo.git.show({:full_index = true, :pretty = 'raw'}, @id)
      end

      if diff =~ /diff --git a/
        diff = diff.sub(/.+?(diff --git a)/m, '\1')
      else
        diff = ''
      end
      Diff.list_from_string(@repo, diff)
    end

    # Shows diffs between the commit's parent and the commit.
    #
    # options - An optional Hash of options, passed to Grit::Commit.diff.
    #
    # Returns Grit::Diff[] (baked)
    def diffs(options = {})
      if parents.empty?
        show
      else
        self.class.diff(@repo, parents.first.id, @id, [], options)
      end
    end

    def stats
      stats = @repo.commit_stats(self.sha, 1)[0][-1]
    end

    # Convert this Commit to a String which is just the SHA1 id
    def to_s
      @id
    end

    def sha
      @id
    end

    def date
      @committed_date
    end

    def to_patch
      @repo.git.format_patch({'1' = true, :stdout = true}, to_s)
    end

    def notes
      ret = {}
      notes = Note.find_all(@repo)
      notes.each do |note|
        if n = note.commit.tree/(self.id)
          ret[note.name] = n.data
        end
      end
      ret
    end

    # Calculates the commit's Patch ID. The Patch ID is essentially the SHA1
    # of the diff that the commit is introducing.
    #
    # Returns the 40 character hex String if a patch-id could be calculated
    #   or nil otherwise.
    def patch_id
      show = @repo.git.show({}, @id)
      patch_line = @repo.git.native(:patch_id, :input = show)
      if patch_line =~ /^([0-9a-f]{40}) [0-9a-f]{40}\n$/
        $1
      else
        nil
      end
    end

    # Pretty object inspection
    def inspect
      %Q{#Grit::Commit "#{@id}"}
    end

    # private

    # Parse out the actor (author or committer) info
    #
    # Returns [String (actor name and email), Time (acted at time)]
    def self.actor(line)
      m, actor, epoch = *line.match(/^.+? (.*) (\d+) .*$/)
      [Actor.from_string(actor), Time.at(epoch.to_i)]
    end

    def author_string
      "%s %s %s %+05d" % [author.name, author.email, authored_date.to_i, 800]
    end

    def to_hash
      {
        'id'       = id,
        'parents'  = parents.map { |p| { 'id' = p.id } },
        'tree'     = tree.id,
        'message'  = message,
        'author'   = {
          'name'  = author.name,
          'email' = author.email
        },
        'committer' = {
          'name'  = committer.name,
          'email' = committer.email
        },
        'authored_date'  = authored_date.xmlschema,
        'committed_date' = committed_date.xmlschema,
      }
    end
  end # Commit

end # Grit
</content>
		</actual_file>
		<actual_file>
			<filename>commit_stats.rb</filename>
			<content>module Grit

  class CommitStats

    attr_reader :id, :files, :additions, :deletions, :total

    # Instantiate a new CommitStats
    #   +id+ is the id of the commit
    #   +files+ is an array of :
    #     [ [filename, adds, deletes, total],
    #       [filename, adds, deletes, total],
    #       [filename, adds, deletes, total] ]
    #
    # Returns Grit::CommitStats (baked)
    def initialize(repo, id, files)
      @repo = repo
      @id = id
      @files = files
      @additions  = files.inject(0) { |total, a| total += a[1] }
      @deletions  = files.inject(0) { |total, a| total += a[2] }
      @total  = files.inject(0) { |total, a| total += a[3] }
    end

    # Find all commit stats matching the given criteria.
    #   +repo+ is the Repo
    #   +ref+ is the ref from which to begin (SHA1 or name) or nil for --all
    #   +options+ is a Hash of optional arguments to git
    #     :max_count is the maximum number of commits to fetch
    #     :skip is the number of commits to skip
    #
    # Returns assoc array [sha, Grit::Commit[] (baked)]
    def self.find_all(repo, ref, options = {})
      allowed_options = [:max_count, :skip, :since]

      default_options = {:numstat = true}
      actual_options = default_options.merge(options)

      if ref
        output = repo.git.log(actual_options, ref)
      else
        output = repo.git.log(actual_options.merge(:all = true))
      end

      self.list_from_string(repo, output)
    end

    # Parse out commit information into an array of baked Commit objects
    #   +repo+ is the Repo
    #   +text+ is the text output from the git command (raw format)
    #
    # Returns assoc array [sha, Grit::Commit[] (baked)]
    def self.list_from_string(repo, text)
      lines = text.split("\n")

      commits = []

      while !lines.empty?
        id = lines.shift.split.last

        lines.shift
        lines.shift
        lines.shift

        message_lines = []
        message_lines  lines.shift[4..-1] while lines.first =~ /^ {4}/ || lines.first == ''

        lines.shift while lines.first && lines.first.empty?

        files = []
        while lines.first =~ /^([-\d]+)\s+([-\d]+)\s+(.+)/
          (additions, deletions, filename) = lines.shift.split
          additions = additions.to_i
          deletions = deletions.to_i
          total = additions + deletions
          files  [filename, additions, deletions, total]
        end

        lines.shift while lines.first && lines.first.empty?

        commits  [id, CommitStats.new(repo, id, files)]
      end

      commits
    end

    # Pretty object inspection
    def inspect
      %Q{#Grit::CommitStats "#{@id}"}
    end

    # Convert to an easy-to-traverse structure
    def to_diffstat
      files.map do |metadata|
        DiffStat.new(*metadata)
      end
    end

    # private

    def to_hash
      {
        'id'        = id,
        'files'     = files,
        'additions' = additions,
        'deletions' = deletions,
        'total'     = total
      }
    end

  end # CommitStats

  class DiffStat
    attr_reader :filename, :additions, :deletions

    def initialize(filename, additions, deletions, total=nil)
      @filename, @additions, @deletions = filename, additions, deletions
    end

    def net
      additions - deletions
    end

    def inspect
      "#{filename}: +#{additions} -#{deletions}"
    end
  end

end # Grit
</content>
		</actual_file>
		<actual_file>
			<filename>config.rb</filename>
			<content>module Grit

  class Config
    def initialize(repo)
      @repo = repo
    end

    def []=(key, value)
      @repo.git.config({}, key, value)
      @data = nil
    end

    def [](key)
      data[key]
    end

    def fetch(key, default = nil)
      data[key] || default || raise(IndexError.new("key not found"))
    end

    def keys
      data.keys
    end

    protected
      def data
        @data ||= load_config
      end

      def load_config
        hash = {}
        config_lines.map do |line|
          key, value = line.split(/=/, 2)
          hash[key] = value
        end
        hash
      end

      def config_lines
        @repo.git.config(:list = true).split(/\n/)
      end
  end # Config

end # Grit</content>
		</actual_file>
		<actual_file>
			<filename>diff.rb</filename>
			<content>module Grit

  class Diff
    attr_reader :a_path, :b_path
    attr_reader :a_blob, :b_blob
    attr_reader :a_mode, :b_mode
    attr_reader :new_file, :deleted_file, :renamed_file
    attr_reader :similarity_index
    attr_accessor :diff

    def initialize(repo, a_path, b_path, a_blob, b_blob, a_mode, b_mode, new_file, deleted_file, diff, renamed_file = false, similarity_index = 0)
      @repo   = repo
      @a_path = a_path
      @b_path = b_path
      @a_blob = a_blob =~ /^0{40}$/ ? nil : Blob.create(repo, :id = a_blob)
      @b_blob = b_blob =~ /^0{40}$/ ? nil : Blob.create(repo, :id = b_blob)
      @a_mode = a_mode
      @b_mode = b_mode
      @new_file         = new_file     || @a_blob.nil?
      @deleted_file     = deleted_file || @b_blob.nil?
      @renamed_file     = renamed_file
      @similarity_index = similarity_index.to_i
      @diff             = diff
    end

    def self.list_from_string(repo, text)
      lines = text.split("\n")

      diffs = []

      while !lines.empty?
        m, a_path, b_path = *lines.shift.match(%r{^diff --git a/(.+?) b/(.+)$})

        if lines.first =~ /^old mode/
          m, a_mode = *lines.shift.match(/^old mode (\d+)/)
          m, b_mode = *lines.shift.match(/^new mode (\d+)/)
        end

        if lines.empty? || lines.first =~ /^diff --git/
          diffs  Diff.new(repo, a_path, b_path, nil, nil, a_mode, b_mode, false, false, nil)
          next
        end

        sim_index    = 0
        new_file     = false
        deleted_file = false
        renamed_file = false

        if lines.first =~ /^new file/
          m, b_mode = lines.shift.match(/^new file mode (.+)$/)
          a_mode    = nil
          new_file  = true
        elsif lines.first =~ /^deleted file/
          m, a_mode    = lines.shift.match(/^deleted file mode (.+)$/)
          b_mode       = nil
          deleted_file = true
        elsif lines.first =~ /^similarity index (\d+)\%/
          sim_index    = $1.to_i
          renamed_file = true
          2.times { lines.shift } # shift away the 2 `rename from/to ...` lines
        end

        m, a_blob, b_blob, b_mode = *lines.shift.match(%r{^index ([0-9A-Fa-f]+)\.\.([0-9A-Fa-f]+) ?(.+)?$})
        b_mode.strip! if b_mode

        diff_lines = []
        while lines.first && lines.first !~ /^diff/
          diff_lines  lines.shift
        end
        diff = diff_lines.join("\n")

        diffs  Diff.new(repo, a_path, b_path, a_blob, b_blob, a_mode, b_mode, new_file, deleted_file, diff, renamed_file, sim_index)
      end

      diffs
    end
  end # Diff

end # Grit
</content>
		</actual_file>
		<actual_file>
			<filename>errors.rb</filename>
			<content>module Grit
  class InvalidGitRepositoryError  StandardError
  end

  class NoSuchPathError  StandardError
  end

  class InvalidObjectType  StandardError
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>git-ruby.rb</filename>
			<content>require 'grit/git-ruby/repository'

module Grit

  # the functions in this module intercept the calls to git binary
  # made by the grit objects and attempts to run them in pure ruby
  # if it will be faster, or if the git binary is not available (!!TODO!!)
  module GitRuby

    attr_accessor :ruby_git_repo, :git_file_index

    def init(options, *args)
      if options.size == 0
        Grit::GitRuby::Repository.init(@git_dir)
      else
        method_missing('init', options, *args)
      end
    end

    def cat_file(options, sha)
      if options[:t]
        file_type(sha)
      elsif options[:s]
        file_size(sha)
      elsif options[:p]
        try_run { ruby_git.cat_file(sha) }
      end
    rescue Grit::GitRuby::Repository::NoSuchShaFound
      ''
    end

    def cat_ref(options, ref)
      sha = rev_parse({}, ref)
      cat_file(options, sha)
    end

    # lib/grit/tree.rb:16:      output = repo.git.ls_tree({}, treeish, *paths)
    def ls_tree(options, treeish, *paths)
      sha = rev_parse({}, treeish)
      ruby_git.ls_tree(sha, paths.flatten, options.delete(:r))
    rescue Grit::GitRuby::Repository::NoSuchShaFound
      ''
    end

    # git diff --full-index 'ec037431382e83c3e95d4f2b3d145afbac8ea55d' 'f1ec1aea10986159456846b8a05615b87828d6c6'
    def diff(options, sha1, sha2 = nil)
      try_run { ruby_git.diff(sha1, sha2, options) }
    end

    def rev_list(options, *refs)
      refs = ['master'] if refs.empty?
      options.delete(:skip) if options[:skip].to_i == 0
      allowed_options = [:max_count, :since, :until, :pretty]  # this is all I can do right now
      if ((options.keys - allowed_options).size  0) || refs.size  1
        method_missing('rev-list', options, *refs)
      elsif (options.size == 0)
        # pure rev-list
        ref = refs.first
        begin
          file_index.commits_from(rev_parse({}, ref)).join("\n") + "\n"
        rescue
          method_missing('rev-list', options, *refs)
        end
      else
        ref = refs.first
        aref = rev_parse({:verify = true}, ref)
        if aref.is_a? Array
          method_missing('rev-list', options, *refs)
        else
          try_run { ruby_git.rev_list(aref, options) }
        end
      end
    end

    def rev_parse(options, string)
      raise RuntimeError, "invalid string: #{string.inspect}" unless string.is_a?(String)

      # Split ranges, but don't split when specifying a ref:path.
      # Don't split HEAD:some/path/in/repo..txt
      # Do split sha1..sha2
      if string !~ /:/ && string =~ /\.\./
        (sha1, sha2) = string.split('..')
        return [rev_parse({}, sha1), rev_parse({}, sha2)]
      end

      if /^[0-9a-f]{40}$/.match(string)  # passing in a sha - just no-op it
        return string.chomp
      end

      head = File.join(@git_dir, 'refs', 'heads', string)
      return File.read(head).chomp if File.file?(head)

      head = File.join(@git_dir, 'refs', 'remotes', string)
      return File.read(head).chomp if File.file?(head)

      head = File.join(@git_dir, 'refs', 'tags', string)
      return File.read(head).chomp if File.file?(head)

      ## check packed-refs file, too
      packref = File.join(@git_dir, 'packed-refs')
      if File.file?(packref)
        File.readlines(packref).each do |line|
          if m = /^(\w{40}) refs\/.+?\/(.*?)$/.match(line)
            next if !Regexp.new(Regexp.escape(string) + '$').match(m[3])
            return m[1].chomp
          end
        end
      end

      ## !! more - partials and such !!

      # revert to calling git - grr
      return method_missing('rev-parse', options, string).chomp
    end

    def refs(options, prefix)
      refs = []
      already = {}
      Dir.chdir(@git_dir) do
        files = Dir.glob(prefix + '/**/*')
        files.each do |ref|
          next if !File.file?(ref)
          id = File.read(ref).chomp
          name = ref.sub("#{prefix}/", '')
          if !already[name]
            refs  "#{name} #{id}"
            already[name] = true
          end
        end

        if File.file?('packed-refs')
          File.readlines('packed-refs').each do |line|
            if m = /^(\w{40}) (.*?)$/.match(line)
              next if !Regexp.new('^' + prefix).match(m[2])
              name = m[2].sub("#{prefix}/", '')
              if !already[name]
                refs  "#{name} #{m[1]}"
                already[name] = true
              end
            end
          end
        end
      end

      refs.join("\n")
    end

    def tags(options, prefix)
      refs = []
      already = {}

      Dir.chdir(repo.path) do
        files = Dir.glob(prefix + '/**/*')

        files.each do |ref|
          next if !File.file?(ref)

          id = File.read(ref).chomp
          name = ref.sub("#{prefix}/", '')

          if !already[name]
            refs  "#{name} #{id}"
            already[name] = true
          end
        end

        if File.file?('packed-refs')
          lines = File.readlines('packed-refs')
          lines.each_with_index do |line, i|
            if m = /^(\w{40}) (.*?)$/.match(line)
              next if !Regexp.new('^' + prefix).match(m[2])
              name = m[2].sub("#{prefix}/", '')

              # Annotated tags in packed-refs include a reference
              # to the commit object on the following line.
              next_line = lines[i + 1]

              id =
              if next_line && next_line[0] == ?^
                next_line[1..-1].chomp
              else
                m[1]
              end

              if !already[name]
                refs  "#{name} #{id}"
                already[name] = true
              end
            end
          end
        end
      end

      refs.join("\n")
    end

    def file_size(ref)
      try_run { ruby_git.cat_file_size(ref).to_s }
    end

    def file_type(ref)
      try_run { ruby_git.cat_file_type(ref).to_s }
    end

    def ruby_git
      @ruby_git_repo ||= Repository.new(@git_dir)
    end

    private

      def try_run
        ret = ''
        Timeout.timeout(self.class.git_timeout) do
          ret = yield
        end
        @bytes_read += ret.size

        #if @bytes_read  5242880 # 5.megabytes
        #  bytes = @bytes_read
        #  @bytes_read = 0
        #  raise Grit::Git::GitTimeout.new(command, bytes)
        #end

        ret
      rescue Timeout::Error = e
        bytes = @bytes_read
        @bytes_read = 0
        raise Grit::Git::GitTimeout.new(command, bytes)
      end

      def looking_for(commit, path = nil)
        tree_sha = ruby_git.get_subtree(rev_parse({}, commit), path)

        looking_for = []
        ruby_git.get_object_by_sha1(tree_sha).entry.each do |e|
          if path && !(path == '' || path == '.' || path == './')
            file = File.join(path, e.name)
          else
            file = e.name
          end
          file += '/' if e.type == :directory
          looking_for  file
        end
        looking_for
      end

      def clean_paths(commit_array)
        new_commits = {}
        commit_array.each do |file, sha|
          file = file.chop if file[file.size - 1 , 1] == '/'
          new_commits[file] = sha
        end
        new_commits
      end

    # TODO
    # git grep -n 'foo' 'master'
    # git log --pretty='raw' --max-count='1' 'master' -- 'LICENSE'
    # git log --pretty='raw' --max-count='1' 'master' -- 'test'

  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>git.rb</filename>
			<content>require 'tempfile'
require 'posix-spawn'
module Grit

  class Git
    include POSIX::Spawn

    class GitTimeout  RuntimeError
      attr_accessor :command
      attr_accessor :bytes_read

      def initialize(command = nil, bytes_read = nil)
        @command = command
        @bytes_read = bytes_read
      end
    end

    # Raised when a native git command exits with non-zero.
    class CommandFailed  StandardError
      # The full git command that failed as a String.
      attr_reader :command

      # The integer exit status.
      attr_reader :exitstatus

      # Everything output on the command's stderr as a String.
      attr_reader :err

      def initialize(command, exitstatus=nil, err='')
        if exitstatus
          @command = command
          @exitstatus = exitstatus
          @err = err
          message = "Command failed [#{exitstatus}]: #{command}"
          message  "\n\n"  err unless err.nil? || err.empty?
          super message
        else
          super command
        end
      end
    end

    undef_method :clone

    include GitRuby

    def exist?
      File.exist?(self.git_dir)
    end

    def put_raw_object(content, type)
      ruby_git.put_raw_object(content, type)
    end

    def get_raw_object(object_id)
      ruby_git.get_raw_object_by_sha1(object_id).content
    end

    def get_git_object(object_id)
      ruby_git.get_raw_object_by_sha1(object_id).to_hash
    end

    def object_exists?(object_id)
      ruby_git.object_exists?(object_id)
    end

    def select_existing_objects(object_ids)
      object_ids.select do |object_id|
        object_exists?(object_id)
      end
    end

    class  self
      attr_accessor :git_timeout, :git_max_size
      def git_binary
        @git_binary ||=
          ENV['PATH'].split(':').
            map  { |p| File.join(p, 'git') }.
            find { |p| File.exist?(p) }
      end
      attr_writer :git_binary
    end

    self.git_timeout  = 10
    self.git_max_size = 5242880 # 5.megabytes

    def self.with_timeout(timeout = 10)
      old_timeout = Grit::Git.git_timeout
      Grit::Git.git_timeout = timeout
      yield
      Grit::Git.git_timeout = old_timeout
    end

    attr_accessor :git_dir, :bytes_read, :work_tree

    def initialize(git_dir)
      self.git_dir    = git_dir
      self.work_tree  = git_dir.gsub(/\/\.git$/,'')
      self.bytes_read = 0
    end

    def shell_escape(str)
      str.to_s.gsub("'", "\\\\'").gsub(";", '\\;')
    end
    alias_method :e, :shell_escape

    # Check if a normal file exists on the filesystem
    #   +file+ is the relative path from the Git dir
    #
    # Returns Boolean
    def fs_exist?(file)
      File.exist?(File.join(self.git_dir, file))
    end

    # Read a normal file from the filesystem.
    #   +file+ is the relative path from the Git dir
    #
    # Returns the String contents of the file
    def fs_read(file)
      File.read(File.join(self.git_dir, file))
    end

    # Write a normal file to the filesystem.
    #   +file+ is the relative path from the Git dir
    #   +contents+ is the String content to be written
    #
    # Returns nothing
    def fs_write(file, contents)
      path = File.join(self.git_dir, file)
      FileUtils.mkdir_p(File.dirname(path))
      File.open(path, 'w') do |f|
        f.write(contents)
      end
    end

    # Delete a normal file from the filesystem
    #   +file+ is the relative path from the Git dir
    #
    # Returns nothing
    def fs_delete(file)
      FileUtils.rm_rf(File.join(self.git_dir, file))
    end

    # Move a normal file
    #   +from+ is the relative path to the current file
    #   +to+ is the relative path to the destination file
    #
    # Returns nothing
    def fs_move(from, to)
      FileUtils.mv(File.join(self.git_dir, from), File.join(self.git_dir, to))
    end

    # Make a directory
    #   +dir+ is the relative path to the directory to create
    #
    # Returns nothing
    def fs_mkdir(dir)
      FileUtils.mkdir_p(File.join(self.git_dir, dir))
    end

    # Chmod the the file or dir and everything beneath
    #   +file+ is the relative path from the Git dir
    #
    # Returns nothing
    def fs_chmod(mode, file = '/')
      FileUtils.chmod_R(mode, File.join(self.git_dir, file))
    end

    def list_remotes
      remotes = []
      Dir.chdir(File.join(self.git_dir, 'refs/remotes')) do
        remotes = Dir.glob('*')
      end
      remotes
    rescue
      []
    end

    def create_tempfile(seed, unlink = false)
      path = Tempfile.new(seed).path
      File.unlink(path) if unlink
      return path
    end

    def commit_from_sha(id)
      git_ruby_repo = GitRuby::Repository.new(self.git_dir)
      object = git_ruby_repo.get_object_by_sha1(id)

      if object.type == :commit
        id
      elsif object.type == :tag
        object.object
      else
        ''
      end
    end

    # Checks if the patch of a commit can be applied to the given head.
    #
    # options     - grit command options hash
    # head_sha    - String SHA or ref to check the patch against.
    # applies_sha - String SHA of the patch.  The patch itself is retrieved
    #               with #get_patch.
    #
    # Returns 0 if the patch applies cleanly (according to `git apply`), or
    # an Integer that is the sum of the failed exit statuses.
    def check_applies(options={}, head_sha=nil, applies_sha=nil)
      options, head_sha, applies_sha = {}, options, head_sha if !options.is_a?(Hash)
      options = options.dup
      options[:env] &&= options[:env].dup

      git_index = create_tempfile('index', true)
      (options[:env] ||= {}).merge!('GIT_INDEX_FILE' = git_index)
      options[:raise] = true

      status = 0
      begin
        native(:read_tree, options.dup, head_sha)
        stdin = native(:diff, options.dup, "#{applies_sha}^", applies_sha)
        native(:apply, options.merge(:check = true, :cached = true, :input = stdin))
      rescue CommandFailed = fail
        status += fail.exitstatus
      end
      status
    end

    # Gets a patch for a given SHA using `git diff`.
    #
    # options     - grit command options hash
    # applies_sha - String SHA to get the patch from, using this command:
    #               `git diff #{applies_sha}^ #{applies_sha}`
    #
    # Returns the String patch from `git diff`.
    def get_patch(options={}, applies_sha=nil)
      options, applies_sha = {}, options if !options.is_a?(Hash)
      options = options.dup
      options[:env] &&= options[:env].dup

      git_index = create_tempfile('index', true)
      (options[:env] ||= {}).merge!('GIT_INDEX_FILE' = git_index)

      native(:diff, options, "#{applies_sha}^", applies_sha)
    end

    # Applies the given patch against the given SHA of the current repo.
    #
    # options  - grit command hash
    # head_sha - String SHA or ref to apply the patch to.
    # patch    - The String patch to apply.  Get this from #get_patch.
    #
    # Returns the String Tree SHA on a successful patch application, or false.
    def apply_patch(options={}, head_sha=nil, patch=nil)
      options, head_sha, patch = {}, options, head_sha if !options.is_a?(Hash)
      options = options.dup
      options[:env] &&= options[:env].dup
      options[:raise] = true

      git_index = create_tempfile('index', true)
      (options[:env] ||= {}).merge!('GIT_INDEX_FILE' = git_index)

      begin
        native(:read_tree, options.dup, head_sha)
        native(:apply, options.merge(:cached = true, :input = patch))
      rescue CommandFailed
        return false
      end
      native(:write_tree, :env = options[:env]).to_s.chomp!
    end

    # Execute a git command, bypassing any library implementation.
    #
    # cmd - The name of the git command as a Symbol. Underscores are
    #   converted to dashes as in :rev_parse = 'rev-parse'.
    # options - Command line option arguments passed to the git command.
    #   Single char keys are converted to short options (:a = -a).
    #   Multi-char keys are converted to long options (:arg = '--arg').
    #   Underscores in keys are converted to dashes. These special options
    #   are used to control command execution and are not passed in command
    #   invocation:
    #     :timeout - Maximum amount of time the command can run for before
    #       being aborted. When true, use Grit::Git.git_timeout; when numeric,
    #       use that number of seconds; when false or 0, disable timeout.
    #     :base - Set false to avoid passing the --git-dir argument when
    #       invoking the git command.
    #     :env - Hash of environment variable key/values that are set on the
    #       child process.
    #     :raise - When set true, commands that exit with a non-zero status
    #       raise a CommandFailed exception. This option is available only on
    #       platforms that support fork(2).
    #     :process_info - By default, a single string with output written to
    #       the process's stdout is returned. Setting this option to true
    #       results in a [exitstatus, out, err] tuple being returned instead.
    # args - Non-option arguments passed on the command line.
    #
    # Optionally yields to the block an IO object attached to the child
    # process's STDIN.
    #
    # Examples
    #   git.native(:rev_list, {:max_count = 10, :header = true}, "master")
    #
    # Returns a String with all output written to the child process's stdout
    #   when the :process_info option is not set.
    # Returns a [exitstatus, out, err] tuple when the :process_info option is
    #   set. The exitstatus is an small integer that was the process's exit
    #   status. The out and err elements are the data written to stdout and
    #   stderr as Strings.
    # Raises Grit::Git::GitTimeout when the timeout is exceeded or when more
    #   than Grit::Git.git_max_size bytes are output.
    # Raises Grit::Git::CommandFailed when the :raise option is set true and the
    #   git command exits with a non-zero exit status. The CommandFailed's #command,
    #   #exitstatus, and #err attributes can be used to retrieve additional
    #   detail about the error.
    def native(cmd, options = {}, *args, &block)
      args     = args.first if args.size == 1 && args[0].is_a?(Array)
      args.map!    { |a| a.to_s }
      args.reject! { |a| a.empty? }

      # special option arguments
      env = options.delete(:env) || {}
      raise_errors = options.delete(:raise)
      process_info = options.delete(:process_info)

      # fall back to using a shell when the last argument looks like it wants to
      # start a pipeline for compatibility with previous versions of grit.
      return run(prefix, cmd, '', options, args) if args[-1].to_s[0] == ?|

      # more options
      input    = options.delete(:input)
      timeout  = options.delete(:timeout); timeout = true if timeout.nil?
      base     = options.delete(:base);    base    = true if base.nil?
      chdir    = options.delete(:chdir)

      # build up the git process argv
      argv = []
      argv  Git.git_binary
      argv  "--git-dir=#{git_dir}" if base
      argv  cmd.to_s.tr('_', '-')
      argv.concat(options_to_argv(options))
      argv.concat(args)

      # run it and deal with fallout
      Grit.log(argv.join(' ')) if Grit.debug

      process =
        Child.new(env, *(argv + [{
          :input   = input,
          :chdir   = chdir,
          :timeout = (Grit::Git.git_timeout if timeout == true),
          :max     = (Grit::Git.git_max_size if timeout == true)
        }]))
      Grit.log(process.out) if Grit.debug
      Grit.log(process.err) if Grit.debug

      status = process.status
      if raise_errors && !status.success?
        raise CommandFailed.new(argv.join(' '), status.exitstatus, process.err)
      elsif process_info
        [status.exitstatus, process.out, process.err]
      else
        process.out
      end
    rescue TimeoutExceeded, MaximumOutputExceeded
      raise GitTimeout, argv.join(' ')
    end

    # Methods not defined by a library implementation execute the git command
    # using #native, passing the method name as the git command name.
    #
    # Examples:
    #   git.rev_list({:max_count = 10, :header = true}, "master")
    def method_missing(cmd, options={}, *args, &block)
      native(cmd, options, *args, &block)
    end

    # Transform a ruby-style options hash to command-line arguments sutiable for
    # use with Kernel::exec. No shell escaping is performed.
    #
    # Returns an Array of String option arguments.
    def options_to_argv(options)
      argv = []
      options.each do |key, val|
        if key.to_s.size == 1
          if val == true
            argv  "-#{key}"
          elsif val == false
            # ignore
          else
            argv  "-#{key}"
            argv  val.to_s
          end
        else
          if val == true
            argv  "--#{key.to_s.tr('_', '-')}"
          elsif val == false
            # ignore
          else
            argv  "--#{key.to_s.tr('_', '-')}=#{val}"
          end
        end
      end
      argv
    end

    # Simple wrapper around Timeout::timeout.
    #
    # seconds - Float number of seconds before a Timeout::Error is raised. When
    #   true, the Grit::Git.git_timeout value is used. When the timeout is less
    #   than or equal to 0, no timeout is established.
    #
    # Raises Timeout::Error when the timeout has elapsed.
    def timeout_after(seconds)
      seconds = self.class.git_timeout if seconds == true
      if seconds && seconds  0
        Timeout.timeout(seconds) { yield }
      else
        yield
      end
    end

    # DEPRECATED OPEN3-BASED COMMAND EXECUTION

    def run(prefix, cmd, postfix, options, args, &block)
      timeout  = options.delete(:timeout) rescue nil
      timeout  = true if timeout.nil?

      base     = options.delete(:base) rescue nil
      base     = true if base.nil?

      if input = options.delete(:input)
        block = lambda { |stdin| stdin.write(input) }
      end

      opt_args = transform_options(options)

      if RUBY_PLATFORM.downcase =~ /mswin(?!ce)|mingw|bccwin/
        ext_args = args.reject { |a| a.empty? }.map { |a| (a == '--' || a[0].chr == '|' || Grit.no_quote) ? a : "\"#{e(a)}\"" }
        gitdir = base ? "--git-dir=\"#{self.git_dir}\"" : ""
        call = "#{prefix}#{Git.git_binary} #{gitdir} #{cmd.to_s.gsub(/_/, '-')} #{(opt_args + ext_args).join(' ')}#{e(postfix)}"
      else
        ext_args = args.reject { |a| a.empty? }.map { |a| (a == '--' || a[0].chr == '|' || Grit.no_quote) ? a : "'#{e(a)}'" }
        gitdir = base ? "--git-dir='#{self.git_dir}'" : ""
        call = "#{prefix}#{Git.git_binary} #{gitdir} #{cmd.to_s.gsub(/_/, '-')} #{(opt_args + ext_args).join(' ')}#{e(postfix)}"
      end

      Grit.log(call) if Grit.debug
      response, err = timeout ? sh(call, &block) : wild_sh(call, &block)
      Grit.log(response) if Grit.debug
      Grit.log(err) if Grit.debug
      response
    end

    def sh(command, &block)
      process =
        Child.new(
          command,
          :timeout = Git.git_timeout,
          :max     = Git.git_max_size
        )
      [process.out, process.err]
    rescue TimeoutExceeded, MaximumOutputExceeded
      raise GitTimeout, command
    end

    def wild_sh(command, &block)
      process = Child.new(command)
      [process.out, process.err]
    end

    # Transform Ruby style options into git command line options
    #   +options+ is a hash of Ruby style options
    #
    # Returns String[]
    #   e.g. ["--max-count=10", "--header"]
    def transform_options(options)
      args = []
      options.keys.each do |opt|
        if opt.to_s.size == 1
          if options[opt] == true
            args  "-#{opt}"
          elsif options[opt] == false
            # ignore
          else
            val = options.delete(opt)
            args  "-#{opt.to_s} '#{e(val)}'"
          end
        else
          if options[opt] == true
            args  "--#{opt.to_s.gsub(/_/, '-')}"
          elsif options[opt] == false
            # ignore
          else
            val = options.delete(opt)
            args  "--#{opt.to_s.gsub(/_/, '-')}='#{e(val)}'"
          end
        end
      end
      args
    end
  end # Git

end # Grit
</content>
		</actual_file>
		<actual_file>
			<filename>index.rb</filename>
			<content>module Grit

  class Index
    # Public: Gets/Sets the Grit::Repo to which this index belongs.
    attr_accessor :repo

    # Public: Gets/Sets the Hash tree map that holds the changes to be made
    # in the next commit.
    attr_accessor :tree

    # Public: Gets/Sets the Grit::Tree object representing the tree upon
    # which the next commit will be based.
    attr_accessor :current_tree

    # Public: if a tree or commit is written, this stores the size of that object
    attr_reader :last_tree_size
    attr_reader :last_commit_size

    # Initialize a new Index object.
    #
    # repo - The Grit::Repo to which the index belongs.
    #
    # Returns the newly initialized Grit::Index.
    def initialize(repo)
      self.repo = repo
      self.tree = {}
      self.current_tree = nil
    end

    # Public: Add a file to the index.
    #
    # path - The String file path including filename (no slash prefix).
    # data - The String binary contents of the file.
    #
    # Returns nothing.
    def add(path, data)
      path = path.split('/')
      filename = path.pop

      current = self.tree

      path.each do |dir|
        current[dir] ||= {}
        node = current[dir]
        current = node
      end

      current[filename] = data
    end

    # Public: Delete the given file from the index.
    #
    # path - The String file path including filename (no slash prefix).
    #
    # Returns nothing.
    def delete(path)
      add(path, false)
    end

    # Public: Read the contents of the given Tree into the index to use as a
    # starting point for the index.
    #
    # tree - The String branch/tag/sha of the Git tree object.
    #
    # Returns nothing.
    def read_tree(tree)
      self.current_tree = self.repo.tree(tree)
    end

    # Public: Commit the contents of the index.  This method supports two
    # formats for arguments:
    #
    # message - The String commit message.
    # options - An optional Hash of index options.
    #           :parents        - Array of String commit SHA1s or Grit::Commit
    #                             objects to attach this commit to to form a 
    #                             new head (default: nil).
    #           :actor          - The Grit::Actor details of the user making
    #                             the commit (default: nil).
    #           :last_tree      - The String SHA1 of a tree to compare with
    #                             in order to avoid making empty commits
    #                             (default: nil).
    #           :head           - The String branch name to write this head to
    #                             (default: nil).
    #           :committed_date - The Time that the commit was made.
    #                             (Default: Time.now)
    #           :authored_date  - The Time that the commit was authored.
    #                             (Default: committed_date)
    #
    # The legacy argument style looks like:
    #
    # message   - The String commit message.
    # parents   - Array of String commit SHA1s or Grit::Commit objects to
    #             attach this commit to to form a new head (default: nil).
    # actor     - The Grit::Actor details of the user making the commit
    #             (default: nil).
    # last_tree - The String SHA1 of a tree to compare with in order to avoid
    #             making empty commits (default: nil).
    # head      - The String branch name to write this head to
    #             (default: "master").
    #
    # Returns a String of the SHA1 of the new commit.
    def commit(message, parents = nil, actor = nil, last_tree = nil, head = 'master')
      commit_tree_sha = nil
      if parents.is_a?(Hash)
        commit_tree_sha = parents[:commit_tree_sha]
        actor          = parents[:actor]
        committer      = parents[:committer]
        author         = parents[:author]
        last_tree      = parents[:last_tree]
        head           = parents[:head]
        committed_date = parents[:committed_date]
        authored_date  = parents[:authored_date]
        parents        = parents[:parents]
      end

      committer ||= actor
      author    ||= committer

      if commit_tree_sha
        tree_sha1 = commit_tree_sha
      else
        tree_sha1 = write_tree(self.tree, self.current_tree)
      end

      # don't write identical commits
      return false if tree_sha1 == last_tree

      contents = []
      contents  ['tree', tree_sha1].join(' ')
      parents.each do |p|
        contents  ['parent', p].join(' ')
      end if parents

      committer      ||= begin
        config = Config.new(self.repo)
        Actor.new(config['user.name'], config['user.email'])
      end
      author         ||= committer
      committed_date ||= Time.now
      authored_date  ||= committed_date

      contents  ['author',    author.output(authored_date)].join(' ')
      contents  ['committer', committer.output(committed_date)].join(' ')
      contents  ''
      contents  message

      contents = contents.join("\n")
      @last_commit_size = contents.size
      commit_sha1 = self.repo.git.put_raw_object(contents, 'commit')

      self.repo.update_ref(head, commit_sha1) if head
      commit_sha1
    end

    # Recursively write a tree to the index.
    #
    # tree -     The Hash tree map:
    #            key - The String directory or filename.
    #            val - The Hash submap or the String contents of the file.
    # now_tree - The Grit::Tree representing the a previous tree upon which
    #            this tree will be based (default: nil).
    #
    # Returns the String SHA1 String of the tree.
    def write_tree(tree = nil, now_tree = nil)
      tree = self.tree if !tree
      tree_contents = {}

      # fill in original tree
      now_tree = read_tree(now_tree) if(now_tree && now_tree.is_a?(String))
      now_tree.contents.each do |obj|
        sha = [obj.id].pack("H*")
        k = obj.name
        k += '/' if (obj.class == Grit::Tree)
        tmode = obj.mode.to_i.to_s  ## remove zero-padding
        tree_contents[k] = "%s %s\0%s" % [tmode, obj.name, sha]
      end if now_tree

      # overwrite with new tree contents
      tree.each do |k, v|
        case v
          when Array
            sha, mode = v
            if sha.size == 40        # must be a sha
              sha = [sha].pack("H*")
              mode = mode.to_i.to_s  # leading 0s not allowed
              k = k.split('/').last  # slashes not allowed
              str = "%s %s\0%s" % [mode, k, sha]
              tree_contents[k] = str
            end
          when String
            sha = write_blob(v)
            sha = [sha].pack("H*")
            str = "%s %s\0%s" % ['100644', k, sha]
            tree_contents[k] = str
          when Hash
            ctree = now_tree/k if now_tree
            sha = write_tree(v, ctree)
            sha = [sha].pack("H*")
            str = "%s %s\0%s" % ['40000', k, sha]
            tree_contents[k + '/'] = str
          when false
            tree_contents.delete(k)
        end
      end

      tr = tree_contents.sort.map { |k, v| v }.join('')
      @last_tree_size = tr.size
      self.repo.git.put_raw_object(tr, 'tree')
    end

    # Write a blob to the index.
    #
    # data - The String data to write.
    #
    # Returns the String SHA1 of the new blob.
    def write_blob(data)
      self.repo.git.put_raw_object(data, 'blob')
    end
  end # Index

end # Grit
</content>
		</actual_file>
		<actual_file>
			<filename>lazy.rb</filename>
			<content>##
# Allows attributes to be declared as lazy, meaning that they won't be
# computed until they are asked for.
#
# Works by delegating each lazy_reader to a cached lazy_source method.
#
# class Person
#   lazy_reader :eyes
#
#   def lazy_source
#     OpenStruct.new(:eyes = 2)
#   end
# end
#
#  Person.new.eyes
# = 2
#
module Lazy
  def self.extended(klass)
    klass.send(:attr_writer, :lazy_source)
  end

  def lazy_reader(*args)
    args.each do |arg|
      ivar = "@#{arg}"
      define_method(arg) do
        if instance_variable_defined?(ivar)
          val = instance_variable_get(ivar)
          return val if val
        end
        instance_variable_set(ivar, (@lazy_source ||= lazy_source).send(arg))
      end
    end
  end
end</content>
		</actual_file>
		<actual_file>
			<filename>merge.rb</filename>
			<content>module Grit

  class Merge

    STATUS_BOTH = 'both'
    STATUS_OURS = 'ours'
    STATUS_THEIRS = 'theirs'

    attr_reader :conflicts, :text, :sections

    def initialize(str)
      status = STATUS_BOTH

      section = 1
      @conflicts = 0
      @text = {}

      lines = str.split("\n")
      lines.each do |line|
        if /^ (.*?)/.match(line)
          status = STATUS_OURS
          @conflicts += 1
          section += 1
        elsif line == '======='
          status = STATUS_THEIRS
        elsif /^ (.*?)/.match(line)
          status = STATUS_BOTH
          section += 1
        else
          @text[section] ||= {}
          @text[section][status] ||= []
          @text[section][status]  line
        end
      end
      @text = @text.values
      @sections = @text.size
    end

    # Pretty object inspection
    def inspect
      %Q{#Grit::Merge}
    end
  end # Merge

end # Grit
</content>
		</actual_file>
		<actual_file>
			<filename>ref.rb</filename>
			<content>module Grit

  class Ref

    class  self

      # Find all Refs
      #   +repo+ is the Repo
      #   +options+ is a Hash of options
      #
      # Returns Grit::Ref[] (baked)
      def find_all(repo, options = {})
        refs = repo.git.refs(options, prefix)
        refs.split("\n").map do |ref|
          name, id = *ref.split(' ')
          commit = Commit.create(repo, :id = id)
          self.new(name, commit)
        end
      end

      protected

        def prefix
          "refs/#{name.to_s.gsub(/^.*::/, '').downcase}s"
        end

    end

    attr_reader :name
    attr_reader :commit

    # Instantiate a new Head
    #   +name+ is the name of the head
    #   +commit+ is the Commit that the head points to
    #
    # Returns Grit::Head (baked)
    def initialize(name, commit)
      @name = name
      @commit = commit
    end

    # Pretty object inspection
    def inspect
      %Q{##{self.class.name} "#{@name}"}
    end
  end # Ref

  # A Head is a named reference to a Commit. Every Head instance contains a name
  # and a Commit object.
  #
  #   r = Grit::Repo.new("/path/to/repo")
  #   h = r.heads.first
  #   h.name       # = "master"
  #   h.commit     # = #Grit::Commit "1c09f116cbc2cb4100fb6935bb162daa4723f455"
  #   h.commit.id  # = "1c09f116cbc2cb4100fb6935bb162daa4723f455"
  class Head  Ref

    # Get the HEAD revision of the repo.
    #   +repo+ is the Repo
    #   +options+ is a Hash of options
    #
    # Returns Grit::Head (baked)
    def self.current(repo, options = {})
      head = repo.git.fs_read('HEAD').chomp
      if /ref: refs\/heads\/(.*)/.match(head)
        id = repo.git.rev_parse(options, 'HEAD')
        commit = Commit.create(repo, :id = id)
        self.new($1, commit)
      end
    end

  end # Head

  class Remote  Ref; end

  class Note  Ref; end

end # Grit
</content>
		</actual_file>
		<actual_file>
			<filename>repo.rb</filename>
			<content>module Grit

  class Repo
    DAEMON_EXPORT_FILE = 'git-daemon-export-ok'
    BATCH_PARSERS      = {
      'commit' = ::Grit::Commit
    }

    # Public: The String path of the Git repo.
    attr_accessor :path

    # Public: The String path to the working directory of the repo, or nil if
    # there is no working directory.
    attr_accessor :working_dir

    # Public: The Boolean of whether or not the repo is bare.
    attr_reader :bare

    # Public: The Grit::Git command line interface object.
    attr_accessor :git

    # Public: Create a new Repo instance.
    #
    # path    - The String path to either the root git directory or the bare
    #           git repo. Bare repos are expected to end with ".git".
    # options - A Hash of options (default: {}):
    #           :is_bare - Boolean whether to consider the repo as bare even
    #                      if the repo name does not end with ".git".
    #
    # Examples
    #
    #   r = Repo.new("/Users/tom/dev/normal")
    #   r = Repo.new("/Users/tom/public/bare.git")
    #   r = Repo.new("/Users/tom/public/bare", {:is_bare = true})
    #
    # Returns a newly initialized Grit::Repo.
    # Raises Grit::InvalidGitRepositoryError if the path exists but is not
    #   a Git repository.
    # Raises Grit::NoSuchPathError if the path does not exist.
    def initialize(path, options = {})
      epath = File.expand_path(path)

      if File.exist?(File.join(epath, '.git'))
        self.working_dir = epath
        self.path = File.join(epath, '.git')
        @bare = false
      elsif File.exist?(epath) && (epath =~ /\.git$/ || options[:is_bare])
        self.path = epath
        @bare = true
      elsif File.exist?(epath)
        raise InvalidGitRepositoryError.new(epath)
      else
        raise NoSuchPathError.new(epath)
      end

      self.git = Git.new(self.path)
    end

    # Public: Initialize a git repository (create it on the filesystem). By
    # default, the newly created repository will contain a working directory.
    # If you would like to create a bare repo, use Grit::Repo.init_bare.
    #
    # path         - The String full path to the repo. Traditionally ends with
    #                "/name.git".
    # git_options  - A Hash of additional options to the git init command
    #                (default: {}).
    # repo_options - A Hash of additional options to the Grit::Repo.new call
    #                (default: {}).
    #
    # Examples
    #
    #   Grit::Repo.init('/var/git/myrepo.git')
    #
    # Returns the newly created Grit::Repo.
    def self.init(path, git_options = {}, repo_options = {})
      git_options = {:base = false}.merge(git_options)
      git = Git.new(path)
      git.fs_mkdir('..')
      git.init(git_options, path)
      self.new(path, repo_options)
    end

    # Public: Initialize a bare git repository (create it on the filesystem).
    #
    # path         - The String full path to the repo. Traditionally ends with
    #                "/name.git".
    # git_options  - A Hash of additional options to the git init command
    #                (default: {}).
    # repo_options - A Hash of additional options to the Grit::Repo.new call
    #                (default: {}).
    #
    # Examples
    #
    #   Grit::Repo.init_bare('/var/git/myrepo.git')
    #
    # Returns the newly created Grit::Repo.
    def self.init_bare(path, git_options = {}, repo_options = {})
      git_options = {:bare = true}.merge(git_options)
      git = Git.new(path)
      git.fs_mkdir('..')
      git.init(git_options)
      repo_options = {:is_bare = true}.merge(repo_options)
      self.new(path, repo_options)
    end

    # Public: Initialize a bare Git repository (create it on the filesystem)
    # or, if the repo already exists, simply return it.
    #
    # path         - The String full path to the repo. Traditionally ends with
    #                "/name.git".
    # git_options  - A Hash of additional options to the git init command
    #                (default: {}).
    # repo_options - A Hash of additional options to the Grit::Repo.new call
    #                (default: {}).
    #
    # Returns the new or existing Grit::Repo.
    def self.init_bare_or_open(path, git_options = {}, repo_options = {})
      git = Git.new(path)

      unless git.exist?
        git.fs_mkdir(path)
        git.init(git_options)
      end

      self.new(path, repo_options)
    end

    # Public: Create a bare fork of this repository.
    #
    # path    - The String full path of where to create the new fork.
    #           Traditionally ends with "/name.git".
    # options - The Hash of additional options to the git clone command.
    #           These options will be merged on top of the default Hash:
    #           {:bare = true, :shared = true}.
    #
    # Returns the newly forked Grit::Repo.
    def fork_bare(path, options = {})
      default_options = {:bare = true, :shared = true}
      real_options = default_options.merge(options)
      Git.new(path).fs_mkdir('..')
      self.git.clone(real_options, self.path, path)
      Repo.new(path)
    end

    # Public: Fork a bare git repository from another repo.
    #
    # path    - The String full path of the repo from which to fork..
    #           Traditionally ends with "/name.git".
    # options - The Hash of additional options to the git clone command.
    #           These options will be merged on top of the default Hash:
    #           {:bare = true, :shared = true}.
    #
    # Returns the newly forked Grit::Repo.
    def fork_bare_from(path, options = {})
      default_options = {:bare = true, :shared = true}
      real_options = default_options.merge(options)
      Git.new(self.path).fs_mkdir('..')
      self.git.clone(real_options, path, self.path)
      Repo.new(self.path)
    end

    # Public: Return the full Git objects from the given SHAs.  Only Commit
    # objects are parsed for now.
    #
    # *shas - Array of String SHAs.
    #
    # Returns an Array of Grit objects (Grit::Commit).
    def batch(*shas)
      shas.flatten!
      text = git.native(:cat_file, {:batch = true, :input = (shas * "\n")})
      parse_batch(text)
    end

    # Parses `git cat-file --batch` output, returning an array of Grit objects.
    #
    # text - Raw String output.
    #
    # Returns an Array of Grit objects (Grit::Commit).
    def parse_batch(text)
      io = StringIO.new(text)
      objects = []
      while line = io.gets
        sha, type, size = line.split(" ", 3)
        parser = BATCH_PARSERS[type]
        if type == 'missing' || !parser
          io.seek(size.to_i + 1, IO::SEEK_CUR)
          objects  nil
          next
        end

        object   = io.read(size.to_i + 1)
        objects  parser.parse_batch(self, sha, size, object)
      end
      objects
    end

    # The project's description. Taken verbatim from GIT_REPO/description
    #
    # Returns String
    def description
      self.git.fs_read('description').chomp
    end

    def blame(file, commit = nil)
      Blame.new(self, file, commit)
    end

    # An array of Head objects representing the branch heads in
    # this repo
    #
    # Returns Grit::Head[] (baked)
    def heads
      Head.find_all(self)
    end

    alias_method :branches, :heads

    def get_head(head_name)
      heads.find { |h| h.name == head_name }
    end

    def is_head?(head_name)
      get_head(head_name)
    end

    # Object reprsenting the current repo head.
    #
    # Returns Grit::Head (baked)
    def head
      Head.current(self)
    end


    # Commits current index
    #
    # Returns true/false if commit worked
    def commit_index(message)
      self.git.commit({}, '-m', message)
    end

    # Commits all tracked and modified files
    #
    # Returns true/false if commit worked
    def commit_all(message)
      self.git.commit({}, '-a', '-m', message)
    end

    # Adds files to the index
    def add(*files)
      self.git.add({}, *files.flatten)
    end

    # Remove files from the index
    def remove(*files)
      self.git.rm({}, *files.flatten)
    end


    def blame_tree(commit, path = nil)
      commit_array = self.git.blame_tree(commit, path)

      final_array = {}
      commit_array.each do |file, sha|
        final_array[file] = commit(sha)
      end
      final_array
    end

    def status
      Status.new(self)
    end


    # An array of Tag objects that are available in this repo
    #
    # Returns Grit::Tag[] (baked)
    def tags
      Tag.find_all(self)
    end

    # Finds the most recent annotated tag name that is reachable from a commit.
    #
    #   @repo.recent_tag_name('master')
    #   # = "v1.0-0-abcdef"
    #
    # committish - optional commit SHA, branch, or tag name.
    # options    - optional hash of options to pass to git.
    #              Default: {:always = true}
    #              :tags = true      # use lightweight tags too.
    #              :abbrev = Integer # number of hex digits to form the unique
    #                name.  Defaults to 7.
    #              :long = true      # always output tag + commit sha
    #              # see `git describe` docs for more options.
    #
    # Returns the String tag name, or just the commit if no tag is
    # found.  If there have been updates since the tag was made, a
    # suffix is added with the number of commits since the tag, and
    # the abbreviated object name of the most recent commit.
    # Returns nil if the committish value is not found.
    def recent_tag_name(committish = nil, options = {})
      value = git.describe({:always = true}.update(options), committish.to_s).to_s.strip
      value.size.zero? ? nil : value
    end

    # An array of Remote objects representing the remote branches in
    # this repo
    #
    # Returns Grit::Remote[] (baked)
    def remotes
      Remote.find_all(self)
    end

    def remote_list
      self.git.list_remotes
    end

    def remote_add(name, url)
      self.git.remote({}, 'add', name, url)
    end

    def remote_fetch(name)
      self.git.fetch({}, name)
    end

    # takes an array of remote names and last pushed dates
    # fetches from all of the remotes where the local fetch
    # date is earlier than the passed date, then records the
    # last fetched date
    #
    # { 'origin' = date,
    #   'peter = date,
    # }
    def remotes_fetch_needed(remotes)
      remotes.each do |remote, date|
        # TODO: check against date
        self.remote_fetch(remote)
      end
    end


    # An array of Ref objects representing the refs in
    # this repo
    #
    # Returns Grit::Ref[] (baked)
    def refs
      [ Head.find_all(self), Tag.find_all(self), Remote.find_all(self) ].flatten
    end

    # returns an array of hashes representing all references
    def refs_list
      refs = self.git.for_each_ref
      refarr = refs.split("\n").map do |line|
        shatype, ref = line.split("\t")
        sha, type = shatype.split(' ')
        [ref, sha, type]
      end
      refarr
    end

    def delete_ref(ref)
      self.git.native(:update_ref, {:d = true}, ref)
    end

    def commit_stats(start = 'master', max_count = 10, skip = 0)
      options = {:max_count = max_count,
                 :skip = skip}

      CommitStats.find_all(self, start, options)
    end

    # An array of Commit objects representing the history of a given ref/commit
    #   +start+ is the branch/commit name (default 'master')
    #   +max_count+ is the maximum number of commits to return (default 10, use +false+ for all)
    #   +skip+ is the number of commits to skip (default 0)
    #
    # Returns Grit::Commit[] (baked)
    def commits(start = 'master', max_count = 10, skip = 0)
      options = {:max_count = max_count,
                 :skip = skip}

      Commit.find_all(self, start, options)
    end

    # The Commits objects that are reachable via +to+ but not via +from+
    # Commits are returned in chronological order.
    #   +from+ is the branch/commit name of the younger item
    #   +to+ is the branch/commit name of the older item
    #
    # Returns Grit::Commit[] (baked)
    def commits_between(from, to)
      Commit.find_all(self, "#{from}..#{to}").reverse
    end

    def fast_forwardable?(to, from)
      mb = self.git.native(:merge_base, {}, [to, from]).strip
      mb == from
    end

    # The Commits objects that are newer than the specified date.
    # Commits are returned in chronological order.
    #   +start+ is the branch/commit name (default 'master')
    #   +since+ is a string representing a date/time
    #   +extra_options+ is a hash of extra options
    #
    # Returns Grit::Commit[] (baked)
    def commits_since(start = 'master', since = '1970-01-01', extra_options = {})
      options = {:since = since}.merge(extra_options)

      Commit.find_all(self, start, options)
    end

    # The number of commits reachable by the given branch/commit
    #   +start+ is the branch/commit name (default 'master')
    #
    # Returns Integer
    def commit_count(start = 'master')
      Commit.count(self, start)
    end

    # The Commit object for the specified id
    #   +id+ is the SHA1 identifier of the commit
    #
    # Returns Grit::Commit (baked)
    def commit(id)
      options = {:max_count = 1}

      Commit.find_all(self, id, options).first
    end

    # Returns a list of commits that is in +other_repo+ but not in self
    #
    # Returns Grit::Commit[]
    def commit_deltas_from(other_repo, ref = "master", other_ref = "master")
      # TODO: we should be able to figure out the branch point, rather than
      # rev-list'ing the whole thing
      repo_refs       = self.git.rev_list({}, ref).strip.split("\n")
      other_repo_refs = other_repo.git.rev_list({}, other_ref).strip.split("\n")

      (other_repo_refs - repo_refs).map do |refn|
        Commit.find_all(other_repo, refn, {:max_count = 1}).first
      end
    end

    def objects(refs)
      refs = refs.split(/\s+/) if refs.respond_to?(:to_str)
      self.git.rev_list({:objects = true, :timeout = false}, *refs).
        split("\n").map { |a| a[0, 40] }
    end

    def commit_objects(refs)
      refs = refs.split(/\s+/) if refs.respond_to?(:to_str)
      self.git.rev_list({:timeout = false}, *refs).split("\n").map { |a| a[0, 40] }
    end

    def objects_between(ref1, ref2 = nil)
      if ref2
        refs = "#{ref2}..#{ref1}"
      else
        refs = ref1
      end
      self.objects(refs)
    end

    def diff_objects(commit_sha, parents = true)
      revs = []
      Grit.no_quote = true
      if parents
        # PARENTS:
        revs = self.git.diff_tree({:timeout = false, :r = true, :t = true, :m = true}, commit_sha).
          strip.split("\n").map{ |a| r = a.split(' '); r[3] if r[1] != '160000' }
      else
        # NO PARENTS:
        revs = self.git.native(:ls_tree, {:timeout = false, :r = true, :t = true}, commit_sha).
          split("\n").map{ |a| a.split("\t").first.split(' ')[2] }
      end
      revs  self.commit(commit_sha).tree.id
      Grit.no_quote = false
      return revs.uniq.compact
    end

    # The Tree object for the given treeish reference
    #   +treeish+ is the reference (default 'master')
    #   +paths+ is an optional Array of directory paths to restrict the tree (default [])
    #
    # Examples
    #   repo.tree('master', ['lib/'])
    #
    # Returns Grit::Tree (baked)
    def tree(treeish = 'master', paths = [])
      Tree.construct(self, treeish, paths)
    end

    # quick way to get a simple array of hashes of the entries
    # of a single tree or recursive tree listing from a given
    # sha or reference
    #   +treeish+ is the reference (default 'master')
    #   +options+ is a hash or options - currently only takes :recursive
    #
    # Examples
    #   repo.lstree('master', :recursive = true)
    #
    # Returns array of hashes - one per tree entry
    def lstree(treeish = 'master', options = {})
      # check recursive option
      opts = {:timeout = false, :l = true, :t = true}
      if options[:recursive]
        opts[:r] = true
      end
      # mode, type, sha, size, path
      revs = self.git.native(:ls_tree, opts, treeish)
      lines = revs.split("\n")
      revs = lines.map do |a|
        stuff, path = a.split("\t")
        mode, type, sha, size = stuff.split(" ")
        entry = {:mode = mode, :type = type, :sha = sha, :path = path}
        entry[:size] = size.strip.to_i if size.strip != '-'
        entry
      end
      revs
    end

    def object(sha)
      obj = git.get_git_object(sha)
      raw = Grit::GitRuby::Internal::RawObject.new(obj[:type], obj[:content])
      object = Grit::GitRuby::GitObject.from_raw(raw)
      object.sha = sha
      object
    end

    # The Blob object for the given id
    #   +id+ is the SHA1 id of the blob
    #
    # Returns Grit::Blob (unbaked)
    def blob(id)
      Blob.create(self, :id = id)
    end

    # The commit log for a treeish
    #
    # Returns Grit::Commit[]
    def log(commit = 'master', path = nil, options = {})
      default_options = {:pretty = "raw"}
      actual_options  = default_options.merge(options)
      arg = path ? [commit, '--', path] : [commit]
      commits = self.git.log(actual_options, *arg)
      Commit.list_from_string(self, commits)
    end

    # The diff from commit +a+ to commit +b+, optionally restricted to the given file(s)
    #   +a+ is the base commit
    #   +b+ is the other commit
    #   +paths+ is an optional list of file paths on which to restrict the diff
    def diff(a, b, *paths)
      diff = self.git.native('diff', {}, a, b, '--', *paths)

      if diff =~ /diff --git a/
        diff = diff.sub(/.*?(diff --git a)/m, '\1')
      else
        diff = ''
      end
      Diff.list_from_string(self, diff)
    end

    # The commit diff for the given commit
    #   +commit+ is the commit name/id
    #
    # Returns Grit::Diff[]
    def commit_diff(commit)
      Commit.diff(self, commit)
    end

    # Archive the given treeish
    #   +treeish+ is the treeish name/id (default 'master')
    #   +prefix+ is the optional prefix
    #
    # Examples
    #   repo.archive_tar
    #   # = String containing tar archive
    #
    #   repo.archive_tar('a87ff14')
    #   # = String containing tar archive for commit a87ff14
    #
    #   repo.archive_tar('master', 'myproject/')
    #   # = String containing tar archive and prefixed with 'myproject/'
    #
    # Returns String (containing tar archive)
    def archive_tar(treeish = 'master', prefix = nil)
      options = {}
      options[:prefix] = prefix if prefix
      self.git.archive(options, treeish)
    end

    # Archive and gzip the given treeish
    #   +treeish+ is the treeish name/id (default 'master')
    #   +prefix+ is the optional prefix
    #
    # Examples
    #   repo.archive_tar_gz
    #   # = String containing tar.gz archive
    #
    #   repo.archive_tar_gz('a87ff14')
    #   # = String containing tar.gz archive for commit a87ff14
    #
    #   repo.archive_tar_gz('master', 'myproject/')
    #   # = String containing tar.gz archive and prefixed with 'myproject/'
    #
    # Returns String (containing tar.gz archive)
    def archive_tar_gz(treeish = 'master', prefix = nil)
      options = {}
      options[:prefix] = prefix if prefix
      self.git.archive(options, treeish, "| gzip -n")
    end

    # Write an archive directly to a file
    #   +treeish+ is the treeish name/id (default 'master')
    #   +prefix+ is the optional prefix (default nil)
    #   +filename+ is the name of the file (default 'archive.tar.gz')
    #   +format+ is the optional format (default nil)
    #   +pipe+ is the command to run the output through (default 'gzip')
    #
    # Returns nothing
    def archive_to_file(treeish = 'master', prefix = nil, filename = 'archive.tar.gz', format = nil, pipe = "gzip")
      options = {}
      options[:prefix] = prefix if prefix
      options[:format] = format if format
      self.git.archive(options, treeish, "| #{pipe}  #{filename}")
    end

    # Enable git-daemon serving of this repository by writing the
    # git-daemon-export-ok file to its git directory
    #
    # Returns nothing
    def enable_daemon_serve
      self.git.fs_write(DAEMON_EXPORT_FILE, '')
    end

    # Disable git-daemon serving of this repository by ensuring there is no
    # git-daemon-export-ok file in its git directory
    #
    # Returns nothing
    def disable_daemon_serve
      self.git.fs_delete(DAEMON_EXPORT_FILE)
    end

    def gc_auto
      self.git.gc({:auto = true})
    end

    # The list of alternates for this repo
    #
    # Returns Array[String] (pathnames of alternates)
    def alternates
      alternates_path = "objects/info/alternates"
      self.git.fs_read(alternates_path).strip.split("\n")
    rescue Errno::ENOENT
      []
    end

    # Sets the alternates
    #   +alts+ is the Array of String paths representing the alternates
    #
    # Returns nothing
    def alternates=(alts)
      alts.each do |alt|
        unless File.exist?(alt)
          raise "Could not set alternates. Alternate path #{alt} must exist"
        end
      end

      if alts.empty?
        self.git.fs_write('objects/info/alternates', '')
      else
        self.git.fs_write('objects/info/alternates', alts.join("\n"))
      end
    end

    def config
      @config ||= Config.new(self)
    end

    def index
      Index.new(self)
    end

    def update_ref(head, commit_sha)
      return nil if !commit_sha || (commit_sha.size != 40)
      self.git.fs_write("refs/heads/#{head}", commit_sha)
      commit_sha
    end

    # Rename the current repository directory.
    #   +name+ is the new name
    #
    # Returns nothing
    def rename(name)
      if @bare
        self.git.fs_move('/', "../#{name}")
      else
        self.git.fs_move('/', "../../#{name}")
      end
    end

    # Pretty object inspection
    def inspect
      %Q{#Grit::Repo "#{@path}"}
    end
  end # Repo

end # Grit
</content>
		</actual_file>
		<actual_file>
			<filename>ruby1.9.rb</filename>
			<content>class String
  if ((defined? RUBY_VERSION) && (RUBY_VERSION[0..2] == "1.9"))
    def getord(offset); self[offset].ord; end
  else
    alias :getord :[]
  end
end</content>
		</actual_file>
		<actual_file>
			<filename>status.rb</filename>
			<content>module Grit

  class Status
    include Enumerable

    attr_reader :files

    @base = nil
    @files = nil

    def initialize(base)
      @base = base
      construct_status
    end

    def changed
      @files.select { |k, f| f.type == 'M' }
    end

    def added
      @files.select { |k, f| f.type == 'A' }
    end

    def deleted
      @files.select { |k, f| f.type == 'D' }
    end

    def untracked
      @files.select { |k, f| f.untracked }
    end

    def pretty
      out = ''
      self.each do |file|
        out  file.path
        out  "\n\tsha(r) " + file.sha_repo.to_s + ' ' + file.mode_repo.to_s
        out  "\n\tsha(i) " + file.sha_index.to_s + ' ' + file.mode_index.to_s
        out  "\n\ttype   " + file.type.to_s
        out  "\n\tstage  " + file.stage.to_s
        out  "\n\tuntrac " + file.untracked.to_s
        out  "\n"
      end
      out  "\n"
      out
    end

    # enumerable method

    def [](file)
      @files[file]
    end

    def each
      @files.each do |k, file|
        yield file
      end
    end

    class StatusFile
      attr_accessor :path, :type, :stage, :untracked
      attr_accessor :mode_index, :mode_repo
      attr_accessor :sha_index, :sha_repo

      @base = nil

      def initialize(base, hash)
        @base = base
        @path = hash[:path]
        @type = hash[:type]
        @stage = hash[:stage]
        @mode_index = hash[:mode_index]
        @mode_repo = hash[:mode_repo]
        @sha_index = hash[:sha_index]
        @sha_repo = hash[:sha_repo]
        @untracked = hash[:untracked]
      end

      def blob(type = :index)
        if type == :repo
          @base.object(@sha_repo)
        else
          @base.object(@sha_index) rescue @base.object(@sha_repo)
        end
      end

    end

    private

      def construct_status
        @files = ls_files

        Dir.chdir(@base.working_dir) do
          # find untracked in working dir
          Dir.glob('**/*') do |file|
            if !@files[file]
              @files[file] = {:path = file, :untracked = true} if !File.directory?(file)
            end
          end

          # find modified in tree
         diff_files.each do |path, data|
            @files[path] ? @files[path].merge!(data) : @files[path] = data
          end

          # find added but not committed - new files
          diff_index('HEAD').each do |path, data|
            @files[path] ? @files[path].merge!(data) : @files[path] = data
          end

          @files.each do |k, file_hash|
            @files[k] = StatusFile.new(@base, file_hash)
          end
        end
      end

      # compares the index and the working directory
      def diff_files
        hsh = {}
        @base.git.diff_files.split("\n").each do |line|
          (info, file) = line.split("\t")
          (mode_src, mode_dest, sha_src, sha_dest, type) = info.split
          hsh[file] = {:path = file, :mode_file = mode_src.to_s[1, 7], :mode_index = mode_dest,
                        :sha_file = sha_src, :sha_index = sha_dest, :type = type}
        end
        hsh
      end

      # compares the index and the repository
      def diff_index(treeish)
        hsh = {}
        @base.git.diff_index({}, treeish).split("\n").each do |line|
          (info, file) = line.split("\t")
          (mode_src, mode_dest, sha_src, sha_dest, type) = info.split
          hsh[file] = {:path = file, :mode_repo = mode_src.to_s[1, 7], :mode_index = mode_dest,
                        :sha_repo = sha_src, :sha_index = sha_dest, :type = type}
        end
        hsh
      end

      def ls_files
        hsh = {}
        lines = @base.git.ls_files({:stage = true})
        lines.split("\n").each do |line|
          (info, file) = line.split("\t")
          (mode, sha, stage) = info.split
          hsh[file] = {:path = file, :mode_index = mode, :sha_index = sha, :stage = stage}
        end
        hsh
      end
  end

end</content>
		</actual_file>
		<actual_file>
			<filename>submodule.rb</filename>
			<content>module Grit

  class Submodule
    attr_reader :id
    attr_reader :mode
    attr_reader :name

    # Create a Submodule containing just the specified attributes
    #   +repo+ is the Repo
    #   +atts+ is a Hash of instance variable data
    #
    # Returns Grit::Submodule (unbaked)
    def self.create(repo, atts)
      self.allocate.create_initialize(repo, atts)
    end

    # Initializer for Submodule.create
    #   +repo+ is the Repo
    #   +atts+ is a Hash of instance variable data
    #
    # Returns Grit::Submodule
    def create_initialize(repo, atts)
      @repo = repo
      atts.each do |k, v|
        instance_variable_set("@#{k}".to_sym, v)
      end
      self
    end

    # The url of this submodule
    #   +ref+ is the committish that should be used to look up the url
    #
    # Returns String
    def url(ref)
      config = self.class.config(@repo, ref)

      lookup = config.keys.inject({}) do |acc, key|
        id = config[key]['id']
        acc[id] = config[key]['url']
        acc
      end

      lookup[@id]
    end

    # The configuration information for the given +repo+
    #   +repo+ is the Repo
    #   +ref+ is the committish (defaults to 'master')
    #
    # Returns a Hash of { path:String = { 'url' = url:String, 'id' = id:String } }
    # Returns {} if no .gitmodules file was found
    def self.config(repo, ref = "master")
      commit = repo.commit(ref)
      blob = commit.tree/'.gitmodules'
      return {} unless blob

      lines = blob.data.gsub(/\r\n?/, "\n" ).split("\n")

      config = {}
      current = nil

      lines.each do |line|
        if line =~ /^\[submodule "(.+)"\]$/
          current = $1
          config[current] = {}
          config[current]['id'] = (commit.tree/current).id
        elsif line =~ /^\t(\w+) = (.+)$/
          config[current][$1] = $2
          config[current]['id'] = (commit.tree/$2).id if $1 == 'path'
        else
          # ignore
        end
      end

      config
    end

    def basename
      File.basename(name)
    end

    # Pretty object inspection
    def inspect
      %Q{#Grit::Submodule "#{@id}"}
    end
  end # Submodule

end # Grit</content>
		</actual_file>
		<actual_file>
			<filename>tag.rb</filename>
			<content>module Grit

  class Tag  Ref
    extend Lazy

    lazy_reader :message
    lazy_reader :tagger
    lazy_reader :tag_date

    def self.find_all(repo, options = {})
      refs = repo.git.refs(options, prefix)
      refs.split("\n").map do |ref|
        name, id = *ref.split(' ')
        sha = repo.git.commit_from_sha(id)
        raise "Unknown object type." if sha == ''
        commit = Commit.create(repo, :id = sha)
        new(name, commit)
      end
    end

    # Writes a new tag object from a hash
    #  +repo+ is a Grit repo
    #  +hash+ is the hash of tag values
    #
    # Returns a hash with +sha+ and +size+ of the created object
    def self.create_tag_object(repo, hash, default_actor = nil)
      tagger = hash[:tagger]
      if !tagger
        tagger = default_actor ? default_actor : Actor.new("none", "none@none")
        tagger_date = Time.now
      else
        tagger_date = tagger[:date] ? Time.parse(tagger[:date]) : Time.now
        tagger = Actor.new(tagger[:name], tagger[:email])
      end
      data = []
      data  "object #{hash[:object]}"
      data  "type #{hash[:type]}"
      data  "tag #{hash[:tag]}"
      data  "tagger #{tagger.output(tagger_date)}"
      data  ""
      data  hash[:message]
      data = data.join("\n")
      sha = repo.git.put_raw_object(data, 'tag')
      { :sha = sha, :size = data.size }
    end

    # Parses the results from `cat-file -p`
    #
    # data - String tag object data.  Example:
    #          object 7bcc0ee821cdd133d8a53e8e7173a334fef448aa
    #          type commit
    #          tag v0.7.0
    #          tagger USER EMAIL DATE
    #          
    #          v0.7.0
    #
    # Returns parsed Hash.  Example: 
    #   {:message = "...", :tagger = "bob", :tag_date = ...}
    def self.parse_tag_data(data)
      return unless data =~ /^object/
      parsed = {}
      lines  = data.split("\n")
      parsed[:object] = lines.shift.sub(/^object /, '')
      parsed[:type] = lines.shift.sub(/^type /, '')
      parsed[:tag] = lines.shift.sub(/^tag /, '')
      author_line = lines.shift
      parsed[:tagger], parsed[:tag_date] = Commit.actor(author_line)
      if !parsed[:tagger] || !parsed[:tagger].name
        parsed[:tag_date] ||= Time.utc(1970)
        parsed[:tagger]     = Actor.from_string(author_line.sub(/^tagger /, ''))
      end
      lines.shift # blank line
      parsed[:message] = []
      while lines.first && lines.first !~ /-----BEGIN PGP SIGNATURE-----/
        parsed[:message]  lines.shift
      end
      parsed[:message] = parsed[:message] * "\n"
      parsed[:pgp] = []
      while lines.first
        parsed[:pgp]  lines.shift
      end
      parsed[:pgp] = parsed[:pgp] * "\n"
      parsed
    end

    def lazy_source
      data         = commit.repo.git.cat_ref({:p = true}, name)
      @message     = commit.short_message
      @tagger      = commit.author
      @tag_date    = commit.authored_date
      return self if data.empty?

      if parsed = self.class.parse_tag_data(data)
        @message  = parsed[:message]
        @tagger   = parsed[:tagger]
        @tag_date = parsed[:tag_date]
      end
      self
    end
  end

end
</content>
		</actual_file>
		<actual_file>
			<filename>tree.rb</filename>
			<content>module Grit

  class Tree
    extend Lazy

    lazy_reader :contents
    attr_reader :id
    attr_reader :mode
    attr_reader :name

    # Construct the contents of the tree
    #   +repo+ is the Repo
    #   +treeish+ is the reference
    #   +paths+ is an optional Array of directory paths to restrict the tree
    #
    # Returns Grit::Tree (baked)
    def self.construct(repo, treeish, paths = [])
      output = repo.git.ls_tree({:raise = true}, treeish, *paths)
      self.allocate.construct_initialize(repo, treeish, output)
    end

    def construct_initialize(repo, id, text)
      @repo = repo
      @id = id
      @contents = []

      text.split("\n").each do |line|
        @contents  content_from_string(repo, line)
      end
      @contents.compact!

      self
    end

    def lazy_source
      Tree.construct(@repo, @id, [])
    end

    # Create an unbaked Tree containing just the specified attributes
    #   +repo+ is the Repo
    #   +atts+ is a Hash of instance variable data
    #
    # Returns Grit::Tree (unbaked)
    def self.create(repo, atts)
      self.allocate.create_initialize(repo, atts)
    end

    # Initializer for Tree.create
    #   +repo+ is the Repo
    #   +atts+ is a Hash of instance variable data
    #
    # Returns Grit::Tree (unbaked)
    def create_initialize(repo, atts)
      @repo = repo

      atts.each do |k, v|
        instance_variable_set("@#{k}", v)
      end
      self
    end

    # Parse a content item and create the appropriate object
    #   +repo+ is the Repo
    #   +text+ is the single line containing the items data in `git ls-tree` format
    #
    # Returns Grit::Blob or Grit::Tree
    def content_from_string(repo, text)
      mode, type, id, name = text.split(/ |\t/, 4)
      case type
        when "tree"
          Tree.create(repo, :id = id, :mode = mode, :name = name)
        when "blob"
          Blob.create(repo, :id = id, :mode = mode, :name = name)
        when "link"
          Blob.create(repo, :id = id, :mode = mode, :name = name)
        when "commit"
          Submodule.create(repo, :id = id, :mode = mode, :name = name)
        else
          raise Grit::InvalidObjectType, type
      end
    end

    # Find the named object in this tree's contents
    #
    # Examples
    #   Repo.new('/path/to/grit').tree/'lib'
    #   # = #Grit::Tree "6cc23ee138be09ff8c28b07162720018b244e95e"
    #   Repo.new('/path/to/grit').tree/'README.txt'
    #   # = #Grit::Blob "8b1e02c0fb554eed2ce2ef737a68bb369d7527df"
    #
    # Returns Grit::Blob or Grit::Tree or nil if not found
    def /(file)
      if file =~ /\//
        file.split("/").inject(self) { |acc, x| acc/x } rescue nil
      else
        self.contents.find { |c| c.name == file }
      end
    end

    def basename
      File.basename(name)
    end

    # Pretty object inspection
    def inspect
      %Q{#Grit::Tree "#{@id}"}
    end

    # Find only Tree objects from contents
    def trees
      contents.select {|v| v.kind_of? Tree}
    end

    # Find only Blob objects from contents
    def blobs
      contents.select {|v| v.kind_of? Blob}
    end

    # Compares trees by name
    def =(other)
      name = other.name
    end
  end # Tree

end # Grit
</content>
		</actual_file>
		<actual_file>
			<filename>commit_db.rb</filename>
			<content>begin
  require 'sequel'

  module Grit

    class CommitDb

      SCHEMA_VERSION = 1

      attr_accessor :db, :git

      def initialize(git_obj, index_location = nil)
        @git = git_obj
        db_file = File.join(index_location || @git.git_dir, 'commit_db')
        if !File.exists?(db_file)
          @db = Sequel.open "sqlite:///#{db_file}"
          setup_tables
        else
          @db = Sequel.open "sqlite:///#{db_file}"
        end
      end

      def rev_list(branch, options)
      end

      def update_db(branch = nil)
        # find all refs/heads, for each
        # add branch if not there
        # go though all commits in branch
          # add new commit_branches a
          # and commit_nodes for each new one
          # stop if reach commit that already has branch and node links
      end

      def setup_tables
        @db  "create table meta (meta_key text, meta_value text)"
        @db[:meta]  {:meta_key = 'schema', :meta_value = SCHEMA_VERSION}

        @db  "create table commits (id integer, sha text, author_date integer)"
        @db  "create table nodes (id integer, path text, type text)"
        @db  "create table branches (id integer, ref text, commit_id integer)"

        @db  "create table commit_branches (commit_id integer, branch_id integer)"
        @db  "create table commit_nodes (commit_id integer, node_id integer, node_sha string)"
      end

    end
  end

rescue LoadError
  # no commit db
end
</content>
		</actual_file>
		<actual_file>
			<filename>git_object.rb</filename>
			<content>#
# converted from the gitrb project
#
# authors:
#    Matthias Lederhofer matled@gmx.net
#    Simon 'corecode' Schubert corecode@fs.ei.tum.de
#    Scott Chacon schacon@gmail.com
#
# provides native ruby access to git objects and pack files
#

# These classes translate the raw binary data kept in the sha encoded files
# into parsed data that can then be used in another fashion
require 'stringio'

module Grit
  module GitRuby

  # class for author/committer/tagger lines
  class UserInfo
    attr_accessor :name, :email, :date, :offset

    def initialize(str)
      @email = ''
      @date = Time.now
      @offset = 0

      m = /^(.*?) (.*) (\d+) ([+-])0*(\d+?)$/.match(str)
      if !m
        case str
        when /.+/
          m, @name, @email = *str.match(/(.*) (.+?)/)
        else
          @name = str
        end
      else
        @name = m[1]
        @email = m[2]
        @date = Time.at(Integer(m[3]))
        @offset = (m[4] == "-" ? -1 : 1)*Integer(m[5])
      end
    end

    def to_s
      "%s %s %s %+05d" % [@name, @email, @date.to_i, @offset]
    end
  end

  # base class for all git objects (blob, tree, commit, tag)
  class GitObject
    attr_accessor :repository
    attr_accessor :sha

    def GitObject.from_raw(rawobject, repository = nil)
      case rawobject.type
      when :blob
        return Blob.from_raw(rawobject, repository)
      when :tree
        return Tree.from_raw(rawobject, repository)
      when :commit
        return Commit.from_raw(rawobject, repository)
      when :tag
        return Tag.from_raw(rawobject, repository)
      else
        raise RuntimeError, "got invalid object-type"
      end
    end

    def initialize
      raise NotImplemented, "abstract class"
    end

    def type
      raise NotImplemented, "abstract class"
    end

    def raw_content
      raise NotImplemented, "abstract class"
    end

    def sha1
      Digest::SHA1.hexdigest("%s %d\0" % \
                             [self.type, self.raw_content.length] + \
                             self.raw_content)
    end
  end

  class Blob  GitObject
    attr_accessor :content

    def self.from_raw(rawobject, repository)
      new(rawobject.content)
    end

    def initialize(content, repository=nil)
      @content = content
      @repository = repository
    end

    def type
      :blob
    end

    def raw_content
      @content
    end
  end

  class DirectoryEntry
    S_IFMT  = 00170000
    S_IFLNK =  0120000
    S_IFREG =  0100000
    S_IFDIR =  0040000
    S_IFGITLINK = 0160000
    attr_accessor :mode, :name, :sha1
    def initialize(mode, filename, sha1o)
      @mode = 0
      mode.each_byte do |i|
        @mode = (@mode  3) | (i-'0'.getord(0))
      end
      @name = filename
      @sha1 = sha1o
      if ![S_IFLNK, S_IFDIR, S_IFREG, S_IFGITLINK].include?(@mode & S_IFMT)
        raise RuntimeError, "unknown type for directory entry"
      end
    end

    def type
      case @mode & S_IFMT
      when S_IFGITLINK
        @type = :submodule
      when S_IFLNK
        @type = :link
      when S_IFDIR
        @type = :directory
      when S_IFREG
        @type = :file
      else
        raise RuntimeError, "unknown type for directory entry"
      end
    end

    def type=(type)
      case @type
      when :link
        @mode = (@mode & ~S_IFMT) | S_IFLNK
      when :directory
        @mode = (@mode & ~S_IFMT) | S_IFDIR
      when :file
        @mode = (@mode & ~S_IFMT) | S_IFREG
      when :submodule
        @mode = (@mode & ~S_IFMT) | S_IFGITLINK
      else
        raise RuntimeError, "invalid type"
      end
    end

    def format_type
      case type
      when :link
        'link'
      when :directory
        'tree'
      when :file
        'blob'
      when :submodule
        'commit'
      end
    end

    def format_mode
      "%06o" % @mode
    end

    def raw
      "%o %s\0%s" % [@mode, @name, [@sha1].pack("H*")]
    end
  end


  def self.read_bytes_until(io, char)
    string = ''
    if RUBY_VERSION  '1.9'
      while ((next_char = io.getc) != char) && !io.eof
        string += next_char
      end
    else
      while ((next_char = io.getc.chr) != char) && !io.eof
        string += next_char
      end
    end
    string
  end


  class Tree  GitObject
    attr_accessor :entry

    def self.from_raw(rawobject, repository=nil)
      raw = StringIO.new(rawobject.content)

      entries = []
      while !raw.eof?
        mode      = Grit::GitRuby.read_bytes_until(raw, ' ')
        file_name = Grit::GitRuby.read_bytes_until(raw, "\0")
        raw_sha   = raw.read(20)
        sha = raw_sha.unpack("H*").first

        entries  DirectoryEntry.new(mode, file_name, sha)
      end
      new(entries, repository)
    end

    def initialize(entries=[], repository = nil)
      @entry = entries
      @repository = repository
    end

    def type
      :tree
    end

    def raw_content
      # TODO: sort correctly
      #@entry.sort { |a,b| a.name = b.name }.
      @entry.collect { |e| [[e.format_mode, e.format_type, e.sha1].join(' '), e.name].join("\t") }.join("\n")
    end

    def actual_raw
      #@entry.collect { |e| e.raw.join(' '), e.name].join("\t") }.join("\n")
    end
  end

  class Commit  GitObject
    attr_accessor :author, :committer, :tree, :parent, :message, :headers

    def self.from_raw(rawobject, repository=nil)
      parent = []
      tree = author = committer = nil

      headers, message = rawobject.content.split(/\n\n/, 2)
      all_headers = headers.split(/\n/).map { |header| header.split(/ /, 2) }
      all_headers.each do |key, value|
        case key
        when "tree"
          tree = value
        when "parent"
          parent.push(value)
        when "author"
          author = UserInfo.new(value)
        when "committer"
          committer = UserInfo.new(value)
        else
          warn "unknown header '%s' in commit %s" % \
            [key, rawobject.sha1.unpack("H*")[0]]
        end
      end
      if not tree && author && committer
        raise RuntimeError, "incomplete raw commit object"
      end
      new(tree, parent, author, committer, message, headers, repository)
    end

    def initialize(tree, parent, author, committer, message, headers, repository=nil)
      @tree = tree
      @author = author
      @parent = parent
      @committer = committer
      @message = message
      @headers = headers
      @repository = repository
    end

    def type
      :commit
    end

    def raw_content
      "tree %s\n%sauthor %s\ncommitter %s\n\n" % [
        @tree,
        @parent.collect { |i| "parent %s\n" % i }.join,
        @author, @committer] + @message
    end

    def raw_log(sha)
      output = "commit #{sha}\n"
      output += @headers + "\n\n"
      output += @message.split("\n").map { |l| '    ' + l }.join("\n") + "\n\n"
    end

  end

  class Tag  GitObject
    attr_accessor :object, :tag, :tagger, :message, :object_type
    attr_writer :type

    def self.from_raw(rawobject, repository=nil)

      headers, message = rawobject.content.split(/\n\n/, 2)
      headers = headers.split(/\n/).map { |header| header.split(' ', 2) }

      object = ''
      type = ''
      tag = ''
      tagger = ''

      headers.each do |key, value|
        case key
        when "object"
          object = value
        when "type"
          if !["blob", "tree", "commit", "tag"].include?(value)
            raise RuntimeError, "invalid type in tag"
          end
          type = value.to_sym
        when "tag"
          tag = value
        when "tagger"
          tagger = UserInfo.new(value)
        else
          warn "unknown header '%s' in tag" % \
            [key, rawobject.sha1.unpack("H*")[0]]
        end
      end

      if not object && type && tag && tagger
        raise RuntimeError, "incomplete raw tag object"
      end
      new(object, type, tag, tagger, message, repository)
    end

    def initialize(object, type, tag, tagger, message, repository=nil)
      @object = object
      @type = type
      @object_type = type
      @tag = tag
      @tagger = tagger
      @repository = repository
      @message = message
    end

    def raw_content
      ("object %s\ntype %s\ntag %s\ntagger %s\n\n" % \
        [@object, @type, @tag, @tagger]) + @message.to_s
    end

    def type
      :tag
    end
  end

  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>repository.rb</filename>
			<content>#
# converted from the gitrb project
#
# authors:
#    Matthias Lederhofer matled@gmx.net
#    Simon 'corecode' Schubert corecode@fs.ei.tum.de
#    Scott Chacon schacon@gmail.com
#
# provides native ruby access to git objects and pack files
#
require 'grit/git-ruby/internal/raw_object'
require 'grit/git-ruby/internal/pack'
require 'grit/git-ruby/internal/loose'
require 'grit/git-ruby/git_object'

require 'rubygems'
require 'diff/lcs'
require 'diff/lcs/hunk'

# have to do this so it doesn't interfere with Grit::Diff
module Difference
  include Diff
end

module Grit
  module GitRuby
    class Repository

      class NoSuchShaFound  StandardError
      end

      class NoSuchPath  StandardError
      end

      attr_accessor :git_dir, :options

      def initialize(git_dir, options = {})
        @git_dir = git_dir
        @options = options
        @packs = []
      end

      # returns the loose objects object lazily
      def loose
        @loose ||= initloose
      end

      # returns the array of pack list objects
      def packs
        @packs ||= initpacks
      end


      # prints out the type, shas and content of all of the pack files
      def show
        packs.each do |p|
          puts p.name
          puts
          p.each_sha1 do |s|
            puts "**#{p[s].type}**"
            if p[s].type.to_s == 'commit'
              puts s.unpack('H*')
              puts p[s].content
            end
          end
          puts
        end
      end


      # returns a raw object given a SHA1
      def get_raw_object_by_sha1(sha1o)
        raise NoSuchShaFound if sha1o.nil? || sha1o.empty? || !sha1o.is_a?(String)

        sha1 = [sha1o.chomp].pack("H*")
        # try packs
        packs.each do |pack|
          o = pack[sha1]
          return pack[sha1] if o
        end

        # try loose storage
        loose.each do |lsobj|
          o = lsobj[sha1]
          return o if o
        end

        # try packs again, maybe the object got packed in the meantime
        initpacks
        packs.each do |pack|
          o = pack[sha1]
          return o if o
        end

#        puts "*#{sha1o}*"
        raise NoSuchShaFound
      end

      def cached(key, object, do_cache = true)
        object
      end

      # returns GitRuby object of any type given a SHA1
      def get_object_by_sha1(sha1)
        r = get_raw_object_by_sha1(sha1)
        return nil if !r
        GitObject.from_raw(r)
      end

      # writes a raw object into the git repo
      def put_raw_object(content, type)
        loose.first.put_raw_object(content, type)
      end

      # returns true or false if that sha exists in the db
      def object_exists?(sha1)
        sha_hex = [sha1].pack("H*")
        return true if in_packs?(sha_hex)
        return true if in_loose?(sha_hex)
        initpacks
        return true if in_packs?(sha_hex) #maybe the object got packed in the meantime
        false
      end

      # returns true if the hex-packed sha is in the packfiles
      def in_packs?(sha_hex)
        # try packs
        packs.each do |pack|
          return true if pack[sha_hex]
        end
        false
      end

      # returns true if the hex-packed sha is in the loose objects
      def in_loose?(sha_hex)
        loose.each do |lsobj|
          return true if lsobj[sha_hex]
        end
        false
      end


      # returns the file type (as a symbol) of this sha
      def cat_file_type(sha)
        get_raw_object_by_sha1(sha).type
      end

      # returns the file size (as an int) of this sha
      def cat_file_size(sha)
        get_raw_object_by_sha1(sha).content.size
      end

      # returns the raw file contents of this sha
      def cat_file(sha)
        get_object_by_sha1(sha).raw_content
      end

      # returns a 2-d hash of the tree
      # ['blob']['FILENAME'] = {:mode = '100644', :sha = SHA}
      # ['tree']['DIRNAME'] = {:mode = '040000', :sha = SHA}
      def list_tree(sha)
        data = {'blob' = {}, 'tree' = {}, 'link' = {}, 'commit' = {}}
        get_object_by_sha1(sha).entry.each do |e|
          data[e.format_type][e.name] = {:mode = e.format_mode, :sha = e.sha1}
        end
        data
      end

      # returns the raw (cat-file) output for a tree
      # if given a commit sha, it will print the tree of that commit
      # if given a path limiter array, it will limit the output to those
      # if asked for recrusive trees, will traverse trees
      def ls_tree(sha, paths = [], recursive = false)
        if paths.size  0
          # pathing
          part = []
          paths.each do |path|
            part += ls_tree_path(sha, path)
          end
          return part.join("\n")
        else
          get_raw_tree(sha, recursive)
        end
      end

      def get_raw_tree(sha, recursive = false)
        o = get_raw_object_by_sha1(sha)
        if o.type == :commit
          tree = get_object_by_sha1(sha).tree
        elsif o.type == :tag
          commit_sha = get_object_by_sha1(sha).object
          tree = get_object_by_sha1(commit_sha).tree
        elsif o.type == :tree
          tree = sha
        else
          return nil
        end

        recursive ? get_raw_trees(tree) : cat_file(tree)
      end

      # Grabs tree contents recursively,
      #   e.g. `git ls-tree -r sha`
      def get_raw_trees(sha, path = '')
        out = ''
        cat_file(sha).split("\n").each do |line|
          mode, type, sha, name = line.split(/\s/)

          if type == 'tree'
            full_name = path.empty? ? name : "#{path}/#{name}"
            out  get_raw_trees(sha, full_name)
          elsif path.empty?
            out  line + "\n"
          else
            out  line.gsub(name, "#{path}/#{name}") + "\n"
          end
        end

        out
      end

      # return array of tree entries
      ## TODO : refactor this to remove the fugly
      def ls_tree_path(sha, path, append = nil)
        tree = get_raw_tree(sha)
        if path =~ /\//
          paths = path.split('/')
          last = path[path.size - 1, 1]
          if (last == '/') && (paths.size == 1)
            append = append ? File.join(append, paths.first) : paths.first
            dir_name = tree.split("\n").select { |p| p.split("\t")[1] == paths.first }.first
            raise NoSuchPath if !dir_name
            next_sha = dir_name.split(' ')[2]
            tree = get_raw_tree(next_sha)
            tree = tree.split("\n")
            if append
              mod_tree = []
              tree.each do |ent|
                (info, fpath) = ent.split("\t")
                mod_tree  [info, File.join(append, fpath)].join("\t")
              end
              mod_tree
            else
              tree
            end
          else
            raise NoSuchPath if tree.nil?
            next_path = paths.shift
            dir_name = tree.split("\n").select { |p| p.split("\t")[1] == next_path }.first
            raise NoSuchPath if !dir_name
            next_sha = dir_name.split(' ')[2]
            next_path = append ? File.join(append, next_path) : next_path
            if (last == '/')
              ls_tree_path(next_sha, paths.join("/") + '/', next_path)
            else
              ls_tree_path(next_sha, paths.join("/"), next_path)
            end
          end
        else
          raise NoSuchPath if tree.nil?
          tree = tree.split("\n")
          tree = tree.select { |p| p.split("\t")[1] == path }
          if append
            mod_tree = []
            tree.each do |ent|
              (info, fpath) = ent.split("\t")
              mod_tree  [info, File.join(append, fpath)].join("\t")
            end
            mod_tree
          else
            tree
          end
        end
      end

      # returns an array of GitRuby Commit objects
      # [ [sha, raw_output], [sha, raw_output], [sha, raw_output] ... ]
      #
      # takes the following options:
      #  :since - Time object specifying that you don't want commits BEFORE this
      #  :until - Time object specifying that you don't want commit AFTER this
      #  :first_parent - tells log to only walk first parent
      #  :path_limiter - string or array of strings to limit path
      #  :max_count - number to limit the output
      def log(sha, options = {})
        @already_searched = {}
        walk_log(sha, options)
      end

      def truncate_arr(arr, sha)
        new_arr = []
        arr.each do |a|
          if a[0] == sha
            return new_arr
          end
          new_arr  a
        end
        return new_arr
      end

      def rev_list(sha, options)
        if sha.is_a? Array
          (end_sha, sha) = sha
        end

        log = log(sha, options)
        log = log.sort { |a, b| a[2] = b[2] }.reverse

        if end_sha
          log = truncate_arr(log, end_sha)
        end

        # shorten the list if it's longer than max_count (had to get everything in branches)
        if options[:max_count]
          if (opt_len = options[:max_count].to_i)  log.size
            log = log[0, opt_len]
          end
        end

        if options[:pretty] == 'raw'
          log.map {|k, v| v }.join('')
        else
          log.map {|k, v| k }.join("\n")
        end
      end

      # called by log() to recursively walk the tree
      def walk_log(sha, opts, total_size = 0)
        return [] if @already_searched[sha] # to prevent rechecking branches
        @already_searched[sha] = true

        array = []
        if (sha)
          o = get_raw_object_by_sha1(sha)
          if o.type == :tag
            commit_sha = get_object_by_sha1(sha).object
            c = get_object_by_sha1(commit_sha)
          else
            c = GitObject.from_raw(o)
          end

          return [] if c.type != :commit

          add_sha = true

          if opts[:since] && opts[:since].is_a?(Time) && (opts[:since]  c.committer.date)
            add_sha = false
          end
          if opts[:until] && opts[:until].is_a?(Time) && (opts[:until]  c.committer.date)
            add_sha = false
          end

          # follow all parents unless '--first-parent' is specified #
          subarray = []

          if !c.parent.first && opts[:path_limiter]  # check for the last commit
            add_sha = false
          end

          if (!opts[:max_count] || ((array.size + total_size)  opts[:max_count]))

            if !opts[:path_limiter]
              output = c.raw_log(sha)
              array  [sha, output, c.committer.date]
            end

            if (opts[:max_count] && (array.size + total_size) = opts[:max_count])
              return array
            end

            c.parent.each do |psha|
              if psha && !files_changed?(c.tree, get_object_by_sha1(psha).tree,
                                        opts[:path_limiter])
                add_sha = false
              end
              subarray += walk_log(psha, opts, (array.size + total_size))
              next if opts[:first_parent]
            end

            if opts[:path_limiter] && add_sha
              output = c.raw_log(sha)
              array  [sha, output, c.committer.date]
            end

            if add_sha
              array += subarray
            end
          end

        end

        array
      end

      def diff(commit1, commit2, options = {})
        patch = ''

        commit_obj1 = get_object_by_sha1(commit1)
        tree1 = commit_obj1.tree
        if commit2
          tree2 = get_object_by_sha1(commit2).tree
        else
          tree2 = get_object_by_sha1(commit_obj1.parent.first).tree
        end

        qdiff = quick_diff(tree1, tree2)

        qdiff.sort.each do |diff_arr|
          path, status, treeSHA1, treeSHA2 = *diff_arr
          format, lines, output = :unified, 3, ''
          file_length_difference = 0

          fileA = treeSHA1 ? cat_file(treeSHA1) : ''
          fileB = treeSHA2 ? cat_file(treeSHA2) : ''

          sha1 = treeSHA1 || '0000000000000000000000000000000000000000'
          sha2 = treeSHA2 || '0000000000000000000000000000000000000000'

          data_old = fileA.split(/\n/).map! { |e| e.chomp }
          data_new = fileB.split(/\n/).map! { |e| e.chomp }

          diffs = Difference::LCS.diff(data_old, data_new)
          next if diffs.empty?

          a_path = "a/#{path.gsub('./', '')}"
          b_path = "b/#{path.gsub('./', '')}"

          header = "diff --git #{a_path} #{b_path}"
          if options[:full_index]
            header  "\n" + 'index ' + sha1 + '..' + sha2
            header  ' 100644' if treeSHA2 # hard coding this because i don't think we use it
          else
            header  "\n" + 'index ' + sha1[0,7] + '..' + sha2[0,7]
            header  ' 100644' if treeSHA2 # hard coding this because i don't think we use it
          end
          header  "\n--- " + (treeSHA1 ? a_path : '/dev/null')
          header  "\n+++ " + (treeSHA2 ? b_path : '/dev/null')
          header += "\n"

          oldhunk = hunk = nil

          diffs.each do |piece|
            begin
              hunk = Difference::LCS::Hunk.new(data_old, data_new, piece, lines, file_length_difference)
              file_length_difference = hunk.file_length_difference

              next unless oldhunk

              if lines  0 && hunk.overlaps?(oldhunk)
                hunk.unshift(oldhunk)
              else
                output  oldhunk.diff(format)
              end
            ensure
              oldhunk = hunk
              output  "\n"
            end
          end

          output  oldhunk.diff(format)
          output  "\n"

          patch  header + output.lstrip
        end
        patch
      rescue
        '' # one of the trees was bad or lcs isn't there - no diff
      end

      # takes 2 tree shas and recursively walks them to find out what
      # files or directories have been modified in them and returns an
      # array of changes
      # [ [full_path, 'added', tree1_hash, nil],
      #   [full_path, 'removed', nil, tree2_hash],
      #   [full_path, 'modified', tree1_hash, tree2_hash]
      #  ]
      def quick_diff(tree1, tree2, path = '.', recurse = true)
        # handle empty trees
        changed = []
        return changed if tree1 == tree2

        t1 = list_tree(tree1) if tree1
        t2 = list_tree(tree2) if tree2

        # finding files that are different
        t1['blob'].each do |file, hsh|
          t2_file = t2['blob'][file] rescue nil
          full = File.join(path, file)
          if !t2_file
            changed  [full, 'added', hsh[:sha], nil]      # not in parent
          elsif (hsh[:sha] != t2_file[:sha])
            changed  [full, 'modified', hsh[:sha], t2_file[:sha]]   # file changed
          end
        end if t1
        t2['blob'].each do |file, hsh|
          if !t1 || !t1['blob'][file]
            changed  [File.join(path, file), 'removed', nil, hsh[:sha]]
          end
        end if t2

        t1['tree'].each do |dir, hsh|
          t2_tree = t2['tree'][dir] rescue nil
          full = File.join(path, dir)
          if !t2_tree
            if recurse
              changed += quick_diff(hsh[:sha], nil, full, true)
            else
              changed  [full, 'added', hsh[:sha], nil]      # not in parent
            end
          elsif (hsh[:sha] != t2_tree[:sha])
            if recurse
              changed += quick_diff(hsh[:sha], t2_tree[:sha], full, true)
            else
              changed  [full, 'modified', hsh[:sha], t2_tree[:sha]]   # file changed
            end
          end
        end if t1
        t2['tree'].each do |dir, hsh|
          t1_tree = t1['tree'][dir] rescue nil
          full = File.join(path, dir)
          if !t1_tree
            if recurse
              changed += quick_diff(nil, hsh[:sha], full, true)
            else
              changed  [full, 'removed', nil, hsh[:sha]]
            end
          end
        end if t2

        changed
      end

      # returns true if the files in path_limiter were changed, or no path limiter
      # used by the log() function when passed with a path_limiter
      def files_changed?(tree_sha1, tree_sha2, path_limiter = nil)
        if path_limiter
          mod = quick_diff(tree_sha1, tree_sha2)
          files = mod.map { |c| c.first }
          path_limiter.to_a.each do |filepath|
            if files.include?(filepath)
              return true
            end
          end
          return false
        end
        true
      end

      def get_subtree(commit_sha, path)
        tree_sha = get_object_by_sha1(commit_sha).tree

        if path && !(path == '' || path == '.' || path == './')
          paths = path.split('/')
          paths.each do |pathname|
            tree = get_object_by_sha1(tree_sha)
            if entry = tree.entry.select { |e| e.name == pathname }.first
              tree_sha = entry.sha1 rescue nil
            else
              return false
            end
          end
        end

        tree_sha
      end

      def blame_tree(commit_sha, path)
        # find subtree
        tree_sha = get_subtree(commit_sha, path)
        return {} if !tree_sha

        looking_for = []
        get_object_by_sha1(tree_sha).entry.each do |e|
          looking_for  File.join('.', e.name)
        end

        @already_searched = {}
        commits = look_for_commits(commit_sha, path, looking_for)

        # cleaning up array
        arr = {}
        commits.each do |commit_array|
          key = commit_array[0].gsub('./', '')
          arr[key] = commit_array[1]
        end
        arr
      end

      def look_for_commits(commit_sha, path, looking_for, options = {})
        return [] if @already_searched[commit_sha] # to prevent rechecking branches

        @already_searched[commit_sha] = true

        commit = get_object_by_sha1(commit_sha)
        tree_sha = get_subtree(commit_sha, path)

        found_data = []

        # at the beginning of the branch
        if commit.parent.size == 0
          looking_for.each do |search|
            # prevents the rare case of multiple branch starting points with
            # files that have never changed
            if found_data.assoc(search)
              found_data  [search, commit_sha]
            end
          end
          return found_data
        end

        # go through the parents recursively, looking for somewhere this has been changed
        commit.parent.each do |pc|
          diff = quick_diff(tree_sha, get_subtree(pc, path), '.', false)

          # remove anything found
          looking_for.each do |search|
            if match = diff.assoc(search)
              found_data  [search, commit_sha, match]
              looking_for.delete(search)
            end
          end

          if looking_for.size = 0  # we're done
            return found_data
          end

          found_data += look_for_commits(pc, path, looking_for)  # recurse into parent
          return found_data if options[:first_parent]
        end

        ## TODO : find most recent commit with change in any parent
        found_data
      end

      # initialize a git repository
      def self.init(dir, bare = true)

        FileUtils.mkdir_p(dir) if !File.exists?(dir)

        FileUtils.cd(dir) do
          if(File.exists?('objects'))
            return false # already initialized
          else
            # initialize directory
            create_initial_config(bare)
            FileUtils.mkdir_p('refs/heads')
            FileUtils.mkdir_p('refs/tags')
            FileUtils.mkdir_p('objects/info')
            FileUtils.mkdir_p('objects/pack')
            FileUtils.mkdir_p('branches')
            add_file('description', 'Unnamed repository; edit this file to name it for gitweb.')
            add_file('HEAD', "ref: refs/heads/master\n")
            FileUtils.mkdir_p('hooks')
            FileUtils.cd('hooks') do
              add_file('applypatch-msg', '# add shell script and make executable to enable')
              add_file('post-commit', '# add shell script and make executable to enable')
              add_file('post-receive', '# add shell script and make executable to enable')
              add_file('post-update', '# add shell script and make executable to enable')
              add_file('pre-applypatch', '# add shell script and make executable to enable')
              add_file('pre-commit', '# add shell script and make executable to enable')
              add_file('pre-rebase', '# add shell script and make executable to enable')
              add_file('update', '# add shell script and make executable to enable')
            end
            FileUtils.mkdir_p('info')
            add_file('info/exclude', "# *.[oa]\n# *~")
          end
        end
      end

      def self.create_initial_config(bare = false)
        bare ? bare_status = 'true' : bare_status = 'false'
        config = "[core]\n\trepositoryformatversion = 0\n\tfilemode = true\n\tbare = #{bare_status}\n\tlogallrefupdates = true"
        add_file('config', config)
      end

      def self.add_file(name, contents)
        File.open(name, 'w') do |f|
          f.write contents
        end
      end

      def close
        @packs.each do |pack|
          pack.close
        end if @packs
      end

      protected

        def git_path(path)
          return "#@git_dir/#{path}"
        end

      private

        def initloose
          @loaded = []
          @loose = []
          load_loose(git_path('objects'))
          load_alternate_loose(git_path('objects'))
          @loose
        end

        def each_alternate_path(path)
          alt = File.join(path, 'info/alternates')
          return if !File.exists?(alt)

          File.readlines(alt).each do |line|
            path = line.chomp
            if path[0, 2] == '..'
              yield File.expand_path(File.join(@git_dir, 'objects', path))

              # XXX this is here for backward compatibility with grit  2.3.0
              # relative alternate objects paths are expanded relative to the
              # objects directory, not the git repository directory.
              yield File.expand_path(File.join(@git_dir, path))
            else
              yield path
            end
          end
        end

        def load_alternate_loose(pathname)
          # load alternate loose, too
          each_alternate_path pathname do |path|
            next if @loaded.include?(path)
            next if !File.exist?(path)
            load_loose(path)
            load_alternate_loose(path)
          end
        end

        def load_loose(path)
          @loaded  path
          return if !File.exists?(path)
          @loose  Grit::GitRuby::Internal::LooseStorage.new(path)
        end

        def initpacks
          close
          @loaded_packs = []
          @packs = []
          load_packs(git_path("objects/pack"))
          load_alternate_packs(git_path('objects'))
          @packs
        end

        def load_alternate_packs(pathname)
          each_alternate_path pathname do |path|
            full_pack = File.join(path, 'pack')
            next if @loaded_packs.include?(full_pack)
            load_packs(full_pack)
            load_alternate_packs(path)
          end
        end

        def load_packs(path)
          @loaded_packs  path
          return if !File.exists?(path)
           Dir.open(path) do |dir|
            dir.each do |entry|
              next if !(entry =~ /\.pack$/i)
              pack = Grit::GitRuby::Internal::PackStorage.new(File.join(path,entry))
              if @options[:map_packfile]
                pack.cache_objects
              end
              @packs  pack
            end
          end
        end

    end

  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>file_window.rb</filename>
			<content>#
# converted from the gitrb project
#
# authors:
#    Matthias Lederhofer matled@gmx.net
#    Simon 'corecode' Schubert corecode@fs.ei.tum.de
#    Scott Chacon schacon@gmail.com
#
# provides native ruby access to git objects and pack files
#

module Grit
  module GitRuby
    module Internal
      class FileWindow
        def initialize(file, version = 1)
          @file = file
          @offset = nil
          if version == 2
            @global_offset = 8
          else
            @global_offset = 0
          end
        end

        def unmap
          @file = nil
        end

        def [](*idx)
          idx = idx[0] if idx.length == 1
          case idx
          when Range
            offset = idx.first
            len = idx.last - idx.first + idx.exclude_end? ? 0 : 1
          when Fixnum
            offset = idx
            len = nil
          when Array
            offset, len = idx
          else
            raise RuntimeError, "invalid index param: #{idx.class}"
          end
          if @offset != offset
            @file.seek(offset + @global_offset)
          end
          @offset = offset + len ? len : 1
          if not len
            @file.read(1).getord(0)
          else
            @file.read(len)
          end
        end
      end
    end
  end
end

</content>
		</actual_file>
		<actual_file>
			<filename>loose.rb</filename>
			<content>#
# converted from the gitrb project
#
# authors:
#    Matthias Lederhofer matled@gmx.net
#    Simon 'corecode' Schubert corecode@fs.ei.tum.de
#    Scott Chacon schacon@gmail.com
#
# provides native ruby access to git objects and pack files
#

require 'zlib'
require 'digest/sha1'
require 'grit/git-ruby/internal/raw_object'
require 'tempfile'

module Grit
  module GitRuby
    module Internal
      class LooseObjectError  StandardError
      end

      class LooseStorage
        def initialize(directory)
          @directory = directory
        end

        def [](sha1)
          sha1 = sha1.unpack("H*")[0]
          begin
            return nil unless sha1[0...2] && sha1[2..39]
            path = @directory + '/' + sha1[0...2] + '/' + sha1[2..39]
            get_raw_object(open(path, 'rb') { |f| f.read })
          rescue Errno::ENOENT
            nil
          end
        end

        def get_raw_object(buf)
          if buf.bytesize  2
            raise LooseObjectError, "object file too small"
          end

          if legacy_loose_object?(buf)
            content = Zlib::Inflate.inflate(buf)
            header, content = content.split(/\0/, 2)
            if !header || !content
              raise LooseObjectError, "invalid object header"
            end
            type, size = header.split(/ /, 2)
            if !%w(blob tree commit tag).include?(type) || size !~ /^\d+$/
              raise LooseObjectError, "invalid object header"
            end
            type = type.to_sym
            size = size.to_i
          else
            type, size, used = unpack_object_header_gently(buf)
            content = Zlib::Inflate.inflate(buf[used..-1])
          end
          raise LooseObjectError, "size mismatch" if content.bytesize != size
          return RawObject.new(type, content)
        end

        # write an object to a temporary file, then atomically rename it
        # into place; this ensures readers never see a half-written file
        def safe_write(path, content)
          f =
            if RUBY_VERSION = '1.9'
              Tempfile.open("tmp_obj_", File.dirname(path), :opt = "wb")
            else
              Tempfile.open("tmp_obj_", File.dirname(path))
            end
          begin
            f.write content
            f.fsync
            File.link(f.path, path)
          rescue Errno::EEXIST
            # The path already exists; we raced with another process,
            # but it's OK, because by definition the content is the
            # same. So we can just ignore the error.
          ensure
            f.unlink
            f.close
          end
        end

        # currently, I'm using the legacy format because it's easier to do
        # this function takes content and a type and writes out the loose object and returns a sha
        def put_raw_object(content, type)
          size = content.bytesize.to_s
          LooseStorage.verify_header(type, size)

          header = "#{type} #{size}\0"
          store = header + content

          sha1 = Digest::SHA1.hexdigest(store)
          path = @directory+'/'+sha1[0...2]+'/'+sha1[2..40]

          if !File.exists?(path)
            content = Zlib::Deflate.deflate(store)

            FileUtils.mkdir_p(@directory+'/'+sha1[0...2])
            safe_write(path, content)
          end
          return sha1
        end

        # simply figure out the sha
        def self.calculate_sha(content, type)
          size = content.bytesize.to_s
          verify_header(type, size)
          header = "#{type} #{size}\0"
          store = header + content

          Digest::SHA1.hexdigest(store)
        end

        def self.verify_header(type, size)
          if !%w(blob tree commit tag).include?(type) || size !~ /^\d+$/
            raise LooseObjectError, "invalid object header"
          end
        end

        # private
        def unpack_object_header_gently(buf)
          used = 0
          c = buf.getord(used)
          used += 1

          type = (c  4) & 7;
          size = c & 15;
          shift = 4;
          while c & 0x80 != 0
            if buf.bytesize = used
              raise LooseObjectError, "object file too short"
            end
            c = buf.getord(used)
            used += 1

            size += (c & 0x7f)  shift
            shift += 7
          end
          type = OBJ_TYPES[type]
          if ![:blob, :tree, :commit, :tag].include?(type)
            raise LooseObjectError, "invalid loose object type"
          end
          return [type, size, used]
        end
        private :unpack_object_header_gently

        def legacy_loose_object?(buf)
          word = (buf.getord(0)  8) + buf.getord(1)
          buf.getord(0) == 0x78 && word % 31 == 0
        end
        private :legacy_loose_object?
      end
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>pack.rb</filename>
			<content>#
# converted from the gitrb project
#
# authors:
#    Matthias Lederhofer matled@gmx.net
#    Simon 'corecode' Schubert corecode@fs.ei.tum.de
#    Scott Chacon schacon@gmail.com
#
# provides native ruby access to git objects and pack files
#

require 'zlib'
require 'grit/git-ruby/internal/raw_object'
require 'grit/git-ruby/internal/file_window'

PACK_SIGNATURE = "PACK"
PACK_IDX_SIGNATURE = "\377tOc"

module Grit
  module GitRuby
    module Internal
      class PackFormatError  StandardError
      end

      class PackStorage
        OBJ_OFS_DELTA = 6
        OBJ_REF_DELTA = 7

        FanOutCount = 256
        SHA1Size = 20
        IdxOffsetSize = 4
        OffsetSize = 4
        ExtendedOffsetSize = 8
        CrcSize = 4
        OffsetStart = FanOutCount * IdxOffsetSize
        SHA1Start = OffsetStart + OffsetSize
        EntrySize = OffsetSize + SHA1Size
        EntrySizeV2 = SHA1Size + CrcSize + OffsetSize

        def initialize(file)
          if file =~ /\.idx$/
            file = file[0...-3] + 'pack'
          end
          @name = file
          @cache = {}
          init_pack
        end

        def with_idx(index_file = nil)
          index_file ||= @name[0...-4] + 'idx'

          begin
            idxfile = File.open(index_file, 'rb')
          rescue Errno::ENOENT = boom
            # file went away. bail out without yielding.
            return
          end

          # read header
          sig = idxfile.read(4)
          ver = idxfile.read(4).unpack("N")[0]

          if sig == PACK_IDX_SIGNATURE
            if(ver != 2)
              raise PackFormatError, "pack #@name has unknown pack file version #{ver}"
            end
            @version = 2
          else
            @version = 1
          end

          idx = FileWindow.new(idxfile, @version)
          yield idx
          idx.unmap
        ensure
          idxfile.close if idxfile
        end

        def with_packfile
          begin
            packfile = File.open(@name, 'rb')
          rescue Errno::ENOENT
            # file went away. bail out without yielding.
            return
          end
          yield packfile
        ensure
          packfile.close if packfile
        end

        def cache_objects
          @cache = {}
          with_packfile do |packfile|
            each_entry do |sha, offset|
              data, type = unpack_object(packfile, offset, {:caching = true})
              if data
                @cache[sha] = RawObject.new(OBJ_TYPES[type], data)
              end
            end
          end
        end

        def name
          @name
        end

        def close
          # shouldnt be anything open now
        end

        # given an index file, list out the shas that it's packfile contains
        def get_shas
          shas = []
          each_sha1 { |sha| shas  sha.unpack("H*")[0] }
          shas
        end

        def [](sha1)
          if obj = @cache[sha1]
            return obj
          end

          offset = find_object(sha1)
          return nil if !offset
          @cache[sha1] = obj = parse_object(offset)
          return obj
        end

        def init_pack
          with_idx do |idx|
            @offsets = [0]
            FanOutCount.times do |i|
              pos = idx[i * IdxOffsetSize,IdxOffsetSize].unpack('N')[0]
              if pos  @offsets[i]
                raise PackFormatError, "pack #@name has discontinuous index #{i}"
              end
              @offsets  pos
            end
            @size = @offsets[-1]
          end
        end

        def each_entry
          with_idx do |idx|
            if @version == 2
              data = read_data_v2(idx)
              data.each do |sha1, crc, offset|
                yield sha1, offset
              end
            else
              pos = OffsetStart
              @size.times do
                offset = idx[pos,OffsetSize].unpack('N')[0]
                sha1 = idx[pos+OffsetSize,SHA1Size]
                pos += EntrySize
                yield sha1, offset
              end
            end
          end
        end

        def read_data_v2(idx)
          data = []
          pos = OffsetStart
          @size.times do |i|
            data[i] = [idx[pos,SHA1Size], 0, 0]
            pos += SHA1Size
          end
          @size.times do |i|
            crc = idx[pos,CrcSize]
            data[i][1] = crc
            pos += CrcSize
          end
          @size.times do |i|
            offset = idx[pos,OffsetSize].unpack('N')[0]
            data[i][2] = offset
            pos += OffsetSize
          end
          data
        end
        private :read_data_v2

        def each_sha1
          with_idx do |idx|
            if @version == 2
              data = read_data_v2(idx)
              data.each do |sha1, crc, offset|
                yield sha1
              end
            else
              pos = SHA1Start
              @size.times do
                sha1 = idx[pos,SHA1Size]
                pos += EntrySize
                yield sha1
              end
            end
          end
        end

        def find_object_in_index(idx, sha1)
          slot = sha1.getord(0)
          return nil if !slot
          first, last = @offsets[slot,2]
          while first  last
            mid = (first + last) / 2
            if @version == 2
              midsha1 = idx[OffsetStart + (mid * SHA1Size), SHA1Size]
              cmp = midsha1 = sha1

              if cmp  0
                first = mid + 1
              elsif cmp  0
                last = mid
              else
                pos = OffsetStart + (@size * (SHA1Size + CrcSize)) + (mid * OffsetSize)
                offset = idx[pos, OffsetSize].unpack('N')[0]
                if offset & 0x80000000  0
                  offset &= 0x7fffffff
                  pos = OffsetStart + (@size * (SHA1Size + CrcSize + OffsetSize)) + (offset * ExtendedOffsetSize)
                  words = idx[pos, ExtendedOffsetSize].unpack('NN')
                  offset = (words[0]  32) | words[1]
                end
                return offset
              end
            else
              midsha1 = idx[SHA1Start + mid * EntrySize,SHA1Size]
              cmp = midsha1 = sha1

              if cmp  0
                first = mid + 1
              elsif cmp  0
                last = mid
              else
                pos = OffsetStart + mid * EntrySize
                offset = idx[pos,OffsetSize].unpack('N')[0]
                return offset
              end
            end
          end
          nil
        end

        def find_object(sha1)
          obj = nil
          with_idx do |idx|
            obj = find_object_in_index(idx, sha1)
          end
          obj
        end
        private :find_object

        def parse_object(offset)
          obj = nil
          with_packfile do |packfile|
            data, type = unpack_object(packfile, offset)
            obj = RawObject.new(OBJ_TYPES[type], data)
          end
          obj
        end
        protected :parse_object

        def unpack_object(packfile, offset, options = {})
          obj_offset = offset
          packfile.seek(offset)

          c = packfile.read(1).getord(0)
          size = c & 0xf
          type = (c  4) & 7
          shift = 4
          offset += 1
          while c & 0x80 != 0
            c = packfile.read(1).getord(0)
            size |= ((c & 0x7f)  shift)
            shift += 7
            offset += 1
          end

          return [false, false] if !(type == OBJ_COMMIT || type == OBJ_TREE) && options[:caching]

          case type
          when OBJ_OFS_DELTA, OBJ_REF_DELTA
            data, type = unpack_deltified(packfile, type, offset, obj_offset, size, options)
            #puts type
          when OBJ_COMMIT, OBJ_TREE, OBJ_BLOB, OBJ_TAG
            data = unpack_compressed(offset, size)
          else
            raise PackFormatError, "invalid type #{type}"
          end
          [data, type]
        end
        private :unpack_object

        def unpack_deltified(packfile, type, offset, obj_offset, size, options = {})
          packfile.seek(offset)
          data = packfile.read(SHA1Size)

          if type == OBJ_OFS_DELTA
            i = 0
            c = data.getord(i)
            base_offset = c & 0x7f
            while c & 0x80 != 0
              c = data.getord(i += 1)
              base_offset += 1
              base_offset = 7
              base_offset |= c & 0x7f
            end
            base_offset = obj_offset - base_offset
            offset += i + 1
          else
            base_offset = find_object(data)
            offset += SHA1Size
          end

          base, type = unpack_object(packfile, base_offset)

          return [false, false] if !(type == OBJ_COMMIT || type == OBJ_TREE) && options[:caching]

          delta = unpack_compressed(offset, size)
          [patch_delta(base, delta), type]
        end
        private :unpack_deltified

        def unpack_compressed(offset, destsize)
          outdata = ""
          with_packfile do |packfile|
            packfile.seek(offset)
            zstr = Zlib::Inflate.new
            while outdata.size  destsize
              indata = packfile.read(4096)
              if indata.size == 0
                raise PackFormatError, 'error reading pack data'
              end
              outdata  zstr.inflate(indata)
            end
            if outdata.size  destsize
              raise PackFormatError, 'error reading pack data'
            end
            zstr.close
          end
          outdata
        end
        private :unpack_compressed

        def patch_delta(base, delta)
          src_size, pos = patch_delta_header_size(delta, 0)
          if src_size != base.size
            raise PackFormatError, 'invalid delta data'
          end

          dest_size, pos = patch_delta_header_size(delta, pos)
          dest = ""
          while pos  delta.size
            c = delta.getord(pos)
            pos += 1
            if c & 0x80 != 0
              pos -= 1
              cp_off = cp_size = 0
              cp_off = delta.getord(pos += 1) if c & 0x01 != 0
              cp_off |= delta.getord(pos += 1)  8 if c & 0x02 != 0
              cp_off |= delta.getord(pos += 1)  16 if c & 0x04 != 0
              cp_off |= delta.getord(pos += 1)  24 if c & 0x08 != 0
              cp_size = delta.getord(pos += 1) if c & 0x10 != 0
              cp_size |= delta.getord(pos += 1)  8 if c & 0x20 != 0
              cp_size |= delta.getord(pos += 1)  16 if c & 0x40 != 0
              cp_size = 0x10000 if cp_size == 0
              pos += 1
              dest  base[cp_off,cp_size]
            elsif c != 0
              dest  delta[pos,c]
              pos += c
            else
              raise PackFormatError, 'invalid delta data'
            end
          end
          dest
        end
        private :patch_delta

        def patch_delta_header_size(delta, pos)
          size = 0
          shift = 0
          begin
            c = delta.getord(pos)
            if c == nil
              raise PackFormatError, 'invalid delta header'
            end
            pos += 1
            size |= (c & 0x7f)  shift
            shift += 7
          end while c & 0x80 != 0
          [size, pos]
        end
        private :patch_delta_header_size
      end
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>raw_object.rb</filename>
			<content>#
# converted from the gitrb project
#
# authors:
#    Matthias Lederhofer matled@gmx.net
#    Simon 'corecode' Schubert corecode@fs.ei.tum.de
#
# provides native ruby access to git objects and pack files
#

require 'digest/sha1'

module Grit
  module GitRuby
    module Internal
      OBJ_NONE = 0
      OBJ_COMMIT = 1
      OBJ_TREE = 2
      OBJ_BLOB = 3
      OBJ_TAG = 4

      OBJ_TYPES = [nil, :commit, :tree, :blob, :tag].freeze

      class RawObject
        attr_accessor :type, :content
        def initialize(type, content)
          @type = type
          @content = content
        end

        def sha1
          Digest::SHA1.digest("%s %d\0" % [@type, @content.length] + @content)
        end

        def to_hash
          {
            :type = @type,
            :content = @content
          }
        end
      end
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>helper.rb</filename>
			<content>require File.join(File.dirname(__FILE__), *%w[.. lib grit])

require 'rubygems'
require 'test/unit'
gem "mocha", "=0"
require 'mocha'

GRIT_REPO = ENV["GRIT_REPO"] || File.expand_path(File.join(File.dirname(__FILE__), '..'))

include Grit

def fixture(name)
  File.read(File.join(File.dirname(__FILE__), 'fixtures', name))
end

def absolute_project_path
  File.expand_path(File.join(File.dirname(__FILE__), '..'))
end

def jruby?
  defined?(RUBY_ENGINE) && RUBY_ENGINE =~ /jruby/
end
</content>
		</actual_file>
		<actual_file>
			<filename>profile.rb</filename>
			<content>require File.join(File.dirname(__FILE__), *%w[.. lib grit])
include Grit

def recurse(tree, indent = "")
  tree.contents.each do |c|
    case c
      when Tree
        # puts "#{indent}#{c.name} (#{c.id})"
        recurse(c, indent + "  ")
    end
  end
end

10.times do
  r = Repo.new("/Users/schacon/projects/ambition")
  t = r.tree

  recurse(t)
end

#500.times { puts `git --git-dir /Users/schacon/projects/ambition/.git ls-tree master` }
</content>
		</actual_file>
		<actual_file>
			<filename>suite.rb</filename>
			<content>require 'test/unit'

tests = Dir["#{File.dirname(__FILE__)}/test_*.rb"]
tests.each do |file|
  require file
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_actor.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestActor  Test::Unit::TestCase
  def setup

  end

  # output
  def test_output_adds_tz_offset
    t = Time.now
    a = Actor.new("Tom Werner", "tom@example.com")
    pieces = a.output(t).split(" ")
    offset = pieces.pop
    output = pieces * ' '
    assert_equal "Tom Werner tom@example.com #{t.to_i}", output
    assert_match /-?\d{4}/, offset
  end

  # from_string

  def test_from_string_should_separate_name_and_email
    a = Actor.from_string("Tom Werner tom@example.com")
    assert_equal "Tom Werner", a.name
    assert_equal "tom@example.com", a.email
  end

  def test_from_string_should_handle_just_name
    a = Actor.from_string("Tom Werner")
    assert_equal "Tom Werner", a.name
    assert_equal nil, a.email
  end

  # inspect

  def test_inspect
    a = Actor.from_string("Tom Werner tom@example.com")
    assert_equal %Q{#Grit::Actor "Tom Werner tom@example.com"}, a.inspect
  end

  # to_s

  def test_to_s_should_alias_name
    a = Actor.from_string("Tom Werner tom@example.com")
    assert_equal a.name, a.to_s
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_blame.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'
require 'pp'

class TestBlame  Test::Unit::TestCase

  def setup
    @r = Repo.new(File.join(File.dirname(__FILE__), *%w[dot_git]), :is_bare = true)
  end

  def test_simple_blame
    commit = '2d3acf90f35989df8f262dc50beadc4ee3ae1560'
    blame = @r.blame('History.txt', commit)
    assert_equal 5, blame.lines.size
    line = blame.lines[2]
    assert_equal '* 1 major enhancement', line.line
    assert_equal 3, line.lineno
    assert_equal 3, line.oldlineno
    assert_equal '634396b2f541a9f2d58b00be1a07f0c358b999b3', line.commit.id
  end

  def test_depth_blame
    commit = '2d3acf90f35989df8f262dc50beadc4ee3ae1560'
    blame = @r.blame('lib/grit.rb', commit)
    assert_equal 37, blame.lines.size
    line = blame.lines[24]
    assert_equal "require 'grit/diff'", line.line
    assert_equal 25, line.lineno
    assert_equal 16, line.oldlineno
    assert_equal '46291865ba0f6e0c9818b11be799fe2db6964d56', line.commit.id
  end

end
</content>
		</actual_file>
		<actual_file>
			<filename>test_blob.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestBlob  Test::Unit::TestCase
  def setup
    @r = Repo.new(GRIT_REPO)
    @b = Blob.allocate
  end

  # blob
  def test_nosuch_blob
    t = @r.blob('blahblah')
    assert t.is_a?(Blob)
  end

  def test_data_should_return_blob_contents
    Git.any_instance.expects(:cat_file).returns(fixture('cat_file_blob'))
    blob = Blob.create(@r, :id = 'abc')
    assert_equal "Hello world", blob.data
  end

  def test_data_should_cache
    Git.any_instance.expects(:cat_file).returns(fixture('cat_file_blob')).times(1)
    blob = Blob.create(@r, :id = 'abc')
    blob.data
    blob.data
  end

  # size

  def test_size_should_return_file_size
    Git.any_instance.expects(:cat_file).returns(fixture('cat_file_blob_size'))
    blob = Blob.create(@r, :id = 'abc')
    assert_equal 11, blob.size
  end

  # data

  # mime_type

  def test_mime_type_should_return_mime_type_for_known_types
    blob = Blob.create(@r, :id = 'abc', :name = 'foo.png')
    assert_equal "image/png", blob.mime_type
  end

  def test_mime_type_should_return_text_plain_for_unknown_types
    blob = Blob.create(@r, :id = 'abc')
    assert_equal "text/plain", blob.mime_type
  end

  # blame

  def test_blame
    Git.any_instance.expects(:blame).returns(fixture('blame'))
    b = Blob.blame(@r, 'master', 'lib/grit.rb')
    assert_equal 13, b.size
    assert_equal 25, b.inject(0) { |acc, x| acc + x.last.size }
    assert_equal b[0].first.object_id, b[9].first.object_id
    c = b.first.first
    c.expects(:__bake__).times(0)
    assert_equal '634396b2f541a9f2d58b00be1a07f0c358b999b3', c.id
    assert_equal 'Tom Preston-Werner', c.author.name
    assert_equal 'tom@mojombo.com', c.author.email
    assert_equal Time.at(1191997100), c.authored_date
    assert_equal 'Tom Preston-Werner', c.committer.name
    assert_equal 'tom@mojombo.com', c.committer.email
    assert_equal Time.at(1191997100), c.committed_date
    assert_equal 'initial grit setup', c.message
    # c.expects(:__bake__).times(1)
    # assert_equal Tree, c.tree.class
  end

  # inspect

  def test_inspect
    @b = Blob.create(@r, :id = 'abc')
    assert_equal %Q{#Grit::Blob "abc"}, @b.inspect
  end

  def test_basename
    @b = Blob.create(@r, :name = 'foo/bar.rb')
    assert_equal "bar.rb", @b.basename
  end
end</content>
		</actual_file>
		<actual_file>
			<filename>test_commit.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestCommit  Test::Unit::TestCase
  def setup
    @r = Repo.new(File.join(File.dirname(__FILE__), *%w[dot_git]), :is_bare = true)
  end

  # __bake__

  def test_bake
    Git.any_instance.expects(:rev_list).returns(fixture('rev_list_single'))
    @c = Commit.create(@r, :id = '4c8124ffcf4039d292442eeccabdeca5af5c5017')
    @c.author # bake

    assert_equal "Tom Preston-Werner", @c.author.name
    assert_equal "tom@mojombo.com", @c.author.email
  end

  # short_name

  def test_id_abbrev
    assert_equal '80f136f', @r.commit('80f136f500dfdb8c3e8abf4ae716f875f0a1b57f').id_abbrev
  end

  # count

  def test_count
    assert_equal 107, Commit.count(@r, 'master')
  end

  # diff

  def test_diff
    # git diff --full-index 91169e1f5fa4de2eaea3f176461f5dc784796769  test/fixtures/diff_p

    Git.any_instance.expects(:diff).with({:full_index = true}, 'master').returns(fixture('diff_p'))
    diffs = Commit.diff(@r, 'master')

    assert_equal 15, diffs.size

    assert_equal '.gitignore', diffs.first.a_path
    assert_equal '.gitignore', diffs.first.b_path
    assert_equal '4ebc8aea50e0a67e000ba29a30809d0a7b9b2666', diffs.first.a_blob.id
    assert_equal '2dd02534615434d88c51307beb0f0092f21fd103', diffs.first.b_blob.id
    assert_equal '100644', diffs.first.b_mode
    assert_equal false, diffs.first.new_file
    assert_equal false, diffs.first.deleted_file
    assert_equal "--- a/.gitignore\n+++ b/.gitignore\n@@ -1 +1,2 @@\n coverage\n+pkg", diffs.first.diff

    assert_equal 'lib/grit/actor.rb', diffs[5].a_path
    assert_equal nil, diffs[5].a_blob
    assert_equal 'f733bce6b57c0e5e353206e692b0e3105c2527f4', diffs[5].b_blob.id
    assert_equal true, diffs[5].new_file
  end

  def test_diff_with_two_commits
    # git diff --full-index 59ddc32 13d27d5  test/fixtures/diff_2
    Git.any_instance.expects(:diff).with({:full_index = true}, '59ddc32', '13d27d5').returns(fixture('diff_2'))
    diffs = Commit.diff(@r, '59ddc32', '13d27d5')

    assert_equal 3, diffs.size
    assert_equal %w(lib/grit/commit.rb test/fixtures/show_empty_commit test/test_commit.rb), diffs.collect { |d| d.a_path }
  end

  def test_diff_with_files
    # git diff --full-index 59ddc32 -- lib  test/fixtures/diff_f
    Git.any_instance.expects(:diff).with({:full_index = true}, '59ddc32', '--', 'lib').returns(fixture('diff_f'))
    diffs = Commit.diff(@r, '59ddc32', %w(lib))

    assert_equal 1, diffs.size
    assert_equal 'lib/grit/diff.rb', diffs.first.a_path
  end

  def test_diff_with_two_commits_and_files
    # git diff --full-index 59ddc32 13d27d5 -- lib  test/fixtures/diff_2f
    Git.any_instance.expects(:diff).with({:full_index = true}, '59ddc32', '13d27d5', '--', 'lib').returns(fixture('diff_2f'))
    diffs = Commit.diff(@r, '59ddc32', '13d27d5', %w(lib))

    assert_equal 1, diffs.size
    assert_equal 'lib/grit/commit.rb', diffs.first.a_path
  end

  def test_diff_with_options
    Git.any_instance.expects(:diff).
      with({:full_index = true, :M = true}, 'master').
      returns(fixture('diff_mode_only'))
    Commit.diff(@r, 'master', nil, [], :M = true)
  end

  # diffs
  def test_diffs
    # git diff --full-index 91169e1f5fa4de2eaea3f176461f5dc784796769  test/fixtures/diff_p

    Git.any_instance.expects(:diff).returns(fixture('diff_p'))
    @c = Commit.create(@r, :id = '91169e1f5fa4de2eaea3f176461f5dc784796769')
    diffs = @c.diffs

    assert_equal 15, diffs.size

    assert_equal '.gitignore', diffs.first.a_path
    assert_equal '.gitignore', diffs.first.b_path
    assert_equal '4ebc8aea50e0a67e000ba29a30809d0a7b9b2666', diffs.first.a_blob.id
    assert_equal '2dd02534615434d88c51307beb0f0092f21fd103', diffs.first.b_blob.id
    assert_equal '100644', diffs.first.b_mode
    assert_equal false, diffs.first.new_file
    assert_equal false, diffs.first.deleted_file
    assert_equal "--- a/.gitignore\n+++ b/.gitignore\n@@ -1 +1,2 @@\n coverage\n+pkg", diffs.first.diff

    assert_equal 'lib/grit/actor.rb', diffs[5].a_path
    assert_equal nil, diffs[5].a_blob
    assert_equal 'f733bce6b57c0e5e353206e692b0e3105c2527f4', diffs[5].b_blob.id
    assert_equal true, diffs[5].new_file
  end

  def test_diffs_on_initial_import
    # git show --full-index 634396b2f541a9f2d58b00be1a07f0c358b999b3  test/fixtures/diff_i

    Git.any_instance.expects(:show).with({:full_index = true, :pretty = 'raw'}, '634396b2f541a9f2d58b00be1a07f0c358b999b3').returns(fixture('diff_i'))
    @c = Commit.create(@r, :id = '634396b2f541a9f2d58b00be1a07f0c358b999b3')
    diffs = @c.diffs

    assert_equal 10, diffs.size

    assert_equal 'History.txt', diffs.first.a_path
    assert_equal 'History.txt', diffs.first.b_path
    assert_equal nil, diffs.first.a_blob
    assert_equal nil, diffs.first.b_mode
    assert_equal '81d2c27608b352814cbe979a6acd678d30219678', diffs.first.b_blob.id
    assert_equal true, diffs.first.new_file
    assert_equal false, diffs.first.deleted_file
    assert_equal "--- /dev/null\n+++ b/History.txt\n@@ -0,0 +1,5 @@\n+== 1.0.0 / 2007-10-09\n+\n+* 1 major enhancement\n+  * Birthday!\n+", diffs.first.diff


    assert_equal 'lib/grit.rb', diffs[5].a_path
    assert_equal nil, diffs[5].a_blob
    assert_equal '32cec87d1e78946a827ddf6a8776be4d81dcf1d1', diffs[5].b_blob.id
    assert_equal true, diffs[5].new_file
  end

  def test_diffs_on_initial_import_with_empty_commit
    Git.any_instance.expects(:show).with(
      {:full_index = true, :pretty = 'raw'},
      '634396b2f541a9f2d58b00be1a07f0c358b999b3'
    ).returns(fixture('show_empty_commit'))

    @c = Commit.create(@r, :id = '634396b2f541a9f2d58b00be1a07f0c358b999b3')
    diffs = @c.diffs

    assert_equal [], diffs
  end

  def test_diffs_with_mode_only_change
    Git.any_instance.expects(:diff).returns(fixture('diff_mode_only'))
    @c = Commit.create(@r, :id = '91169e1f5fa4de2eaea3f176461f5dc784796769')
    diffs = @c.diffs

    assert_equal 23, diffs.size
    assert_equal '100644', diffs[0].a_mode
    assert_equal '100755', diffs[0].b_mode
  end

  def test_diffs_with_options
    Git.any_instance.expects(:diff).
      with({:full_index = true, :M = true}, 
        '038af8c329ef7c1bae4568b98bd5c58510465493', 
        '91169e1f5fa4de2eaea3f176461f5dc784796769').
      returns(fixture('diff_mode_only'))
    @c = Commit.create(@r, :id = '91169e1f5fa4de2eaea3f176461f5dc784796769')
    @c.diffs :M = true
  end

  # to_s

  def test_to_s
    @c = Commit.create(@r, :id = 'abc')
    assert_equal "abc", @c.to_s
  end

  # to_patch

  def test_to_patch
    @c = Commit.create(@r, :id = '80f136f500dfdb8c3e8abf4ae716f875f0a1b57f')

    patch = @c.to_patch

    assert patch.include?('From 80f136f500dfdb8c3e8abf4ae716f875f0a1b57f Mon Sep 17 00:00:00 2001')
    assert patch.include?('From: tom tom@taco.(none)')
    assert patch.include?('Date: Tue, 20 Nov 2007 17:27:42 -0800')
    assert patch.include?('Subject: [PATCH] fix tests on other machines')
    assert patch.include?('test/test_reality.rb |   30 +++++++++++++++---------------')
    assert patch.include?('@@ -1,17 +1,17 @@')
    assert patch.include?('+#     recurse(t)')
    assert patch.include?("1.7.")
  end

  # patch_id
  
  def test_patch_id
    @c = Commit.create(@r, :id = '80f136f500dfdb8c3e8abf4ae716f875f0a1b57f')
    assert_equal '9450b04e4f83ad0067199c9e9e338197d1835cbb', @c.patch_id
  end

  # inspect

  def test_inspect
    @c = Commit.create(@r, :id = 'abc')
    assert_equal %Q{#Grit::Commit "abc"}, @c.inspect
  end

  # to_hash

  def test_to_hash
    old_tz, ENV["TZ"] = ENV["TZ"], "US/Pacific"
    @c = Commit.create(@r, :id = '4c8124ffcf4039d292442eeccabdeca5af5c5017')
    date = Time.parse('Wed Oct 10 03:06:12 -0400 2007')
    expected = {
      'parents' = ['id' = "634396b2f541a9f2d58b00be1a07f0c358b999b3"],
      'committed_date' = date.xmlschema,
      'tree' = "672eca9b7f9e09c22dcb128c283e8c3c8d7697a4",
      'authored_date' = date.xmlschema,
      'committer' = {'email' = "tom@mojombo.com", 'name' = "Tom Preston-Werner"},
      'message' = "implement Grit#heads",
      'author' = {'email' = "tom@mojombo.com", 'name' = "Tom Preston-Werner"},
      'id' = "4c8124ffcf4039d292442eeccabdeca5af5c5017"
    }

    assert_equal expected, @c.to_hash
  ensure
    ENV["TZ"] = old_tz
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_commit_stats.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestCommitStats  Test::Unit::TestCase

  def setup
    File.expects(:exist?).returns(true)
    @r = Repo.new(GRIT_REPO)

    Git.any_instance.expects(:log).returns(fixture('log'))
    @stats = @r.commit_stats
  end

  def test_commit_stats
    assert_equal 3, @stats.size
  end

  # to_hash

  def test_to_hash
    expected = {
      "files"=
        [["examples/ex_add_commit.rb", 13, 0, 13],
         ["examples/ex_index.rb", 1, 1, 2]],
       "total"=15,
       "additions"=14,
       "id"="a49b96b339c525d7fd455e0ad4f6fe7b550c9543",
       "deletions"=1
    }

    assert_equal expected, @stats.assoc('a49b96b339c525d7fd455e0ad4f6fe7b550c9543')[1].to_hash
  end

end
</content>
		</actual_file>
		<actual_file>
			<filename>test_commit_write.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestCommitWrite  Test::Unit::TestCase
  def setup
    @r = Repo.new(GRIT_REPO)
  end

  def test_commit
    Git.any_instance.expects(:commit).returns(fixture('commit'))
    results = @r.commit_index('my message')
    assert_match /Created commit/, results
  end

  def test_commit_all
    Git.any_instance.expects(:commit).returns(fixture('commit'))
    results = @r.commit_all('my message')
    assert_match /Created commit/, results
  end

end
</content>
		</actual_file>
		<actual_file>
			<filename>test_config.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestConfig  Test::Unit::TestCase
  def setup
    @r = Repo.new(GRIT_REPO)
  end

  # data

  def test_bracketed_fetch
    Git.any_instance.expects(:config).returns(fixture('simple_config'))

    config = @r.config

    assert_equal "git://github.com/mojombo/grit.git", config["remote.origin.url"]
  end

  def test_bracketed_fetch_returns_nil
    Git.any_instance.expects(:config).returns(fixture('simple_config'))

    config = @r.config

    assert_equal nil, config["unknown"]
  end

  def test_fetch
    Git.any_instance.expects(:config).returns(fixture('simple_config'))

    config = @r.config

    assert_equal "false", config.fetch("core.bare")
  end

  def test_fetch_with_default
    Git.any_instance.expects(:config).returns(fixture('simple_config'))

    config = @r.config

    assert_equal "default", config.fetch("unknown", "default")
  end

  def test_fetch_without_default_raises
    Git.any_instance.expects(:config).returns(fixture('simple_config'))

    config = @r.config

    assert_raise(IndexError) do
      config.fetch("unknown")
    end
  end

  def test_set_value
    Git.any_instance.expects(:config).with({}, 'unknown', 'default')

    config = @r.config
    config["unknown"] = "default"
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_diff.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestDiff  Test::Unit::TestCase
  def setup
    @r = Repo.new(GRIT_REPO)
  end

  # list_from_string

  def test_list_from_string_new_mode
    output = fixture('diff_new_mode')

    diffs = Grit::Diff.list_from_string(@r, output)
    assert_equal 2,   diffs.size
    assert_equal 10,  diffs.first.diff.split("\n").size
    assert_nil        diffs.last.diff
  end

  def test_list_from_string_with_renames
    output = fixture('diff_renames')

    diffs = Grit::Diff.list_from_string(@r, output)

    # rename + update
    assert_equal 5,             diffs.size
    assert_equal 'LICENSE',     diffs[0].a_path
    assert_equal 'MIT-LICENSE', diffs[0].b_path
    assert_equal 90,            diffs[0].similarity_index
    assert                      diffs[0].renamed_file
    assert diffs[0].diff.size  0

    # updated file
    assert_equal 'README.md', diffs[1].a_path
    assert_equal 'README.md', diffs[1].b_path
    assert                   !diffs[1].renamed_file
    assert                   !diffs[1].new_file
    assert                   !diffs[1].deleted_file

    # deleted file
    assert_equal 'Rakefile', diffs[2].a_path
    assert_equal 'Rakefile', diffs[2].b_path
    assert                   diffs[2].deleted_file

    # rename w/o update
    assert_equal 'PURE_TODO', diffs[3].a_path
    assert_equal 'TODO',      diffs[3].b_path
    assert_equal 100,         diffs[3].similarity_index
    assert                    diffs[3].renamed_file
    assert diffs[3].diff.size.zero?

    # created file
    assert_equal 'foobar', diffs[4].a_path
    assert_equal 'foobar', diffs[4].b_path
    assert                 diffs[4].new_file
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_git.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestGit  Test::Unit::TestCase
  def setup
    @git = Git.new(File.join(File.dirname(__FILE__), *%w[..]))
  end

  def teardown
    Grit.debug = false
  end

  def test_method_missing
    assert_match(/^git version [\w\.]*$/, @git.version)
  end

  def test_logs_stderr
    Grit.debug = true
    Grit.stubs(:log)
    Grit.expects(:log).with(includes("git: 'bad' is not a git command"))
    @git.bad
  end

  def test_logs_stderr_when_skipping_timeout
    Grit.debug = true
    Grit.stubs(:log)
    Grit.expects(:log).with(includes("git: 'bad' is not a git command"))
    @git.bad :timeout = false
  end

  def test_transform_options
    assert_equal ["-s"], @git.transform_options({:s = true})
    assert_equal [], @git.transform_options({:s = false})
    assert_equal ["-s '5'"], @git.transform_options({:s = 5})

    assert_equal ["--max-count"], @git.transform_options({:max_count = true})
    assert_equal ["--max-count='5'"], @git.transform_options({:max_count = 5})

    assert_equal ["-s", "-t"], @git.transform_options({:s = true, :t = true}).sort
  end

  def test_uses_native_command_execution
    @git.expects(:native)
    @git.something
  end

  def test_can_skip_timeout
    Timeout.expects(:timeout).never
    @git.something(:timeout = false)
  end

  def test_raises_if_too_many_bytes
    fail if jruby?
    assert_raises Grit::Git::GitTimeout do
      @git.sh "yes | head -#{Grit::Git.git_max_size + 1}"
    end
  end

  def test_raises_on_slow_shell
    Grit::Git.git_timeout = 0.0000001
    assert_raises Grit::Git::GitTimeout do
      @git.version
    end
  ensure
    Grit::Git.git_timeout = 5.0
  end

  def test_with_timeout_default_parameter
    assert_nothing_raised do
      Git::Git.with_timeout do
        @git.version
      end
    end
  end

  def test_it_really_shell_escapes_arguments_to_the_git_shell
    @git.expects(:sh).with("#{Git.git_binary} --git-dir='#{@git.git_dir}' foo --bar='bazz\\'er'")
    @git.run('', :foo, '', {:bar = "bazz'er"}, [])
    @git.expects(:sh).with("#{Git.git_binary} --git-dir='#{@git.git_dir}' bar -x 'quu\\'x'")
    @git.run('', :bar, '', {:x = "quu'x"}, [])
  end

  def test_it_shell_escapes_the_standalone_argument
    @git.expects(:sh).with("#{Git.git_binary} --git-dir='#{@git.git_dir}' foo 'bar\\'s'")
    @git.run('', :foo, '', {}, ["bar's"])

    @git.expects(:sh).with("#{Git.git_binary} --git-dir='#{@git.git_dir}' foo 'bar' '\\; echo \\'noooo\\''")
    @git.run('', :foo, '', {}, ["bar", "; echo 'noooo'"])
  end

  def test_piping_should_work_on_1_9
    @git.expects(:sh).with("#{Git.git_binary} --git-dir='#{@git.git_dir}' archive 'master' | gzip")
    @git.archive({}, "master", "| gzip")
  end

  def test_fs_read
    f = stub
    File.expects(:read).with(File.join(@git.git_dir, 'foo')).returns('bar')
    assert_equal 'bar', @git.fs_read('foo')
  end

  def test_fs_write
    f = stub
    f.expects(:write).with('baz')
    FileUtils.expects(:mkdir_p).with(File.join(@git.git_dir, 'foo'))
    File.expects(:open).with(File.join(@git.git_dir, 'foo/bar'), 'w').yields(f)
    @git.fs_write('foo/bar', 'baz')
  end

  def test_fs_delete
    FileUtils.expects(:rm_rf).with(File.join(@git.git_dir, 'foo'))
    @git.fs_delete('foo')
  end

  def test_passing_env_to_native
    args = [
      { 'A' = 'B' },
      Grit::Git.git_binary, "--git-dir=#{@git.git_dir}", "help", "-a",
      {:input = nil, :chdir = nil, :timeout = Grit::Git.git_timeout, :max = Grit::Git.git_max_size}
    ]
    p = Grit::Git::Child.new(*args)
    Grit::Git::Child.expects(:new).with(*args).returns(p)
    @git.native(:help, {:a = true, :env = { 'A' = 'B' }})
  end

  def test_native_process_info_option_on_failure
    exitstatus, out, err = @git.no_such_command({:process_info = true})
    assert_equal 1, exitstatus
    assert !err.empty?
  end

  def test_native_process_info_option_on_success
    exitstatus, out, err = @git.help({:process_info = true})
    assert_equal 0, exitstatus
    assert !out.empty?
    assert err.empty?
  end

  def test_raising_exceptions_when_native_git_commands_fail
    assert_raise Grit::Git::CommandFailed do
      @git.native(:bad, {:raise = true})
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_git_patching.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestGitPatching  Test::Unit::TestCase
  def setup
    @testdir  = File.dirname(__FILE__)
    @patchdir = File.join(@testdir, 'patch')
    @clonedir = File.join(@testdir, 'patch_clone.git')
    @git = Git.new(@patchdir)
  end

  def teardown
    Grit.debug = false
    FileUtils.rm_rf(@clonedir)
  end

  def test_gets_a_valid_patch
    assert_match /\-patchme/, @git.get_patch("good")
    assert_match /\-initial/, @git.get_patch("bad")
  end

  def test_checks_patch_applies
    assert_equal 0, @git.check_applies("master", "good")
    assert_equal 1, @git.check_applies("master", "bad")
  end

  def test_applies_patch
    repo  = Grit::Repo.new(@patchdir, :is_bare = true)
    clone = repo.fork_bare(@clonedir)
    assert_equal 'patchme', (clone.tree / 'patchme').data.strip

    badpatch = clone.git.get_patch('bad')
    assert !clone.git.apply_patch('master', badpatch)
    assert_equal 'patchme', (clone.tree / 'patchme').data.strip

    goodpatch = clone.git.get_patch('good')
    sha = clone.git.apply_patch('master', goodpatch)
    assert_equal 'patched', (clone.tree(sha) / 'patchme').data.strip
  end
end</content>
		</actual_file>
		<actual_file>
			<filename>test_grit.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestGrit  Test::Unit::TestCase
  def setup
    @old_debug  = Grit.debug
    @old_logger = Grit.logger
    Grit.debug  = true
  end

  def teardown
    Grit.debug  = @old_debug
    Grit.logger = @old_logger
  end

  def test_uses_stdout_logger_by_default
    assert_equal STDOUT, Grit.logger.instance_variable_get(:@logdev).dev
  end

  def test_can_override_logger
    my_logger = Logger.new(io = StringIO.new)
    Grit.logger = my_logger
    assert_equal my_logger, Grit.logger
  end

  def test_logs_to_specified_logger
    Grit.logger = Logger.new(io = StringIO.new)
    Grit.log 'hi mom'
    io.rewind
    assert io.read.include?('hi mom')
  end

end</content>
		</actual_file>
		<actual_file>
			<filename>test_head.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestHead  Test::Unit::TestCase
  def setup
    @r = Repo.new(File.join(File.dirname(__FILE__), *%w[dot_git]), :is_bare = true)
  end

  # inspect

  def test_inspect
    head = @r.heads[1]
    assert_equal %Q{#Grit::Head "test/master"}, head.inspect
  end

  def test_master
    head = @r.commit('master')
    assert_equal 'ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a', head.id
  end

  def test_head_commit
    head = @r.head
    assert_equal 'master', head.name
    assert_equal 'ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a', head.commit.sha
  end

  def test_submaster
    head = @r.commit('test/master')
    assert_equal '2d3acf90f35989df8f262dc50beadc4ee3ae1560', head.id
  end

  # heads with slashes

  def test_heads_with_slashes
    head = @r.heads[3]
    assert_equal %Q{#Grit::Head "test/chacon"}, head.inspect
  end

  def test_is_head
    assert @r.is_head?('master')
    assert @r.is_head?('test/chacon')
    assert !@r.is_head?('masterblah')
  end

  def test_head_count
    assert_equal 5, @r.heads.size
  end


  def test_nonpack
    assert @r.heads.map { |h| h.name }.include?('nonpack')
  end

end
</content>
		</actual_file>
		<actual_file>
			<filename>test_index_status.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestIndexStatus  Test::Unit::TestCase
  def setup
    @r = Repo.new(GRIT_REPO)
  end

  def test_add
    Git.any_instance.expects(:add).with({}, 'file1', 'file2')
    @r.add('file1', 'file2')
  end

  def test_add_array
    Git.any_instance.expects(:add).with({}, 'file1', 'file2')
    @r.add(['file1', 'file2'])
  end

  def test_remove
    Git.any_instance.expects(:rm).with({}, 'file1', 'file2')
    @r.remove('file1', 'file2')
  end

  def test_remove_array
    Git.any_instance.expects(:rm).with({}, 'file1', 'file2')
    @r.remove(['file1', 'file2'])
  end

  def test_status
    Git.any_instance.expects(:diff_index).with({}, 'HEAD').returns(fixture('diff_index'))
    Git.any_instance.expects(:diff_files).returns(fixture('diff_files'))
    Git.any_instance.expects(:ls_files).with({:stage = true}).returns(fixture('ls_files'))
    status = @r.status
    stat = status['lib/grit/repo.rb']
    assert_equal stat.sha_repo, "71e930d551c413a123f43e35c632ea6ba3e3705e"
    assert_equal stat.mode_repo, "100644"
    assert_equal stat.type, "M"
  end


end</content>
		</actual_file>
		<actual_file>
			<filename>test_merge.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'
require 'pp'

class TestMerge  Test::Unit::TestCase

  def setup
    @r = Repo.new(File.join(File.dirname(__FILE__), *%w[dot_git]), :is_bare = true)
    @merge = fixture('merge_result')
  end

  def test_from_string
    m = Grit::Merge.new(@merge)
    assert_equal m.sections, 3
    assert_equal m.conflicts, 1
  end

end</content>
		</actual_file>
		<actual_file>
			<filename>test_raw.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'
require 'pp'

class TestFileIndex  Test::Unit::TestCase

  def setup
    @r = Grit::Repo.new(File.join(File.dirname(__FILE__), *%w[dot_git]), :is_bare = true)
    @tag = 'f0055fda16c18fd8b27986dbf038c735b82198d7'
  end

  def test_raw_tag
    tag = @r.git.ruby_git.get_object_by_sha1(@tag)
    assert_match Regexp.new('v0.7.0'),  tag.raw_content
  end

end</content>
		</actual_file>
		<actual_file>
			<filename>test_real.rb</filename>
			<content># require File.dirname(__FILE__) + '/helper'
#
# class TestReal  Test::Unit::TestCase
#   def setup
#     `rm -fr /Users/tom/dev/sandbox/grittest.git`
#     `git --git-dir=/Users/tom/dev/sandbox/grittest.git init`
#     @repo = Repo.new('/Users/tom/dev/sandbox/grittest.git')
#   end
#
#   def test_real
#     Grit.debug = true
#
#     index = @repo.index
#     index.add('foo/bar/baz.txt', 'hello!')
#     index.add('foo/qux/bam.txt', 'world!')
#
#     puts index.commit('first commit')
#   end
# end</content>
		</actual_file>
		<actual_file>
			<filename>test_reality.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

# class TestTreeRecursion  Test::Unit::TestCase
#   def test_
#     r = Repo.new("/Users/tom/dev/god")
#     t = r.tree("HEAD")
#
#     recurse(t)
#   end
#
#   def recurse(tree, indent = "")
#     tree.contents.each do |c|
#       # puts "#{indent}#{c.name} (#{c.id})"
#       recurse(c, indent + "  ") if c.kind_of?(Tree)
#     end
#   end
# end</content>
		</actual_file>
		<actual_file>
			<filename>test_remote.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestRemote  Test::Unit::TestCase
  def setup
    @r = Repo.new(GRIT_REPO)
  end

  # inspect

  def test_inspect
    remote = @r.remotes.first
    assert_equal %Q{#Grit::Remote "#{remote.name}"}, remote.inspect
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_repo.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestRepo  Test::Unit::TestCase
  def setup
    @r = Repo.new(GRIT_REPO)
  end

  def create_temp_repo(clone_path)
    filename = 'git_test' + Time.now.to_i.to_s + rand(300).to_s.rjust(3, '0')
    tmp_path = File.join("/tmp/", filename)
    FileUtils.mkdir_p(tmp_path)
    FileUtils.cp_r(clone_path, tmp_path)
    File.join(tmp_path, 'dot_git')
  end

  def test_update_refs_packed
    gpath = create_temp_repo(File.join(File.dirname(__FILE__), *%w[dot_git]))
    @git = Grit::Repo.new(gpath, :is_bare = true)

    # new and existing
    test   = 'ac9a30f5a7f0f163bbe3b6f0abf18a6c83b06872'
    master = 'ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a'

    @git.update_ref('testref', test)
    new_t = @git.get_head('testref').commit.sha
    assert new_t != master

    @git.update_ref('master', test)
    new_m = @git.get_head('master').commit.sha
    assert new_m != master

    old = @git.get_head('nonpack').commit.sha
    @git.update_ref('nonpack', test)
    newp = @git.get_head('nonpack').commit.sha
    assert newp != old

    FileUtils.rm_r(gpath)
  end

  # new

  def test_new_should_raise_on_invalid_repo_location
    assert_raise(InvalidGitRepositoryError) do
      Repo.new("/tmp")
    end
  end

  def test_new_should_raise_on_non_existant_path
    assert_raise(NoSuchPathError) do
      Repo.new("/foobar")
    end
  end

  # descriptions

  def test_description
    assert @r.description.include?("Unnamed repository; edit this file")
  end

  # refs

  def test_refs_should_return_array_of_ref_objects
    @r.refs.each do |ref|
      assert ref.is_a?(Grit::Ref)
    end
  end

  # heads

  def test_current_head
    @r = Repo.new(File.join(File.dirname(__FILE__), *%w[dot_git]), :is_bare = true)
    head = @r.head
    assert_equal Grit::Head, head.class
    assert_equal 'master', head.name
    assert_equal 'ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a', @r.commits(head.name).first.id
  end

  def test_heads_should_return_array_of_head_objects
    @r.heads.each do |head|
      assert_equal Grit::Head, head.class
    end
  end

  def test_heads_should_populate_head_data
    @r = Repo.new(File.join(File.dirname(__FILE__), *%w[dot_git]), :is_bare = true)
    head = @r.heads[1]

    assert_equal 'test/master', head.name
    assert_equal '2d3acf90f35989df8f262dc50beadc4ee3ae1560', head.commit.id
  end

  # branches

  def test_branches
    # same as heads
  end

  # commits

  def test_commits
    Git.any_instance.expects(:rev_list).returns(fixture('rev_list'))

    commits = @r.commits('master', 10)

    c = commits[0]
    assert_equal '4c8124ffcf4039d292442eeccabdeca5af5c5017', c.id
    assert_equal ["634396b2f541a9f2d58b00be1a07f0c358b999b3"], c.parents.map { |p| p.id }
    assert_equal "672eca9b7f9e09c22dcb128c283e8c3c8d7697a4", c.tree.id
    assert_equal "Tom Preston-Werner", c.author.name
    assert_equal "tom@mojombo.com", c.author.email
    assert_equal Time.at(1191999972), c.authored_date
    assert_equal "Tom Preston-Werner", c.committer.name
    assert_equal "tom@mojombo.com", c.committer.email
    assert_equal Time.at(1191999972), c.committed_date
    assert_equal "implement Grit#heads", c.message

    c = commits[1]
    assert_equal [], c.parents

    c = commits[2]
    assert_equal ["6e64c55896aabb9a7d8e9f8f296f426d21a78c2c", "7f874954efb9ba35210445be456c74e037ba6af2"], c.parents.map { |p| p.id }
    assert_equal "Merge branch 'site'\n\n  * Some other stuff\n  * just one more", c.message
    assert_equal "Merge branch 'site'", c.short_message
  end

  def test_commit_batch
    commits = @r.batch('4c8124ffcf4039d292442eeccabdeca5af5c5017',
      '634396b2f541a9f2d58b00be1a07f0c358b999b3')
    assert_equal "4c8124ffcf4039d292442eeccabdeca5af5c5017", commits[0].id
    assert_equal "634396b2f541a9f2d58b00be1a07f0c358b999b3", commits[1].id
    assert_equal "tom@mojombo.com", commits[0].author.email
    assert_equal "tom@mojombo.com", commits[1].author.email
  end

  def test_commit_batch_with_non_commit_objects
    commits = @r.batch(
      '4c8124ffcf4039d292442eeccabdeca5af5c5017',
      '608b0482499341bd2fe32002192936f7241a8569', # this is a blob SHA1
      '634396b2f541a9f2d58b00be1a07f0c358b999b3'
    )
    assert_equal 3, commits.size
    assert_nil commits[1]
    assert_equal "4c8124ffcf4039d292442eeccabdeca5af5c5017", commits[0].id
    assert_equal "634396b2f541a9f2d58b00be1a07f0c358b999b3", commits[2].id
    assert_equal "tom@mojombo.com", commits[0].author.email
    assert_equal "tom@mojombo.com", commits[2].author.email
  end

  # generate enough input to overflow the max pipe input buffer. this will cause
  # the git child process hang if stdin is not written at the same time as stdout
  # is being read.
  #
  # The pipe buffer is 32K on Mac, 64K on Linux 2.6.
  def test_large_commit_batch
    fail if jruby?
    n = 1000 # 41K of input
    commits = @r.batch(['4c8124ffcf4039d292442eeccabdeca5af5c5017'] * n)
    assert_equal n, commits.size
  end

  # commit_count

  def test_commit_count
    Git.any_instance.expects(:rev_list).with({}, 'master').returns(fixture('rev_list_count'))

    assert_equal 655, @r.commit_count('master')
  end

  # commit

  def test_commit
    commit = @r.commit('634396b2f541a9f2d58b00be1a07f0c358b999b3')

    assert_equal "634396b2f541a9f2d58b00be1a07f0c358b999b3", commit.id
  end

  # tree

  def test_tree
    Git.any_instance.expects(:ls_tree).returns(fixture('ls_tree_a'))
    tree = @r.tree('master')

    assert_equal 4, tree.contents.select { |c| c.instance_of?(Blob) }.size
    assert_equal 3, tree.contents.select { |c| c.instance_of?(Tree) }.size
  end

  # blob

  def test_blob
    Git.any_instance.expects(:cat_file).returns(fixture('cat_file_blob'))
    blob = @r.blob("abc")
    assert_equal "Hello world", blob.data
  end

  # init

  def test_init
    FileUtils.stubs(:mkdir_p)

    Git.any_instance.expects(:init).with({:base = false}, "/foo/bar").returns(true)
    Repo.expects(:new).with("/foo/bar", {})
    Repo.init("/foo/bar")
  end

  # init_bare

  def test_init_bare
    FileUtils.stubs(:mkdir_p)

    Git.any_instance.expects(:init).with(:bare = true).returns(true).twice
    Repo.expects(:new).with("/foo/bar.git", {:is_bare = true})
    Repo.init_bare("/foo/bar.git")

    Repo.expects(:new).with("/foo/bar", {:is_bare = true})
    Repo.init_bare("/foo/bar")
  end

  def test_init_bare_with_options
    FileUtils.stubs(:mkdir_p)

    Git.any_instance.expects(:init).with(
      :bare = true, :template = "/baz/sweet").returns(true)
    Repo.expects(:new).with("/foo/bar.git", {:is_bare = true})
    Repo.init_bare("/foo/bar.git", :template = "/baz/sweet")
  end

  # fork_bare

  def test_fork_bare
    FileUtils.stubs(:mkdir_p)

    Git.any_instance.expects(:clone).with(
      {:bare = true, :shared = true},
      "#{absolute_project_path}/.git",
      "/foo/bar.git").returns(nil)
    Repo.expects(:new)

    @r.fork_bare("/foo/bar.git")
  end

  def test_fork_bare_with_options
    FileUtils.stubs(:mkdir_p)

    Git.any_instance.expects(:clone).with(
      {:bare = true, :shared = true, :template = '/awesome'},
      "#{absolute_project_path}/.git",
      "/foo/bar.git").returns(nil)
    Repo.expects(:new)

    @r.fork_bare("/foo/bar.git", :template = '/awesome')
  end

  # diff

  def test_diff
    Git.any_instance.expects(:diff).with({}, 'master^', 'master', '--')
    @r.diff('master^', 'master')

    Git.any_instance.expects(:diff).with({}, 'master^', 'master', '--', 'foo/bar')
    @r.diff('master^', 'master', 'foo/bar')

    Git.any_instance.expects(:diff).with({}, 'master^', 'master', '--', 'foo/bar', 'foo/baz')
    @r.diff('master^', 'master', 'foo/bar', 'foo/baz')
  end

  def test_diff2
    Git.any_instance.expects(:native).with('diff', {}, 'a', 'b', '--').returns(fixture('diff_p'))
    diffs = @r.diff('a', 'b')

    assert_equal 15, diffs.size
  end

  # commit_diff

  def test_diff
    Git.any_instance.expects(:diff).returns(fixture('diff_p'))
    diffs = @r.commit_diff('master')

    assert_equal 15, diffs.size
  end

  # init bare

  # archive

  def test_archive_tar
    #@r.archive_tar  -- no assertion being done here
  end

  # archive_tar_gz

  def test_archive_tar_gz
    #@r.archive_tar_gz -- again, no assertion
  end

  # enable_daemon_serve

  def test_enable_daemon_serve
    f = stub
    f.expects("write").with('')
    File.expects(:open).with(File.join(@r.path, 'git-daemon-export-ok'), 'w').yields(f)
    @r.enable_daemon_serve
  end

  # disable_daemon_serve

  def test_disable_daemon_serve
    FileUtils.expects(:rm_rf).with(File.join(@r.path, 'git-daemon-export-ok'))
    @r.disable_daemon_serve
  end

  def test_gc_auto
    Git.any_instance.expects(:gc).with({:auto = true})
    @r.gc_auto
  end

  # alternates

  def test_alternates_with_two_alternates
    File.expects(:read).with("#{absolute_project_path}/.git/objects/info/alternates").returns("/path/to/repo1/.git/objects\n/path/to/repo2.git/objects\n")

    assert_equal ["/path/to/repo1/.git/objects", "/path/to/repo2.git/objects"], @r.alternates
  end

  def test_alternates_no_file
    File.expects(:read).raises(Errno::ENOENT)

    assert_equal [], @r.alternates
  end

  # alternates=

  def test_alternates_setter_ok
    alts = %w{/path/to/repo.git/objects /path/to/repo2.git/objects}

    alts.each do |alt|
      File.expects(:exist?).with(alt).returns(true)
    end

    File.any_instance.expects(:write).with(alts.join("\n"))

    assert_nothing_raised do
      @r.alternates = alts
    end
  end

  def test_alternates_setter_bad
    alts = %w{/path/to/repo.git/objects}

    alts.each do |alt|
      File.expects(:exist?).with(alt).returns(false)
    end

    File.any_instance.expects(:write).never

    assert_raise RuntimeError do
      @r.alternates = alts
    end
  end

  def test_alternates_setter_empty
    File.any_instance.expects(:write)
    @r.alternates = []
  end

  # inspect

  def test_inspect
    assert_equal %Q{#Grit::Repo "#{File.expand_path(GRIT_REPO)}/.git"}, @r.inspect
  end

  # log

  def test_log
    Git.any_instance.expects(:log).times(2).with({:pretty = 'raw'}, 'master').returns(fixture('rev_list'))

    assert_equal '4c8124ffcf4039d292442eeccabdeca5af5c5017', @r.log.first.id
    assert_equal 'ab25fd8483882c3bda8a458ad2965d2248654335', @r.log.last.id
  end

  def test_log_with_path_and_options
    Git.any_instance.expects(:log).with({:pretty = 'raw', :max_count = 1}, 'master', '--', 'file.rb').returns(fixture('rev_list'))
    @r.log('master', 'file.rb', :max_count = 1)
  end

  # commit_deltas_from

  def test_commit_deltas_from_nothing_new
    other_repo = Repo.new(GRIT_REPO)
    @r.git.expects(:rev_list).with({}, "master").returns(fixture("rev_list_delta_b"))
    other_repo.git.expects(:rev_list).with({}, "master").returns(fixture("rev_list_delta_a"))

    delta_blobs = @r.commit_deltas_from(other_repo)
    assert_equal 0, delta_blobs.size
  end

  def test_commit_deltas_from_when_other_has_new
    other_repo = Repo.new(GRIT_REPO)
    @r.git.expects(:rev_list).with({}, "master").returns(fixture("rev_list_delta_a"))
    other_repo.git.expects(:rev_list).with({}, "master").returns(fixture("rev_list_delta_b"))
    %w[
      4c8124ffcf4039d292442eeccabdeca5af5c5017
      634396b2f541a9f2d58b00be1a07f0c358b999b3
      ab25fd8483882c3bda8a458ad2965d2248654335
    ].each do |ref|
      Commit.expects(:find_all).with(other_repo, ref, :max_count = 1).returns([stub()])
    end
    delta_blobs = @r.commit_deltas_from(other_repo)
    assert_equal 3, delta_blobs.size
  end

  # object_exist

  def test_select_existing_objects
    before = ['634396b2f541a9f2d58b00be1a07f0c358b999b3', 'deadbeef']
    after = ['634396b2f541a9f2d58b00be1a07f0c358b999b3']
    assert_equal after, @r.git.select_existing_objects(before)
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_rgit_spaces.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'
require 'tempfile'

class TestGritSpaces  Test::Unit::TestCase

  def setup
    @repo = Repo.new(File.join(File.dirname(__FILE__), *%w[dot_git_spaces]), :is_bare = true)
  end

  def test_log_with_path_no_leading_space
    log = @repo.log('master', 'a file')
    assert_equal 1, log.size
    assert_equal "7f09709727b53fdf3c6c6a6ae653515c4e1a3ef2", log.first.to_s
  end

  def test_log_with_path_leading_space
    log = @repo.log('master', ' an evil file with a leading space')
    assert_equal 1, log.size
    assert_equal "2edb031f77340b65a897e8536ad75f7b7596a607", log.first.to_s
  end

  def test_log_with_path_trailing_space
    log = @repo.log('master', 'an evil file with a trailing space ')
    assert_equal 1, log.size
    assert_equal "2edb031f77340b65a897e8536ad75f7b7596a607", log.first.to_s
  end


  def test_log_with_path_no_leading_space_in_a_branch
    log = @repo.log('branch_one', 'simple_file')
    assert_equal 1, log.size
    assert_equal "8f4094b31327dd0223979adc288e2b12ca86b0a1", log.first.to_s
  end

  def test_log_with_path_leading_space_in_a_branch
    log = @repo.log('branch_one', ' a leading space file in a branch')
    assert_equal 1, log.size
    assert_equal "36a4f6bc8c5e4e67534b98c996f4e91ffff73ea5", log.first.to_s
  end

  def test_tree_with_leading_space
    tree = @repo.tree()
    names = tree.blobs.collect { |b| b.name }
    assert names.include?(" an evil file with a leading space"), "does not contain the leading space named file"
  end

  def test_tree_with_trailing_space
    tree = @repo.tree()
    names = tree.blobs.collect { |b| b.name }
    assert names.include?("an evil file with a trailing space "), "does not contain the trailing space named file"
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_rubygit.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'
require 'tempfile'

class TestRubyGit  Test::Unit::TestCase

  def setup
    @git = Git.new(File.join(File.dirname(__FILE__), *%w[dot_git]))
    @commit_sha = '5e3ee1198672257164ce3fe31dea3e40848e68d5'
    @tree_sha = 'cd7422af5a2e0fff3e94d6fb1a8fff03b2841881'
    @blob_sha = '4232d073306f01cf0b895864e5a5cfad7dd76fce'
  end

  def test_init_gitdir
    tf = Tempfile.new('gitdir')
    temppath = tf.path
    tf.unlink

    git = Git.new(temppath)
    git.init({})
    assert File.exists?(File.join(temppath, 'config'))
  end

  def test_log_merge
    c1 = '420eac97a826bfac8724b6b0eef35c20922124b7'
    c2 = '30e367cef2203eba2b341dc9050993b06fd1e108'
    out = @git.rev_list({:pretty = 'raw', :max_count = 10}, 'master')
    assert_match "commit #{c1}", out
    assert_match "commit #{c2}", out
  end

  def test_log_max_count
    out = @git.rev_list({:max_count = 10}, 'master')
    assert_equal 10, out.split("\n").size
  end

  def test_diff
    commit1 = '2d3acf90f35989df8f262dc50beadc4ee3ae1560'
    commit2 = '420eac97a826bfac8724b6b0eef35c20922124b7'
    out = @git.diff({}, commit1, commit2)
    assert_match 'index 6afcf64..9e78ddf 100644', out
  end

  def test_diff_single
    commit1 = '2d3acf90f35989df8f262dc50beadc4ee3ae1560'
    out = @git.diff({}, commit1, nil)
    assert_match 'index ad42ff5..aa50f09 100644', out
  end

  def test_diff_full
    commit1 = '2d3acf90f35989df8f262dc50beadc4ee3ae1560'
    commit2 = '420eac97a826bfac8724b6b0eef35c20922124b7'
    out = @git.diff({:full_index = true}, commit1, commit2)
    assert_match 'index 6afcf64c80da8253fa47228eb09bc0eea217e5d1..9e78ddfaabf79f8314cc9a53a2f59775aee06bd7', out
  end

  def test_diff_add
    commit1 = 'c9cf68fc61bd2634e90a4f6a12d88744e6297c4e'
    commit2 = '7a8d32cb18a0ba2ff8bf86cadacc3fd2816da219'
    out = @git.diff({}, commit1, commit2)
    assert_match "--- /dev/null\n+++ b/test/test_tag.rb", out
    assert_match "diff --git a/test/test_tag.rb b/test/test_tag.rb", out
    assert_match 'index 0000000..2e3b0cb', out
  end

  def test_diff_remove
    commit1 = 'c9cf68fc61bd2634e90a4f6a12d88744e6297c4e'
    commit2 = '7a8d32cb18a0ba2ff8bf86cadacc3fd2816da219'
    out = @git.diff({}, commit1, commit2)
    assert_match "--- a/test/fixtures/diff_2\n+++ /dev/null", out
    assert_match "diff --git a/test/fixtures/diff_2 b/test/fixtures/diff_2", out
    assert_match 'index 0000000..2e3b0cb', out
  end


  def test_cat_file_contents_commit
    out = @git.cat_file({:p = true}, @commit_sha)
    assert_equal out, fixture('cat_file_commit_ruby')
  end

  def test_cat_file_contents_tree
    out = @git.cat_file({:p = true}, @tree_sha)
    assert_equal out, fixture('cat_file_tree_ruby').chomp
  end

  def test_cat_file_contents_blob
    out = @git.cat_file({:p = true}, @blob_sha)
    assert_equal out, fixture('cat_file_blob_ruby')
  end

  def test_cat_file_size
    out = @git.cat_file({:s = true}, @tree_sha)
    assert_equal '252', out
  end

  def test_ls_tree
    out = @git.ls_tree({}, @tree_sha)
    assert_equal out, fixture('cat_file_tree_ruby').chomp
  end

  def test_ls_tree_with_blobs
    out = @git.ls_tree({}, @blob_sha)
    assert_equal out, nil
  end

  def test_ls_tree_treeish
    out = @git.ls_tree({}, 'testing')
    assert_equal out, fixture('cat_file_tree_ruby').chomp
  end

  def test_ls_tree_paths
    paths = ['History.txt', 'lib']
    out = @git.ls_tree({}, @tree_sha, paths)
    assert_equal out, fixture('ls_tree_paths_ruby').chomp
  end

  def test_ls_tree_paths_multi_single
    paths = ['lib/grit.rb']
    out = @git.ls_tree({}, @tree_sha, paths)
    assert_equal out, "100644 blob 6afcf64c80da8253fa47228eb09bc0eea217e5d1\tlib/grit.rb"
  end

  def test_ls_tree_recursive
    # this is the tree associated with @commit_sha, which we use in
    # the next test
    tree_sha = '77fc9894c0904279fde93adc9c0ba231515ce68a'

    out = @git.ls_tree({:r = true}, tree_sha)
    assert_equal out, fixture('ls_tree_recursive')
  end

  def test_ls_tree_recursive_with_a_commit
    out = @git.ls_tree({:r = true}, @commit_sha)
    assert_equal out, fixture('ls_tree_recursive')
  end

  def test_rev_list_pretty
    out = @git.rev_list({:pretty = 'raw'}, 'master')
    assert_equal out, fixture('rev_list_all')
  end

  def test_rev_list_raw_since
    out = @git.rev_list({:since = Time.at(1204644738)}, 'master')
    assert_match fixture('rev_list_since'), out  # I return slightly more for now
  end

  def test_rev_list_pretty_raw
    out = @git.rev_list({:pretty = 'raw'}, 'f1964ad1919180dd1d9eae9d21a1a1f68ac60e77')
    assert_match 'f1964ad1919180dd1d9eae9d21a1a1f68ac60e77', out
    assert_equal out.split("\n").size, 654
  end

  def test_rev_list
    out = @git.rev_list({}, 'master')
    assert_equal out, fixture('rev_list_lines')
  end

  def test_rev_list_range
    range = '30e367cef2203eba2b341dc9050993b06fd1e108..3fa4e130fa18c92e3030d4accb5d3e0cadd40157'
    out = @git.rev_list({}, range)
    assert_equal fixture('rev_list_range'), out
  end

  def test_ls_tree_paths_multi
    paths = ['History.txt', 'lib/grit.rb']
    out = @git.ls_tree({}, @tree_sha, paths)
    assert_equal out, fixture('ls_tree_paths_ruby_deep').chomp
  end

  def test_ls_tree_path
    paths = ['lib/']
    out = @git.ls_tree({}, @tree_sha, paths)
    assert_equal out, "100644 blob 6afcf64c80da8253fa47228eb09bc0eea217e5d1\tlib/grit.rb\n040000 tree 6244414d0229fb2bd58bc426a2afb5ba66773498\tlib/grit"
  end

  def test_ls_tree_path_deep
    paths = ['lib/grit/']
    out = @git.ls_tree({}, @tree_sha, paths)
    assert_equal out, fixture('ls_tree_subdir').chomp
  end

  def test_file_type
    out = @git.file_type(@tree_sha).to_s
    assert_equal 'tree', out
    out = @git.file_type(@blob_sha).to_s
    assert_equal 'blob', out
    out = @git.file_type(@commit_sha).to_s
    assert_equal 'commit', out
  end

  #def test_ls_tree_noexist
  #  puts out = @git.ls_tree({}, '6afcf64c80da8253fa47228eb09bc0eea217e5d0')
  #end


=begin
  def test_ls_tree_grit_tree
    paths = ['lib/grit.rb']
    @repo = Grit::Repo.new('~/projects/github')
    paths = ['app/models/event.rb']
    puts out = @repo.git.ls_tree({}, 'master', ['app/models/event.rb'])
    puts out = @repo.tree('master', paths).contents
    assert_equal out, '100644 blob 6afcf64c80da8253fa47228eb09bc0eea217e5d1 lib/grit.rb'
  end
=end

end
</content>
		</actual_file>
		<actual_file>
			<filename>test_rubygit_alt.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'
require 'pp'

class TestRubyGitAlt  Test::Unit::TestCase

  def setup
    @git1 = Grit::Repo.new(File.join(File.dirname(__FILE__), *%w[dot_git]), :is_bare = true)
    @git2 = Grit::Repo.new(File.join(File.dirname(__FILE__), *%w[dot_git_clone]), :is_bare = true)
    @git3 = Grit::Repo.new(File.join(File.dirname(__FILE__), *%w[dot_git_clone2]), :is_bare = true)
    @commit_sha = 'ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a'
    @tree_sha = 'cd7422af5a2e0fff3e94d6fb1a8fff03b2841881'
    @blob_sha = '4232d073306f01cf0b895864e5a5cfad7dd76fce'
  end

  def test_basic
    sha_hex = [@commit_sha].pack("H*")
    assert @git1.git.ruby_git.in_loose?(sha_hex)
    assert @git2.git.ruby_git.in_loose?(sha_hex)
    assert @git1.git.ruby_git.object_exists?(@commit_sha)
    assert @git2.git.ruby_git.object_exists?(@commit_sha)
    assert_equal 10, @git1.commits.size
    assert_equal 10, @git2.commits.size
  end

  def test_clone_of_clone
    sha_hex = [@commit_sha].pack("H*")
    assert @git2.git.ruby_git.in_loose?(sha_hex)
    assert @git3.git.ruby_git.in_loose?(sha_hex)
    assert @git2.git.ruby_git.object_exists?(@commit_sha)
    assert @git3.git.ruby_git.object_exists?(@commit_sha)
    assert_equal 10, @git2.commits.size
    assert_equal 10, @git3.commits.size
  end

  def test_tree_path
    file = @git2.tree('master', ['test/test_head.rb']).contents.first.name
    assert_equal file, 'test/test_head.rb'
  end

end</content>
		</actual_file>
		<actual_file>
			<filename>test_rubygit_index.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'
require 'pp'

class TestRubyGitIndex  Test::Unit::TestCase

  def setup
    @base_repo = create_temp_repo(File.join(File.dirname(__FILE__), *%w[dot_git_iv2]))
    @git = Grit::Repo.new(@base_repo, :is_bare = true)
    @rgit = @git.git.ruby_git
    @user = Actor.from_string("Tom Werner tom@example.com")
  end

  def teardown
    FileUtils.rm_r(@base_repo)
  end

  def create_temp_repo(clone_path)
    filename = 'git_test' + Time.now.to_i.to_s + rand(300).to_s.rjust(3, '0')
    tmp_path = File.join("/tmp/", filename)
    FileUtils.mkdir_p(tmp_path)
    FileUtils.cp_r(clone_path, tmp_path)
    File.join(tmp_path, 'dot_git_iv2')
  end

  def test_set_default_committed_date
    parents = [@git.commits.first]
    sha     = @git.index.commit('message', parents, @user, nil, 'master')
    commit  = @git.commit(sha)
    now     = Time.now
    assert_equal now.year,  commit.committed_date.year
    assert_equal now.month, commit.committed_date.month
    assert_equal now.day,   commit.committed_date.day
  end

  def test_set_actor
    parents = [@git.commits.first]
    sha     = @git.index.commit('message', parents, @user)

    commit  = @git.commit(sha)
    assert_equal @user.name, commit.committer.name
    assert_equal @user.name, commit.author.name
  end

  def test_allow_custom_committed_and_authored_dates
    parents = [@git.commits.first]
    sha     = @git.index.commit 'message', 
                :committed_date = Time.local(2000),
                :authored_date  = Time.local(2001),
                :parents        = parents, 
                :actor          = @user, 
                :head           = 'master'

    commit  = @git.commit(sha)
    now     = Time.now
    assert_equal 2000,  commit.committed_date.year
    assert_equal 2001,  commit.authored_date.year
  end

  def test_allow_custom_committers_and_authors
    parents = [@git.commits.first]
    sha     = @git.index.commit 'message', 
                :committer = Grit::Actor.new('abc', nil),
                :author    = Grit::Actor.new('def', nil),
                :parents   = parents, 
                :head      = 'master'

    commit  = @git.commit(sha)
    assert_equal parents.map { |c| c.sha }, commit.parents.map { |c| c.sha }
    assert_equal 'abc', commit.committer.name
    assert_equal 'def', commit.author.name
  end

  def test_add_files
    sha = @git.commits.first.tree.id

    i = @git.index
    i.read_tree(sha)
    i.add('atester.rb', 'test stuff')
    i.commit('message', [@git.commits.first], @user, nil, 'master')

    b = @git.commits.first.tree/'atester.rb'
    assert_equal 'f80c3b68482d5e1c8d24c9b8139340f0d0a928d0', b.id
  end

  def test_add_path_file
    sha = @git.commits.first.tree.id

    i = @git.index
    i.read_tree(sha)
    i.add('lib/atester.rb', 'test stuff')
    i.commit('message', [@git.commits.first], @user, nil, 'master')

    b = @git.commits.first.tree/'lib'/'atester.rb'
    assert_equal 'f80c3b68482d5e1c8d24c9b8139340f0d0a928d0', b.id
    b = @git.commits.first.tree/'lib'/'grit.rb'
    assert_equal '77aa887449c28a922a660b2bb749e4127f7664e5', b.id
  end

  def test_ordered_properly
    sha = @git.commits.first.tree.id

    i = @git.index
    i.read_tree(sha)
    i.add('lib.rb', 'test stuff')
    i.commit('message', [@git.commits.first], @user, nil, 'master')

    tr = @git.commits.first.tree.contents
    entries = tr.select { |c| c.name[0, 3] == 'lib' }.map { |c| c.name }
    assert_equal 'lib.rb', entries[0]
    assert_equal 'lib', entries[1]
  end

  def test_modify_file
    sha = @git.commits.first.tree.id

    i = @git.index
    i.read_tree(sha)
    i.add('README.txt', 'test more stuff')
    i.commit('message', [@git.commits.first], @user, nil, 'master')

    b = @git.commits.first.tree/'README.txt'
    assert_equal 'e45d6b418e34951ddaa3e78e4fc4d3d92a46d3d1', b.id
  end
end</content>
		</actual_file>
		<actual_file>
			<filename>test_rubygit_iv2.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'
require 'pp'

class TestRubyGitIv2  Test::Unit::TestCase

  def setup
    @git = Grit::Repo.new(File.join(File.dirname(__FILE__), *%w[dot_git_iv2]), :is_bare = true)
    @rgit = @git.git.ruby_git
    @commit_sha = 'ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a'
    @tree_sha   = 'cd7422af5a2e0fff3e94d6fb1a8fff03b2841881'
    @blob_sha   = '4232d073306f01cf0b895864e5a5cfad7dd76fce'
  end

  def test_basic
    assert @rgit.object_exists?(@commit_sha)
    assert_equal 10, @git.commits.size
  end

  def test_objects
    commit = @rgit.get_object_by_sha1(@commit_sha)
    assert_equal commit.author.email, 'schacon@gmail.com'
    tree = @rgit.get_object_by_sha1(@tree_sha)
    assert_equal 7, tree.entry.size
    blob = @rgit.get_object_by_sha1(@blob_sha)
    assert_match 'First public release', blob.content
  end

end</content>
		</actual_file>
		<actual_file>
			<filename>test_submodule.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestSubmodule  Test::Unit::TestCase
  def setup
    @r = Repo.new(GRIT_REPO)
    @s = Submodule.allocate
  end

  # config

  def test_config
    data = fixture('gitmodules')
    blob = stub(:data = data, :id = 'abc')
    tree = stub(:'/' = blob)
    commit = stub(:tree = tree)
    repo = stub(:commit = commit)

    config = Submodule.config(repo)

    assert_equal "git://github.com/mojombo/glowstick", config['test/glowstick']['url']
    assert_equal "git://github.com/mojombo/god", config['god']['url']
  end

  def test_config_with_windows_lineendings
    data = fixture('gitmodules').gsub(/\n/, "\r\n")
    blob = stub(:data = data, :id = 'abc')
    tree = stub(:'/' = blob)
    commit = stub(:tree = tree)
    repo = stub(:commit = commit)

    config = Submodule.config(repo)

    assert_equal "git://github.com/mojombo/glowstick", config['test/glowstick']['url']
    assert_equal "git://github.com/mojombo/god", config['god']['url']
  end

  def test_no_config
    tree = stub(:'/' = nil)
    commit = stub(:tree = tree)
    repo = stub(:commit = commit)

    config = Submodule.config(repo)

    assert_equal({}, config)
  end

  def test_empty_config
    blob = stub(:data = '', :id = 'abc')
    tree = stub(:'/' = blob)
    commit = stub(:tree = tree)
    repo = stub(:commit = commit)

    config = Submodule.config(repo)

    assert_equal({}, config)
  end

  # inspect

  def test_inspect
    @t = Submodule.create(@r, :id = 'abc')
    assert_equal %Q{#Grit::Submodule "abc"}, @t.inspect
  end

  def test_basename
    @submodule = Submodule.create(@r, :name = 'foo/bar')
    assert_equal "bar", @submodule.basename
  end
end</content>
		</actual_file>
		<actual_file>
			<filename>test_tag.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestTag  Test::Unit::TestCase
  def setup
    @r = Repo.new(File.join(File.dirname(__FILE__), *%w[dot_git]), :is_bare = true)
    @tags = {}
    @r.tags.each {|t| @tags[t.name] = t}
  end

  # list_from_string size

  def test_list_from_string_size
    assert_equal 5, @r.tags.size
  end

  # list_from_string

  def test_list_from_string
    tag = @tags['not_annotated']

    assert_equal 'not_annotated', tag.name
    assert_equal 'ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a', tag.commit.id
  end

  # list_from_string_for_signed_tag

  def test_list_from_string_for_signed_tag
    tag = @tags['v0.7.0']

    assert_equal 'v0.7.0', tag.name
    assert_equal '7bcc0ee821cdd133d8a53e8e7173a334fef448aa', tag.commit.id
  end

  # list_from_string_for_annotated_tag

  def test_list_from_string_for_annotated_tag
    tag = @tags['annotated']

    assert_equal 'annotated', tag.name
    assert_equal 'ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a', tag.commit.id
  end

  # list_from_string_for_packed_tag

  def test_list_from_string_for_packed_tag
    tag = @tags['packed']

    assert_equal 'packed', tag.name
    assert_equal 'ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a', tag.commit.id
  end

  # list_from_string_for_packed_annotated_tag

  def test_list_from_string_for_packed_annotated_tag
    tag = @tags['packed_annotated']

    assert_equal 'packed_annotated', tag.name
    assert_equal '7bcc0ee821cdd133d8a53e8e7173a334fef448aa', tag.commit.id
  end

  # describe_recent_tag

  def test_describe_recent_tag
    assert_equal 'annotated', @r.recent_tag_name
  end

  # describe_recent_tag_with_updates

  def test_describe_recent_tag_with_updates
    assert_equal 'v0.7.0-62-g3fa4e13', @r.recent_tag_name('3fa4e130fa18c92e3030d4accb5d3e0cadd40157')
  end

  # describe_missing_tag

  def test_describe_missing_Tag
    assert_nil @r.recent_tag_name('boom')
  end

  # reads_light_tag_contents

  def test_reads_light_tag_contents
    tag = @tags['not_annotated']
    assert_equal 'not_annotated', tag.name
    assert_equal 'added a pure-ruby git library and converted the cat_file commands to use it',
      tag.message
    assert_equal 'Scott Chacon',      tag.tagger.name
    assert_equal 'schacon@gmail.com', tag.tagger.email
    assert_equal Time.utc(2008, 4, 18, 23, 27, 8), tag.tag_date.utc
  end

  # reads_annotated_tag_contents

  def test_reads_annotated_tag_contents
    tag = @tags['annotated']
    assert_equal 'annotated',       tag.name
    assert_equal 'Annotated tag.',  tag.message
    assert_equal 'Chris Wanstrath', tag.tagger.name
    assert_equal 'chris@ozmm.org',  tag.tagger.email
    assert_equal Time.utc(2009, 2, 13, 22, 22, 16), tag.tag_date.utc
  end

  def test_parses_tag_object_without_message
    parsed = Grit::Tag.parse_tag_data(-TAG)
object 2695effb5807a22ff3d138d593fd856244e155e7
type commit
tag rel-0-1-0
tagger bob bob
Thu Jan 1 00:00:00 1970 +0000
TAG
    assert_equal 'bob',          parsed[:tagger].name
    assert_equal Time.utc(1970), parsed[:tag_date]
    assert_equal '',             parsed[:message]
  end

  # reads_annotated_and_packed_tag_contents

  def test_reads_annotated_and_packed_tag_contents
    tag = @tags['packed_annotated']
    assert_equal 'packed_annotated',   tag.name
    assert_equal 'v0.7.0',             tag.message
    assert_equal 'Tom Preston-Werner', tag.tagger.name
    assert_equal 'tom@mojombo.com',    tag.tagger.email
    assert_equal Time.utc(2008, 1, 8, 5, 32, 29), tag.tag_date.utc
  end

  # inspect

  def test_inspect
    tag = @tags['v0.7.0']

    assert_equal %Q{#Grit::Tag "#{tag.name}"}, tag.inspect
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_tree.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestTree  Test::Unit::TestCase
  def setup
    @r = Repo.new(GRIT_REPO)
    @t = Tree.allocate
  end

  # contents
  def test_nosuch_tree
    t = @r.tree('blahblah')
    assert t.contents.is_a?(Array)
    assert t.is_a?(Tree)
  end

  def test_contents_should_cache
    Git.any_instance.expects(:ls_tree).returns(
      fixture('ls_tree_a'),
      fixture('ls_tree_b')
    ).times(2)
    tree = @r.tree('master')

    child = tree.contents.last

    child.contents
    child.contents
  end

  # content_from_string

  def test_content_from_string_tree_should_return_tree
    text = fixture('ls_tree_a').split("\n").last

    tree = @t.content_from_string(nil, text)

    assert_equal Tree, tree.class
    assert_equal "650fa3f0c17f1edb4ae53d8dcca4ac59d86e6c44", tree.id
    assert_equal "040000", tree.mode
    assert_equal "test", tree.name
  end

  def test_content_from_string_tree_should_return_blob
    text = fixture('ls_tree_b').split("\n").first

    tree = @t.content_from_string(nil, text)

    assert_equal Blob, tree.class
    assert_equal "aa94e396335d2957ca92606f909e53e7beaf3fbb", tree.id
    assert_equal "100644", tree.mode
    assert_equal "grit.rb", tree.name
  end

  def test_content_from_string_tree_should_return_submodule
    text = fixture('ls_tree_submodule').split("\n").first

    sm = @t.content_from_string(nil, text)

    assert_kind_of Submodule, sm
  end

  def test_content_from_string_invalid_type_should_raise
    assert_raise(Grit::InvalidObjectType) do
      @t.content_from_string(nil, "040000 bogus 650fa3f0c17f1edb4ae53d8dcca4ac59d86e6c44	test")
    end
  end

  # /

  def test_slash
    Git.any_instance.expects(:ls_tree).returns(
      fixture('ls_tree_a')
    )
    tree = @r.tree('master')

    assert_equal 'aa06ba24b4e3f463b3c4a85469d0fb9e5b421cf8', (tree/'lib').id
    assert_equal '8b1e02c0fb554eed2ce2ef737a68bb369d7527df', (tree/'README.txt').id
  end

  def test_slash_with_commits
    Git.any_instance.expects(:ls_tree).returns(
      fixture('ls_tree_commit')
    )
    tree = @r.tree('master')

    assert_equal 'd35b34c6e931b9da8f6941007a92c9c9a9b0141a', (tree/'bar').id
    assert_equal '2afb47bcedf21663580d5e6d2f406f08f3f65f19', (tree/'foo').id
    assert_equal 'f623ee576a09ca491c4a27e48c0dfe04be5f4a2e', (tree/'baz').id
  end

  # inspect

  def test_inspect
    @t = Tree.create(@r, :id = 'abc')
    assert_equal %Q{#Grit::Tree "abc"}, @t.inspect
  end

  def test_basename
    @t = Tree.create(@r, :name = 'foo/bar')
    assert_equal "bar", @t.basename
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>benchmarks.rb</filename>
			<content>require 'fileutils'
require 'benchmark'
require 'rubygems'
require 'ruby-prof'
require 'memcache'
require 'pp'

gem 'grit', '=0.7.0' 
#require '../../lib/grit'

def main
  @wbare = File.expand_path(File.join('../../', 'test', 'dot_git'))
  
  in_temp_dir do
    #result = RubyProf.profile do

      git = Grit::Repo.new('.')
      puts Grit::VERSION
      #Grit::GitRuby.cache_client = MemCache.new 'localhost:11211', :namespace = 'grit'
      #Grit.debug = true
    
      #pp Grit::GitRuby.cache_client.stats 
    
      commit1 = '5e3ee1198672257164ce3fe31dea3e40848e68d5'
      commit2 = 'ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a'
    
      Benchmark.bm(8) do |x|
            
        run_code(x, 'packobj') do
          @commit = git.commit('5e3ee1198672257164ce3fe31dea3e40848e68d5')
          @tree = git.tree('cd7422af5a2e0fff3e94d6fb1a8fff03b2841881')
          @blob = git.blob('4232d073306f01cf0b895864e5a5cfad7dd76fce')
          @commit.parents[0].parents[0].parents[0]
        end

        run_code(x, 'commits 1') do
          git.commits.size
        end
              
        run_code(x, 'commits 2') do
          log = git.commits('master', 15)
          log.size
          log.size
          log.first
          git.commits('testing').map { |c| c.message }
        end

        run_code(x, 'big revlist') do
          c = git.commits('master', 200)
        end

        run_code(x, 'log') do
          log = git.log('master')
          log.size
          log.size
          log.first
        end

        run_code(x, 'diff') do
          c = git.diff(commit1, commit2)
        end

        run_code(x, 'commit-diff') do
          c = git.commit_diff(commit1)
        end

        run_code(x, 'heads') do
          c = git.heads.collect { |b| b.commit.id }
        end

       # run_code(x, 'config', 100) do
       #   c = git.config['user.name']
       #   c = git.config['user.email']
       # end

        #run_code(x, 'commit count') do
        #  c = git.commit_count('testing')
        #end


      end
    #end

    #printer = RubyProf::FlatPrinter.new(result)
    #printer.print(STDOUT, 0)
    
  end


end


def run_code(x, name, times = 30)
    x.report(name.ljust(12)) do
      for i in 1..times do
        yield i
      end
    end
  
  #end
  
  # Print a graph profile to text
end

def new_file(name, contents)
  File.open(name, 'w') do |f|
    f.puts contents
  end
end


def in_temp_dir(remove_after = true)
  filename = 'git_test' + Time.now.to_i.to_s + rand(300).to_s.rjust(3, '0')
  tmp_path = File.join("/tmp/", filename)
  FileUtils.mkdir(tmp_path)
  Dir.chdir tmp_path do
    FileUtils.cp_r(@wbare, File.join(tmp_path, '.git'))
    yield tmp_path
  end
  puts tmp_path
  #FileUtils.rm_r(tmp_path) if remove_after
end

main()

##pp Grit::GitRuby.cache_client.stats 
</content>
		</actual_file>
		<actual_file>
			<filename>benchmarks.txt</filename>
			<content>Grit : 
              user     system      total        real
packobj       0.030000   0.260000   1.320000 (  1.344565)
commits 1     0.030000   0.070000   0.380000 (  0.366209)
commits 2     0.110000   0.160000   0.830000 (  0.802311)
big revlist   0.330000   0.130000   0.830000 (  0.795258)
log           0.380000   0.140000   0.880000 (  0.856951)
diff          0.330000   0.190000   2.080000 (  2.072242)
commit-diff   0.690000   0.250000   1.560000 (  1.521016)
heads         0.000000   0.070000   0.360000 (  0.376296)


Grit (with GitRuby) : 

              user     system      total        real
packobj       0.050000   0.000000   0.050000 (  0.051167)
commits 1     0.140000   0.010000   0.150000 (  0.164900)
commits 2     0.430000   0.030000   0.460000 (  0.454646)
big revlist   1.540000   0.100000   1.640000 (  1.637204)
log           0.480000   0.030000   0.510000 (  0.512445)
diff          0.200000   0.190000   1.970000 (  1.905014)
commit-diff   0.550000   0.240000   1.420000 (  1.366508)
heads         0.020000   0.090000   0.410000 (  0.402519)
</content>
		</actual_file>
		<actual_file>
			<filename>COMMIT_EDITMSG</filename>
			<content>added a pure-ruby git library and converted the cat_file commands to use it
# Please enter the commit message for your changes.
# (Comment lines starting with '#' will not be included)
# On branch master
# Changes to be committed:
#   (use "git reset HEAD file..." to unstage)
#
#	new file:   PURE_TODO
#	modified:   lib/grit.rb
#	new file:   lib/grit/git-ruby.rb
#	new file:   lib/grit/git-ruby/internal/loose.rb
#	new file:   lib/grit/git-ruby/internal/mmap.rb
#	new file:   lib/grit/git-ruby/internal/pack.rb
#	new file:   lib/grit/git-ruby/internal/raw_object.rb
#	new file:   lib/grit/git-ruby/object.rb
#	new file:   lib/grit/git-ruby/repository.rb
#	modified:   lib/grit/git.rb
#	new file:   test/fixtures/cat_file_blob_ruby
#	new file:   test/fixtures/cat_file_commit_ruby
#	new file:   test/fixtures/cat_file_tree_ruby
#	new file:   test/test_rubygit.rb
#
</content>
		</actual_file>
		<actual_file>
			<filename>config</filename>
			<content>[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
[remote "origin"]
	url = git@github.com:schacon/grit.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch "master"]
	remote = origin
	merge = refs/heads/master
</content>
		</actual_file>
		<actual_file>
			<filename>description</filename>
			<content>Unnamed repository; edit this file to name it for gitweb.
</content>
		</actual_file>
		<actual_file>
			<filename>FETCH_HEAD</filename>
			<content>2d3acf90f35989df8f262dc50beadc4ee3ae1560		branch 'master' of git://github.com/mojombo/grit
</content>
		</actual_file>
		<actual_file>
			<filename>file-index</filename>
			<content>634396b2f541a9f2d58b00be1a07f0c358b999b3 initial grit setup
History.txt
Manifest.txt
README.txt
Rakefile
bin/grit
lib/grit.rb
lib/grit/errors.rb
lib/grit/grit.rb
test/helper.rb
test/test_grit.rb
4c8124ffcf4039d292442eeccabdeca5af5c5017 634396b2f541a9f2d58b00be1a07f0c358b999b3 implement Grit#heads
lib/grit.rb
lib/grit/grit.rb
lib/grit/head.rb
test/test_grit.rb
06f63b43050935962f84fe54473a7c5de7977325 4c8124ffcf4039d292442eeccabdeca5af5c5017 stub git call for Grit#heads test
lib/grit/grit.rb
test/helper.rb
test/test_grit.rb
5057e76a11abd02e83b7d3d3171c4b68d9c88480 06f63b43050935962f84fe54473a7c5de7977325 clean up heads test
test/test_grit.rb
a47fd41f3aa4610ea527dcc1669dfdb9c15c5425 5057e76a11abd02e83b7d3d3171c4b68d9c88480 add more comments throughout
lib/grit.rb
lib/grit/commit.rb
lib/grit/grit.rb
d01a4cfad6ea50285c4710243e3cbe019d381eba a47fd41f3aa4610ea527dcc1669dfdb9c15c5425 convert to Grit module, refactor to be more OO
lib/grit.rb
lib/grit/commit.rb
lib/grit/errors.rb
lib/grit/git.rb
lib/grit/grit.rb
lib/grit/head.rb
lib/grit/repo.rb
test/helper.rb
test/suite.rb
test/test_git.rb
test/test_grit.rb
test/test_repo.rb
d837bd432d63b740b62d964dda48818bd97e778b d01a4cfad6ea50285c4710243e3cbe019d381eba implement Repo#branches
lib/grit/repo.rb
test/test_repo.rb
2c6af5a45ddf8b539e8481d7bf9dff4bc71dde78 d837bd432d63b740b62d964dda48818bd97e778b implement Repo.commits
Rakefile
lib/grit/commit.rb
lib/grit/git.rb
lib/grit/repo.rb
test/fixtures/for_each_ref
test/fixtures/rev_list
test/helper.rb
test/test_commit.rb
test/test_git.rb
test/test_repo.rb
a911921efe39c4f6fdce8571c1828eaf45d5551e 2c6af5a45ddf8b539e8481d7bf9dff4bc71dde78 move heads logic into Head
lib/grit/head.rb
lib/grit/repo.rb
404b7a0dea6406545f9969232049ff8119d3ac6f a911921efe39c4f6fdce8571c1828eaf45d5551e handle multiline commit messages
lib/grit/commit.rb
lib/grit/repo.rb
test/test_repo.rb
de8ecf488033fb75504bf5179608f90d750f8759 404b7a0dea6406545f9969232049ff8119d3ac6f more commits tests
test/fixtures/rev_list
test/test_repo.rb
8bfefdbc0d901a6e8ccd27b9f20879d109f49c03 de8ecf488033fb75504bf5179608f90d750f8759 implement Repo#commit and begin on Repo#tree
lib/grit/repo.rb
test/test_repo.rb
6ffe534098dacefb3633efafff01eb0296f26725 8bfefdbc0d901a6e8ccd27b9f20879d109f49c03 branches is alias of heads
lib/grit/commit.rb
lib/grit/repo.rb
test/test_commit.rb
test/test_repo.rb
3b1930208a82457747d76729ae088e90edca4673 6ffe534098dacefb3633efafff01eb0296f26725 big refactor to do lazy loading
lib/grit.rb
lib/grit/commit.rb
lib/grit/git.rb
lib/grit/head.rb
lib/grit/lazy.rb
lib/grit/repo.rb
test/fixtures/for_each_ref
test/test_git.rb
test/test_repo.rb
4aa0e11f540c42a32ba24988966e9b1efbba6de3 3b1930208a82457747d76729ae088e90edca4673 add comments and make Comment.parents return Commits
lib/grit/commit.rb
test/test_repo.rb
917522c4572a6237897e9a554cde21b8c6292dd3 4aa0e11f540c42a32ba24988966e9b1efbba6de3 more code comments throughout
lib/grit/commit.rb
lib/grit/git.rb
lib/grit/head.rb
lib/grit/repo.rb
b17b974691f0a26f26908495d24d9c4c718920f8 917522c4572a6237897e9a554cde21b8c6292dd3 started implementing Tree
lib/grit.rb
lib/grit/repo.rb
lib/grit/tree.rb
test/test_repo.rb
2ac1712b56771dd2ca6420eb5319765c1827e13e b17b974691f0a26f26908495d24d9c4c718920f8 add lazy computation of tree contents
lib/grit/tree.rb
test/fixtures/ls_tree_a
test/profile.rb
test/test_reality.rb
test/test_tree.rb
74fd66519e983a0f29e16a342a6059dbffe36020 2ac1712b56771dd2ca6420eb5319765c1827e13e add Blob
lib/grit.rb
lib/grit/blob.rb
lib/grit/git.rb
lib/grit/tree.rb
test/fixtures/ls_tree_b
test/test_reality.rb
test/test_repo.rb
test/test_tree.rb
c12f398c2f3c4068ca5e01d736b1c9ae994b2138 74fd66519e983a0f29e16a342a6059dbffe36020 add inspects to objects
lib/grit/blob.rb
lib/grit/commit.rb
lib/grit/head.rb
lib/grit/tree.rb
fc128af28cb263bf1f524f84609a7a75ffa27a9b c12f398c2f3c4068ca5e01d736b1c9ae994b2138 commit now returns Tree object for tree attribute
lib/grit/commit.rb
lib/grit/tree.rb
test/test_repo.rb
34a87f9a723cc51b6b74e0fe095c9046a826ef3b fc128af28cb263bf1f524f84609a7a75ffa27a9b implement Blob.data and Blob.size
.gitignore
lib/grit/blob.rb
lib/grit/git.rb
test/fixtures/cat_file_blob
test/fixtures/cat_file_blob_size
test/fixtures/rev_list_single
test/test_blob.rb
test/test_commit.rb
test/test_head.rb
test/test_repo.rb
test/test_tree.rb
ebdf4716e38c810b06b6e1fbc2ce3a6da2821f7a 34a87f9a723cc51b6b74e0fe095c9046a826ef3b add Repo.blob
Rakefile
lib/grit/repo.rb
lib/grit/tree.rb
test/test_repo.rb
b6e1b765e0c15586a2c5b9832854f95defd71e1f ebdf4716e38c810b06b6e1fbc2ce3a6da2821f7a implement Repo.init_bare
lib/grit.rb
lib/grit/blob.rb
lib/grit/git.rb
lib/grit/head.rb
lib/grit/repo.rb
test/test_blob.rb
test/test_repo.rb
01a1b4f1cbf0f4d9c13618a3ca9c9f429c8dd0e8 b6e1b765e0c15586a2c5b9832854f95defd71e1f implement Blob.blame
lib/grit/blob.rb
lib/grit/commit.rb
lib/grit/lazy.rb
test/fixtures/blame
test/test_blob.rb
1fddfabeaa0b62cb4becdb44980ec6cfa48ebd87 01a1b4f1cbf0f4d9c13618a3ca9c9f429c8dd0e8 clear info hash in Blob.blame and update the doc
lib/grit/blob.rb
4ea50f4754937bf19461af58ce3b3d24c77311d9 1fddfabeaa0b62cb4becdb44980ec6cfa48ebd87 better errors for Repo.new
lib/grit/errors.rb
lib/grit/repo.rb
test/test_repo.rb
40d3057d09a7a4d61059bca9dca5ae698de58cbe 4ea50f4754937bf19461af58ce3b3d24c77311d9 add Tree./ to ease getting subtrees
lib/grit/repo.rb
lib/grit/tree.rb
test/test_tree.rb
038af8c329ef7c1bae4568b98bd5c58510465493 40d3057d09a7a4d61059bca9dca5ae698de58cbe implement repo level diff
lib/grit/repo.rb
test/test_repo.rb
91169e1f5fa4de2eaea3f176461f5dc784796769 038af8c329ef7c1bae4568b98bd5c58510465493 fix some initialization warnings
lib/grit/commit.rb
lib/grit/lazy.rb
lib/grit/tree.rb
test/test_blob.rb
test/test_git.rb
e80bbd2ce67651aa18e57fb0b43618ad4baf7750 91169e1f5fa4de2eaea3f176461f5dc784796769 add Actor class to encapsulate name and email
lib/grit.rb
lib/grit/actor.rb
lib/grit/blob.rb
lib/grit/commit.rb
test/test_actor.rb
test/test_blob.rb
test/test_commit.rb
test/test_repo.rb
ec037431382e83c3e95d4f2b3d145afbac8ea55d e80bbd2ce67651aa18e57fb0b43618ad4baf7750 add Actor inspect
lib/grit/actor.rb
test/test_actor.rb
f1ec1aea10986159456846b8a05615b87828d6c6 ec037431382e83c3e95d4f2b3d145afbac8ea55d begin readme
README.txt
b5d4f15a4dd41646405f11fb107aa8efb16c98a4 f1ec1aea10986159456846b8a05615b87828d6c6 more readme
README.txt
8c7f4e1d8cb66590825701b758160e3721003dde b5d4f15a4dd41646405f11fb107aa8efb16c98a4 dynamically rewrite ruby style git options
lib/grit/git.rb
test/test_git.rb
337539e896b8c85cc043a923c8fbb927f58e6450 8c7f4e1d8cb66590825701b758160e3721003dde prepare for packaging as gem
.gitignore
Manifest.txt
Rakefile
lib/grit.rb
5f141d9c0181b8732c0ec2fab4967f0ffa24fa3f 337539e896b8c85cc043a923c8fbb927f58e6450 git-log support
lib/grit/repo.rb
test/test_repo.rb
02617bd0f7cae462e71be075c99385f709279533 5f141d9c0181b8732c0ec2fab4967f0ffa24fa3f add Actor#to_s as alias to Actor#name
lib/grit/actor.rb
test/test_actor.rb
46291865ba0f6e0c9818b11be799fe2db6964d56 02617bd0f7cae462e71be075c99385f709279533 implement commit diff
lib/grit.rb
lib/grit/commit.rb
lib/grit/diff.rb
lib/grit/repo.rb
test/fixtures/diff_p
test/test_commit.rb
test/test_repo.rb
44f82e5ac93ba322161019dce44b78c5bd1fdce2 46291865ba0f6e0c9818b11be799fe2db6964d56 fix commit-diff deleted file bug
lib/grit/diff.rb
test/test_commit.rb
1d22e6fde59c9ded9b8093cf26213a5bd9d4c5ec 44f82e5ac93ba322161019dce44b78c5bd1fdce2 add #diffs to commit object
lib/grit/commit.rb
test/test_commit.rb
4c596908ce1136e8c32174ba13892c6fe68a010d 1d22e6fde59c9ded9b8093cf26213a5bd9d4c5ec rework lazy some to be more of a delegator
lib/grit.rb
lib/grit/commit.rb
lib/grit/lazy.rb
lib/grit/tree.rb
80f136f500dfdb8c3e8abf4ae716f875f0a1b57f 44f82e5ac93ba322161019dce44b78c5bd1fdce2 fix tests on other machines
README.txt
test/test_git.rb
test/test_reality.rb
test/test_repo.rb
b86b48e3520a106739035b149dbed97445152868 80f136f500dfdb8c3e8abf4ae716f875f0a1b57f abbreviated sha1 and archiving
lib/grit/commit.rb
lib/grit/repo.rb
test/fixtures/rev_parse
test/test_commit.rb
test/test_repo.rb
62e423d6d27b3c5016072c94e72bee1be37aea6d 1d22e6fde59c9ded9b8093cf26213a5bd9d4c5ec b86b48e3520a106739035b149dbed97445152868 Merge branch 'mojombo'
3e0955045cb189a7112015c26132152a94f637bf b86b48e3520a106739035b149dbed97445152868 add Commit#mime_type
lib/grit.rb
lib/grit/blob.rb
test/test_blob.rb
db64b1265cb572d3b97cde164312194b83449ef2 62e423d6d27b3c5016072c94e72bee1be37aea6d 3e0955045cb189a7112015c26132152a94f637bf Merge branch 'mojombo'
7bcc0ee821cdd133d8a53e8e7173a334fef448aa 3e0955045cb189a7112015c26132152a94f637bf prepare for public release
History.txt
Manifest.txt
bin/grit
lib/grit.rb
6c38e553796a965fe62397350c537d0a795c9fd6 7bcc0ee821cdd133d8a53e8e7173a334fef448aa rake site
.gitignore
Rakefile
fe3bf3660ac64d86f2855ac3185eb5953ea2c3bd 6c38e553796a965fe62397350c537d0a795c9fd6 add Repo#commits_between
lib/grit/repo.rb
e631529f2525180e49b7b90fd0198d90d8106de0 fe3bf3660ac64d86f2855ac3185eb5953ea2c3bd add fork_bare
lib/grit/git.rb
lib/grit/repo.rb
fb49d370b21ed9214677d812dcde243cfeaf2303 e631529f2525180e49b7b90fd0198d90d8106de0 62e423d6d27b3c5016072c94e72bee1be37aea6d Merge branch 'master' of git://github.com/defunkt/grit into defunkt2
18e19dbbe8b7e152f762af65799bb19429e0d349 fb49d370b21ed9214677d812dcde243cfeaf2303 add options to fork_bare
lib/grit/repo.rb
test/test_repo.rb
275a2b7c7aeadbd03fae865a5f67900a7ee1bfc6 18e19dbbe8b7e152f762af65799bb19429e0d349 update readme with github location
README.txt
8f24479836ada10f08846678a59d79609ce3d14f 275a2b7c7aeadbd03fae865a5f67900a7ee1bfc6 add options to Repo.init_bare
lib/grit/repo.rb
test/test_repo.rb
02879cf62c803fd706dc45ab85dbc2e7efe5acc1 8f24479836ada10f08846678a59d79609ce3d14f add enable/disable daemon serve
lib/grit.rb
lib/grit/repo.rb
test/test_repo.rb
3c413f1d3879a80ee3cbd8c7cd8033f7f04afa68 db64b1265cb572d3b97cde164312194b83449ef2 02879cf62c803fd706dc45ab85dbc2e7efe5acc1 Merge branch 'mojombo'
c45fa0feea864d535f77d39caa735820aa720caa 3c413f1d3879a80ee3cbd8c7cd8033f7f04afa68 display the first commit of a repo without dying
lib/grit/commit.rb
test/fixtures/diff_i
test/test_commit.rb
6f6cb7cd4ab707c2273dd97113d9891da7a11885 02879cf62c803fd706dc45ab85dbc2e7efe5acc1 add commits_since
lib/grit/commit.rb
lib/grit/repo.rb
301edd42ff7a55dffb86446349b33d6d4198d192 6f6cb7cd4ab707c2273dd97113d9891da7a11885 quote all git parameters
lib/grit/git.rb
lib/grit/head.rb
lib/grit/repo.rb
lib/grit/tree.rb
test/test_git.rb
test/test_real.rb
4ceb8e966103ba1c0cf442f90b476367b0302347 c45fa0feea864d535f77d39caa735820aa720caa 301edd42ff7a55dffb86446349b33d6d4198d192 Merge branch 'mojombo'
3ed8c6eb935326c8de850dae4be5e2493a2a8c2e 301edd42ff7a55dffb86446349b33d6d4198d192 fix quoting problem for Repo#log
lib/grit/git.rb
lib/grit/repo.rb
test/test_repo.rb
7235ace853d766d2c4a39d5e505c05497b1b7fb7 3ed8c6eb935326c8de850dae4be5e2493a2a8c2e add Repo#commit_count
lib/grit/commit.rb
lib/grit/repo.rb
test/fixtures/rev_list_count
test/test_repo.rb
13d27d5cea4d0d787163dd97f8ee63d200d2a663 7235ace853d766d2c4a39d5e505c05497b1b7fb7 c45fa0feea864d535f77d39caa735820aa720caa Merge branch 'master' of git://github.com/defunkt/grit into d3
59ddc32609925a9fb7e3b2e2cee04b7afd204d00 13d27d5cea4d0d787163dd97f8ee63d200d2a663 deal with empty initial commit
lib/grit/commit.rb
test/fixtures/show_empty_commit
test/test_commit.rb
460b3216db32a55d07b1de0570bbb8427611b599 59ddc32609925a9fb7e3b2e2cee04b7afd204d00 fix bug in diff caused by new mode
lib/grit/diff.rb
test/fixtures/diff_new_mode
test/test_diff.rb
80238dccfb24b5dee8f6d6c99fc8d272486e0946 460b3216db32a55d07b1de0570bbb8427611b599 wip
lib/grit/repo.rb
lib/grit/tag.rb
7a8d32cb18a0ba2ff8bf86cadacc3fd2816da219 80238dccfb24b5dee8f6d6c99fc8d272486e0946 add tag support
lib/grit.rb
lib/grit/head.rb
lib/grit/repo.rb
lib/grit/tag.rb
test/fixtures/for_each_ref_tags
test/test_tag.rb
c9cf68fc61bd2634e90a4f6a12d88744e6297c4e 460b3216db32a55d07b1de0570bbb8427611b599 allow Grit::Commit.diff to specify an optional array of paths
lib/grit/commit.rb
test/fixtures/diff_2
test/fixtures/diff_2f
test/fixtures/diff_f
test/test_commit.rb
f32458940ef496d61946d4e3d63bc5edd1ae0af7 c9cf68fc61bd2634e90a4f6a12d88744e6297c4e add to Commit::Diff tests so we know the right filename is parsed
test/test_commit.rb
c6d10852bf3cca44f17c0e3f3abb721c6fe7ec27 7a8d32cb18a0ba2ff8bf86cadacc3fd2816da219 add alternates getter and setter
lib/grit/repo.rb
test/test_repo.rb
e8e7b385fd00a7e9609cf2f270d021f19f08f17f c6d10852bf3cca44f17c0e3f3abb721c6fe7ec27 better alternates behavior
lib/grit/repo.rb
test/test_repo.rb
3ea514188523ae9e8ecd603f760442f147042d6c f32458940ef496d61946d4e3d63bc5edd1ae0af7 add alternates getter and setter
lib/grit/repo.rb
test/test_repo.rb
125c3f885f9041a48b2828cd1c707dbaff78a825 3ea514188523ae9e8ecd603f760442f147042d6c better alternates behavior
lib/grit/repo.rb
test/test_repo.rb
182a706d083de61af95c3dba0d59dd3f91fe31b2 125c3f885f9041a48b2828cd1c707dbaff78a825 compact Commit contents from Trees so that #/(path_to_commit) doesn't raise a NoMethodError on NilClass#name.
lib/grit/tree.rb
test/fixtures/ls_tree_commit
test/test_tree.rb
e8ea908dd932eb21856495db140e27efb014bf3e e8e7b385fd00a7e9609cf2f270d021f19f08f17f Update tests to not use fixed absolute paths
test/helper.rb
test/test_repo.rb
3c230a377740b6beb679a6b57a1e2b7e9940d321 e8ea908dd932eb21856495db140e27efb014bf3e 182a706d083de61af95c3dba0d59dd3f91fe31b2 merge from technoweenie
242253bdce7ae94d34b2af702e3618eea8ed9754 3c230a377740b6beb679a6b57a1e2b7e9940d321 fix diffs for mode only changes
lib/grit/diff.rb
test/fixtures/diff_mode_only
test/test_commit.rb
991ac754cafa7c87ccf25d77225154d16d4f4be6 4ceb8e966103ba1c0cf442f90b476367b0302347 242253bdce7ae94d34b2af702e3618eea8ed9754 Merge branch 'mojombo'
4f0ea0c7c8985c48c94269886ba93c0ea73636cc 991ac754cafa7c87ccf25d77225154d16d4f4be6 4c596908ce1136e8c32174ba13892c6fe68a010d Merge branch 'lazy_delegator'
ff3f41fe66bd482281347314ed1cd1cb4b853c38 242253bdce7ae94d34b2af702e3618eea8ed9754 get full message from commits as well
lib/grit/commit.rb
test/test_repo.rb
f6b346156dd19a9fe46004a3efce4fc8d66addf9 ff3f41fe66bd482281347314ed1cd1cb4b853c38 repsect blank lines in commit messages
lib/grit/commit.rb
test/fixtures/rev_list
test/test_repo.rb
55737f3f9128b02bf3519f5f70b6118234454c65 f6b346156dd19a9fe46004a3efce4fc8d66addf9 do not strip leading spaces from commit messages
lib/grit/commit.rb
test/fixtures/rev_list
test/test_repo.rb
472e4f3d6f54514c560487ce6bde30405a84ffa7 55737f3f9128b02bf3519f5f70b6118234454c65 Tiny fix to add mime-types as a dependency in Hoe's extra_deps
Rakefile
179f919876a255a8e09d32a95c8209d66c7ed660 55737f3f9128b02bf3519f5f70b6118234454c65 enable --all for Commit.find_all
lib/grit/commit.rb
lib/grit/repo.rb
ca78e948410d39b690a76a7c613b83b70de64eeb 179f919876a255a8e09d32a95c8209d66c7ed660 allow letters in git version test
test/test_git.rb
4aa3410e2d458b00b0f41920ffc2aa21f019d13d ca78e948410d39b690a76a7c613b83b70de64eeb don't crash when diffing and last pair only contains file mode changes
lib/grit/diff.rb
test/fixtures/diff_new_mode
test/test_diff.rb
f1964ad1919180dd1d9eae9d21a1a1f68ac60e77 179f919876a255a8e09d32a95c8209d66c7ed660 Add support for accessing repository configuration values
lib/grit.rb
lib/grit/config.rb
lib/grit/repo.rb
test/fixtures/simple_config
test/test_config.rb
3dc4f654a697467692478f502817dfc3e0248378 f1964ad1919180dd1d9eae9d21a1a1f68ac60e77 Don't add .git to "bare" repositories as it is unnecessary.
lib/grit/repo.rb
test/test_repo.rb
ccc8ba203bfb6b6051bfa083f73969f680ced61a 3dc4f654a697467692478f502817dfc3e0248378 Add write support to the git configuration
lib/grit/config.rb
test/test_config.rb
a55a698345a3f27a981ada27c7486d89e374bc21 4f0ea0c7c8985c48c94269886ba93c0ea73636cc add in Commit#to_hash method
lib/grit/commit.rb
test/test_commit.rb
78617eaee2ca3b88cd9bb5361d29a99b5555a3d2 a55a698345a3f27a981ada27c7486d89e374bc21 179f919876a255a8e09d32a95c8209d66c7ed660 Merge branch 'master' of git://github.com/mojombo/grit into mojombo/master
ad44b88d69c4b7b61a9ec12445f00f082ca19f41 78617eaee2ca3b88cd9bb5361d29a99b5555a3d2 Touch up Commit#to_hash
lib/grit/commit.rb
test/test_commit.rb
22825175e37f22c9418d756ca69b574d75602994 179f919876a255a8e09d32a95c8209d66c7ed660 do not screw up diffs that have files with spaces in them
.gitignore
lib/grit/diff.rb
be3178ec3bf47bbdc69bd6023443fb6c4ac5385c 22825175e37f22c9418d756ca69b574d75602994 472e4f3d6f54514c560487ce6bde30405a84ffa7 Merge branch 'master' of git://github.com/kamal/grit into kamal
28e7a1d3dd172a8e757ff777ab205a538b80385e be3178ec3bf47bbdc69bd6023443fb6c4ac5385c 4aa3410e2d458b00b0f41920ffc2aa21f019d13d Merge branch 'master' of git://github.com/evilchelu/grit into evilchelu
f11ceb37cbd72b8c7627aa9e2a7b8dbcbf10d107 28e7a1d3dd172a8e757ff777ab205a538b80385e ccc8ba203bfb6b6051bfa083f73969f680ced61a Merge branch 'master' of git://github.com/halorgium/grit into halorgium
11d191ef3f04012a78222cb118619c16d5581886 f11ceb37cbd72b8c7627aa9e2a7b8dbcbf10d107 ad44b88d69c4b7b61a9ec12445f00f082ca19f41 Merge branch 'defunkt' into local
d6016bc9fa3950ad18e3028f9d2d26f831061a62 11d191ef3f04012a78222cb118619c16d5581886 require time for xmlschema
lib/grit.rb
e1193f8092ae9ece0ba336b7aa4c29dcde78777f d6016bc9fa3950ad18e3028f9d2d26f831061a62 support for heads with slashes in them
lib/grit/head.rb
test/fixtures/for_each_ref
test/test_head.rb
5a0943123f6872e75a9b1dd0b6519dd42a186fda e1193f8092ae9ece0ba336b7aa4c29dcde78777f add timeout protection to grit
lib/grit.rb
lib/grit/git.rb
30e367cef2203eba2b341dc9050993b06fd1e108 5a0943123f6872e75a9b1dd0b6519dd42a186fda timeout code and tests
lib/grit/git.rb
test/test_git.rb
420eac97a826bfac8724b6b0eef35c20922124b7 d6016bc9fa3950ad18e3028f9d2d26f831061a62 Added a method for getting the current branch.
lib/grit/head.rb
lib/grit/repo.rb
5e3ee1198672257164ce3fe31dea3e40848e68d5 30e367cef2203eba2b341dc9050993b06fd1e108 420eac97a826bfac8724b6b0eef35c20922124b7 Merge branch 'master' of git://github.com/dustin/grit
2d3acf90f35989df8f262dc50beadc4ee3ae1560 5e3ee1198672257164ce3fe31dea3e40848e68d5 ignore errors from SIGCHLD on trap
lib/grit/git.rb
3fa4e130fa18c92e3030d4accb5d3e0cadd40157 2d3acf90f35989df8f262dc50beadc4ee3ae1560 added a git directory to the testing dir for current and future testing
test/dot_git/FETCH_HEAD
test/dot_git/HEAD
test/dot_git/ORIG_HEAD
test/dot_git/config
test/dot_git/description
test/dot_git/hooks/applypatch-msg
test/dot_git/hooks/commit-msg
test/dot_git/hooks/post-commit
test/dot_git/hooks/post-receive
test/dot_git/hooks/post-update
test/dot_git/hooks/pre-applypatch
test/dot_git/hooks/pre-commit
test/dot_git/hooks/pre-rebase
test/dot_git/hooks/prepare-commit-msg
test/dot_git/hooks/update
test/dot_git/index
test/dot_git/info/exclude
test/dot_git/logs/HEAD
test/dot_git/logs/refs/heads/master
test/dot_git/logs/refs/remotes/origin/master
test/dot_git/logs/refs/remotes/tom/master
test/dot_git/objects/00/03f8338f3668723f26b37c8ccf544a95e29ec6
test/dot_git/objects/00/1569f8fc3eb464ba486e4b22f2f06494f399e2
test/dot_git/objects/00/b71297a9d326f1c9647dc3199759696aa0fcd3
test/dot_git/objects/00/f3447967b64aba158140cd40ee8b367612ce81
test/dot_git/objects/01/0ad5aba678e910d4d663b42dcc23b42beb829f
test/dot_git/objects/02/1e14889189cd86cff25b5677e12ac2c7234e0b
test/dot_git/objects/02/3d5211ccff94a988645cdeb1738ef681053928
test/dot_git/objects/03/37a36c245dcafeb65eb8a77322bfa353447774
test/dot_git/objects/03/7f79a326dbcb10176d28f61998d72924ce77c8
test/dot_git/objects/04/c3a03b3f0d0a60b313f4be77749845a5235c08
test/dot_git/objects/05/7826b56de5733beb44b4561443d3b46a449691
test/dot_git/objects/05/7926e768e8b202655a3aa26adc7f201c0edcfc
test/dot_git/objects/05/7929610b4988ec16e3c45b8383bd158990b4a0
test/dot_git/objects/05/af9a86721dbfc9c26aa1e51ae2a69e3e659d4e
test/dot_git/objects/05/b059421d3747a7806ac17ae7fec58942f4febb
test/dot_git/objects/06/05c3b4232a3ce29e9eaa37c5b87798500a6e7d
test/dot_git/objects/06/2279d5eb12f88189544abbaed53853c5ed9515
test/dot_git/objects/06/e218ce2718fb29fe8c3406e20a03af92b2c211
test/dot_git/objects/08/31f152b831b72c29c402c43a4f0d5f9c08098b
test/dot_git/objects/09/509a4195f9fb7afbf688b03c80695bf42415aa
test/dot_git/objects/09/722f3e93f2ac8b7576ad9875570b9fcd9c7742
test/dot_git/objects/0a/8a50a991f45aacd9182cc9660352291102d62c
test/dot_git/objects/0b/7cad903e284fb0c67b4c5c2b7dce7bcb1ab331
test/dot_git/objects/0c/27bd8cee7c56836d7116224eeee572b14d9207
test/dot_git/objects/0c/93fbac2cae83e0c1ae53b95b1ad1e52049f9dc
test/dot_git/objects/0d/757583ecf0ce5235d41487d26bee258c317b3e
test/dot_git/objects/0f/341dd5b4a15b61545f8f8a22fdfcfa611b88ba
test/dot_git/objects/0f/41b030d38bc256c46da51ec61d8fbf78d95c71
test/dot_git/objects/0f/f24bd854839ec2d63df82511b30a87563cf93b
test/dot_git/objects/10/3b19041fdc3d56c2a233faeb835250f7979025
test/dot_git/objects/10/49a9f3dde7bb76587fe082462866b5d0dbd286
test/dot_git/objects/11/8273918e8e542d828b37fb58cb2ec0f557fb5f
test/dot_git/objects/11/af521eb0e6e9c112b3bb6c4ad7ec24986d3ca9
test/dot_git/objects/12/285f38fe70a726001e29108536954f64d7133a
test/dot_git/objects/12/c33c0bcf3ac3f569850943ad62c46c9861edeb
test/dot_git/objects/12/c7b3bf5cdc29830afecbe20755d6f08fe735a1
test/dot_git/objects/13/2335def2380870cd3b8f40d326976aea182aa7
test/dot_git/objects/13/d306ed324d1be706c78071a72414d50c68dca5
test/dot_git/objects/14/66fcacc4070eb9a8fd88b3a825c6647f6491f1
test/dot_git/objects/14/67cde22fefa7ddcab86786d5066bc6f51b250a
test/dot_git/objects/15/2111c53821f7dd53a3cc4f6a251a7de3789414
test/dot_git/objects/15/d022ad2ff13d0ef33424ff412676b6047ffed8
test/dot_git/objects/15/e293762a035e16b6d3f5562c51e8a524c84381
test/dot_git/objects/15/ebfa5c7792de35a107f413b397407ac3330888
test/dot_git/objects/16/48e3b1e22ebb852ded047d0ab7eac1b05fe060
test/dot_git/objects/16/81e1b6486f601c8edcaddcaba5b43cee4aea3f
test/dot_git/objects/16/910c6a1377054903ccb52369d3ee07b13e5d08
test/dot_git/objects/16/ff20f07ceb75dc60619c082f530ccd3379d572
test/dot_git/objects/17/ac818de1cc5ab1b1e1fc5f2796b0bb816a600c
test/dot_git/objects/17/d488c2f71729e5d182cb944d28c837fba95ccf
test/dot_git/objects/17/da04256d519b3bc102ff6654388a15ede87a9e
test/dot_git/objects/19/6583fa8a32069927196d341590917ec3a44068
test/dot_git/objects/19/f53b5d629ef910276aa4ff3da37098b84ebbe5
test/dot_git/objects/1a/d7f5703990fffc0623027f890c8da5a84b7f69
test/dot_git/objects/1b/4ac33eca9279c482cf15bfbdaeff285dd610b1
test/dot_git/objects/1b/6572ea59d924437ef351841ad7769189744070
test/dot_git/objects/1b/9fe079b5b81a05c585e71d7a3f435cf740ef98
test/dot_git/objects/1b/fb8784f878f9cd3cfeaca34357cf50a74f1e09
test/dot_git/objects/1c/6ab3410ae104091c7c48eb51fafeb10ceb840a
test/dot_git/objects/1d/52507d6a4b62353f17426395176114a78c3e27
test/dot_git/objects/1d/ad0ebe6a69a154ae53834551aac811e2084d92
test/dot_git/objects/1e/48c5e962aed49286c66caf359ec9c2d36c2702
test/dot_git/objects/1e/602e850a67f89c395797eac185740d5f26d4d2
test/dot_git/objects/1e/d9b70c5aeb93e24139fa7203d9a7455476c102
test/dot_git/objects/1e/eb71ddbc2be8fd6cc4fe8c8465361601d2e1a5
test/dot_git/objects/1f/cfb4f859faed6bf0384993f0fd5edf41f00ef5
test/dot_git/objects/20/527a9f7bff75c1fbddd9d99bb7e6da2558650a
test/dot_git/objects/20/58b040a09bd2a1fbaebb1e40aae595115a715e
test/dot_git/objects/21/0ce1bcc38e0e98f8ec8930a930dbd7988ac4b2
test/dot_git/objects/21/6092db5b7af3826eb8cab98f214b87338f2e85
test/dot_git/objects/22/0553c2c0869a33996016d0f01a16471c3cdfb4
test/dot_git/objects/22/fb8209d8655a24594398d47f339870f924804f
test/dot_git/objects/24/bc825eb69933d3c42e1a81c92cc9ebc6cc3472
test/dot_git/objects/27/9478dba188b07e2948b2f52ac865557065031e
test/dot_git/objects/27/b04aeb5b6042a2d90fb40d4293863841257640
test/dot_git/objects/28/08c797feeb40639304a503a395e8333daa0aaf
test/dot_git/objects/28/0ebe908f5b3306f56b95c2e6758abeed139e26
test/dot_git/objects/28/f509a6f26bcce60274974581e63d730236cf90
test/dot_git/objects/29/bb1b3a815aa0c6c6f41aaf4bca766d0bef1cdf
test/dot_git/objects/2a/525a828e4d0d02c01d14445b49c645771bb82a
test/dot_git/objects/2a/5c7305b52b836fbc0ec7200df58f3f9ba06ec0
test/dot_git/objects/2a/6d2a310fdaed46fb3a44901392e0bf4f05f8e7
test/dot_git/objects/2a/88c76b382e2e3c3e3587e0676301f9949d646d
test/dot_git/objects/2b/79e430dc370f0810552660b495e4ecdeca6aae
test/dot_git/objects/2c/97dd5ed8d14496cfc71e7ab12bedfec7c14f2e
test/dot_git/objects/2d/aea61e18b399977a0fc0b124c837e1d00934fa
test/dot_git/objects/2d/f7c5ddd50228c2d751df8b6aab96b37cdbc965
test/dot_git/objects/2e/e881239adb659aea65927a76daf526c0d83891
test/dot_git/objects/2f/91a713750e086ab1704e05177d4a8f0d88953b
test/dot_git/objects/30/2bc1a9a65d8c4ddf073a56d0fdacaff71d5500
test/dot_git/objects/30/a95debfc08077d566c9aa204f708104c716e1d
test/dot_git/objects/30/c859bedf72cb8dfb745bb17f705e4774d4f339
test/dot_git/objects/30/eaea1a7dbd755b4774f2e7b4663623398b09a3
test/dot_git/objects/31/5cd4d93bf65f8d00303515c7f31be1b888a349
test/dot_git/objects/31/98cb65f97c46156ad634d04141a3aec5a7f637
test/dot_git/objects/31/aaeceab051ff055f4b46b642f5891ac54e85ae
test/dot_git/objects/31/c867dca3a847692dc87bc4906194f13d183cae
test/dot_git/objects/32/d7a7f04ce188e48735ca805f27a2e399a1cffc
test/dot_git/objects/32/dec7871d83a6de85e5b96d06178ada1b4185c8
test/dot_git/objects/33/49c1bb38f1a3bff19ffdb83fe81373f0947531
test/dot_git/objects/33/a3d4c5d14917e67edec483f3222245be341fd1
test/dot_git/objects/33/b61981170deb261faec0ce907d8775dc9b0827
test/dot_git/objects/34/a29f36e9085784d1c22db7331c0d9ac4e90d99
test/dot_git/objects/35/82158a912c79ee8d48eba6196c3613b1e34e57
test/dot_git/objects/36/5e358e24b22ca327750961b28dbfba0330d53f
test/dot_git/objects/37/175959911a8e8032e07935cde93b873f2466f3
test/dot_git/objects/37/593280ce24318d5ff8eb1448ae06c83772afe4
test/dot_git/objects/37/7c4c6c44acbdfd450bdd0eba55845ee885be82
test/dot_git/objects/37/b6a48b7f3b475a48fe1cbe6c85e1e5c47caa32
test/dot_git/objects/38/5b7e7fbe895f4c9e866899c8a9dd413c687e3f
test/dot_git/objects/38/5f9658195f704e1f20ae167f23c3a91871dba2
test/dot_git/objects/38/d6fa611eb2c06126f711eb64f036ffa83331fe
test/dot_git/objects/3a/6030afdfb2890fd10a19d4fba1395d7b24f828
test/dot_git/objects/3b/494f98fb24ee05c63c63cfaafa730bd933f9ea
test/dot_git/objects/3b/5cc49cd62921d1abc9eaac373c29ea6fa604c9
test/dot_git/objects/3c/135209062a3ccd2032092ab2457eb3980b249f
test/dot_git/objects/3c/631958129f12cd496c2c918ff76c04e3aec471
test/dot_git/objects/3c/681414cda7c8200292d9c37baef74b8e55b25e
test/dot_git/objects/3d/6fb637c4c133a62712c2f5c5bc5d6c918b257b
test/dot_git/objects/3d/8cf6e46dbc2863435a7c0befa9f0f9b72f2b40
test/dot_git/objects/3e/4e5142403fdafa5daaf580ad2754bd5469f297
test/dot_git/objects/3e/8b951715d51b517615319e74f1ff5f143bdd33
test/dot_git/objects/3e/c671d1b0661dec389ec97ac49729be98a98363
test/dot_git/objects/3f/09b8a94def39594ff66018a0267e3a095f0166
test/dot_git/objects/3f/a8b0bb7b1158b3d75cb01a338c688465266ae8
test/dot_git/objects/3f/ab2e2576d21e160f65e0f037ef49932153b750
test/dot_git/objects/3f/ef1de16cfa99882a900d682c98bf4cdbb0bd1e
test/dot_git/objects/40/878bdc3b0b546884c23cc56e36bb01bca26360
test/dot_git/objects/42/8b046f3d44ee60a2707cd0ec870f214d52b51d
test/dot_git/objects/42/ea225300e8cf78bb8dee7867cd9b9dd62a2e42
test/dot_git/objects/44/c1bb76bef6677159624272045dbbd9e1be3de6
test/dot_git/objects/46/d3b63432ebd26da44b9b5f4463ecab8610003c
test/dot_git/objects/47/07d2feacccdc27e3ae08b6557313c66ad792cb
test/dot_git/objects/47/f94fe43e503475c4699b9bab535949d45786da
test/dot_git/objects/48/18f5a5bf96cc367861b358578bad5d14bc1ad9
test/dot_git/objects/49/9167ba61ed6a925dbf1d801a417fed31325e79
test/dot_git/objects/49/c183e5076a69d95cb3267d65b15f07e8ef3dd0
test/dot_git/objects/4a/4960fbcaa4f2b5f540c2417a0e6e3e13cd21e5
test/dot_git/objects/4c/5d14c6b35b4b9f9f8a10db253e3a61968fe0d5
test/dot_git/objects/4c/721af72f40368c4af46c04956fe6553505b03e
test/dot_git/objects/4c/765b6172fefd3aa2f2462f40b2c5614f855e33
test/dot_git/objects/4c/82aff6d42a4a658102f617678bfd9653e0a997
test/dot_git/objects/4c/c4d71390cf1c9fbe9543b5da0cb0506fc354da
test/dot_git/objects/4e/1ba5a8835b0208f7b4b8832a3ac1f11c5923ad
test/dot_git/objects/4e/749569e29fd394f47f679262bf138307352c19
test/dot_git/objects/4f/72728413e0e66b7281b979dce17eadc2fd8c60
test/dot_git/objects/4f/f1303d44eba1b583ea2a3b7765153ee1743e61
test/dot_git/objects/50/40f4c67674acda890725edcd0425d02093107c
test/dot_git/objects/51/48455670cac62caf07b4104b898982a2ee1d27
test/dot_git/objects/51/84bca98dfa4da277688eb0cf5d4c3c30049dbc
test/dot_git/objects/52/c074ceaeeae3ad8faba5eaa883b29d47e3753d
test/dot_git/objects/52/e6e4c8d61116b7306af1e3a83330e9b2f2b22e
test/dot_git/objects/52/ebe29d5aab2f2d13bff0300809349e47a93578
test/dot_git/objects/52/f056f557e9c34c1d410e38f28fb0ff3eb8cf8a
test/dot_git/objects/53/bed2e68961f68a0d28589ab78ac3cddea26870
test/dot_git/objects/53/e7f70cb60a4a2c42e0c16f9eac862d527ef2b5
test/dot_git/objects/55/4dd421736514dbff8ee54bcd0fdb14c6066ec5
test/dot_git/objects/56/3e1a6828c118fda28f11a33f9349bc15dd2607
test/dot_git/objects/56/cfafc365c69aa55f9558a59e6d909d2f6822d9
test/dot_git/objects/58/40f249cdfffd086dbad61feea0c3a8a4b3d109
test/dot_git/objects/58/628e6483b6cc5cc721f1ee6d398bd0c2a87312
test/dot_git/objects/59/96606c30d29c0bc97f67b18a0f255f87cc2da3
test/dot_git/objects/59/eb45a3f0a6b80dbbb7b99024e55227a4086eba
test/dot_git/objects/59/ee1a70e83c28f2d74843b91e39e557340e6172
test/dot_git/objects/59/ef600ad21001772c04e540918f28c00ea71b39
test/dot_git/objects/5b/2741fde089f266afca1adcfdc4eeb8dfe4a463
test/dot_git/objects/5b/9e2e35bffc027b09677112d4bd1b3af4d5c313
test/dot_git/objects/5b/c6f75b8462a5d6190fdd50f3e74cf9e1dfeed3
test/dot_git/objects/5b/fd1435a75583e9dd95536f2da3882f41604727
test/dot_git/objects/5d/84fe98507e47d78953bd0208ae063f06e52b1f
test/dot_git/objects/5e/329b884e07932517bf9909303f6017cb178a25
test/dot_git/objects/5e/79da1a7446822b46659edf25e9144816fa0454
test/dot_git/objects/5f/ec1ca382b811bf51abc319eb929cd7553842e8
test/dot_git/objects/60/390f7ddecc01fafb62b7d891f93ea23498acb8
test/dot_git/objects/63/142041870ce53f5ef4451b8cf021151e145054
test/dot_git/objects/63/2ff9f2fc143cb67362b8267d57ff969d91ce85
test/dot_git/objects/64/2b8924b35c87dd48f07bbdb6d0deb1ae5495dc
test/dot_git/objects/64/e717a84fb544375169f554be6b922aba692aa9
test/dot_git/objects/64/ec7cc059b0db49a529e51823891aef4d8bf338
test/dot_git/objects/66/1b95aeb34878aeacb70d74bf1c577b2cc461c3
test/dot_git/objects/66/7e57234226564739a618858668734a6b244876
test/dot_git/objects/66/99b0c4524bcdf045b66498ef281f863fc10628
test/dot_git/objects/66/e81f2947ee43f489386e4839edbc51bbaa3200
test/dot_git/objects/67/3f9b7a23a3fffe64f9ce4701914a110d70172b
test/dot_git/objects/67/9a2f922a0937fc209a3ae77bffcc9fda6c49d0
test/dot_git/objects/68/ad8c20d09837654709a9511a22d719631606d4
test/dot_git/objects/6a/0f0474e45585c06d7caac652d252483187d68e
test/dot_git/objects/6a/a4e1aa5e7dbd47c73b28ed8ca30bcab93b4638
test/dot_git/objects/6b/7b8ca7b28c4c62f8a25ccccb4d6ade9e46c2d7
test/dot_git/objects/6c/4b8c2fd3da22ef73e392683f926ae3b7494e57
test/dot_git/objects/6c/57ae690bc5271210392920898240c13f4e5634
test/dot_git/objects/6d/7b878255abaea31a1bd43cfacd89727a40b334
test/dot_git/objects/6e/af969270949b97cde160323221579ebf7d0ae6
test/dot_git/objects/6f/6906254fa5d16d54cd4511e79acc3ee79da96c
test/dot_git/objects/70/7d0fbd934e645980235d52112ce9ed8a8da14c
test/dot_git/objects/71/1cf6f726379a9c1a83eea1fae4ec3a10af28f1
test/dot_git/objects/72/944ef1b06abd709ae708d6be3426937f248a32
test/dot_git/objects/72/c02e7e07d2284fe144183529f9b5ca45027a99
test/dot_git/objects/73/1501ae418cdc7babb9a86f3cb869daf11c28e8
test/dot_git/objects/73/167b43c845d98eaa2040c701334f0c6f24a69c
test/dot_git/objects/73/5942ed3013eb862658960cf891e4c7de0f511e
test/dot_git/objects/74/e48401ad6085171109f933862cb87c98cf1132
test/dot_git/objects/76/940ef6ba3d8d1048e6059d48417279b74e057f
test/dot_git/objects/78/06987ac105edba10fe27c9a9f415dab7c0f9b8
test/dot_git/objects/78/3367a2b50a733782aec243f1e8760effd62769
test/dot_git/objects/78/591e22e8e9fd665bf9bf955ecd7601bc10efc5
test/dot_git/objects/78/99ce846a293ff465fd391e790a8c7e6d896cbf
test/dot_git/objects/79/0005c92fc8f75b3d194ae031bb89b041eecb04
test/dot_git/objects/79/0e7b517e808fb9ddbc67ac1e6b4c02bd4f302a
test/dot_git/objects/79/6a9d3b5c3ad98586fa0e68f91ddb9d317600ab
test/dot_git/objects/79/d5f65d307915105523c1267ee2457c853f6d76
test/dot_git/objects/7a/087349e9f350ece8e7fa7715da5e84927e9705
test/dot_git/objects/7a/5e762fa8f7fa3e2302f1ad4c0710b6910812c1
test/dot_git/objects/7a/e93eb82d94273605ea4ffa808223f3517751f1
test/dot_git/objects/7b/0eb3a3b0d48710afc0fb2f7b95cf949c17db45
test/dot_git/objects/7b/3c2f5c49cc882758b2dfebcda96f14bf04ba11
test/dot_git/objects/7b/95db1c259d8fca0aa9d641dfc85127b079c311
test/dot_git/objects/7d/bfba85b625779105f0d853f89522971346b3ef
test/dot_git/objects/7d/cfb401bdfd9817a0b3ca08ada41bf0c1080802
test/dot_git/objects/7e/3f8ceb97f84e983cbae9934eda025babbb393a
test/dot_git/objects/7e/4639a2cb181a6592f431d42db83cf640a563d1
test/dot_git/objects/7f/8c688c758239f302451b0bc10679e547003b5e
test/dot_git/objects/7f/d9cd76d00c54c434d003a49058592b6f0c10c1
test/dot_git/objects/7f/e607b5531e290bd50f1f70ea236d0306a882a9
test/dot_git/objects/82/def912edf146e3f30dd02ec78c07356aefdfa5
test/dot_git/objects/83/6dca6265fb655643b769aa1dd9d24de45713c4
test/dot_git/objects/83/b2a44866c05489569466edd0b64fd64c35f3bf
test/dot_git/objects/85/1c599e01cab929963ee07bb8911477da3817bd
test/dot_git/objects/85/4e76fadf16d5005f334dbaac7a951bf690c310
test/dot_git/objects/85/bb8a9e19a9a179bd9f5c2056588e6e25274288
test/dot_git/objects/85/e5fdbc2cefd10f0aa7042e092bd5f4c8c823d3
test/dot_git/objects/86/1b019631332e20abcedcd44efb78b4bc245797
test/dot_git/objects/88/a86c6983316e48805a13bbb54fa0f9c80248b2
test/dot_git/objects/89/353c81b260c81a3340ce0a1b92da0d94d8f6de
test/dot_git/objects/89/6cdba0f0e33856711cb64067e30256894fe40c
test/dot_git/objects/89/d0fc07bb62c543b73721d9eb8e76375317777c
test/dot_git/objects/8a/0d30f5ec46a905b14597f5f1a50526339313f1
test/dot_git/objects/8a/8a57d37adad012752dbba3c6e1063a374b66a6
test/dot_git/objects/8a/ac2492e118b62b049858e49286eda99b70424c
test/dot_git/objects/8b/8e7f353094009e7fc3b360ecc266081fa7e72d
test/dot_git/objects/8b/a8d47b778c172e3fa94f59d715d3ccfec9eab8
test/dot_git/objects/8b/ea8baddf15affc95414c402dfff718790816ee
test/dot_git/objects/8c/a7f29a74c0245e6d5ffe19047290e89c53c2e3
test/dot_git/objects/8c/b1801bab79dbed4c457f7c56a4243b19a572a1
test/dot_git/objects/8c/cc9b07c5a8c07bb3170758dcd76bfd26631f05
test/dot_git/objects/8d/e21b364f1831a676486d65deea2bfbe141962c
test/dot_git/objects/8d/fad1edfb99419586b830f19f9e96ce9d241c49
test/dot_git/objects/8f/1becb8995005a7e1b22260e5d6d674249f094c
test/dot_git/objects/8f/1d9f4bc14deac99f49eddae61ef2c3db7ab5c4
test/dot_git/objects/8f/67e2313d82205d121e809ba1095930ded3e3c7
test/dot_git/objects/8f/a525c77fec13ec6c2178840912c6c37b8c3cce
test/dot_git/objects/92/1f3eccb5f75c6b81f9044aedd151dd391eef10
test/dot_git/objects/92/ffbe0beb74ed54fe13db418914b436f8b155b8
test/dot_git/objects/93/a8d9a44e349e3b8eb1138d58aed8574dd1e5eb
test/dot_git/objects/94/2831545ab1b5a6c47998d5204e8fa4a13af252
test/dot_git/objects/95/c29e184a0ec7c5fa0a2d4ecd105f17bec6218b
test/dot_git/objects/95/efe1bd08e0b7b1469b4773c14dc728d5068b7e
test/dot_git/objects/97/71f107d373b028c2b73e2e169218951f772028
test/dot_git/objects/97/bc5e8c3cff57c5ad09ee02a39e90a0de08109d
test/dot_git/objects/97/ec7d3e32843a7a846c3b24332d812a05d28fff
test/dot_git/objects/98/36cd7a87f3baa9c004d7ed277baef050b2ce3d
test/dot_git/objects/98/4ab69b9f09ba4087a503628badb3bfb001e417
test/dot_git/objects/98/b806b34a110411575eee9d45f949a72ac27c7a
test/dot_git/objects/9b/70d75286c8218b28f623a9b0801b0b952ffb8b
test/dot_git/objects/9c/5810283f7b71f0e6658f83fa3cea4c42add182
test/dot_git/objects/9c/a4d54b87ae030f69c6a1652b06458229163bff
test/dot_git/objects/9d/4cb25621a8fd3751691b5320a63acc0cb71359
test/dot_git/objects/9e/5651973373448a7621f2b50a6c7719fc731717
test/dot_git/objects/9f/17dfcb0f307446f1a9f5f4f265fd03f01e5337
test/dot_git/objects/9f/94c114fbd1a011d99783c2df5dc97db923fd27
test/dot_git/objects/9f/9b08b0ed1e63325c5669c54b1666cf00231856
test/dot_git/objects/9f/ace5ebf66d7a4990759a6b23d593b27c560371
test/dot_git/objects/a0/1626c862e48de9548a21ee3877c96266a9f247
test/dot_git/objects/a0/292a1e42c64c9738088223f119740f9bcf25a4
test/dot_git/objects/a0/89b4d1cc2b3887c816f5ba51ce48d90ea53e4a
test/dot_git/objects/a0/931153ab2b7eadad5cccf57e8cfe67051a902a
test/dot_git/objects/a1/3905543ce8634d5206f155d887818c261a34ca
test/dot_git/objects/a2/83d38a51ccde7f05bf3b2cdbb374d3e794e3e4
test/dot_git/objects/a2/d4e7e0f4d030940b4a62cf905c7f18c9f3ed08
test/dot_git/objects/a4/8dbab8aaf71f35784363f7bd5fe0bbdc91219a
test/dot_git/objects/a4/949eb5bfc411c724532a24a2070e16fafbdbf8
test/dot_git/objects/a6/25a89a89cfe2916a812c0a19bbf7c88d2bc6c5
test/dot_git/objects/a6/61101de591928518b26e5cf19f976173af84b1
test/dot_git/objects/a6/b63376a6c6208c700d28f4152f06561a8591f5
test/dot_git/objects/a6/cc9707d22121121c4c436961f25ad3136c7a2d
test/dot_git/objects/a7/f6425fdc0d6eab1f94942603f9101a9eb010f3
test/dot_git/objects/a8/2dc65e43b5f13287fe61d9c0d535319e10d1fb
test/dot_git/objects/a8/a74a93cf26ee794cebc9f1440c56882b0124e7
test/dot_git/objects/a8/f3b83e0ed58f5a7c58fd673eeca588942bcde5
test/dot_git/objects/a9/35f4bb2d641436ab22510afdb2ddf59f953521
test/dot_git/objects/aa/ca7266c757878ce0f80a5edd9651afc32624c5
test/dot_git/objects/ab/c19c8c3819bbaa4964ca4f7fafc32d97834920
test/dot_git/objects/ac/e84f11ee83b490c7b0421c3815da52172e6106
test/dot_git/objects/ad/ac6394aaa5f63348d12c6d7c556cc5895bdb5e
test/dot_git/objects/ad/be3ad1cfaed6ae867ff4c780e57b24aba92bb6
test/dot_git/objects/ae/45e5b88fcd45b55efa1e8a1f60e6525897430f
test/dot_git/objects/ae/88cc08586ab2baad34a00de9aed2be4e8ec297
test/dot_git/objects/ae/aa7324c31d374eac09744a5e1cf3eb5c11b1ef
test/dot_git/objects/af/37cb1d947f50b5a9c4ea7c68dcfeb67ad66f8a
test/dot_git/objects/af/ae8e12352682bf9d015dce28e338a451c5f55e
test/dot_git/objects/af/d4d958e849a246bd3413f2cc02e7910f19f058
test/dot_git/objects/b0/1401ffc98de4b600588fcfcd09a3961d162c69
test/dot_git/objects/b0/3531d097981c72b9c99aca10eca9c50a70d466
test/dot_git/objects/b1/c0001ea8e43861235f34cd4d21853ca458158e
test/dot_git/objects/b2/1d54ab7d3ec8d8a3c91c997ed9538777e46188
test/dot_git/objects/b2/1f05a2f9d51a8ef2c143fb7b8282fc53be06dd
test/dot_git/objects/b4/3d94c5a8e399fff7661187411c2f3702898160
test/dot_git/objects/b4/fd01bf7d2194b58ffc3a8e703bcdef5b3046bc
test/dot_git/objects/b6/33e336e94e1090bd7e19773972b1bf177d18bb
test/dot_git/objects/b6/9a6fedabd2d05896b06986e7ac8f69f6d32903
test/dot_git/objects/b6/e387967dd4d8cc2a590dae48327dd7b1225992
test/dot_git/objects/b7/6a1914a9461f6e66a4fc5a32b890f38b3dbe89
test/dot_git/objects/b8/a5e1b3d5334ec5484f1299b77526b187a94c25
test/dot_git/objects/b9/e18f001d183fcf54debaf1b2995d31a2f60de8
test/dot_git/objects/b9/fe6cfc99544168ab86a9e5326d2278651204c9
test/dot_git/objects/ba/8e143dc8770a08a289c15e575adc55c5a4bb54
test/dot_git/objects/ba/c7b8660ab69c5728f49b9e63751ad1d86ef5d3
test/dot_git/objects/bb/332bf8f4417e45a74d87c762665d27562d4e95
test/dot_git/objects/bb/d2a60494d609583a1117447158a329e1629022
test/dot_git/objects/bd/1d7e6252aaa69a1a67688101117881c20c6ce2
test/dot_git/objects/be/df2c64a1d0b97f039e8bc0d80722f020adfb70
test/dot_git/objects/bf/2c69e3ff4f9c3abc2c8711a4d9b94fad30e9f0
test/dot_git/objects/c0/a0771d3e3ca04f47b010867ac7a4a42408da0d
test/dot_git/objects/c0/bff5fee2b3e7ced9f6db56394af1aad1ea7ed8
test/dot_git/objects/c1/ccd31fd431573003f6492034e888f7d9f0b9b8
test/dot_git/objects/c1/f6b5ee610aeb6ac999ad6dfba1252f17d06d76
test/dot_git/objects/c2/85fb81c97b0ad4b5e31d6c88f7d2de1a999bf6
test/dot_git/objects/c2/dcc243dd5586cdefe67c1a47922f2b33515e84
test/dot_git/objects/c3/0c8c756c092cc3c5260805b630973786a0c740
test/dot_git/objects/c3/d90063e61a4f18f0c67f40875c3fbef7679c37
test/dot_git/objects/c4/e1178df3417161a08166519c671cc7eb9d13da
test/dot_git/objects/c5/316e5a772e358243b305cd39185907ba4000e8
test/dot_git/objects/c6/c29d8b2626547f47c454e3132643e911a9dca7
test/dot_git/objects/c7/7d84a29d341be904705ff97f40060d896d32a2
test/dot_git/objects/c9/67cea0a628ff0f9b85d59003b56ab3db1ab2b4
test/dot_git/objects/ca/c661c85aa6405085fb561e4f5a1dbd62c89e0c
test/dot_git/objects/cb/9af18c3753abd34f1bffd77af3c02e8975e24c
test/dot_git/objects/cb/b903f44f2508c6204f58f812977dcc8cf9cefe
test/dot_git/objects/cc/70a2b9b33e50633e146745b14be7b827a1b3fd
test/dot_git/objects/cc/a47071801b43a39ca8d0a88f2201ad30ebedc9
test/dot_git/objects/cc/fdeb08df97d990299a7cf523c0f26be1a17b72
test/dot_git/objects/cd/b5ce2c133787835ca0b75e3dddd4482d7d40ce
test/dot_git/objects/ce/37aab31d5b51592d153e85dc31a1164f2c74d5
test/dot_git/objects/cf/19fd85e7967177d5419c4d07398f990c33545d
test/dot_git/objects/cf/1c5abec20238b4fda0b8fb9c9fcc0314198010
test/dot_git/objects/cf/ba8a784564e61ab02beec0546e2b7deb1dedf8
test/dot_git/objects/d0/b8e19994cff4866d3464f604a44f5856436e67
test/dot_git/objects/d0/c74daaca46f35c1ff78c5b600826deb5649524
test/dot_git/objects/d1/13634b1167576fe27292c3857813ef5cc4a669
test/dot_git/objects/d1/152cb07487bd11c9f63843437b277d51e07205
test/dot_git/objects/d1/5036828e61ea14859aa7d1bfcebd0e3b0eb881
test/dot_git/objects/d1/624b21caf0eee83ec682d312cf477e88f750d3
test/dot_git/objects/d1/f010bd414b89ab2d70d95f819b913dfe421a14
test/dot_git/objects/d2/110dfef12479935cf619a11136153f94ca9b67
test/dot_git/objects/d2/563757320e1557299ad7249cd23523f065e654
test/dot_git/objects/d2/ef2754d3f4498e5f39093a13bb7b63f5ac53e0
test/dot_git/objects/d3/60d56c0dc32d09a1dac7d14227c0dc502e0315
test/dot_git/objects/d3/6adf3899666534d3dfdbb7cb56ae6cd67c775f
test/dot_git/objects/d4/c1f16003f3a9dbd786ff9c76fd870f6410219e
test/dot_git/objects/d4/c52892a65b126bd009552425629d3ddeac187c
test/dot_git/objects/d5/b2e50283d7c08ba11cff41cf969bc409e25b04
test/dot_git/objects/d6/a96d9347d002e1f4c994f6e706c92cacf34c1b
test/dot_git/objects/d6/fa111185d38e869024040461d97e3fb1f2a3dd
test/dot_git/objects/d7/06308dfda94ed1d1fa3b4e166204a3b3b821de
test/dot_git/objects/d7/7e88e54007ca7054c80e4a553dfc9497033190
test/dot_git/objects/d7/b6c50da9b2013a2b68a58ad248a5ee86e3e413
test/dot_git/objects/d8/263d0d2544145f915010a759217b3cca42372d
test/dot_git/objects/d8/32e468be4f1fc8898bf2e5273f1edbe96df5a1
test/dot_git/objects/da/1669b4371b10947264cb338e9a1cbedc0ad569
test/dot_git/objects/da/a1ae72d1b50ea84156ab4609e643a070bdef4e
test/dot_git/objects/da/fd8a6599574a188701e2efd965b5a9907925ee
test/dot_git/objects/db/0101ef085f8c71eb0f4a1ec982d292924a5d7e
test/dot_git/objects/db/d625cae0863ef56c00c09d7954dea8165650db
test/dot_git/objects/dc/0bcf3df4f74fa898ab5541c38e38b405dbcaa9
test/dot_git/objects/dc/13b3e9e0c9f064e50c432158e3b038dc36b63e
test/dot_git/objects/dc/a70d64a067eb0739bd71b8725d8e34fbc1ed0a
test/dot_git/objects/dd/7efbb77e82a842d13c91288c372e26fc701ed6
test/dot_git/objects/de/6582afb45f6095e001f58add5ea7c10e9dcb6d
test/dot_git/objects/de/b2346f42ba644e6768541b5eded5d381c26158
test/dot_git/objects/de/e78dfdbff2d10b632252914a27b087c133c6c0
test/dot_git/objects/df/bda7c78373c97807758e7385e980ea1969a6a6
test/dot_git/objects/df/eeb6e6ca48947e35b882ae04bdcc7cbc992d99
test/dot_git/objects/e1/c2a8f7843b588275eda6f3c8e321e23e74fd96
test/dot_git/objects/e2/56e219e2898ef4e259472205a4cfb3fb782f3b
test/dot_git/objects/e2/c9f53517ee568ac02ce2b8f2633e8b0a9f513e
test/dot_git/objects/e3/3e78cb3c472bc6e1566146f6758851ce2677b6
test/dot_git/objects/e3/a3038573f3b1246def8ef1a1614f054bedf997
test/dot_git/objects/e3/e846396d26e98aa34d26c7417e851f46801f9a
test/dot_git/objects/e4/45223b62c0dfe199d2db14b439c5eb1f10edd4
test/dot_git/objects/e4/e9744dfabd3c54cddf8274d95ffe7e8d4ae1f6
test/dot_git/objects/e5/3c62a8e65bcb441de67dd388f22d9e59ff41b4
test/dot_git/objects/e6/04d431540c63ebb9387bd1506b7df63e3d4868
test/dot_git/objects/e6/1b707b59d20dc125ae1c2383eb67e06ee6686e
test/dot_git/objects/e7/67e28974d0047a53f3880d1361822c2386873b
test/dot_git/objects/e8/c36a5942eb01f7036ed8969f5845c4d5385896
test/dot_git/objects/e9/0d7972cddfcbed0e7efd7dac92cbe894c226f0
test/dot_git/objects/e9/462ac46b53343c09ea5dcdc7ab53b28dbdaf95
test/dot_git/objects/e9/4f08ad7175d17064b709e487cf3d16954fb204
test/dot_git/objects/e9/5d5db706850682b2798f7643e31f3f82cfa8e0
test/dot_git/objects/e9/6f1622e59e32a89c727359f2c8c5e598d719c8
test/dot_git/objects/ea/7d7232c2035543c3b0f349339d50157874b5f0
test/dot_git/objects/eb/275489327879906f5ced9f04220aa896534243
test/dot_git/objects/eb/ee5088c07150ab83f09d7f56b7317afdc0b447
test/dot_git/objects/ec/a0c428506f18dc36589e9464513f7157cd6e52
test/dot_git/objects/ed/c62f0fb7f82ee1ad7c29b42e513960fdcf13d9
test/dot_git/objects/ee/88371bc4a42cb7980fdb7704be9f05fee3b0a3
test/dot_git/objects/ee/e9df3d091825b2ce066c0fe717e2224f2f2931
test/dot_git/objects/ef/9d99db794a654d4c67527d277064481e996c5a
test/dot_git/objects/ef/9e75f59ccadfd4c67c6853828b9bc34d974ec7
test/dot_git/objects/ef/b165f0221d9739b6be5179ae3cecd633e45ce8
test/dot_git/objects/f0/32303006cdfe5892e2f8f64cf0f972d351b9a3
test/dot_git/objects/f0/5fb20e635d8ae2ff50ccb6a984274e58058632
test/dot_git/objects/f0/6db1288baf0f8671f287ad5a2a91d943747068
test/dot_git/objects/f0/f6f7e25c4bdd0647932e859fca992ff37869b3
test/dot_git/objects/f0/f87fe091f1256b42135c6e2e482cd3a078c7f9
test/dot_git/objects/f1/bf0001951ac41581e708bacacc4bdb4deddf3c
test/dot_git/objects/f2/0b59e485ec38019c363f3e1e89e0f804ed48ec
test/dot_git/objects/f2/41613e98ac4f7d57d45dfd8d7f38b7c8df99f3
test/dot_git/objects/f2/55ce10804955454568678091a6f328ef66a8a6
test/dot_git/objects/f2/7d9bd39b44bd80abd029a481c6a54617d0d170
test/dot_git/objects/f2/8d3bb5dd2c9be42f4ec9458808a4d8487c2e3e
test/dot_git/objects/f2/ce4153e5b1231e5603dea5772cd7a895d93923
test/dot_git/objects/f2/e63e8292a9e5750c459398d54f3ad9a23c18d7
test/dot_git/objects/f3/58447ff06a87a0aeac39e1945e3c635b328801
test/dot_git/objects/f3/b578c9694e83744b094524cbd190f2763f4a12
test/dot_git/objects/f4/1be6d524d8db969348f7e3bdcc08908932bb4e
test/dot_git/objects/f5/0489c78cc3d06d797c82d871726716684fc61c
test/dot_git/objects/f5/3a1631d49cfdb0a257974b3ebc0b5bc79bde52
test/dot_git/objects/f5/3eb189e857104b44de96b0a41436ebf60ffd78
test/dot_git/objects/f5/42ce17ea0da75b3de894eb7d0ffd8b9efe97d2
test/dot_git/objects/f5/69f066cdae3a13946f7ef9608677006ff387ed
test/dot_git/objects/f6/2215251c1d9fd76bdfb6454446cb1826ee9246
test/dot_git/objects/f6/c9c0b559fd041a0a23d33ae4bb605f0dba7b58
test/dot_git/objects/f7/3b9daf41c4c1380be40168b5cb7a3fefb87728
test/dot_git/objects/f8/1eec2ace52484d074b1db7a29b32c8b716d056
test/dot_git/objects/f8/206296fd197c506a224e9bbee22a8dccd2d8b7
test/dot_git/objects/f8/f75c70d9abddb176e61fe67520a0f0a168b8ee
test/dot_git/objects/f9/f3fe3f0b327e5b7955a195e5d789791bcc08f1
test/dot_git/objects/fa/64d91bcda155c1622505ca91dde0fa694c04c1
test/dot_git/objects/fb/c4ed43dfd3173f9707e3d7657809dc77c0bd9a
test/dot_git/objects/fc/0bfccdebfaea6fbb28e5a6cea62f9a820ea817
test/dot_git/objects/fe/7efffeafed1ecd4679b5526d72a7dd3df140a9
test/dot_git/objects/fe/96440abd8d769d80037c7a8afcbf225156b604
test/dot_git/objects/fe/a98a018892bd22aa0bf7de727097eafc66ecc2
test/dot_git/objects/ff/2a1936f7883f44e7587a65dcbb5d18b03f3835
test/dot_git/objects/ff/667b71fb08b0642e5a92087e763fc09096893c
test/dot_git/objects/ff/97e5351d9fccccd047d798573c5a61771fc6c9
test/dot_git/refs/heads/master
test/dot_git/refs/remotes/origin/HEAD
test/dot_git/refs/remotes/origin/master
test/dot_git/refs/remotes/tom/master
test/dot_git/refs/tags/v0.7.0
ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a 3fa4e130fa18c92e3030d4accb5d3e0cadd40157 added a pure-ruby git library and converted the cat_file commands to use it
PURE_TODO
lib/grit.rb
lib/grit/git-ruby.rb
lib/grit/git-ruby/internal/loose.rb
lib/grit/git-ruby/internal/mmap.rb
lib/grit/git-ruby/internal/pack.rb
lib/grit/git-ruby/internal/raw_object.rb
lib/grit/git-ruby/object.rb
lib/grit/git-ruby/repository.rb
lib/grit/git.rb
test/fixtures/cat_file_blob_ruby
test/fixtures/cat_file_commit_ruby
test/fixtures/cat_file_tree_ruby
test/test_rubygit.rb
</content>
		</actual_file>
		<actual_file>
			<filename>HEAD</filename>
			<content>ref: refs/heads/master
</content>
		</actual_file>
		<actual_file>
			<filename>ORIG_HEAD</filename>
			<content>2d3acf90f35989df8f262dc50beadc4ee3ae1560
</content>
		</actual_file>
		<actual_file>
			<filename>packed-refs</filename>
			<content># pack-refs with: peeled 
2d3acf90f35989df8f262dc50beadc4ee3ae1560 refs/heads/test/master
ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a refs/heads/master
ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a refs/heads/test/chacon
2d3acf90f35989df8f262dc50beadc4ee3ae1560 refs/heads/testing
ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a refs/remotes/origin/master
2d3acf90f35989df8f262dc50beadc4ee3ae1560 refs/remotes/tom/master
f0055fda16c18fd8b27986dbf038c735b82198d7 refs/tags/packed_annotated
^7bcc0ee821cdd133d8a53e8e7173a334fef448aa
ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a refs/tags/packed
</content>
		</actual_file>
		<actual_file>
			<filename>applypatch-msg</filename>
			<content>#!/bin/sh
#
# An example hook script to check the commit log message taken by
# applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.  The hook is
# allowed to edit the commit message file.
#
# To enable this hook, make this file executable.

. git-sh-setup
test -x "$GIT_DIR/hooks/commit-msg" &&
	exec "$GIT_DIR/hooks/commit-msg" ${1+"$@"}
:
</content>
		</actual_file>
		<actual_file>
			<filename>commit-msg</filename>
			<content>#!/bin/sh
#
# An example hook script to check the commit log message.
# Called by git-commit with one argument, the name of the file
# that has the commit message.  The hook should exit with non-zero
# status after issuing an appropriate message if it wants to stop the
# commit.  The hook is allowed to edit the commit message file.
#
# To enable this hook, make this file executable.

# Uncomment the below to add a Signed-off-by line to the message.
# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
# hook is more suited to it.
#
# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*\).*$/Signed-off-by: \1/p')
# grep -qs "^$SOB" "$1" || echo "$SOB"  "$1"

# This example catches duplicate Signed-off-by lines.

test "" = "$(grep '^Signed-off-by: ' "$1" |
	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
	echo &2 Duplicate Signed-off-by lines.
	exit 1
}
</content>
		</actual_file>
		<actual_file>
			<filename>post-commit</filename>
			<content>#!/bin/sh
#
# An example hook script that is called after a successful
# commit is made.
#
# To enable this hook, make this file executable.

: Nothing
</content>
		</actual_file>
		<actual_file>
			<filename>post-receive</filename>
			<content>#!/bin/sh
#
# An example hook script for the post-receive event
#
# This script is run after receive-pack has accepted a pack and the
# repository has been updated.  It is passed arguments in through stdin
# in the form
#  oldrev newrev refname
# For example:
#  aa453216d1b3e49e7f6f98441fa56946ddcd6a20 68f7abf4e6f922807889f52bc043ecd31b79f814 refs/heads/master
#
# see contrib/hooks/ for an sample, or uncomment the next line (on debian)
#


#. /usr/share/doc/git-core/contrib/hooks/post-receive-email
</content>
		</actual_file>
		<actual_file>
			<filename>post-update</filename>
			<content>#!/bin/sh
#
# An example hook script to prepare a packed repository for use over
# dumb transports.
#
# To enable this hook, make this file executable by "chmod +x post-update".

exec git-update-server-info
</content>
		</actual_file>
		<actual_file>
			<filename>pre-applypatch</filename>
			<content>#!/bin/sh
#
# An example hook script to verify what is about to be committed
# by applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.
#
# To enable this hook, make this file executable.

. git-sh-setup
test -x "$GIT_DIR/hooks/pre-commit" &&
	exec "$GIT_DIR/hooks/pre-commit" ${1+"$@"}
:
</content>
		</actual_file>
		<actual_file>
			<filename>pre-commit</filename>
			<content>#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by git-commit with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message if
# it wants to stop the commit.
#
# To enable this hook, make this file executable.

# This is slightly modified from Andrew Morton's Perfect Patch.
# Lines you introduce should not have trailing whitespace.
# Also check for an indentation that has SP before a TAB.

if git-rev-parse --verify HEAD 2/dev/null
then
	git-diff-index -p -M --cached HEAD --
else
	# NEEDSWORK: we should produce a diff with an empty tree here
	# if we want to do the same verification for the initial import.
	:
fi |
perl -e '
    my $found_bad = 0;
    my $filename;
    my $reported_filename = "";
    my $lineno;
    sub bad_line {
	my ($why, $line) = @_;
	if (!$found_bad) {
	    print STDERR "*\n";
	    print STDERR "* You have some suspicious patch lines:\n";
	    print STDERR "*\n";
	    $found_bad = 1;
	}
	if ($reported_filename ne $filename) {
	    print STDERR "* In $filename\n";
	    $reported_filename = $filename;
	}
	print STDERR "* $why (line $lineno)\n";
	print STDERR "$filename:$lineno:$line\n";
    }
    while () {
	if (m|^diff --git a/(.*) b/\1$|) {
	    $filename = $1;
	    next;
	}
	if (/^@@ -\S+ \+(\d+)/) {
	    $lineno = $1 - 1;
	    next;
	}
	if (/^ /) {
	    $lineno++;
	    next;
	}
	if (s/^\+//) {
	    $lineno++;
	    chomp;
	    if (/\s$/) {
		bad_line("trailing whitespace", $_);
	    }
	    if (/^\s* \t/) {
		bad_line("indent SP followed by a TAB", $_);
	    }
	    if (/^([])\1{6} |^={7}$/) {
		bad_line("unresolved merge conflict", $_);
	    }
	}
    }
    exit($found_bad);
'
</content>
		</actual_file>
		<actual_file>
			<filename>pre-rebase</filename>
			<content>#!/bin/sh
#
# Copyright (c) 2006 Junio C Hamano
#

publish=next
basebranch="$1"
if test "$#" = 2
then
	topic="refs/heads/$2"
else
	topic=`git symbolic-ref HEAD`
fi

case "$basebranch,$topic" in
master,refs/heads/??/*)
	;;
*)
	exit 0 ;# we do not interrupt others.
	;;
esac

# Now we are dealing with a topic branch being rebased
# on top of master.  Is it OK to rebase it?

# Is topic fully merged to master?
not_in_master=`git-rev-list --pretty=oneline ^master "$topic"`
if test -z "$not_in_master"
then
	echo &2 "$topic is fully merged to master; better remove it."
	exit 1 ;# we could allow it, but there is no point.
fi

# Is topic ever merged to next?  If so you should not be rebasing it.
only_next_1=`git-rev-list ^master "^$topic" ${publish} | sort`
only_next_2=`git-rev-list ^master           ${publish} | sort`
if test "$only_next_1" = "$only_next_2"
then
	not_in_topic=`git-rev-list "^$topic" master`
	if test -z "$not_in_topic"
	then
		echo &2 "$topic is already up-to-date with master"
		exit 1 ;# we could allow it, but there is no point.
	else
		exit 0
	fi
else
	not_in_next=`git-rev-list --pretty=oneline ^${publish} "$topic"`
	perl -e '
		my $topic = $ARGV[0];
		my $msg = "* $topic has commits already merged to public branch:\n";
		my (%not_in_next) = map {
			/^([0-9a-f]+) /;
			($1 = 1);
		} split(/\n/, $ARGV[1]);
		for my $elem (map {
				/^([0-9a-f]+) (.*)$/;
				[$1 = $2];
			} split(/\n/, $ARGV[2])) {
			if (!exists $not_in_next{$elem-[0]}) {
				if ($msg) {
					print STDERR $msg;
					undef $msg;
				}
				print STDERR " $elem-[1]\n";
			}
		}
	' "$topic" "$not_in_next" "$not_in_master"
	exit 1
fi

exit 0

################################################################

This sample hook safeguards topic branches that have been
published from being rewound.

The workflow assumed here is:

 * Once a topic branch forks from "master", "master" is never
   merged into it again (either directly or indirectly).

 * Once a topic branch is fully cooked and merged into "master",
   it is deleted.  If you need to build on top of it to correct
   earlier mistakes, a new topic branch is created by forking at
   the tip of the "master".  This is not strictly necessary, but
   it makes it easier to keep your history simple.

 * Whenever you need to test or publish your changes to topic
   branches, merge them into "next" branch.

The script, being an example, hardcodes the publish branch name
to be "next", but it is trivial to make it configurable via
$GIT_DIR/config mechanism.

With this workflow, you would want to know:

(1) ... if a topic branch has ever been merged to "next".  Young
    topic branches can have stupid mistakes you would rather
    clean up before publishing, and things that have not been
    merged into other branches can be easily rebased without
    affecting other people.  But once it is published, you would
    not want to rewind it.

(2) ... if a topic branch has been fully merged to "master".
    Then you can delete it.  More importantly, you should not
    build on top of it -- other people may already want to
    change things related to the topic as patches against your
    "master", so if you need further changes, it is better to
    fork the topic (perhaps with the same name) afresh from the
    tip of "master".

Let's look at this example:

		   o---o---o---o---o---o---o---o---o---o "next"
		  /       /           /           /
		 /   a---a---b A     /           /
		/   /               /           /
	       /   /   c---c---c---c B         /
	      /   /   /             \         /
	     /   /   /   b---b C     \       /
	    /   /   /   /             \     /
    ---o---o---o---o---o---o---o---o---o---o---o "master"


A, B and C are topic branches.

 * A has one fix since it was merged up to "next".

 * B has finished.  It has been fully merged up to "master" and "next",
   and is ready to be deleted.

 * C has not merged to "next" at all.

We would want to allow C to be rebased, refuse A, and encourage
B to be deleted.

To compute (1):

	git-rev-list ^master ^topic next
	git-rev-list ^master        next

	if these match, topic has not merged in next at all.

To compute (2):

	git-rev-list master..topic

	if this is empty, it is fully merged to "master".
</content>
		</actual_file>
		<actual_file>
			<filename>prepare-commit-msg</filename>
			<content>#!/bin/sh
#
# An example hook script to prepare the commit log message.
# Called by git-commit with the name of the file that has the
# commit message, followed by the description of the commit
# message's source.  The hook's purpose is to edit the commit
# message file.  If the hook fails with a non-zero status,
# the commit is aborted.
#
# To enable this hook, make this file executable.

# This hook includes three examples.  The first comments out the
# "Conflicts:" part of a merge commit.
#
# The second includes the output of "git diff --name-status -r"
# into the message, just before the "git status" output.  It is
# commented because it doesn't cope with --amend or with squashed
# commits.
#
# The third example adds a Signed-off-by line to the message, that can
# still be edited.  This is rarely a good idea.

case "$2 $3" in
  merge)
    sed -i '/^Conflicts:/,/#/!b;s/^/# &/;s/^# #/#/' "$1" ;;

# ""|template)
#   perl -i -pe '
#      print "\n" . `git diff --cached --name-status -r`
#	 if /^#/ && $first++ == 0' "$1" ;;

  *) ;;
esac

# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*\).*$/Signed-off-by: \1/p')
# grep -qs "^$SOB" "$1" || echo "$SOB"  "$1"
</content>
		</actual_file>
		<actual_file>
			<filename>update</filename>
			<content>#!/bin/sh
#
# An example hook script to blocks unannotated tags from entering.
# Called by git-receive-pack with arguments: refname sha1-old sha1-new
#
# To enable this hook, make this file executable by "chmod +x update".
#
# Config
# ------
# hooks.allowunannotated
#   This boolean sets whether unannotated tags will be allowed into the
#   repository.  By default they won't be.
# hooks.allowdeletetag
#   This boolean sets whether deleting tags will be allowed in the
#   repository.  By default they won't be.
# hooks.allowdeletebranch
#   This boolean sets whether deleting branches will be allowed in the
#   repository.  By default they won't be.
#

# --- Command line
refname="$1"
oldrev="$2"
newrev="$3"

# --- Safety check
if [ -z "$GIT_DIR" ]; then
	echo "Don't run this script from the command line." &2
	echo " (if you want, you could supply GIT_DIR then run" &2
	echo "  $0 ref oldrev newrev)" &2
	exit 1
fi

if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
	echo "Usage: $0 ref oldrev newrev" &2
	exit 1
fi

# --- Config
allowunannotated=$(git config --bool hooks.allowunannotated)
allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
allowdeletetag=$(git config --bool hooks.allowdeletetag)

# check for no description
projectdesc=$(sed -e '1q' "$GIT_DIR/description")
if [ -z "$projectdesc" -o "$projectdesc" = "Unnamed repository; edit this file to name it for gitweb." ]; then
	echo "*** Project description file hasn't been set" &2
	exit 1
fi

# --- Check types
# if $newrev is 0000...0000, it's a commit to delete a ref.
if [ "$newrev" = "0000000000000000000000000000000000000000" ]; then
	newrev_type=delete
else
	newrev_type=$(git-cat-file -t $newrev)
fi

case "$refname","$newrev_type" in
	refs/tags/*,commit)
		# un-annotated tag
		short_refname=${refname##refs/tags/}
		if [ "$allowunannotated" != "true" ]; then
			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" &2
			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." &2
			exit 1
		fi
		;;
	refs/tags/*,delete)
		# delete tag
		if [ "$allowdeletetag" != "true" ]; then
			echo "*** Deleting a tag is not allowed in this repository" &2
			exit 1
		fi
		;;
	refs/tags/*,tag)
		# annotated tag
		;;
	refs/heads/*,commit)
		# branch
		;;
	refs/heads/*,delete)
		# delete branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a branch is not allowed in this repository" &2
			exit 1
		fi
		;;
	refs/remotes/*,commit)
		# tracking branch
		;;
	refs/remotes/*,delete)
		# delete tracking branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a tracking branch is not allowed in this repository" &2
			exit 1
		fi
		;;
	*)
		# Anything else (is there anything else?)
		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" &2
		exit 1
		;;
esac

# --- Finished
exit 0
</content>
		</actual_file>
		<actual_file>
			<filename>exclude</filename>
			<content># git-ls-files --others --exclude-from=.git/info/exclude
# Lines that start with '#' are comments.
# For a project mostly in C, the following would be a good set of
# exclude patterns (uncomment them if you want to use them):
# *.[oa]
# *~
</content>
		</actual_file>
		<actual_file>
			<filename>HEAD</filename>
			<content>0000000000000000000000000000000000000000 2d3acf90f35989df8f262dc50beadc4ee3ae1560 Scott Chacon schacon@gmail.com 1208560687 -0700
2d3acf90f35989df8f262dc50beadc4ee3ae1560 3fa4e130fa18c92e3030d4accb5d3e0cadd40157 Scott Chacon schacon@gmail.com 1208561167 -0700	commit: added a git directory to the testing dir for current and future testing
3fa4e130fa18c92e3030d4accb5d3e0cadd40157 ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a Scott Chacon schacon@gmail.com 1208561228 -0700	commit: added a pure-ruby git library and converted the cat_file commands to use it
</content>
		</actual_file>
		<actual_file>
			<filename>master</filename>
			<content>0000000000000000000000000000000000000000 2d3acf90f35989df8f262dc50beadc4ee3ae1560 Scott Chacon schacon@gmail.com 1208560687 -0700
2d3acf90f35989df8f262dc50beadc4ee3ae1560 3fa4e130fa18c92e3030d4accb5d3e0cadd40157 Scott Chacon schacon@gmail.com 1208561167 -0700	commit: added a git directory to the testing dir for current and future testing
3fa4e130fa18c92e3030d4accb5d3e0cadd40157 ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a Scott Chacon schacon@gmail.com 1208561228 -0700	commit: added a pure-ruby git library and converted the cat_file commands to use it
</content>
		</actual_file>
		<actual_file>
			<filename>master</filename>
			<content>0000000000000000000000000000000000000000 2d3acf90f35989df8f262dc50beadc4ee3ae1560 Scott Chacon schacon@gmail.com 1208560687 -0700	clone: from git@github.com:schacon/grit.git
2d3acf90f35989df8f262dc50beadc4ee3ae1560 ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a Scott Chacon schacon@agadorsparticus.(none) 1208561232 -0700	update by push
</content>
		</actual_file>
		<actual_file>
			<filename>master</filename>
			<content>0000000000000000000000000000000000000000 2d3acf90f35989df8f262dc50beadc4ee3ae1560 Scott Chacon schacon@gmail.com 1208550091 -0700	pull tom: storing head
</content>
		</actual_file>
		<actual_file>
			<filename>fccf8916dbf1a607b69cb308affb800b24eff8</filename>
			<content>x+)JMU046b040031QHL634ILL4M3366H14J6K1O655KN64MJI2MeGvVʶW@MHJ5NL1LNKLM1KL03OK3I60H55O22ILJ4JJ2cZb}cS-</content>
		</actual_file>
		<actual_file>
			<filename>223b18290bf0265b04b3697f729dba40f9e7cc</filename>
			<content>x+)JMU03c040031Q0HL1MLJ43H44H1I133N21JIN6IIFiVafRc_+ʂr3</content>
		</actual_file>
		<actual_file>
			<filename>72f12ea25d302ad4a4ceb9f5f9f033cbf3fffc</filename>
			<content>x+)JMU03c040031Q07H1750K02H2H332NL200L2H45JKKHb{Q*c!\kFM</content>
		</actual_file>
		<actual_file>
			<filename>88d05fb1efcdb4d1c825b3590f6a941d878048</filename>
			<content>x+)JMU03c040031Q0N63JH53MJN211LI53OI1H32JL5LK31L2aegWZ¥w</content>
		</actual_file>
		<actual_file>
			<filename>039964bc11de4db51deada1676b0a8e7c80fbf</filename>
			<content>x+)JMU03c040031Q03I4LJNI445M6432250MN4LII5HK44I60I6d3fbʝ3S0Q</content>
		</actual_file>
		<actual_file>
			<filename>3312cdadae43ef320f56980491d2db43649ccc</filename>
			<content>x+)JMU046b040031QH6L34300N3NLIJ10KKL67KK07H331402Le8"HTȴif̓OW`jdaihfdhdb``ijjdbdjfdblha T|iȋ#3DY+</content>
		</actual_file>
		<actual_file>
			<filename>594eba936a7a228d42b65d700bebff95a4d7d9</filename>
			<content>x+)JMU03c040031QH6IM11NIK1647N470O5N17350LI67O6HJLdГ
\Aa.S7</content>
		</actual_file>
		<actual_file>
			<filename>c97e96fc539a6586110b4698c64e8167f09b7d</filename>
			<content>x+)JMU03c040031Q0HJKNNIMJKLM4KKJ2H5M4Kr,-R-3.j|#i_2B"</content>
		</actual_file>
		<actual_file>
			<filename>c90099c5e43ab88371cdccc411d0424b0a4fb9</filename>
			<content>x+)JMU03c040031QH6LJ27KJM333774432127201MIJJL5LJ5NI5c(1pJdUxoL)=</content>
		</actual_file>
		<actual_file>
			<filename>alternates</filename>
			<content></content>
		</actual_file>
		<actual_file>
			<filename>pack-c8881c2613522dc3ac69af9c7b4881a061aaec8c.keep</filename>
			<content>fetch-pack 3903 on agadorsparticus
</content>
		</actual_file>
		<actual_file>
			<filename>nonpack</filename>
			<content>ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a
</content>
		</actual_file>
		<actual_file>
			<filename>HEAD</filename>
			<content>ref: refs/remotes/origin/master
</content>
		</actual_file>
		<actual_file>
			<filename>master</filename>
			<content>ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a
</content>
		</actual_file>
		<actual_file>
			<filename>master</filename>
			<content>2d3acf90f35989df8f262dc50beadc4ee3ae1560
</content>
		</actual_file>
		<actual_file>
			<filename>annotated</filename>
			<content>b7f932bd02b3e0a4228ee7b55832749028d345de
</content>
		</actual_file>
		<actual_file>
			<filename>not_annotated</filename>
			<content>ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a
</content>
		</actual_file>
		<actual_file>
			<filename>v0.7.0</filename>
			<content>f0055fda16c18fd8b27986dbf038c735b82198d7
</content>
		</actual_file>
		<actual_file>
			<filename>config</filename>
			<content>[core]
	repositoryformatversion = 0
	filemode = true
	bare = true
</content>
		</actual_file>
		<actual_file>
			<filename>description</filename>
			<content>Unnamed repository; edit this file to name it for gitweb.
</content>
		</actual_file>
		<actual_file>
			<filename>HEAD</filename>
			<content>ref: refs/heads/master
</content>
		</actual_file>
		<actual_file>
			<filename>applypatch-msg</filename>
			<content>#!/bin/sh
#
# An example hook script to check the commit log message taken by
# applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.  The hook is
# allowed to edit the commit message file.
#
# To enable this hook, make this file executable.

. git-sh-setup
test -x "$GIT_DIR/hooks/commit-msg" &&
	exec "$GIT_DIR/hooks/commit-msg" ${1+"$@"}
:
</content>
		</actual_file>
		<actual_file>
			<filename>commit-msg</filename>
			<content>#!/bin/sh
#
# An example hook script to check the commit log message.
# Called by git-commit with one argument, the name of the file
# that has the commit message.  The hook should exit with non-zero
# status after issuing an appropriate message if it wants to stop the
# commit.  The hook is allowed to edit the commit message file.
#
# To enable this hook, make this file executable.

# Uncomment the below to add a Signed-off-by line to the message.
# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
# hook is more suited to it.
#
# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*\).*$/Signed-off-by: \1/p')
# grep -qs "^$SOB" "$1" || echo "$SOB"  "$1"

# This example catches duplicate Signed-off-by lines.

test "" = "$(grep '^Signed-off-by: ' "$1" |
	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
	echo &2 Duplicate Signed-off-by lines.
	exit 1
}
</content>
		</actual_file>
		<actual_file>
			<filename>post-commit</filename>
			<content>#!/bin/sh
#
# An example hook script that is called after a successful
# commit is made.
#
# To enable this hook, make this file executable.

: Nothing
</content>
		</actual_file>
		<actual_file>
			<filename>post-receive</filename>
			<content>#!/bin/sh
#
# An example hook script for the post-receive event
#
# This script is run after receive-pack has accepted a pack and the
# repository has been updated.  It is passed arguments in through stdin
# in the form
#  oldrev newrev refname
# For example:
#  aa453216d1b3e49e7f6f98441fa56946ddcd6a20 68f7abf4e6f922807889f52bc043ecd31b79f814 refs/heads/master
#
# see contrib/hooks/ for an sample, or uncomment the next line (on debian)
#


#. /usr/share/doc/git-core/contrib/hooks/post-receive-email
</content>
		</actual_file>
		<actual_file>
			<filename>post-update</filename>
			<content>#!/bin/sh
#
# An example hook script to prepare a packed repository for use over
# dumb transports.
#
# To enable this hook, make this file executable by "chmod +x post-update".

exec git-update-server-info
</content>
		</actual_file>
		<actual_file>
			<filename>pre-applypatch</filename>
			<content>#!/bin/sh
#
# An example hook script to verify what is about to be committed
# by applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.
#
# To enable this hook, make this file executable.

. git-sh-setup
test -x "$GIT_DIR/hooks/pre-commit" &&
	exec "$GIT_DIR/hooks/pre-commit" ${1+"$@"}
:
</content>
		</actual_file>
		<actual_file>
			<filename>pre-commit</filename>
			<content>#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by git-commit with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message if
# it wants to stop the commit.
#
# To enable this hook, make this file executable.

# This is slightly modified from Andrew Morton's Perfect Patch.
# Lines you introduce should not have trailing whitespace.
# Also check for an indentation that has SP before a TAB.

if git-rev-parse --verify HEAD 2/dev/null
then
	git-diff-index -p -M --cached HEAD --
else
	# NEEDSWORK: we should produce a diff with an empty tree here
	# if we want to do the same verification for the initial import.
	:
fi |
perl -e '
    my $found_bad = 0;
    my $filename;
    my $reported_filename = "";
    my $lineno;
    sub bad_line {
	my ($why, $line) = @_;
	if (!$found_bad) {
	    print STDERR "*\n";
	    print STDERR "* You have some suspicious patch lines:\n";
	    print STDERR "*\n";
	    $found_bad = 1;
	}
	if ($reported_filename ne $filename) {
	    print STDERR "* In $filename\n";
	    $reported_filename = $filename;
	}
	print STDERR "* $why (line $lineno)\n";
	print STDERR "$filename:$lineno:$line\n";
    }
    while () {
	if (m|^diff --git a/(.*) b/\1$|) {
	    $filename = $1;
	    next;
	}
	if (/^@@ -\S+ \+(\d+)/) {
	    $lineno = $1 - 1;
	    next;
	}
	if (/^ /) {
	    $lineno++;
	    next;
	}
	if (s/^\+//) {
	    $lineno++;
	    chomp;
	    if (/\s$/) {
		bad_line("trailing whitespace", $_);
	    }
	    if (/^\s* \t/) {
		bad_line("indent SP followed by a TAB", $_);
	    }
	    if (/^([])\1{6} |^={7}$/) {
		bad_line("unresolved merge conflict", $_);
	    }
	}
    }
    exit($found_bad);
'
</content>
		</actual_file>
		<actual_file>
			<filename>pre-rebase</filename>
			<content>#!/bin/sh
#
# Copyright (c) 2006 Junio C Hamano
#

publish=next
basebranch="$1"
if test "$#" = 2
then
	topic="refs/heads/$2"
else
	topic=`git symbolic-ref HEAD`
fi

case "$basebranch,$topic" in
master,refs/heads/??/*)
	;;
*)
	exit 0 ;# we do not interrupt others.
	;;
esac

# Now we are dealing with a topic branch being rebased
# on top of master.  Is it OK to rebase it?

# Is topic fully merged to master?
not_in_master=`git-rev-list --pretty=oneline ^master "$topic"`
if test -z "$not_in_master"
then
	echo &2 "$topic is fully merged to master; better remove it."
	exit 1 ;# we could allow it, but there is no point.
fi

# Is topic ever merged to next?  If so you should not be rebasing it.
only_next_1=`git-rev-list ^master "^$topic" ${publish} | sort`
only_next_2=`git-rev-list ^master           ${publish} | sort`
if test "$only_next_1" = "$only_next_2"
then
	not_in_topic=`git-rev-list "^$topic" master`
	if test -z "$not_in_topic"
	then
		echo &2 "$topic is already up-to-date with master"
		exit 1 ;# we could allow it, but there is no point.
	else
		exit 0
	fi
else
	not_in_next=`git-rev-list --pretty=oneline ^${publish} "$topic"`
	perl -e '
		my $topic = $ARGV[0];
		my $msg = "* $topic has commits already merged to public branch:\n";
		my (%not_in_next) = map {
			/^([0-9a-f]+) /;
			($1 = 1);
		} split(/\n/, $ARGV[1]);
		for my $elem (map {
				/^([0-9a-f]+) (.*)$/;
				[$1 = $2];
			} split(/\n/, $ARGV[2])) {
			if (!exists $not_in_next{$elem-[0]}) {
				if ($msg) {
					print STDERR $msg;
					undef $msg;
				}
				print STDERR " $elem-[1]\n";
			}
		}
	' "$topic" "$not_in_next" "$not_in_master"
	exit 1
fi

exit 0

################################################################

This sample hook safeguards topic branches that have been
published from being rewound.

The workflow assumed here is:

 * Once a topic branch forks from "master", "master" is never
   merged into it again (either directly or indirectly).

 * Once a topic branch is fully cooked and merged into "master",
   it is deleted.  If you need to build on top of it to correct
   earlier mistakes, a new topic branch is created by forking at
   the tip of the "master".  This is not strictly necessary, but
   it makes it easier to keep your history simple.

 * Whenever you need to test or publish your changes to topic
   branches, merge them into "next" branch.

The script, being an example, hardcodes the publish branch name
to be "next", but it is trivial to make it configurable via
$GIT_DIR/config mechanism.

With this workflow, you would want to know:

(1) ... if a topic branch has ever been merged to "next".  Young
    topic branches can have stupid mistakes you would rather
    clean up before publishing, and things that have not been
    merged into other branches can be easily rebased without
    affecting other people.  But once it is published, you would
    not want to rewind it.

(2) ... if a topic branch has been fully merged to "master".
    Then you can delete it.  More importantly, you should not
    build on top of it -- other people may already want to
    change things related to the topic as patches against your
    "master", so if you need further changes, it is better to
    fork the topic (perhaps with the same name) afresh from the
    tip of "master".

Let's look at this example:

		   o---o---o---o---o---o---o---o---o---o "next"
		  /       /           /           /
		 /   a---a---b A     /           /
		/   /               /           /
	       /   /   c---c---c---c B         /
	      /   /   /             \         /
	     /   /   /   b---b C     \       /
	    /   /   /   /             \     /
    ---o---o---o---o---o---o---o---o---o---o---o "master"


A, B and C are topic branches.

 * A has one fix since it was merged up to "next".

 * B has finished.  It has been fully merged up to "master" and "next",
   and is ready to be deleted.

 * C has not merged to "next" at all.

We would want to allow C to be rebased, refuse A, and encourage
B to be deleted.

To compute (1):

	git-rev-list ^master ^topic next
	git-rev-list ^master        next

	if these match, topic has not merged in next at all.

To compute (2):

	git-rev-list master..topic

	if this is empty, it is fully merged to "master".
</content>
		</actual_file>
		<actual_file>
			<filename>prepare-commit-msg</filename>
			<content>#!/bin/sh
#
# An example hook script to prepare the commit log message.
# Called by git-commit with the name of the file that has the
# commit message, followed by the description of the commit
# message's source.  The hook's purpose is to edit the commit
# message file.  If the hook fails with a non-zero status,
# the commit is aborted.
#
# To enable this hook, make this file executable.

# This hook includes three examples.  The first comments out the
# "Conflicts:" part of a merge commit.
#
# The second includes the output of "git diff --name-status -r"
# into the message, just before the "git status" output.  It is
# commented because it doesn't cope with --amend or with squashed
# commits.
#
# The third example adds a Signed-off-by line to the message, that can
# still be edited.  This is rarely a good idea.

case "$2 $3" in
  merge)
    sed -i '/^Conflicts:/,/#/!b;s/^/# &/;s/^# #/#/' "$1" ;;

# ""|template)
#   perl -i -pe '
#      print "\n" . `git diff --cached --name-status -r`
#	 if /^#/ && $first++ == 0' "$1" ;;

  *) ;;
esac

# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*\).*$/Signed-off-by: \1/p')
# grep -qs "^$SOB" "$1" || echo "$SOB"  "$1"
</content>
		</actual_file>
		<actual_file>
			<filename>update</filename>
			<content>#!/bin/sh
#
# An example hook script to blocks unannotated tags from entering.
# Called by git-receive-pack with arguments: refname sha1-old sha1-new
#
# To enable this hook, make this file executable by "chmod +x update".
#
# Config
# ------
# hooks.allowunannotated
#   This boolean sets whether unannotated tags will be allowed into the
#   repository.  By default they won't be.
# hooks.allowdeletetag
#   This boolean sets whether deleting tags will be allowed in the
#   repository.  By default they won't be.
# hooks.allowdeletebranch
#   This boolean sets whether deleting branches will be allowed in the
#   repository.  By default they won't be.
#

# --- Command line
refname="$1"
oldrev="$2"
newrev="$3"

# --- Safety check
if [ -z "$GIT_DIR" ]; then
	echo "Don't run this script from the command line." &2
	echo " (if you want, you could supply GIT_DIR then run" &2
	echo "  $0 ref oldrev newrev)" &2
	exit 1
fi

if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
	echo "Usage: $0 ref oldrev newrev" &2
	exit 1
fi

# --- Config
allowunannotated=$(git config --bool hooks.allowunannotated)
allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
allowdeletetag=$(git config --bool hooks.allowdeletetag)

# check for no description
projectdesc=$(sed -e '1q' "$GIT_DIR/description")
if [ -z "$projectdesc" -o "$projectdesc" = "Unnamed repository; edit this file to name it for gitweb." ]; then
	echo "*** Project description file hasn't been set" &2
	exit 1
fi

# --- Check types
# if $newrev is 0000...0000, it's a commit to delete a ref.
if [ "$newrev" = "0000000000000000000000000000000000000000" ]; then
	newrev_type=delete
else
	newrev_type=$(git-cat-file -t $newrev)
fi

case "$refname","$newrev_type" in
	refs/tags/*,commit)
		# un-annotated tag
		short_refname=${refname##refs/tags/}
		if [ "$allowunannotated" != "true" ]; then
			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" &2
			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." &2
			exit 1
		fi
		;;
	refs/tags/*,delete)
		# delete tag
		if [ "$allowdeletetag" != "true" ]; then
			echo "*** Deleting a tag is not allowed in this repository" &2
			exit 1
		fi
		;;
	refs/tags/*,tag)
		# annotated tag
		;;
	refs/heads/*,commit)
		# branch
		;;
	refs/heads/*,delete)
		# delete branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a branch is not allowed in this repository" &2
			exit 1
		fi
		;;
	refs/remotes/*,commit)
		# tracking branch
		;;
	refs/remotes/*,delete)
		# delete tracking branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a tracking branch is not allowed in this repository" &2
			exit 1
		fi
		;;
	*)
		# Anything else (is there anything else?)
		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" &2
		exit 1
		;;
esac

# --- Finished
exit 0
</content>
		</actual_file>
		<actual_file>
			<filename>exclude</filename>
			<content># git-ls-files --others --exclude-from=.git/info/exclude
# Lines that start with '#' are comments.
# For a project mostly in C, the following would be a good set of
# exclude patterns (uncomment them if you want to use them):
# *.[oa]
# *~
</content>
		</actual_file>
		<actual_file>
			<filename>alternates</filename>
			<content>../../dot_git/objects</content>
		</actual_file>
		<actual_file>
			<filename>master</filename>
			<content>ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a
</content>
		</actual_file>
		<actual_file>
			<filename>nonpack</filename>
			<content>ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a
</content>
		</actual_file>
		<actual_file>
			<filename>testing</filename>
			<content>2d3acf90f35989df8f262dc50beadc4ee3ae1560
</content>
		</actual_file>
		<actual_file>
			<filename>chacon</filename>
			<content>ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a
</content>
		</actual_file>
		<actual_file>
			<filename>v0.7.0</filename>
			<content>f0055fda16c18fd8b27986dbf038c735b82198d7
</content>
		</actual_file>
		<actual_file>
			<filename>config</filename>
			<content>[core]
	repositoryformatversion = 0
	filemode = true
	bare = true
</content>
		</actual_file>
		<actual_file>
			<filename>description</filename>
			<content>Unnamed repository; edit this file to name it for gitweb.
</content>
		</actual_file>
		<actual_file>
			<filename>HEAD</filename>
			<content>ref: refs/heads/master
</content>
		</actual_file>
		<actual_file>
			<filename>applypatch-msg</filename>
			<content>#!/bin/sh
#
# An example hook script to check the commit log message taken by
# applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.  The hook is
# allowed to edit the commit message file.
#
# To enable this hook, make this file executable.

. git-sh-setup
test -x "$GIT_DIR/hooks/commit-msg" &&
	exec "$GIT_DIR/hooks/commit-msg" ${1+"$@"}
:
</content>
		</actual_file>
		<actual_file>
			<filename>commit-msg</filename>
			<content>#!/bin/sh
#
# An example hook script to check the commit log message.
# Called by git-commit with one argument, the name of the file
# that has the commit message.  The hook should exit with non-zero
# status after issuing an appropriate message if it wants to stop the
# commit.  The hook is allowed to edit the commit message file.
#
# To enable this hook, make this file executable.

# Uncomment the below to add a Signed-off-by line to the message.
# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
# hook is more suited to it.
#
# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*\).*$/Signed-off-by: \1/p')
# grep -qs "^$SOB" "$1" || echo "$SOB"  "$1"

# This example catches duplicate Signed-off-by lines.

test "" = "$(grep '^Signed-off-by: ' "$1" |
	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
	echo &2 Duplicate Signed-off-by lines.
	exit 1
}
</content>
		</actual_file>
		<actual_file>
			<filename>post-commit</filename>
			<content>#!/bin/sh
#
# An example hook script that is called after a successful
# commit is made.
#
# To enable this hook, make this file executable.

: Nothing
</content>
		</actual_file>
		<actual_file>
			<filename>post-receive</filename>
			<content>#!/bin/sh
#
# An example hook script for the post-receive event
#
# This script is run after receive-pack has accepted a pack and the
# repository has been updated.  It is passed arguments in through stdin
# in the form
#  oldrev newrev refname
# For example:
#  aa453216d1b3e49e7f6f98441fa56946ddcd6a20 68f7abf4e6f922807889f52bc043ecd31b79f814 refs/heads/master
#
# see contrib/hooks/ for an sample, or uncomment the next line (on debian)
#


#. /usr/share/doc/git-core/contrib/hooks/post-receive-email
</content>
		</actual_file>
		<actual_file>
			<filename>post-update</filename>
			<content>#!/bin/sh
#
# An example hook script to prepare a packed repository for use over
# dumb transports.
#
# To enable this hook, make this file executable by "chmod +x post-update".

exec git-update-server-info
</content>
		</actual_file>
		<actual_file>
			<filename>pre-applypatch</filename>
			<content>#!/bin/sh
#
# An example hook script to verify what is about to be committed
# by applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.
#
# To enable this hook, make this file executable.

. git-sh-setup
test -x "$GIT_DIR/hooks/pre-commit" &&
	exec "$GIT_DIR/hooks/pre-commit" ${1+"$@"}
:
</content>
		</actual_file>
		<actual_file>
			<filename>pre-commit</filename>
			<content>#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by git-commit with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message if
# it wants to stop the commit.
#
# To enable this hook, make this file executable.

# This is slightly modified from Andrew Morton's Perfect Patch.
# Lines you introduce should not have trailing whitespace.
# Also check for an indentation that has SP before a TAB.

if git-rev-parse --verify HEAD 2/dev/null
then
	git-diff-index -p -M --cached HEAD --
else
	# NEEDSWORK: we should produce a diff with an empty tree here
	# if we want to do the same verification for the initial import.
	:
fi |
perl -e '
    my $found_bad = 0;
    my $filename;
    my $reported_filename = "";
    my $lineno;
    sub bad_line {
	my ($why, $line) = @_;
	if (!$found_bad) {
	    print STDERR "*\n";
	    print STDERR "* You have some suspicious patch lines:\n";
	    print STDERR "*\n";
	    $found_bad = 1;
	}
	if ($reported_filename ne $filename) {
	    print STDERR "* In $filename\n";
	    $reported_filename = $filename;
	}
	print STDERR "* $why (line $lineno)\n";
	print STDERR "$filename:$lineno:$line\n";
    }
    while () {
	if (m|^diff --git a/(.*) b/\1$|) {
	    $filename = $1;
	    next;
	}
	if (/^@@ -\S+ \+(\d+)/) {
	    $lineno = $1 - 1;
	    next;
	}
	if (/^ /) {
	    $lineno++;
	    next;
	}
	if (s/^\+//) {
	    $lineno++;
	    chomp;
	    if (/\s$/) {
		bad_line("trailing whitespace", $_);
	    }
	    if (/^\s* \t/) {
		bad_line("indent SP followed by a TAB", $_);
	    }
	    if (/^([])\1{6} |^={7}$/) {
		bad_line("unresolved merge conflict", $_);
	    }
	}
    }
    exit($found_bad);
'
</content>
		</actual_file>
		<actual_file>
			<filename>pre-rebase</filename>
			<content>#!/bin/sh
#
# Copyright (c) 2006 Junio C Hamano
#

publish=next
basebranch="$1"
if test "$#" = 2
then
	topic="refs/heads/$2"
else
	topic=`git symbolic-ref HEAD`
fi

case "$basebranch,$topic" in
master,refs/heads/??/*)
	;;
*)
	exit 0 ;# we do not interrupt others.
	;;
esac

# Now we are dealing with a topic branch being rebased
# on top of master.  Is it OK to rebase it?

# Is topic fully merged to master?
not_in_master=`git-rev-list --pretty=oneline ^master "$topic"`
if test -z "$not_in_master"
then
	echo &2 "$topic is fully merged to master; better remove it."
	exit 1 ;# we could allow it, but there is no point.
fi

# Is topic ever merged to next?  If so you should not be rebasing it.
only_next_1=`git-rev-list ^master "^$topic" ${publish} | sort`
only_next_2=`git-rev-list ^master           ${publish} | sort`
if test "$only_next_1" = "$only_next_2"
then
	not_in_topic=`git-rev-list "^$topic" master`
	if test -z "$not_in_topic"
	then
		echo &2 "$topic is already up-to-date with master"
		exit 1 ;# we could allow it, but there is no point.
	else
		exit 0
	fi
else
	not_in_next=`git-rev-list --pretty=oneline ^${publish} "$topic"`
	perl -e '
		my $topic = $ARGV[0];
		my $msg = "* $topic has commits already merged to public branch:\n";
		my (%not_in_next) = map {
			/^([0-9a-f]+) /;
			($1 = 1);
		} split(/\n/, $ARGV[1]);
		for my $elem (map {
				/^([0-9a-f]+) (.*)$/;
				[$1 = $2];
			} split(/\n/, $ARGV[2])) {
			if (!exists $not_in_next{$elem-[0]}) {
				if ($msg) {
					print STDERR $msg;
					undef $msg;
				}
				print STDERR " $elem-[1]\n";
			}
		}
	' "$topic" "$not_in_next" "$not_in_master"
	exit 1
fi

exit 0

################################################################

This sample hook safeguards topic branches that have been
published from being rewound.

The workflow assumed here is:

 * Once a topic branch forks from "master", "master" is never
   merged into it again (either directly or indirectly).

 * Once a topic branch is fully cooked and merged into "master",
   it is deleted.  If you need to build on top of it to correct
   earlier mistakes, a new topic branch is created by forking at
   the tip of the "master".  This is not strictly necessary, but
   it makes it easier to keep your history simple.

 * Whenever you need to test or publish your changes to topic
   branches, merge them into "next" branch.

The script, being an example, hardcodes the publish branch name
to be "next", but it is trivial to make it configurable via
$GIT_DIR/config mechanism.

With this workflow, you would want to know:

(1) ... if a topic branch has ever been merged to "next".  Young
    topic branches can have stupid mistakes you would rather
    clean up before publishing, and things that have not been
    merged into other branches can be easily rebased without
    affecting other people.  But once it is published, you would
    not want to rewind it.

(2) ... if a topic branch has been fully merged to "master".
    Then you can delete it.  More importantly, you should not
    build on top of it -- other people may already want to
    change things related to the topic as patches against your
    "master", so if you need further changes, it is better to
    fork the topic (perhaps with the same name) afresh from the
    tip of "master".

Let's look at this example:

		   o---o---o---o---o---o---o---o---o---o "next"
		  /       /           /           /
		 /   a---a---b A     /           /
		/   /               /           /
	       /   /   c---c---c---c B         /
	      /   /   /             \         /
	     /   /   /   b---b C     \       /
	    /   /   /   /             \     /
    ---o---o---o---o---o---o---o---o---o---o---o "master"


A, B and C are topic branches.

 * A has one fix since it was merged up to "next".

 * B has finished.  It has been fully merged up to "master" and "next",
   and is ready to be deleted.

 * C has not merged to "next" at all.

We would want to allow C to be rebased, refuse A, and encourage
B to be deleted.

To compute (1):

	git-rev-list ^master ^topic next
	git-rev-list ^master        next

	if these match, topic has not merged in next at all.

To compute (2):

	git-rev-list master..topic

	if this is empty, it is fully merged to "master".
</content>
		</actual_file>
		<actual_file>
			<filename>prepare-commit-msg</filename>
			<content>#!/bin/sh
#
# An example hook script to prepare the commit log message.
# Called by git-commit with the name of the file that has the
# commit message, followed by the description of the commit
# message's source.  The hook's purpose is to edit the commit
# message file.  If the hook fails with a non-zero status,
# the commit is aborted.
#
# To enable this hook, make this file executable.

# This hook includes three examples.  The first comments out the
# "Conflicts:" part of a merge commit.
#
# The second includes the output of "git diff --name-status -r"
# into the message, just before the "git status" output.  It is
# commented because it doesn't cope with --amend or with squashed
# commits.
#
# The third example adds a Signed-off-by line to the message, that can
# still be edited.  This is rarely a good idea.

case "$2 $3" in
  merge)
    sed -i '/^Conflicts:/,/#/!b;s/^/# &/;s/^# #/#/' "$1" ;;

# ""|template)
#   perl -i -pe '
#      print "\n" . `git diff --cached --name-status -r`
#	 if /^#/ && $first++ == 0' "$1" ;;

  *) ;;
esac

# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*\).*$/Signed-off-by: \1/p')
# grep -qs "^$SOB" "$1" || echo "$SOB"  "$1"
</content>
		</actual_file>
		<actual_file>
			<filename>update</filename>
			<content>#!/bin/sh
#
# An example hook script to blocks unannotated tags from entering.
# Called by git-receive-pack with arguments: refname sha1-old sha1-new
#
# To enable this hook, make this file executable by "chmod +x update".
#
# Config
# ------
# hooks.allowunannotated
#   This boolean sets whether unannotated tags will be allowed into the
#   repository.  By default they won't be.
# hooks.allowdeletetag
#   This boolean sets whether deleting tags will be allowed in the
#   repository.  By default they won't be.
# hooks.allowdeletebranch
#   This boolean sets whether deleting branches will be allowed in the
#   repository.  By default they won't be.
#

# --- Command line
refname="$1"
oldrev="$2"
newrev="$3"

# --- Safety check
if [ -z "$GIT_DIR" ]; then
	echo "Don't run this script from the command line." &2
	echo " (if you want, you could supply GIT_DIR then run" &2
	echo "  $0 ref oldrev newrev)" &2
	exit 1
fi

if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
	echo "Usage: $0 ref oldrev newrev" &2
	exit 1
fi

# --- Config
allowunannotated=$(git config --bool hooks.allowunannotated)
allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
allowdeletetag=$(git config --bool hooks.allowdeletetag)

# check for no description
projectdesc=$(sed -e '1q' "$GIT_DIR/description")
if [ -z "$projectdesc" -o "$projectdesc" = "Unnamed repository; edit this file to name it for gitweb." ]; then
	echo "*** Project description file hasn't been set" &2
	exit 1
fi

# --- Check types
# if $newrev is 0000...0000, it's a commit to delete a ref.
if [ "$newrev" = "0000000000000000000000000000000000000000" ]; then
	newrev_type=delete
else
	newrev_type=$(git-cat-file -t $newrev)
fi

case "$refname","$newrev_type" in
	refs/tags/*,commit)
		# un-annotated tag
		short_refname=${refname##refs/tags/}
		if [ "$allowunannotated" != "true" ]; then
			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" &2
			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." &2
			exit 1
		fi
		;;
	refs/tags/*,delete)
		# delete tag
		if [ "$allowdeletetag" != "true" ]; then
			echo "*** Deleting a tag is not allowed in this repository" &2
			exit 1
		fi
		;;
	refs/tags/*,tag)
		# annotated tag
		;;
	refs/heads/*,commit)
		# branch
		;;
	refs/heads/*,delete)
		# delete branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a branch is not allowed in this repository" &2
			exit 1
		fi
		;;
	refs/remotes/*,commit)
		# tracking branch
		;;
	refs/remotes/*,delete)
		# delete tracking branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a tracking branch is not allowed in this repository" &2
			exit 1
		fi
		;;
	*)
		# Anything else (is there anything else?)
		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" &2
		exit 1
		;;
esac

# --- Finished
exit 0
</content>
		</actual_file>
		<actual_file>
			<filename>exclude</filename>
			<content># git-ls-files --others --exclude-from=.git/info/exclude
# Lines that start with '#' are comments.
# For a project mostly in C, the following would be a good set of
# exclude patterns (uncomment them if you want to use them):
# *.[oa]
# *~
</content>
		</actual_file>
		<actual_file>
			<filename>alternates</filename>
			<content>../../dot_git_clone/objects
</content>
		</actual_file>
		<actual_file>
			<filename>master</filename>
			<content>ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a
</content>
		</actual_file>
		<actual_file>
			<filename>nonpack</filename>
			<content>ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a
</content>
		</actual_file>
		<actual_file>
			<filename>testing</filename>
			<content>2d3acf90f35989df8f262dc50beadc4ee3ae1560
</content>
		</actual_file>
		<actual_file>
			<filename>chacon</filename>
			<content>ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a
</content>
		</actual_file>
		<actual_file>
			<filename>v0.7.0</filename>
			<content>f0055fda16c18fd8b27986dbf038c735b82198d7
</content>
		</actual_file>
		<actual_file>
			<filename>config</filename>
			<content>[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
[remote "origin"]
	url = git@github.com:schacon/grit.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch "master"]
	remote = origin
	merge = refs/heads/master
</content>
		</actual_file>
		<actual_file>
			<filename>description</filename>
			<content>Unnamed repository; edit this file to name it for gitweb.
</content>
		</actual_file>
		<actual_file>
			<filename>HEAD</filename>
			<content>ref: refs/heads/master
</content>
		</actual_file>
		<actual_file>
			<filename>packed-refs</filename>
			<content># pack-refs with: peeled 
ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a refs/heads/master
ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a refs/heads/nonpack
ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a refs/heads/test/chacon
2d3acf90f35989df8f262dc50beadc4ee3ae1560 refs/heads/test/master
2d3acf90f35989df8f262dc50beadc4ee3ae1560 refs/heads/testing
ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a refs/remotes/origin/master
2d3acf90f35989df8f262dc50beadc4ee3ae1560 refs/remotes/tom/master
f0055fda16c18fd8b27986dbf038c735b82198d7 refs/tags/v0.7.0
^7bcc0ee821cdd133d8a53e8e7173a334fef448aa
</content>
		</actual_file>
		<actual_file>
			<filename>exclude</filename>
			<content># git-ls-files --others --exclude-from=.git/info/exclude
# Lines that start with '#' are comments.
# For a project mostly in C, the following would be a good set of
# exclude patterns (uncomment them if you want to use them):
# *.[oa]
# *~
</content>
		</actual_file>
		<actual_file>
			<filename>refs</filename>
			<content>ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a	refs/heads/master
ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a	refs/heads/nonpack
ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a	refs/heads/test/chacon
2d3acf90f35989df8f262dc50beadc4ee3ae1560	refs/heads/test/master
2d3acf90f35989df8f262dc50beadc4ee3ae1560	refs/heads/testing
ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a	refs/remotes/origin/HEAD
ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a	refs/remotes/origin/master
2d3acf90f35989df8f262dc50beadc4ee3ae1560	refs/remotes/tom/master
f0055fda16c18fd8b27986dbf038c735b82198d7	refs/tags/v0.7.0
7bcc0ee821cdd133d8a53e8e7173a334fef448aa	refs/tags/v0.7.0^{}
</content>
		</actual_file>
		<actual_file>
			<filename>alternates</filename>
			<content></content>
		</actual_file>
		<actual_file>
			<filename>packs</filename>
			<content>P pack-4eb8bbafbe65e4f3841581537735fc5d448759c5.pack
P pack-c8881c2613522dc3ac69af9c7b4881a061aaec8c.pack

</content>
		</actual_file>
		<actual_file>
			<filename>pack-c8881c2613522dc3ac69af9c7b4881a061aaec8c.keep</filename>
			<content>fetch-pack 3903 on agadorsparticus
</content>
		</actual_file>
		<actual_file>
			<filename>HEAD</filename>
			<content>ref: refs/remotes/origin/master
</content>
		</actual_file>
		<actual_file>
			<filename>config</filename>
			<content>[core]
	repositoryformatversion = 0
	filemode = true
	bare = true
</content>
		</actual_file>
		<actual_file>
			<filename>description</filename>
			<content>Unnamed repository; edit this file 'description' to name the repository.
</content>
		</actual_file>
		<actual_file>
			<filename>HEAD</filename>
			<content>ref: refs/heads/master
</content>
		</actual_file>
		<actual_file>
			<filename>exclude</filename>
			<content># git-ls-files --others --exclude-from=.git/info/exclude
# Lines that start with '#' are comments.
# For a project mostly in C, the following would be a good set of
# exclude patterns (uncomment them if you want to use them):
# *.[oa]
# *~
</content>
		</actual_file>
		<actual_file>
			<filename>branch_one</filename>
			<content>8f4094b31327dd0223979adc288e2b12ca86b0a1
</content>
		</actual_file>
		<actual_file>
			<filename>master</filename>
			<content>2edb031f77340b65a897e8536ad75f7b7596a607
</content>
		</actual_file>
		<actual_file>
			<filename>blame</filename>
			<content>634396b2f541a9f2d58b00be1a07f0c358b999b3 1 1 7
author Tom Preston-Werner
author-mail tom@mojombo.com
author-time 1191997100
author-tz -0700
committer Tom Preston-Werner
committer-mail tom@mojombo.com
committer-time 1191997100
committer-tz -0700
filename lib/grit.rb
summary initial grit setup
boundary
	$:.unshift File.dirname(__FILE__)     # For use/testing when no gem is installed
634396b2f541a9f2d58b00be1a07f0c358b999b3 2 2
	
634396b2f541a9f2d58b00be1a07f0c358b999b3 3 3
	# core
634396b2f541a9f2d58b00be1a07f0c358b999b3 4 4
	
634396b2f541a9f2d58b00be1a07f0c358b999b3 5 5
	# stdlib
634396b2f541a9f2d58b00be1a07f0c358b999b3 6 6
	
634396b2f541a9f2d58b00be1a07f0c358b999b3 7 7
	# internal requires
3b1930208a82457747d76729ae088e90edca4673 8 8 1
author Tom Preston-Werner
author-mail tom@mojombo.com
author-time 1192267241
author-tz -0700
committer Tom Preston-Werner
committer-mail tom@mojombo.com
committer-time 1192267241
committer-tz -0700
filename lib/grit.rb
summary big refactor to do lazy loading
	require 'grit/lazy'
4c8124ffcf4039d292442eeccabdeca5af5c5017 8 9 1
author Tom Preston-Werner
author-mail tom@mojombo.com
author-time 1191999972
author-tz -0700
committer Tom Preston-Werner
committer-mail tom@mojombo.com
committer-time 1191999972
committer-tz -0700
filename lib/grit.rb
summary implement Grit#heads
	require 'grit/errors'
d01a4cfad6ea50285c4710243e3cbe019d381eba 9 10 1
author Tom Preston-Werner
author-mail tom@mojombo.com
author-time 1192032303
author-tz -0700
committer Tom Preston-Werner
committer-mail tom@mojombo.com
committer-time 1192032303
committer-tz -0700
filename lib/grit.rb
summary convert to Grit module, refactor to be more OO
	require 'grit/git'
4c8124ffcf4039d292442eeccabdeca5af5c5017 9 11 1
	require 'grit/head'
a47fd41f3aa4610ea527dcc1669dfdb9c15c5425 10 12 1
author Tom Preston-Werner
author-mail tom@mojombo.com
author-time 1192002639
author-tz -0700
committer Tom Preston-Werner
committer-mail tom@mojombo.com
committer-time 1192002639
committer-tz -0700
filename lib/grit.rb
summary add more comments throughout
	require 'grit/commit'
b17b974691f0a26f26908495d24d9c4c718920f8 13 13 1
author Tom Preston-Werner
author-mail tom@mojombo.com
author-time 1192271832
author-tz -0700
committer Tom Preston-Werner
committer-mail tom@mojombo.com
committer-time 1192271832
committer-tz -0700
filename lib/grit.rb
summary started implementing Tree
	require 'grit/tree'
74fd66519e983a0f29e16a342a6059dbffe36020 14 14 1
author Tom Preston-Werner
author-mail tom@mojombo.com
author-time 1192317005
author-tz -0700
committer Tom Preston-Werner
committer-mail tom@mojombo.com
committer-time 1192317005
committer-tz -0700
filename lib/grit.rb
summary add Blob
	require 'grit/blob'
d01a4cfad6ea50285c4710243e3cbe019d381eba 12 15 1
	require 'grit/repo'
634396b2f541a9f2d58b00be1a07f0c358b999b3 9 16 1
	
d01a4cfad6ea50285c4710243e3cbe019d381eba 14 17 1
	module Grit
b6e1b765e0c15586a2c5b9832854f95defd71e1f 18 18 6
author Tom Preston-Werner
author-mail tom@mojombo.com
author-time 1192860483
author-tz -0700
committer Tom Preston-Werner
committer-mail tom@mojombo.com
committer-time 1192860483
committer-tz -0700
filename lib/grit.rb
summary implement Repo.init_bare
	  class  self
b6e1b765e0c15586a2c5b9832854f95defd71e1f 19 19
	    attr_accessor :debug
b6e1b765e0c15586a2c5b9832854f95defd71e1f 20 20
	  end
b6e1b765e0c15586a2c5b9832854f95defd71e1f 21 21
	  
b6e1b765e0c15586a2c5b9832854f95defd71e1f 22 22
	  self.debug = false
b6e1b765e0c15586a2c5b9832854f95defd71e1f 23 23
	  
634396b2f541a9f2d58b00be1a07f0c358b999b3 11 24 2
	  VERSION = '1.0.0'
634396b2f541a9f2d58b00be1a07f0c358b999b3 12 25
	end</content>
		</actual_file>
		<actual_file>
			<filename>cat_file_blob</filename>
			<content>Hello world</content>
		</actual_file>
		<actual_file>
			<filename>cat_file_blob_ruby</filename>
			<content>== 0.7.0 / 2008-01-07

* 1 major enhancement
  * First public release!

</content>
		</actual_file>
		<actual_file>
			<filename>cat_file_blob_size</filename>
			<content>11
</content>
		</actual_file>
		<actual_file>
			<filename>cat_file_commit_ruby</filename>
			<content>tree 77fc9894c0904279fde93adc9c0ba231515ce68a
parent 30e367cef2203eba2b341dc9050993b06fd1e108
parent 420eac97a826bfac8724b6b0eef35c20922124b7
author Tom Preston-Werner tom@mojombo.com 1208054148 -0700
committer Tom Preston-Werner tom@mojombo.com 1208054148 -0700

Merge branch 'master' of git://github.com/dustin/grit
</content>
		</actual_file>
		<actual_file>
			<filename>cat_file_tree_ruby</filename>
			<content>100644 blob baaa47163a922b716898936f4ab032db4e08ae8a	.gitignore
100644 blob 4232d073306f01cf0b895864e5a5cfad7dd76fce	History.txt
100644 blob 22158f1075113476d332d6f5112cf948f38ae658	Manifest.txt
100644 blob dd53bb4983125be6a5b2cc7ac9e89d75804a6a73	README.txt
100644 blob fdbea19c6688404f2a65767d8f889a0acdb0b25a	Rakefile
040000 tree a93f4c338734259d8ae577b16537ad6b99a90937	lib
040000 tree ce9b0e78f28d705665030d29d72515f86c28b2b3	test
</content>
		</actual_file>
		<actual_file>
			<filename>commit</filename>
			<content>Created commit 005b873: my test commit
 1 files changed, 1 insertions(+), 0 deletions(-)
 create mode 100644 doc
</content>
		</actual_file>
		<actual_file>
			<filename>diff_2</filename>
			<content>diff --git a/lib/grit/commit.rb b/lib/grit/commit.rb
index a093bb1db8e884cccf396b297259181d1caebed4..80fd3d527f269ecbd570b65b8e21fd85baedb6e9 100644
--- a/lib/grit/commit.rb
+++ b/lib/grit/commit.rb
@@ -156,12 +156,8 @@ module Grit
 
     def diffs
       if parents.empty?
-        diff = @repo.git.show({:full_index = true, :pretty = 'raw'}, @id)
-        if diff =~ /diff --git a/
-          diff = diff.sub(/.+?(diff --git a)/m, '\1')
-        else
-          diff = ''
-        end
+        diff = @repo.git.show({:full_index = true, :pretty = 'raw'}, @id) 
+        diff = diff.sub(/.+?(diff --git a)/m, '\1')
         Diff.list_from_string(@repo, diff)
       else
         self.class.diff(@repo, parents.first.id, @id) 
diff --git a/test/fixtures/show_empty_commit b/test/fixtures/show_empty_commit
deleted file mode 100644
index ea25e32a409fdf74c1b9268820108d1c16dcc553..0000000000000000000000000000000000000000
--- a/test/fixtures/show_empty_commit
+++ /dev/null
@@ -1,6 +0,0 @@
-commit 1e3824339762bd48316fe87bfafc853732d43264
-tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904
-author Tom Preston-Werner tom@mojombo.com 1157392833 +0000
-committer Tom Preston-Werner tom@mojombo.com 1157392833 +0000
-
-    initial directory structure
diff --git a/test/test_commit.rb b/test/test_commit.rb
index fdeb9000089b052f0b31a845e0173e9b089e06a0..bdbc450e08084d7d611e985cfa12fb424cab29b2 100644
--- a/test/test_commit.rb
+++ b/test/test_commit.rb
@@ -98,18 +98,6 @@ class TestCommit  Test::Unit::TestCase
     assert_equal true, diffs[5].new_file
   end
   
-  def test_diffs_on_initial_import_with_empty_commit
-    Git.any_instance.expects(:show).with(
-      {:full_index = true, :pretty = 'raw'}, 
-      '634396b2f541a9f2d58b00be1a07f0c358b999b3'
-    ).returns(fixture('show_empty_commit'))
-    
-    @c = Commit.create(@r, :id = '634396b2f541a9f2d58b00be1a07f0c358b999b3')
-    diffs = @c.diffs
-    
-    assert_equal [], diffs
-  end
-  
   # to_s
   
   def test_to_s
</content>
		</actual_file>
		<actual_file>
			<filename>diff_2f</filename>
			<content>diff --git a/lib/grit/commit.rb b/lib/grit/commit.rb
index a093bb1db8e884cccf396b297259181d1caebed4..80fd3d527f269ecbd570b65b8e21fd85baedb6e9 100644
--- a/lib/grit/commit.rb
+++ b/lib/grit/commit.rb
@@ -156,12 +156,8 @@ module Grit
 
     def diffs
       if parents.empty?
-        diff = @repo.git.show({:full_index = true, :pretty = 'raw'}, @id)
-        if diff =~ /diff --git a/
-          diff = diff.sub(/.+?(diff --git a)/m, '\1')
-        else
-          diff = ''
-        end
+        diff = @repo.git.show({:full_index = true, :pretty = 'raw'}, @id) 
+        diff = diff.sub(/.+?(diff --git a)/m, '\1')
         Diff.list_from_string(@repo, diff)
       else
         self.class.diff(@repo, parents.first.id, @id) 
</content>
		</actual_file>
		<actual_file>
			<filename>diff_f</filename>
			<content>diff --git a/lib/grit/diff.rb b/lib/grit/diff.rb
index 537955bb86a8ceaa19aea89e75ccbea5ce6f2698..00b0b4a67eca9242db5f8991e99625acd55f040c 100644
--- a/lib/grit/diff.rb
+++ b/lib/grit/diff.rb
@@ -27,6 +27,10 @@ module Grit
       while !lines.empty?
         m, a_path, b_path = *lines.shift.match(%r{^diff --git a/(\S+) b/(\S+)$})
         
+        if lines.first =~ /^old mode/
+          2.times { lines.shift }
+        end
+        
         new_file = false
         deleted_file = false
         
</content>
		</actual_file>
		<actual_file>
			<filename>diff_files</filename>
			<content>:100644 100644 5f3988355e1c811fbf9e0ce7f4582aa4a4ae20d2 0000000000000000000000000000000000000000 M	PURE_TODO
:100644 100644 62a6be213ccc3c770b97481d0e73eb1b2ee46547 0000000000000000000000000000000000000000 M	lib/grit.rb
:100644 100644 71e930d551c413a123f43e35c632ea6ba3e3705e 0000000000000000000000000000000000000000 M	lib/grit/repo.rb
:100644 100644 48412bac5814d476ba98550b4674189ecf514087 0000000000000000000000000000000000000000 M	test/test_commit.rb</content>
		</actual_file>
		<actual_file>
			<filename>diff_i</filename>
			<content>commit 634396b2f541a9f2d58b00be1a07f0c358b999b3
Author: Tom Preston-Werner tom@mojombo.com
Date:   Tue Oct 9 23:18:20 2007 -0700

    initial grit setup

diff --git a/History.txt b/History.txt
new file mode 100644
index 0000000000000000000000000000000000000000..81d2c27608b352814cbe979a6acd678d30219678
--- /dev/null
+++ b/History.txt
@@ -0,0 +1,5 @@
+== 1.0.0 / 2007-10-09
+
+* 1 major enhancement
+  * Birthday!
+
diff --git a/Manifest.txt b/Manifest.txt
new file mode 100644
index 0000000000000000000000000000000000000000..641972d82c6d1b51122274ae8f6a0ecdfb56ee22
--- /dev/null
+++ b/Manifest.txt
@@ -0,0 +1,7 @@
+History.txt
+Manifest.txt
+README.txt
+Rakefile
+bin/grit
+lib/grit.rb
+test/test_grit.rb
\ No newline at end of file
diff --git a/README.txt b/README.txt
new file mode 100644
index 0000000000000000000000000000000000000000..8b1e02c0fb554eed2ce2ef737a68bb369d7527df
--- /dev/null
+++ b/README.txt
@@ -0,0 +1,48 @@
+grit
+    by FIX (your name)
+    FIX (url)
+
+== DESCRIPTION:
+  
+FIX (describe your package)
+
+== FEATURES/PROBLEMS:
+  
+* FIX (list of features or problems)
+
+== SYNOPSIS:
+
+  FIX (code sample of usage)
+
+== REQUIREMENTS:
+
+* FIX (list of requirements)
+
+== INSTALL:
+
+* FIX (sudo gem install, anything else)
+
+== LICENSE:
+
+(The MIT License)
+
+Copyright (c) 2007 FIX
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+'Software'), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/Rakefile b/Rakefile
new file mode 100644
index 0000000000000000000000000000000000000000..ff69c3684a18592c741332b290492aa39d980e02
--- /dev/null
+++ b/Rakefile
@@ -0,0 +1,17 @@
+# -*- ruby -*-
+
+require 'rubygems'
+require 'hoe'
+require './lib/grit.rb'
+
+Hoe.new('grit', Grit::VERSION) do |p|
+  p.rubyforge_name = 'grit'
+  # p.author = 'FIX'
+  # p.email = 'FIX'
+  # p.summary = 'FIX'
+  # p.description = p.paragraphs_of('README.txt', 2..5).join("\n\n")
+  # p.url = p.paragraphs_of('README.txt', 0).first.split(/\n/)[1..-1]
+  p.changes = p.paragraphs_of('History.txt', 0..1).join("\n\n")
+end
+
+# vim: syntax=Ruby
diff --git a/bin/grit b/bin/grit
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
diff --git a/lib/grit.rb b/lib/grit.rb
new file mode 100644
index 0000000000000000000000000000000000000000..32cec87d1e78946a827ddf6a8776be4d81dcf1d1
--- /dev/null
+++ b/lib/grit.rb
@@ -0,0 +1,12 @@
+$:.unshift File.dirname(__FILE__)     # For use/testing when no gem is installed
+
+# core
+
+# stdlib
+
+# internal requires
+require 'grit/grit'
+
+class Grit
+  VERSION = '1.0.0'
+end
\ No newline at end of file
diff --git a/lib/grit/errors.rb b/lib/grit/errors.rb
new file mode 100644
index 0000000000000000000000000000000000000000..b3be31553741937607a89be8b6a2ab1df208852e
--- /dev/null
+++ b/lib/grit/errors.rb
@@ -0,0 +1,4 @@
+class Grit
+  class InvalidGitRepositoryError  StandardError
+  end
+end
\ No newline at end of file
diff --git a/lib/grit/grit.rb b/lib/grit/grit.rb
new file mode 100644
index 0000000000000000000000000000000000000000..48fd36e16081ec09903f7a0e2253b3d16f9efb01
--- /dev/null
+++ b/lib/grit/grit.rb
@@ -0,0 +1,24 @@
+class Grit
+  attr_accessor :path
+  
+  # Create a new Grit instance
+  #   +path+ is the path to either the root git directory or the bare git repo
+  #
+  # Examples
+  #   g = Grit.new("/Users/tom/dev/grit")
+  #   g = Grit.new("/Users/tom/public/grit.git")
+  def initialize(path)
+    if File.exist?(File.join(path, '.git'))
+      self.path = File.join(path, '.git')
+    elsif File.exist?(path) && path =~ /\.git$/
+      self.path = path
+    else
+      raise InvalidGitRepositoryError.new(path) unless File.exist?(path)
+    end
+  end
+  
+  # Return the project's description. Taken verbatim from REPO/description
+  def description
+    File.open(File.join(self.path, 'description')).read.chomp
+  end
+end
\ No newline at end of file
diff --git a/test/helper.rb b/test/helper.rb
new file mode 100644
index 0000000000000000000000000000000000000000..56e21da6b4ce3021d2754775dfa589947a4e37e5
--- /dev/null
+++ b/test/helper.rb
@@ -0,0 +1,5 @@
+require File.join(File.dirname(__FILE__), *%w[.. lib grit])
+
+require 'test/unit'
+
+GRIT_REPO = File.join(File.dirname(__FILE__), *%w[..])
diff --git a/test/test_grit.rb b/test/test_grit.rb
new file mode 100644
index 0000000000000000000000000000000000000000..93aa481b37629797df739380306ae689e13f2855
--- /dev/null
+++ b/test/test_grit.rb
@@ -0,0 +1,11 @@
+require File.dirname(__FILE__) + '/helper'
+
+class TestGrit  Test::Unit::TestCase
+  def setup
+    @g = Grit.new(GRIT_REPO)
+  end
+  
+  def test_description
+    assert_equal "Grit is a ruby library for interfacing with git repositories.", @g.description
+  end
+end
\ No newline at end of file
</content>
		</actual_file>
		<actual_file>
			<filename>diff_index</filename>
			<content>:000000 100644 0000000000000000000000000000000000000000 dd6736a01e3560e56a3c7685ddc513f9e1dc2d89 A	API.txt
:100644 100644 5f3988355e1c811fbf9e0ce7f4582aa4a4ae20d2 0000000000000000000000000000000000000000 M	PURE_TODO
:100644 100644 62a6be213ccc3c770b97481d0e73eb1b2ee46547 0000000000000000000000000000000000000000 M	lib/grit.rb
:100644 100644 71e930d551c413a123f43e35c632ea6ba3e3705e 0000000000000000000000000000000000000000 M	lib/grit/repo.rb
:100644 100644 48412bac5814d476ba98550b4674189ecf514087 0000000000000000000000000000000000000000 M	test/test_commit.rb</content>
		</actual_file>
		<actual_file>
			<filename>diff_mode_only</filename>
			<content>diff --git a/bin/merb b/bin/merb
old mode 100644
new mode 100755
diff --git a/lib/merb.rb b/lib/merb.rb
index 76cb3e269e46fdf9b63cda7cb563c6cf40fdcb15..a2ab4ed47f9cb2ab942da5c46a2b561758a0d704 100644
--- a/lib/merb.rb
+++ b/lib/merb.rb
@@ -15,7 +15,7 @@ require 'merb_core/core_ext'
 require 'merb_core/gem_ext/erubis'
 require 'merb_core/logger'
 require 'merb_core/version'
-
+require 'merb_core/controller/mime'
 
 module Merb
   class  self
@@ -23,6 +23,7 @@ module Merb
     def start(argv=ARGV)
       Merb::Config.parse_args(argv)
       BootLoader.run
+      
       case Merb::Config[:adapter]
       when "mongrel"
         adapter = Merb::Rack::Mongrel
diff --git a/lib/merb_core/boot/bootloader.rb b/lib/merb_core/boot/bootloader.rb
index d873924860bf4da06ac93db5c6a188f63dd1c3cc..57da75f05e28e8a256922bf345ccd3902e0a0b02 100644
--- a/lib/merb_core/boot/bootloader.rb
+++ b/lib/merb_core/boot/bootloader.rb
@@ -20,7 +20,7 @@ module Merb
       end
       
       def run
-        subclasses.each {|klass| Object.full_const_get(klass).new.run }
+        subclasses.each {|klass| Object.full_const_get(klass).run }
       end
       
       def after(klass)
@@ -37,95 +37,128 @@ module Merb
   
 end
 
-class Merb::BootLoader::BuildFramework  Merb::BootLoader
-  def run
-    build_framework
+class Merb::BootLoader::LoadInit  Merb::BootLoader
+  def self.run
+    if Merb::Config[:init_file]
+      require Merb.root / Merb::Config[:init_file]
+    elsif File.exists?(Merb.root / "config" / "merb_init.rb")
+      require Merb.root / "config" / "merb_init"
+    elsif File.exists?(Merb.root / "merb_init.rb")
+      require Merb.root / "merb_init"
+    elsif File.exists?(Merb.root / "application.rb")
+      require Merb.root / "application"
+    end
+  end
+end
+
+class Merb::BootLoader::Environment  Merb::BootLoader
+  def self.run
+    Merb.environment = Merb::Config[:environment]
+  end
+end
+
+class Merb::BootLoader::Logger  Merb::BootLoader
+  def self.run
+    Merb.logger = Merb::Logger.new(Merb.dir_for(:log) / "test_log")
+    Merb.logger.level = Merb::Logger.const_get(Merb::Config[:log_level].upcase) rescue Merb::Logger::INFO    
   end
+end
+
+class Merb::BootLoader::BuildFramework  Merb::BootLoader
+  class  self
+    def run
+      build_framework
+    end
   
-  # This method should be overridden in merb_init.rb before Merb.start to set up a different
-  # framework structure
-  def build_framework
-    %[view model controller helper mailer part].each do |component|
-      Merb.push_path(component.to_sym, Merb.root_path("app/#{component}s"))
+    # This method should be overridden in merb_init.rb before Merb.start to set up a different
+    # framework structure
+    def build_framework
+      %w[view model controller helper mailer part].each do |component|
+        Merb.push_path(component.to_sym, Merb.root_path("app/#{component}s"))
+      end
+      Merb.push_path(:application,    Merb.root_path("app/controllers/application.rb"))
+      Merb.push_path(:config,         Merb.root_path("config/router.rb"))
+      Merb.push_path(:lib,            Merb.root_path("lib"))    
     end
-    Merb.push_path(:application,    Merb.root_path("app/controllers/application.rb"))
-    Merb.push_path(:config,         Merb.root_path("config/router.rb"))
-    Merb.push_path(:lib,            Merb.root_path("lib"))    
   end
 end
 
 class Merb::BootLoader::LoadPaths  Merb::BootLoader
   LOADED_CLASSES = {}
   
-  def run
-    # Add models, controllers, and lib to the load path
-    $LOAD_PATH.unshift Merb.load_paths[:model].first      if Merb.load_paths[:model]
-    $LOAD_PATH.unshift Merb.load_paths[:controller].first if Merb.load_paths[:controller]
-    $LOAD_PATH.unshift Merb.load_paths[:lib].first        if Merb.load_paths[:lib]
+  class  self
+    def run
+      # Add models, controllers, and lib to the load path
+      $LOAD_PATH.unshift Merb.load_paths[:model].first      if Merb.load_paths[:model]
+      $LOAD_PATH.unshift Merb.load_paths[:controller].first if Merb.load_paths[:controller]
+      $LOAD_PATH.unshift Merb.load_paths[:lib].first        if Merb.load_paths[:lib]
     
-    # Require all the files in the registered load paths
-    puts Merb.load_paths.inspect
-    Merb.load_paths.each do |name, path|
-      Dir[path.first / path.last].each do |file| 
-        klasses = ObjectSpace.classes.dup
-        require f
-        LOADED_CLASSES[file] = ObjectSpace.classes - klasses
+      # Require all the files in the registered load paths
+      puts Merb.load_paths.inspect
+      Merb.load_paths.each do |name, path|
+        Dir[path.first / path.last].each do |file| 
+          klasses = ObjectSpace.classes.dup
+          require file
+          LOADED_CLASSES[file] = ObjectSpace.classes - klasses
+        end
       end
     end
-  end
 
-  def reload(file)
-    if klasses = LOADED_CLASSES[file]
-      klasses.each do |klass|
-        remove_constant(klass)
+    def reload(file)
+      if klasses = LOADED_CLASSES[file]
+        klasses.each do |klass|
+          remove_constant(klass)
+        end
       end
+      load file
     end
-    load file
-  end
   
-  def remove_constant(const)
-    # This is to support superclasses (like AbstractController) that track
-    # their subclasses in a class variable. Classes that wish to use this
-    # functionality are required to alias it to _subclasses_list. Plugins
-    # for ORMs and other libraries should keep this in mind.
-    if klass.superclass.respond_to?(:_subclasses_list)
-      klass.superclass.send(:_subclasses_list).delete(klass)
-      klass.superclass.send(:_subclasses_list).delete(klass.to_s)          
-    end
+    def remove_constant(const)
+      # This is to support superclasses (like AbstractController) that track
+      # their subclasses in a class variable. Classes that wish to use this
+      # functionality are required to alias it to _subclasses_list. Plugins
+      # for ORMs and other libraries should keep this in mind.
+      if klass.superclass.respond_to?(:_subclasses_list)
+        klass.superclass.send(:_subclasses_list).delete(klass)
+        klass.superclass.send(:_subclasses_list).delete(klass.to_s)          
+      end
   
-    parts = const.to_s.split("::")
-    base = parts.size == 1 ? Object : Object.full_const_get(parts[0..-2].join("::"))
-    object = parts[-1].intern
-    Merb.logger.debugger("Removing constant #{object} from #{base}")
-    base.send(:remove_const, object) if object
+      parts = const.to_s.split("::")
+      base = parts.size == 1 ? Object : Object.full_const_get(parts[0..-2].join("::"))
+      object = parts[-1].intern
+      Merb.logger.debugger("Removing constant #{object} from #{base}")
+      base.send(:remove_const, object) if object
+    end
   end
   
 end
 
 class Merb::BootLoader::Templates  Merb::BootLoader
-  def run
-    template_paths.each do |path|
-      Merb::Template.inline_template(path)
+  class  self
+    def run
+      template_paths.each do |path|
+        Merb::Template.inline_template(path)
+      end
     end
-  end
   
-  def template_paths
-    extension_glob = "{#{Merb::Template::EXTENSIONS.keys.join(',')}}"
+    def template_paths
+      extension_glob = "{#{Merb::Template::EXTENSIONS.keys.join(',')}}"
 
-    # This gets all templates set in the controllers template roots        
-    # We separate the two maps because most of controllers will have
-    # the same _template_root, so it's silly to be globbing the same
-    # path over and over.
-    template_paths = Merb::AbstractController._abstract_subclasses.map do |klass| 
-      Object.full_const_get(klass)._template_root
-    end.uniq.map {|path| Dir["#{path}/**/*.#{extension_glob}"] }
+      # This gets all templates set in the controllers template roots        
+      # We separate the two maps because most of controllers will have
+      # the same _template_root, so it's silly to be globbing the same
+      # path over and over.
+      template_paths = Merb::AbstractController._abstract_subclasses.map do |klass| 
+        Object.full_const_get(klass)._template_root
+      end.uniq.compact.map {|path| Dir["#{path}/**/*.#{extension_glob}"] }
     
-    # This gets the templates that might be created outside controllers
-    # template roots.  eg app/views/shared/*
-    template_paths  Dir["#{Merb.dir_for(:view)}/**/*.#{extension_glob}"] if Merb.dir_for(:view)
+      # This gets the templates that might be created outside controllers
+      # template roots.  eg app/views/shared/*
+      template_paths  Dir["#{Merb.dir_for(:view)}/**/*.#{extension_glob}"] if Merb.dir_for(:view)
     
-    template_paths.flatten.compact.uniq
-  end  
+      template_paths.flatten.compact.uniq
+    end
+  end
 end
 
 class Merb::BootLoader::Libraries  Merb::BootLoader
@@ -145,18 +178,41 @@ class Merb::BootLoader::Libraries  Merb::BootLoader
   def self.add_libraries(hsh)
     @@libraries.merge!(hsh)
   end
-  
-  def run
+
+  def self.run
     @@libraries.each do |exclude, choices|
       require_first_working(*choices) unless Merb::Config[exclude]
     end
   end
-  
-  def require_first_working(first, *rest)
+
+  def self.require_first_working(first, *rest)
     p first, rest
     require first
   rescue LoadError
     raise LoadError if rest.empty?
     require_first_working rest.unshift, *rest
   end
+end
+
+class Merb::BootLoader::MimeTypes  Merb::BootLoader
+  def self.run
+    # Sets the default mime-types
+    # 
+    # By default, the mime-types include:
+    # :all:: no transform, */*
+    # :yaml:: to_yaml, application/x-yaml or text/yaml
+    # :text:: to_text, text/plain
+    # :html:: to_html, text/html or application/xhtml+xml or application/html
+    # :xml:: to_xml, application/xml or text/xml or application/x-xml, adds "Encoding: UTF-8" response header
+    # :js:: to_json, text/javascript ot application/javascript or application/x-javascript
+    # :json:: to_json, application/json or text/x-json
+    Merb.available_mime_types.clear
+    Merb.add_mime_type(:all,  nil,      %w[*/*])
+    Merb.add_mime_type(:yaml, :to_yaml, %w[application/x-yaml text/yaml])
+    Merb.add_mime_type(:text, :to_text, %w[text/plain])
+    Merb.add_mime_type(:html, :to_html, %w[text/html application/xhtml+xml application/html])
+    Merb.add_mime_type(:xml,  :to_xml,  %w[application/xml text/xml application/x-xml], :Encoding = "UTF-8")
+    Merb.add_mime_type(:js,   :to_json, %w[text/javascript application/javascript application/x-javascript])
+    Merb.add_mime_type(:json, :to_json, %w[application/json text/x-json])      
+  end
 end
\ No newline at end of file
diff --git a/lib/merb_core/config.rb b/lib/merb_core/config.rb
index c92f2e6f071c234551ecb16a4716d47fa92f6c7b..ab0864e0174b54833c758f9f22a840d3b53c7653 100644
--- a/lib/merb_core/config.rb
+++ b/lib/merb_core/config.rb
@@ -92,6 +92,10 @@ module Merb
              options[:cluster] = nodes
            end
 
+           opts.on("-I", "--init-file FILE", "Name of the file to load first") do |init_file|
+             options[:init_file] = init_file
+           end
+
            opts.on("-p", "--port PORTNUM", "Port to run merb on, defaults to 4000.") do |port|
              options[:port] = port
            end
@@ -261,29 +265,29 @@ module Merb
 
          @configuration = Merb::Config.apply_configuration_from_file options, environment_merb_yml
          
-         case Merb::Config[:environment].to_s
-         when 'production'
-           Merb::Config[:reloader] = Merb::Config.fetch(:reloader, false)
-           Merb::Config[:exception_details] = Merb::Config.fetch(:exception_details, false)
-           Merb::Config[:cache_templates] = true
-         else
-           Merb::Config[:reloader] = Merb::Config.fetch(:reloader, true)
-           Merb::Config[:exception_details] = Merb::Config.fetch(:exception_details, true)
-         end
-
-         Merb::Config[:reloader_time] ||= 0.5 if Merb::Config[:reloader] == true
-
-
-         if Merb::Config[:reloader]
-           Thread.abort_on_exception = true
-           Thread.new do
-             loop do
-               sleep( Merb::Config[:reloader_time] )
-               ::Merb::BootLoader.reload if ::Merb::BootLoader.app_loaded?
-             end
-             Thread.exit
-           end
-         end
+         # case Merb::Config[:environment].to_s
+         # when 'production'
+         #   Merb::Config[:reloader] = Merb::Config.fetch(:reloader, false)
+         #   Merb::Config[:exception_details] = Merb::Config.fetch(:exception_details, false)
+         #   Merb::Config[:cache_templates] = true
+         # else
+         #   Merb::Config[:reloader] = Merb::Config.fetch(:reloader, true)
+         #   Merb::Config[:exception_details] = Merb::Config.fetch(:exception_details, true)
+         # end
+         # 
+         # Merb::Config[:reloader_time] ||= 0.5 if Merb::Config[:reloader] == true
+         # 
+         # 
+         # if Merb::Config[:reloader]
+         #   Thread.abort_on_exception = true
+         #   Thread.new do
+         #     loop do
+         #       sleep( Merb::Config[:reloader_time] )
+         #       ::Merb::BootLoader.reload if ::Merb::BootLoader.app_loaded?
+         #     end
+         #     Thread.exit
+         #   end
+         # end
          @configuration
        end
        
diff --git a/lib/merb_core/controller/abstract_controller.rb b/lib/merb_core/controller/abstract_controller.rb
index fbf83372793da6da4b803b799994f0e341fddf88..f5e9a59057d67a6d56377a516a726cf51aa03d6f 100644
--- a/lib/merb_core/controller/abstract_controller.rb
+++ b/lib/merb_core/controller/abstract_controller.rb
@@ -96,7 +96,7 @@ class Merb::AbstractController
   # the superclass.
   #---
   # @public
-  def _template_location(action, controller = controller_name, type = nil)
+  def _template_location(action, type = nil, controller = controller_name)
     "#{controller}/#{action}"
   end
   
@@ -106,6 +106,8 @@ class Merb::AbstractController
   # own subclasses. We're using a Set so we don't have to worry about
   # uniqueness.
   self._abstract_subclasses = Set.new
+  self._template_root = Merb.dir_for(:view)
+  
   def self.subclasses_list() _abstract_subclasses end
   
   class  self
@@ -114,7 +116,6 @@ class Merb::AbstractController
     #   The controller that is being inherited from Merb::AbstractController
     def inherited(klass)
       _abstract_subclasses  klass.to_s
-      klass._template_root ||= Merb.dir_for(:view)
       super
     end
     
diff --git a/lib/merb_core/controller/merb_controller.rb b/lib/merb_core/controller/merb_controller.rb
index 7283f006bb0501b29f825da129600cf045264b62..98af6ef3330a6b3f46d7bb1f8643261e28155ae5 100644
--- a/lib/merb_core/controller/merb_controller.rb
+++ b/lib/merb_core/controller/merb_controller.rb
@@ -71,6 +71,10 @@ class Merb::Controller  Merb::AbstractController
     end
   end
   
+  def _template_location(action, type = nil, controller = controller_name)
+    "#{controller}/#{action}.#{type}"
+  end  
+  
   # Sets the variables that came in through the dispatch as available to
   # the controller. This is called by .build, so see it for more
   # information.
@@ -107,9 +111,7 @@ class Merb::Controller  Merb::AbstractController
         request.cookies[_session_id_key] = request.params[_session_id_key]
       end
     end
-    @_request, @_response, @_status, @_headers = 
-      request, response, status, headers
-
+    @request, @response, @status, @headers = request, response, status, headers
     nil
   end
   
@@ -135,7 +137,8 @@ class Merb::Controller  Merb::AbstractController
     @_benchmarks[:action_time] = Time.now - start
   end
   
-  _attr_reader :request, :response, :status, :headers
+  attr_reader :request, :response, :headers
+  attr_accessor :status
   def params()  request.params  end
   def cookies() request.cookies end
   def session() request.session end
diff --git a/lib/merb_core/controller/mime.rb b/lib/merb_core/controller/mime.rb
index d17570786ca318cff7201c4b1e947ae229b01de8..ff9abe4d1c452aeabfcf5f7dc7a2c7cdd3f67035 100644
--- a/lib/merb_core/controller/mime.rb
+++ b/lib/merb_core/controller/mime.rb
@@ -8,7 +8,7 @@ module Merb
 
     # Any specific outgoing headers should be included here.  These are not
     # the content-type header but anything in addition to it.
-    # +tranform_method+ should be set to a symbol of the method used to
+    # +transform_method+ should be set to a symbol of the method used to
     # transform a resource into this mime type.
     # For example for the :xml mime type an object might be transformed by
     # calling :to_xml, or for the :js mime type, :to_json.
@@ -71,27 +71,6 @@ module Merb
     def mime_by_request_header(header)
       available_mime_types.find {|key,info| info[request_headers].include?(header)}.first
     end
-
-    # Resets the default mime-types
-    # 
-    # By default, the mime-types include:
-    # :all:: no transform, */*
-    # :yaml:: to_yaml, application/x-yaml or text/yaml
-    # :text:: to_text, text/plain
-    # :html:: to_html, text/html or application/xhtml+xml or application/html
-    # :xml:: to_xml, application/xml or text/xml or application/x-xml, adds "Encoding: UTF-8" response header
-    # :js:: to_json, text/javascript ot application/javascript or application/x-javascript
-    # :json:: to_json, application/json or text/x-json
-    def reset_default_mime_types!
-      available_mime_types.clear
-      Merb.add_mime_type(:all,  nil,      %w[*/*])
-      Merb.add_mime_type(:yaml, :to_yaml, %w[application/x-yaml text/yaml])
-      Merb.add_mime_type(:text, :to_text, %w[text/plain])
-      Merb.add_mime_type(:html, :to_html, %w[text/html application/xhtml+xml application/html])
-      Merb.add_mime_type(:xml,  :to_xml,  %w[application/xml text/xml application/x-xml], :Encoding = "UTF-8")
-      Merb.add_mime_type(:js,   :to_json, %w[text/javascript application/javascript application/x-javascript])
-      Merb.add_mime_type(:json, :to_json, %w[application/json text/x-json])      
-    end
     
   end
 end
\ No newline at end of file
diff --git a/lib/merb_core/controller/mixins/render.rb b/lib/merb_core/controller/mixins/render.rb
index 8e096546d4647bb597ab2e00a4b15d09db35e9c9..a298263af7d655d9ce43007554f3827046831287 100644
--- a/lib/merb_core/controller/mixins/render.rb
+++ b/lib/merb_core/controller/mixins/render.rb
@@ -51,21 +51,22 @@ module Merb::RenderMixin
     
     # If you don't specify a thing to render, assume they want to render the current action
     thing ||= action_name.to_sym
-    
+
     # Content negotiation
     opts[:format] ? (self.content_type = opts[:format]) : content_type 
     
     # Do we have a template to try to render?
     if thing.is_a?(Symbol) || opts[:template]
-      
+
       # Find a template path to look up (_template_location adds flexibility here)
-      template_location = _template_root / (opts[:template] || _template_location(thing))
+      template_location = _template_root / (opts[:template] || _template_location(thing, content_type))
+      
       # Get the method name from the previously inlined list
       template_method = Merb::Template.template_for(template_location)
 
       # Raise an error if there's no template
       raise TemplateNotFound, "No template found at #{template_location}" unless 
-        self.respond_to?(template_method)
+        template_method && self.respond_to?(template_method)
 
       # Call the method in question and throw the content for later consumption by the layout
       throw_content(:for_layout, self.send(template_method))
diff --git a/lib/merb_core/controller/mixins/responder.rb b/lib/merb_core/controller/mixins/responder.rb
index e910b2b32c844ab51cf2a10d0ad26c314dbb3631..5ac67fb907aaf9f95effc7eb3cbb07b8963ce022 100644
--- a/lib/merb_core/controller/mixins/responder.rb
+++ b/lib/merb_core/controller/mixins/responder.rb
@@ -97,6 +97,8 @@ module Merb
   # and none of the provides methods can be used.
   module ResponderMixin
     
+    TYPES = {}
+    
     class ContentTypeAlreadySet  StandardError; end
     
     # ==== Parameters
@@ -105,6 +107,7 @@ module Merb
       base.extend(ClassMethods)
       base.class_eval do
         class_inheritable_accessor :class_provided_formats
+        self.class_provided_formats = []
       end
       base.reset_provides
     end
@@ -178,171 +181,253 @@ module Merb
       def reset_provides
         only_provides(:html)
       end
-      
-      # ==== Returns
-      # The current list of formats provided for this instance of the controller. 
-      # It starts with what has been set in the controller (or :html by default) 
-      # but can be modifed on a per-action basis.      
-      def _provided_formats
-        @_provided_formats ||= class_provided_formats.dup
+    end
+
+    # ==== Returns
+    # The current list of formats provided for this instance of the controller. 
+    # It starts with what has been set in the controller (or :html by default) 
+    # but can be modifed on a per-action basis.      
+    def _provided_formats
+      @_provided_formats ||= class_provided_formats.dup
+    end
+    
+    # Sets the provided formats for this action.  Usually, you would
+    # use a combination of +provides+, +only_provides+ and +does_not_provide+
+    # to manage this, but you can set it directly.
+    # 
+    # ==== Parameters
+    # *formatsSymbol:: A list of formats to be passed to provides
+    #
+    # ==== Raises
+    # Merb::ResponderMixin::ContentTypeAlreadySet::
+    #   Content negotiation already occured, and the content_type is set.
+    #
+    # ==== Returns
+    # Array:: List of formats passed in
+    def _set_provided_formats(*formats)
+      if @_content_type
+        raise ContentTypeAlreadySet, "Cannot modify provided_formats because content_type has already been set"
       end
-      
-      # Sets the provided formats for this action.  Usually, you would
-      # use a combination of +provides+, +only_provides+ and +does_not_provide+
-      # to manage this, but you can set it directly.
-      # 
-      # ==== Parameters
-      # *formatsSymbol:: A list of formats to be passed to provides
-      #
-      # ==== Raises
-      # Merb::ResponderMixin::ContentTypeAlreadySet::
-      #   Content negotiation already occured, and the content_type is set.
-      #
-      # ==== Returns
-      # Array:: List of formats passed in
-      def _set_provided_formats(*formats)
-        if @_content_type
-          raise ContentTypeAlreadySet, "Cannot modify provided_formats because content_type has already been set"
-        end
-        @_provided_formats = []
-        provides(*formats)
+      @_provided_formats = []
+      provides(*formats)
+    end
+    alias :_provided_formats= :_set_provided_formats   
+    
+    # Adds formats to the list of provided formats for this particular 
+    # request. Usually used to add formats to a single action. See also
+    # the controller-level provides that affects all actions in a controller.
+    #
+    # ==== Parameters
+    # *formatsSymbol:: A list of formats to add to the per-action list
+    #                    of provided formats
+    #
+    # ==== Raises
+    # Merb::ResponderMixin::ContentTypeAlreadySet::
+    #   Content negotiation already occured, and the content_type is set.
+    #
+    # ==== Returns
+    # Array:: List of formats passed in
+    #
+    #---
+    # @public
+    def provides(*formats)
+      if @_content_type
+        raise ContentTypeAlreadySet, "Cannot modify provided_formats because content_type has already been set"
       end
-      alias :_provided_formats= :_set_provided_formats   
-      
-      # Adds formats to the list of provided formats for this particular 
-      # request. Usually used to add formats to a single action. See also
-      # the controller-level provides that affects all actions in a controller.
-      #
-      # ==== Parameters
-      # *formatsSymbol:: A list of formats to add to the per-action list
-      #                    of provided formats
-      #
-      # ==== Raises
-      # Merb::ResponderMixin::ContentTypeAlreadySet::
-      #   Content negotiation already occured, and the content_type is set.
-      #
-      # ==== Returns
-      # Array:: List of formats passed in
-      #
-      #---
-      # @public
-      def provides(*formats)
-        if @_content_type
-          raise ContentTypeAlreadySet, "Cannot modify provided_formats because content_type has already been set"
-        end
-        formats.each do |fmt|
-          _provided_formats  fmt unless _provided_formats.include?(fmt)
-        end
+      formats.each do |fmt|
+        _provided_formats  fmt unless _provided_formats.include?(fmt)
       end
+    end
 
-      # Sets list of provided formats for this particular 
-      # request. Usually used to limit formats to a single action. See also
-      # the controller-level only_provides that affects all actions
-      # in a controller.      
-      # 
-      # ==== Parameters
-      # *formatsSymbol:: A list of formats to use as the per-action list
-      #                    of provided formats
-      #
-      # ==== Returns
-      # Array:: List of formats passed in
-      #
-      #---
-      # @public
-      def only_provides(*formats)
-        self._provided_formats = *formats
-      end
-      
-      # Removes formats from the list of provided formats for this particular 
-      # request. Usually used to remove formats from a single action.  See
-      # also the controller-level does_not_provide that affects all actions in a
-      # controller.
-      #
-      # ==== Parameters
-      # *formatsSymbol:: Registered mime-type
-      # 
-      # ==== Returns
-      # Array:: List of formats that remain after removing the ones not to provide
-      #
-      #---
-      # @public      
-      def does_not_provide(*formats)
-        formats.flatten!
-        self._provided_formats -= formats
-      end
-      
-      # Do the content negotiation:
-      # 1. if params[:format] is there, and provided, use it
-      # 2. Parse the Accept header
-      # 3. If it's */*, use the first provided format
-      # 4. Look for one that is provided, in order of request
-      # 5. Raise 406 if none found
-      def _perform_content_negotiation # :nodoc:
-        raise Merb::ControllerExceptions::NotAcceptable if provided_formats.empty?
-        if fmt = params[:format]
-          return fmt.to_sym if provided_formats.include?(fmt.to_sym)
-        else
-          accepts = Responder.parse(request.accept).map {|t| t.to_sym}
-          return provided_formats.first if accepts.include?(:all)
-          return accepts.each { |type| break type if provided_formats.include?(type) }
-        end
-        raise Merb::ControllerExceptions::NotAcceptable          
+    # Sets list of provided formats for this particular 
+    # request. Usually used to limit formats to a single action. See also
+    # the controller-level only_provides that affects all actions
+    # in a controller.      
+    # 
+    # ==== Parameters
+    # *formatsSymbol:: A list of formats to use as the per-action list
+    #                    of provided formats
+    #
+    # ==== Returns
+    # Array:: List of formats passed in
+    #
+    #---
+    # @public
+    def only_provides(*formats)
+      self._provided_formats = *formats
+    end
+    
+    # Removes formats from the list of provided formats for this particular 
+    # request. Usually used to remove formats from a single action.  See
+    # also the controller-level does_not_provide that affects all actions in a
+    # controller.
+    #
+    # ==== Parameters
+    # *formatsSymbol:: Registered mime-type
+    # 
+    # ==== Returns
+    # Array:: List of formats that remain after removing the ones not to provide
+    #
+    #---
+    # @public      
+    def does_not_provide(*formats)
+      formats.flatten!
+      self._provided_formats -= formats
+    end
+    
+    # Do the content negotiation:
+    # 1. if params[:format] is there, and provided, use it
+    # 2. Parse the Accept header
+    # 3. If it's */*, use the first provided format
+    # 4. Look for one that is provided, in order of request
+    # 5. Raise 406 if none found
+    def _perform_content_negotiation # :nodoc:
+      raise Merb::ControllerExceptions::NotAcceptable if _provided_formats.empty?
+      if fmt = params[:format] && _provided_formats.include?(fmt.to_sym)
+        return fmt.to_sym
       end
+      accepts = Responder.parse(request.accept).map {|t| t.to_sym}
+      return _provided_formats.first if accepts.include?(:all)
+      (accepts & _provided_formats).first || (raise Merb::ControllerExceptions::NotAcceptable)
+    end
 
-      # Returns the output format for this request, based on the 
-      # provided formats, ttparams[:format]/tt and the client's HTTP
-      # Accept header.
-      #
-      # The first time this is called, it triggers content negotiation
-      # and caches the value.  Once you call +content_type+ you can
-      # not set or change the list of provided formats.
-      #
-      # Called automatically by +render+, so you should only call it if
-      # you need the value, not to trigger content negotiation. 
-      # 
-      # ==== Parameters
-      # fmtString?:: 
-      #   An optional format to use instead of performing content negotiation.
-      #   This can be used to pass in the values of opts[:format] from the 
-      #   render function to short-circuit content-negotiation when it's not
-      #   necessary. This optional parameter should not be considered part
-      #   of the public API.
-      #
-      # ==== Returns
-      # Symbol:: The content-type that will be used for this controller.
-      #
-      #---
-      # @public
-      def content_type(fmt = nil)
-        self.content_type = (fmt || _perform_content_negotiation) unless @_content_type
-        @_content_type
+    # Returns the output format for this request, based on the 
+    # provided formats, ttparams[:format]/tt and the client's HTTP
+    # Accept header.
+    #
+    # The first time this is called, it triggers content negotiation
+    # and caches the value.  Once you call +content_type+ you can
+    # not set or change the list of provided formats.
+    #
+    # Called automatically by +render+, so you should only call it if
+    # you need the value, not to trigger content negotiation. 
+    # 
+    # ==== Parameters
+    # fmtString?:: 
+    #   An optional format to use instead of performing content negotiation.
+    #   This can be used to pass in the values of opts[:format] from the 
+    #   render function to short-circuit content-negotiation when it's not
+    #   necessary. This optional parameter should not be considered part
+    #   of the public API.
+    #
+    # ==== Returns
+    # Symbol:: The content-type that will be used for this controller.
+    #
+    #---
+    # @public
+    def content_type(fmt = nil)
+      @_content_type = (fmt || _perform_content_negotiation) unless @_content_type
+      @_content_type
+    end
+    
+    # Sets the content type of the current response to a value based on 
+    # a passed in key. The Content-Type header will be set to the first
+    # registered header for the mime-type.
+    #
+    # ==== Parameters
+    # typeSymbol:: A type that is in the list of registered mime-types.
+    #
+    # ==== Raises
+    # ArgumentError:: "type" is not in the list of registered mime-types.
+    #
+    # ==== Returns
+    # Symbol:: The content-type that was passed in.
+    #
+    #---
+    # @semipublic
+    def content_type=(type)
+      unless Merb.available_mime_types.has_key?(type)
+        raise Merb::ControllerExceptions::NotAcceptable.new("Unknown content_type for response: #{type}") 
+      end        
+      headers['Content-Type'] = Merb.available_mime_types[type].first        
+      @_content_type = type
+    end
+    
+  end
+
+  class Responder
+  
+    protected
+    def self.parse(accept_header)
+      # parse the raw accept header into a unique, sorted array of AcceptType objects
+      list = accept_header.to_s.split(/,/).enum_for(:each_with_index).map do |entry,index|
+        AcceptType.new(entry,index += 1)
+      end.sort.uniq
+      # firefox (and possibly other browsers) send broken default accept headers.
+      # fix them up by sorting alternate xml forms (namely application/xhtml+xml)
+      # ahead of pure xml types (application/xml,text/xml).
+      if app_xml = list.detect{|e| e.super_range == 'application/xml'}
+        list.select{|e| e.to_s =~ /\+xml/}.each { |acc_type|
+          list[list.index(acc_type)],list[list.index(app_xml)] = 
+            list[list.index(app_xml)],list[list.index(acc_type)] }
       end
-      
-      # Sets the content type of the current response to a value based on 
-      # a passed in key. The Content-Type header will be set to the first
-      # registered header for the mime-type.
-      #
-      # ==== Parameters
-      # typeSymbol:: A type that is in the list of registered mime-types.
-      #
-      # ==== Raises
-      # ArgumentError:: "type" is not in the list of registered mime-types.
-      #
-      # ==== Returns
-      # Symbol:: The content-type that was passed in.
-      #
-      #---
-      # @semipublic
-      def content_type=(type)
-        unless Merb.available_mime_types.has_key?(type)
-          raise Merb::ControllerExceptions::NotAcceptable.new("Unknown content_type for response: #{type}") 
-        end        
-        headers['Content-Type'] = Merb.available_mime_types[type].first        
-        @_content_type = type
+      list
+    end
+    
+    public
+    def self.params_to_query_string(value, prefix = nil)
+      case value
+      when Array
+        value.map { |v|
+          params_to_query_string(v, "#{prefix}[]")
+        } * "&"
+      when Hash
+        value.map { |k, v|
+          params_to_query_string(v, prefix ? "#{prefix}[#{Merb::Request.escape(k)}]" : Merb::Request.escape(k))
+        } * "&"
+      else
+        "#{prefix}=#{Merb::Request.escape(value)}"
       end
+    end      
       
-    end
+  end
+
+  class AcceptType
+
+    attr_reader :media_range, :quality, :index, :type, :sub_type
     
+    def initialize(entry,index)
+      @index = index
+      @media_range, quality = entry.split(/;\s*q=/).map{|a| a.strip }
+      @type, @sub_type = @media_range.split(/\//)
+      quality ||= 0.0 if @media_range == '*/*'
+      @quality = ((quality || 1.0).to_f * 100).to_i
+    end
+  
+    def =(entry)
+      c = entry.quality = quality
+      c = index = entry.index if c == 0
+      c
+    end
+  
+    def eql?(entry)
+      synonyms.include?(entry.media_range)
+    end
+  
+    def ==(entry); eql?(entry); end
+  
+    def hash; super_range.hash; end
+  
+    def synonyms
+      @syns ||= Merb.available_mime_types.values.map do |e| 
+        e[:request_headers] if e[:request_headers].include?(@media_range)
+      end.compact.flatten
+    end
+  
+    def super_range
+      synonyms.first || @media_range
+    end
+  
+    def to_sym
+      Merb.available_mime_types.select{|k,v| 
+        v[:request_headers] == synonyms || v[:request_headers][0] == synonyms[0]}.flatten.first
+    end
+  
+    def to_s
+      @media_range
+    end
+  
   end
+
     
 end
\ No newline at end of file
diff --git a/lib/merb_core/dispatch/dispatcher.rb b/lib/merb_core/dispatch/dispatcher.rb
index c458c9f9ad454d3b0c3055d6b2a8e88b17712b44..f7fed0f539a20f9cce08b72c551725ad0563bf37 100644
--- a/lib/merb_core/dispatch/dispatcher.rb
+++ b/lib/merb_core/dispatch/dispatcher.rb
@@ -33,10 +33,10 @@ class Merb::Dispatcher
 
     # this is the custom dispatch_exception; it allows failures to still be dispatched
     # to the error controller
-    rescue = exception
-      Merb.logger.error(Merb.exception(exception))
-      exception = controller_exception(exception)
-      dispatch_exception(request, response, exception)
+    # rescue = exception
+    #   Merb.logger.error(Merb.exception(exception))
+    #   exception = controller_exception(exception)
+    #   dispatch_exception(request, response, exception)
     end
     
     private
@@ -49,10 +49,10 @@ class Merb::Dispatcher
     def dispatch_action(klass, action, request, response, status=200)
       # build controller
       controller = klass.build(request, response, status)
-      if @@use_mutex
-        @@mutex.synchronize { controller.dispatch(action) }
+      if use_mutex
+        @@mutex.synchronize { controller._dispatch(action) }
       else
-        controller.dispatch(action)
+        controller._dispatch(action)
       end
       [controller, action]
     end
diff --git a/lib/merb_core/rack/adapter.rb b/lib/merb_core/rack/adapter.rb
index ffc7117e9733e83b0567bbe4a43fac7663800b7d..217399a5382d0b3878aaea3d3e302173c5b5f119 100644
--- a/lib/merb_core/rack/adapter.rb
+++ b/lib/merb_core/rack/adapter.rb
@@ -40,7 +40,7 @@ module Merb
         begin
           controller, action = ::Merb::Dispatcher.handle(request, response)
         rescue Object = e
-          return [500, {"Content-Type"="text/html"}, "Internal Server Error"]
+          return [500, {"Content-Type"="text/html"}, e.message + "br/" + e.backtrace.join("br/")]
         end
         [controller.status, controller.headers, controller.body]
       end
diff --git a/lib/merb_core/test/request_helper.rb b/lib/merb_core/test/request_helper.rb
index 10a9fb3ace56eaf1db0fa300df3fb2ab88a7118a..f302a3b71539182ba142cd208fe6d6aae171b1a1 100644
--- a/lib/merb_core/test/request_helper.rb
+++ b/lib/merb_core/test/request_helper.rb
@@ -26,8 +26,10 @@ module Merb::Test::RequestHelper
     Merb::Test::FakeRequest.new(env, StringIO.new(req))
   end
   
-  def dispatch_to(controller_klass, action, env = {}, opt = {}, &blk)
-    request = fake_request(env, opt)
+  def dispatch_to(controller_klass, action, params = {}, env = {}, &blk)
+    request = fake_request(env, 
+      :query_string = Merb::Responder.params_to_query_string(params))
+
     controller = controller_klass.build(request)
     controller.instance_eval(&blk) if block_given?
     controller._dispatch(action)
diff --git a/spec/public/abstract_controller/spec_helper.rb b/spec/public/abstract_controller/spec_helper.rb
index df759008d14e7572b5c44de24f77f828f83f1682..694cee2592a210a5c1fa40ca7846beeaa09725fe 100644
--- a/spec/public/abstract_controller/spec_helper.rb
+++ b/spec/public/abstract_controller/spec_helper.rb
@@ -1,12 +1,10 @@
 __DIR__ = File.dirname(__FILE__)
 require File.join(__DIR__, "..", "..", "spec_helper")
 
-# The framework structure *must* be set up before loading in framework
-# files.
 require File.join(__DIR__, "controllers", "filters")
 require File.join(__DIR__, "controllers", "render")
 
-Merb::BootLoader::Templates.new.run
+Merb::BootLoader::Templates.run
 
 module Merb::Test::Behaviors
   def dispatch_should_make_body(klass, body, action = :index)
diff --git a/spec/public/controller/base_spec.rb b/spec/public/controller/base_spec.rb
index 1709e612629ed2c2b6af4579a8b89684aca9aa3c..5bcdb59948cc22592639b1aee9bd233ff2c306fa 100644
--- a/spec/public/controller/base_spec.rb
+++ b/spec/public/controller/base_spec.rb
@@ -10,11 +10,11 @@ describe Merb::Controller, " callable actions" do
   end
   
   it "should dispatch to callable actions" do
-    dispatch_to(Merb::Test::Fixtures::TestFoo, :index).body.should == "index"
+    dispatch_to(Merb::Test::Fixtures::TestBase, :index).body.should == "index"
   end
 
   it "should not dispatch to hidden actions" do
-    calling { dispatch_to(Merb::Test::Fixtures::TestFoo, :hidden) }.
+    calling { dispatch_to(Merb::Test::Fixtures::TestBase, :hidden) }.
       should raise_error(Merb::ControllerExceptions::ActionNotFound)
   end
     
diff --git a/spec/public/controller/controllers/base.rb b/spec/public/controller/controllers/base.rb
index a1b3beb27899df781d943427d9b23945f02e14de..c4b69a440a9da3c3486208d2cb95ccb8bdb974b9 100644
--- a/spec/public/controller/controllers/base.rb
+++ b/spec/public/controller/controllers/base.rb
@@ -3,7 +3,7 @@ module Merb::Test::Fixtures
     self._template_root = File.dirname(__FILE__) / "views"
   end
   
-  class TestFoo  ControllerTesting
+  class TestBase  ControllerTesting
     def index
       "index"
     end
diff --git a/spec/public/controller/controllers/responder.rb b/spec/public/controller/controllers/responder.rb
new file mode 100644
index 0000000000000000000000000000000000000000..867192e8f6e995a43fd5cd3daffa0ec11b3d31e5
--- /dev/null
+++ b/spec/public/controller/controllers/responder.rb
@@ -0,0 +1,25 @@
+module Merb::Test::Fixtures
+  class ControllerTesting  Merb::Controller
+    self._template_root = File.dirname(__FILE__) / "views"
+  end
+  
+  class TestResponder  ControllerTesting
+    def index
+      render
+    end
+  end
+  
+  class TestHtmlDefault  TestResponder; end
+  
+  class TestClassProvides  TestResponder; 
+    provides :xml
+  end
+  
+  class TestLocalProvides  TestResponder; 
+    def index
+      provides :xml
+      render
+    end
+  end
+  
+end
\ No newline at end of file
diff --git a/spec/public/controller/controllers/views/merb/test/fixtures/test_class_provides/index.html.erb b/spec/public/controller/controllers/views/merb/test/fixtures/test_class_provides/index.html.erb
new file mode 100644
index 0000000000000000000000000000000000000000..1bfb77d4a44c444bba6888ae7740f7df4b074c58
--- /dev/null
+++ b/spec/public/controller/controllers/views/merb/test/fixtures/test_class_provides/index.html.erb
@@ -0,0 +1 @@
+This should not be rendered
\ No newline at end of file
diff --git a/spec/public/controller/controllers/views/merb/test/fixtures/test_class_provides/index.xml.erb b/spec/public/controller/controllers/views/merb/test/fixtures/test_class_provides/index.xml.erb
new file mode 100644
index 0000000000000000000000000000000000000000..7c91f633987348e87e5e34e1d9e87d9dd0e5100c
--- /dev/null
+++ b/spec/public/controller/controllers/views/merb/test/fixtures/test_class_provides/index.xml.erb
@@ -0,0 +1 @@
+XML:Class provides='true' /
\ No newline at end of file
diff --git a/spec/public/controller/controllers/views/merb/test/fixtures/test_html_default/index.html.erb b/spec/public/controller/controllers/views/merb/test/fixtures/test_html_default/index.html.erb
new file mode 100644
index 0000000000000000000000000000000000000000..eb4b52bf5a7aaba8f1706de419f42789c05684a2
--- /dev/null
+++ b/spec/public/controller/controllers/views/merb/test/fixtures/test_html_default/index.html.erb
@@ -0,0 +1 @@
+HTML: Default
\ No newline at end of file
diff --git a/spec/public/controller/controllers/views/merb/test/fixtures/test_local_provides/index.html.erb b/spec/public/controller/controllers/views/merb/test/fixtures/test_local_provides/index.html.erb
new file mode 100644
index 0000000000000000000000000000000000000000..a3a841a89c62e6174038935a42da9cd24ff54413
--- /dev/null
+++ b/spec/public/controller/controllers/views/merb/test/fixtures/test_local_provides/index.html.erb
@@ -0,0 +1 @@
+This should not render
\ No newline at end of file
diff --git a/spec/public/controller/controllers/views/merb/test/fixtures/test_local_provides/index.xml.erb b/spec/public/controller/controllers/views/merb/test/fixtures/test_local_provides/index.xml.erb
new file mode 100644
index 0000000000000000000000000000000000000000..c1384ec6af0357b585cc367035d1bc3a30347ade
--- /dev/null
+++ b/spec/public/controller/controllers/views/merb/test/fixtures/test_local_provides/index.xml.erb
@@ -0,0 +1 @@
+XML:Local provides='true' /
\ No newline at end of file
diff --git a/spec/public/controller/responder_spec.rb b/spec/public/controller/responder_spec.rb
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..bcf18532442e5965cf6ca8501770d7b7a1eb2429 100644
--- a/spec/public/controller/responder_spec.rb
+++ b/spec/public/controller/responder_spec.rb
@@ -0,0 +1,31 @@
+require File.join(File.dirname(__FILE__), "spec_helper")
+
+describe Merb::Controller, " responds" do
+  
+  before do
+    Merb.push_path(:layout, File.dirname(__FILE__) / "controllers" / "views" / "layouts")    
+    Merb::Router.prepare do |r|
+      r.default_routes
+    end
+  end
+  
+  it "should default the mime-type to HTML" do
+    dispatch_to(Merb::Test::Fixtures::TestHtmlDefault, :index).body.should == "HTML: Default"
+  end
+
+  it "should use other mime-types if they are provided on the class level" do
+    controller = dispatch_to(Merb::Test::Fixtures::TestClassProvides, :index, {}, :http_accept = "application/xml")
+    controller.body.should == "XML:Class provides='true' /"
+  end
+
+  it "should fail if none of the acceptable mime-types are available" do
+    calling { dispatch_to(Merb::Test::Fixtures::TestClassProvides, :index, {}, :http_accept = "application/json") }.
+      should raise_error(Merb::ControllerExceptions::NotAcceptable)
+  end
+  
+  it "should use mime-types that are provided at the local level" do
+    controller = dispatch_to(Merb::Test::Fixtures::TestLocalProvides, :index, {}, :http_accept = "application/xml")
+    controller.body.should == "XML:Local provides='true' /"    
+  end
+    
+end
\ No newline at end of file
diff --git a/spec/public/controller/spec_helper.rb b/spec/public/controller/spec_helper.rb
index f68628a63740f4ce0235a15d71c5889e55ecaf78..e360194c1fbaf72c3298c61543c2d3a19b512b41 100644
--- a/spec/public/controller/spec_helper.rb
+++ b/spec/public/controller/spec_helper.rb
@@ -1,4 +1,10 @@
 __DIR__ = File.dirname(__FILE__)
+require 'ruby-debug'
+
 require File.join(__DIR__, "..", "..", "spec_helper")
 
-require File.join(__DIR__, "controllers", "base")
\ No newline at end of file
+require File.join(__DIR__, "controllers", "base")
+require File.join(__DIR__, "controllers", "responder")
+
+Merb::BootLoader::Templates.run
+Merb::BootLoader::MimeTypes.run
\ No newline at end of file
</content>
		</actual_file>
		<actual_file>
			<filename>diff_new_mode</filename>
			<content>diff --git a/conf/global_settings.py b/conf/global_settings.py
old mode 100644
new mode 100755
index 9ec1bac..1c4f83b
--- a/conf/global_settings.py
+++ b/conf/global_settings.py
@@ -58,6 +58,7 @@ TEMPLATE_CONTEXT_PROCESSORS = (
 )
 
 MIDDLEWARE_CLASSES = (
+    "django.middleware.cache.CacheMiddleware",
     "django.middleware.common.CommonMiddleware",
     "django.contrib.sessions.middleware.SessionMiddleware",
     "django.contrib.auth.middleware.AuthenticationMiddleware",
diff --git a/moo b/moo
old mode 100755
new mode 100644
</content>
		</actual_file>
		<actual_file>
			<filename>diff_p</filename>
			<content>diff --git a/.gitignore b/.gitignore
index 4ebc8aea50e0a67e000ba29a30809d0a7b9b2666..2dd02534615434d88c51307beb0f0092f21fd103 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1 +1,2 @@
 coverage
+pkg
diff --git a/Manifest.txt b/Manifest.txt
index 641972d82c6d1b51122274ae8f6a0ecdfb56ee22..38bf80c54a526e76d74820a0f48606fe1ca7b1be 100644
--- a/Manifest.txt
+++ b/Manifest.txt
@@ -4,4 +4,31 @@ README.txt
 Rakefile
 bin/grit
 lib/grit.rb
-test/test_grit.rb
\ No newline at end of file
+lib/grit/actor.rb
+lib/grit/blob.rb
+lib/grit/commit.rb
+lib/grit/errors.rb
+lib/grit/git.rb
+lib/grit/head.rb
+lib/grit/lazy.rb
+lib/grit/repo.rb
+lib/grit/tree.rb
+test/fixtures/blame
+test/fixtures/cat_file_blob
+test/fixtures/cat_file_blob_size
+test/fixtures/for_each_ref
+test/fixtures/ls_tree_a
+test/fixtures/ls_tree_b
+test/fixtures/rev_list
+test/fixtures/rev_list_single
+test/helper.rb
+test/profile.rb
+test/suite.rb
+test/test_actor.rb
+test/test_blob.rb
+test/test_commit.rb
+test/test_git.rb
+test/test_head.rb
+test/test_reality.rb
+test/test_repo.rb
+test/test_tree.rb
diff --git a/README.txt b/README.txt
index 8b1e02c0fb554eed2ce2ef737a68bb369d7527df..fca94f84afd7d749c62626011f972a509f6a5ac6 100644
--- a/README.txt
+++ b/README.txt
@@ -1,32 +1,185 @@
 grit
-    by FIX (your name)
-    FIX (url)
+    by Tom Preston-Werner
+    grit.rubyforge.org
 
 == DESCRIPTION:
+
+Grit is a Ruby library for extracting information from a git repository in and
+object oriented manner.
+
+== REQUIREMENTS:
+
+* git (http://git.or.cz) tested with 1.5.3.4
+
+== INSTALL:
+
+sudo gem install grit
+
+== USAGE:
+
+Grit gives you object model access to your git repository. Once you have
+created a repository object, you can traverse it to find parent commit(s),
+trees, blobs, etc.
+
+= Initialize a Repo object
+
+The first step is to create a Grit::Repo object to represent your repo. I
+include the Grit module so reduce typing.
+
+  include Grit
+  repo = Repo.new("/Users/tom/dev/grit")
   
-FIX (describe your package)
+In the above example, the directory /Users/tom/dev/grit is my working
+repo and contains the .git directory. You can also initialize Grit with a 
+bare repo.
 
-== FEATURES/PROBLEMS:
+  repo = Repo.new("/var/git/grit.git")
   
-* FIX (list of features or problems)
+= Getting a list of commits
 
-== SYNOPSIS:
+From the Repo object, you can get a list of commits as an array of Commit
+objects.
 
-  FIX (code sample of usage)
+  repo.commits
+  # = [#Grit::Commit "e80bbd2ce67651aa18e57fb0b43618ad4baf7750",
+        #Grit::Commit "91169e1f5fa4de2eaea3f176461f5dc784796769",
+        #Grit::Commit "038af8c329ef7c1bae4568b98bd5c58510465493",
+        #Grit::Commit "40d3057d09a7a4d61059bca9dca5ae698de58cbe",
+        #Grit::Commit "4ea50f4754937bf19461af58ce3b3d24c77311d9"]
+        
+Called without arguments, Repo#commits returns a list of up to ten commits
+reachable by the master branch (starting at the latest commit). You can ask
+for commits beginning at a different branch, commit, tag, etc.
 
-== REQUIREMENTS:
+  repo.commits('mybranch')
+  repo.commits('40d3057d09a7a4d61059bca9dca5ae698de58cbe')
+  repo.commits('v0.1')
+  
+You can specify the maximum number of commits to return.
 
-* FIX (list of requirements)
+  repo.commits('master', 100)
+  
+If you need paging, you can specify a number of commits to skip.
 
-== INSTALL:
+  repo.commits('master', 10, 20)
+  
+The above will return commits 21-30 from the commit list.
+        
+= The Commit object
+
+Commit objects contain information about that commit.
+
+  head = repo.commits.first
+  
+  head.id
+  # = "e80bbd2ce67651aa18e57fb0b43618ad4baf7750"
+  
+  head.parents
+  # = [#Grit::Commit "91169e1f5fa4de2eaea3f176461f5dc784796769"]
+  
+  head.tree
+  # = #Grit::Tree "3536eb9abac69c3e4db583ad38f3d30f8db4771f"
+  
+  head.author
+  # = #Grit::Actor "Tom Preston-Werner tom@mojombo.com"
+  
+  head.authored_date
+  # = Wed Oct 24 22:02:31 -0700 2007
+  
+  head.committer
+  # = #Grit::Actor "Tom Preston-Werner tom@mojombo.com"
+  
+  head.committed_date
+  # = Wed Oct 24 22:02:31 -0700 2007
+  
+  head.message
+  # = "add Actor inspect"
+  
+You can traverse a commit's ancestry by chaining calls to #parents.
+
+  repo.commits.first.parents[0].parents[0].parents[0]
+  
+The above corresponds to master^^^ or master~3 in git parlance.
+
+= The Tree object
+
+A tree records pointers to the contents of a directory. Let's say you want
+the root tree of the latest commit on the master branch.
+
+  tree = repo.commits.first.tree
+  # = #Grit::Tree "3536eb9abac69c3e4db583ad38f3d30f8db4771f"
+  
+  tree.id
+  # = "3536eb9abac69c3e4db583ad38f3d30f8db4771f"
+  
+Once you have a tree, you can get the contents.
+
+  contents = tree.contents
+  # = [#Grit::Blob "4ebc8aea50e0a67e000ba29a30809d0a7b9b2666",
+        #Grit::Blob "81d2c27608b352814cbe979a6acd678d30219678",
+        #Grit::Tree "c3d07b0083f01a6e1ac969a0f32b8d06f20c62e5",
+        #Grit::Tree "4d00fe177a8407dbbc64a24dbfc564762c0922d8"]
+
+This tree contains two Blob objects and two Tree objects. The trees are
+subdirectories and the blobs are files. Trees below the root have additional
+attributes.
+
+  contents.last.name
+  # = "lib"
+  
+  contents.last.mode
+  # = "040000"
+  
+There is a convenience method that allows you to get a named sub-object
+from a tree.
+
+  tree/"lib"
+  # = #Grit::Tree "e74893a3d8a25cbb1367cf241cc741bfd503c4b2"
+  
+You can also get a tree directly from the repo if you know its name.
+
+  repo.tree
+  # = #Grit::Tree "master"
+  
+  repo.tree("91169e1f5fa4de2eaea3f176461f5dc784796769")
+  # = #Grit::Tree "91169e1f5fa4de2eaea3f176461f5dc784796769"
+  
+= The Blob object
+
+A blob represents a file. Trees often contain blobs.
+
+  blob = tree.contents.first
+  # = #Grit::Blob "4ebc8aea50e0a67e000ba29a30809d0a7b9b2666"
+  
+A blob has certain attributes.
+
+  blob.id
+  # = "4ebc8aea50e0a67e000ba29a30809d0a7b9b2666"
+  
+  blob.name
+  # = "README.txt"
+  
+  blob.mode
+  # = "100644"
+  
+  blob.size
+  # = 7726
+  
+You can get the data of a blob as a string.
+
+  blob.data
+  # = "Grit is a library to ..."
+  
+You can also get a blob directly from the repo if you know its name.
 
-* FIX (sudo gem install, anything else)
+  repo.blob("4ebc8aea50e0a67e000ba29a30809d0a7b9b2666")
+  # = #Grit::Blob "4ebc8aea50e0a67e000ba29a30809d0a7b9b2666"
 
 == LICENSE:
 
 (The MIT License)
 
-Copyright (c) 2007 FIX
+Copyright (c) 2007 Tom Preston-Werner
 
 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
diff --git a/Rakefile b/Rakefile
index 5bfb62163af455ca54422fd0b2e723ba1021ad12..72fde8c9ca87a1c992ce992bab13c3c4f13cddb9 100644
--- a/Rakefile
+++ b/Rakefile
@@ -4,11 +4,11 @@ require './lib/grit.rb'
 
 Hoe.new('grit', Grit::VERSION) do |p|
   p.rubyforge_name = 'grit'
-  # p.author = 'FIX'
-  # p.email = 'FIX'
-  # p.summary = 'FIX'
-  # p.description = p.paragraphs_of('README.txt', 2..5).join("\n\n")
-  # p.url = p.paragraphs_of('README.txt', 0).first.split(/\n/)[1..-1]
+  p.author = 'Tom Preston-Werner'
+  p.email = 'tom@rubyisawesome.com'
+  p.summary = 'Object model interface to a git repo'
+  p.description = p.paragraphs_of('README.txt', 2..2).join("\n\n")
+  p.url = p.paragraphs_of('README.txt', 0).first.split(/\n/)[2..-1].map { |u| u.strip }
   p.changes = p.paragraphs_of('History.txt', 0..1).join("\n\n")
 end
 
diff --git a/lib/grit.rb b/lib/grit.rb
index ae0792ae39d4891ebc1af996102a4f9df703394d..ae55fd7961ac49233f6ca515622a61e90d516044 100644
--- a/lib/grit.rb
+++ b/lib/grit.rb
@@ -1,4 +1,4 @@
-$:.unshift File.dirname(__FILE__)     # For use/testing when no gem is installed
+$:.unshift File.dirname(__FILE__) # For use/testing when no gem is installed
 
 # core
 
@@ -12,6 +12,8 @@ require 'grit/head'
 require 'grit/commit'
 require 'grit/tree'
 require 'grit/blob'
+require 'grit/actor'
+require 'grit/diff'
 require 'grit/repo'
 
 module Grit
@@ -21,5 +23,5 @@ module Grit
   
   self.debug = false
   
-  VERSION = '1.0.0'
+  VERSION = '0.1.0'
 end
\ No newline at end of file
diff --git a/lib/grit/actor.rb b/lib/grit/actor.rb
new file mode 100644
index 0000000000000000000000000000000000000000..f733bce6b57c0e5e353206e692b0e3105c2527f4
--- /dev/null
+++ b/lib/grit/actor.rb
@@ -0,0 +1,35 @@
+module Grit
+  
+  class Actor
+    attr_reader :name
+    attr_reader :email
+    
+    def initialize(name, email)
+      @name = name
+      @email = email
+    end
+    
+    # Create an Actor from a string.
+    #   +str+ is the string, which is expected to be in regular git format
+    #
+    # Format
+    #   John Doe jdoe@example.com
+    #
+    # Returns Actor
+    def self.from_string(str)
+      case str
+        when /.+/
+          m, name, email = *str.match(/(.*) (.+?)/)
+          return self.new(name, email)
+        else
+          return self.new(str, nil)
+      end
+    end
+    
+    # Pretty object inspection
+    def inspect
+      %Q{#Grit::Actor "#{@name} #{@email}"}
+    end
+  end # Actor
+  
+end # Grit
\ No newline at end of file
diff --git a/lib/grit/blob.rb b/lib/grit/blob.rb
index c863646d4278bfee2a7bcb64caace6b31f89ef03..87d43fab37844afdc2f8814dba3abdaa791f1370 100644
--- a/lib/grit/blob.rb
+++ b/lib/grit/blob.rb
@@ -81,9 +81,9 @@ module Grit
             c = commits[info[:id]]
             unless c
               c = Commit.create(repo, :id = info[:id],
-                                      :author = info[:author],
+                                      :author = Actor.from_string(info[:author] + ' ' + info[:author_email]),
                                       :authored_date = info[:author_date],
-                                      :committer = info[:committer],
+                                      :committer = Actor.from_string(info[:committer] + ' ' + info[:committer_email]),
                                       :committed_date = info[:committer_date],
                                       :message = info[:summary])
               commits[info[:id]] = c
@@ -102,11 +102,6 @@ module Grit
     def inspect
       %Q{#Grit::Blob "#{@id}"}
     end
-    
-    # private
-    
-    def self.read_
-    end
   end # Blob
   
 end # Grit
\ No newline at end of file
diff --git a/lib/grit/commit.rb b/lib/grit/commit.rb
index c2a9e2f81657b19925fe9bab4bc5d7ac130e5880..cd9c3e3184c97e83a8982fab9499cad3aec339f6 100644
--- a/lib/grit/commit.rb
+++ b/lib/grit/commit.rb
@@ -136,6 +136,11 @@ module Grit
       commits
     end
     
+    def self.diff(repo, id)
+      text = repo.git.diff({:full_index = true}, id)
+      Diff.list_from_string(repo, text)
+    end
+    
     # Convert this Commit to a String which is just the SHA1 id
     def to_s
       @id
@@ -153,7 +158,7 @@ module Grit
     # Returns [String (actor name and email), Time (acted at time)]
     def self.actor(line)
       m, actor, epoch = *line.match(/^.+? (.*) (\d+) .*$/)
-      [actor, Time.at(epoch.to_i)]
+      [Actor.from_string(actor), Time.at(epoch.to_i)]
     end
   end # Commit
   
diff --git a/lib/grit/git.rb b/lib/grit/git.rb
index 1d5251d40fb65ac89184ec662a3e1b04d0c24861..98eeddda5ed2b0e215e21128112393bdc9bc9039 100644
--- a/lib/grit/git.rb
+++ b/lib/grit/git.rb
@@ -13,17 +13,6 @@ module Grit
       self.git_dir = git_dir
     end
     
-    # Converstion hash from Ruby style options to git command line
-    # style options
-    TRANSFORM = {:max_count = "--max-count=",
-                 :skip = "--skip=",
-                 :pretty = "--pretty=",
-                 :sort = "--sort=",
-                 :format = "--format=",
-                 :since = "--since=",
-                 :p = "-p",
-                 :s = "-s"}
-    
     # Run the given git command with the specified arguments and return
     # the result as a String
     #   +cmd+ is the command
@@ -52,12 +41,19 @@ module Grit
     def transform_options(options)
       args = []
       options.keys.each do |opt|
-        if TRANSFORM[opt]
+        if opt.to_s.size == 1
+          if options[opt] == true
+            args  "-#{opt}"
+          else
+            val = options.delete(opt)
+            args  "-#{opt.to_s} #{val}"
+          end
+        else
           if options[opt] == true
-            args  TRANSFORM[opt]
+            args  "--#{opt.to_s.gsub(/_/, '-')}"
           else
             val = options.delete(opt)
-            args  TRANSFORM[opt] + val.to_s
+            args  "--#{opt.to_s.gsub(/_/, '-')}=#{val}"
           end
         end
       end
diff --git a/lib/grit/repo.rb b/lib/grit/repo.rb
index 624991d07e240ae66ff2a0dc55e2f2b5e262c75b..63bf03b839374c96a3d42a07d56681a797f52a71 100644
--- a/lib/grit/repo.rb
+++ b/lib/grit/repo.rb
@@ -93,6 +93,17 @@ module Grit
     def blob(id)
       Blob.create(self, :id = id)
     end
+
+    # The commit log for a treeish
+    #
+    # Returns Grit::Commit[]
+    def log(commit = 'master', path = nil, options = {})
+      default_options = {:pretty = "raw"}
+      actual_options  = default_options.merge(options)
+      arg = path ? "#{commit} -- #{path}" : commit
+      commits = self.git.log(actual_options, arg)
+      Commit.list_from_string(self, commits)
+    end
     
     # The diff from commit +a+ to commit +b+, optionally restricted to the given file(s)
     #   +a+ is the base commit
@@ -121,4 +132,4 @@ module Grit
     end
   end # Repo
   
-end # Grit
\ No newline at end of file
+end # Grit
diff --git a/test/test_actor.rb b/test/test_actor.rb
new file mode 100644
index 0000000000000000000000000000000000000000..08391f12336831d048122c8d13bc8404f27e6b91
--- /dev/null
+++ b/test/test_actor.rb
@@ -0,0 +1,28 @@
+require File.dirname(__FILE__) + '/helper'
+
+class TestActor  Test::Unit::TestCase
+  def setup
+    
+  end
+  
+  # from_string
+  
+  def test_from_string_should_separate_name_and_email
+    a = Actor.from_string("Tom Werner tom@example.com")
+    assert_equal "Tom Werner", a.name
+    assert_equal "tom@example.com", a.email
+  end
+  
+  def test_from_string_should_handle_just_name
+    a = Actor.from_string("Tom Werner")
+    assert_equal "Tom Werner", a.name
+    assert_equal nil, a.email
+  end
+  
+  # inspect
+  
+  def test_inspect
+    a = Actor.from_string("Tom Werner tom@example.com")
+    assert_equal %Q{#Grit::Actor "Tom Werner tom@example.com"}, a.inspect
+  end
+end
\ No newline at end of file
diff --git a/test/test_blob.rb b/test/test_blob.rb
index 6fa087d785661843034d03c7e0b917a8a80d5d8c..9ef84cc14266141b070771706b8aeebc3dfbef82 100644
--- a/test/test_blob.rb
+++ b/test/test_blob.rb
@@ -40,9 +40,11 @@ class TestBlob  Test::Unit::TestCase
     c = b.first.first
     c.expects(:__bake__).times(0)
     assert_equal '634396b2f541a9f2d58b00be1a07f0c358b999b3', c.id
-    assert_equal 'Tom Preston-Werner', c.author
+    assert_equal 'Tom Preston-Werner', c.author.name
+    assert_equal 'tom@mojombo.com', c.author.email
     assert_equal Time.at(1191997100), c.authored_date
-    assert_equal 'Tom Preston-Werner', c.committer
+    assert_equal 'Tom Preston-Werner', c.committer.name
+    assert_equal 'tom@mojombo.com', c.committer.email
     assert_equal Time.at(1191997100), c.committed_date
     assert_equal 'initial grit setup', c.message
     # c.expects(:__bake__).times(1)
diff --git a/test/test_commit.rb b/test/test_commit.rb
index 3bd6af75deda05725900eb7fd06e8107df14c655..0936c90e5b29ede2b5214d6dc26d256a8c6646f4 100644
--- a/test/test_commit.rb
+++ b/test/test_commit.rb
@@ -10,9 +10,28 @@ class TestCommit  Test::Unit::TestCase
   def test_bake
     Git.any_instance.expects(:rev_list).returns(fixture('rev_list_single'))
     @c = Commit.create(@r, :id = '4c8124ffcf4039d292442eeccabdeca5af5c5017')
-    @c.author # cause bake-age
+    @c.author # bake
     
-    assert_equal "Tom Preston-Werner tom@mojombo.com", @c.author
+    assert_equal "Tom Preston-Werner", @c.author.name
+    assert_equal "tom@mojombo.com", @c.author.email
+  end
+  
+  # diff
+  
+  def test_diff
+    Git.any_instance.expects(:diff).returns(fixture('diff_p'))
+    diffs = Commit.diff(@r, 'master')
+    
+    assert_equal 15, diffs.size
+    
+    assert_equal '.gitignore', diffs.first.a_path
+    assert_equal '.gitignore', diffs.first.b_path
+    assert_equal '4ebc8ae', diffs.first.a_commit
+    assert_equal '2dd0253', diffs.first.b_commit
+    assert_equal '100644', diffs.first.mode
+    assert_equal false, diffs.first.new_file
+    assert_equal false, diffs.first.deleted_file
+    assert_equal "--- a/.gitignore\n+++ b/.gitignore\n@@ -1 +1,2 @@\n coverage\n+pkg", diffs.first.diff
   end
   
   # to_s
diff --git a/test/test_git.rb b/test/test_git.rb
index e615a035d096b6cbc984e2f4213c06d0ac785321..72a18ec424f078f6daee75dbc62265c02ba7a892 100644
--- a/test/test_git.rb
+++ b/test/test_git.rb
@@ -10,6 +10,12 @@ class TestGit  Test::Unit::TestCase
   end
   
   def test_transform_options
+    assert_equal ["-s"], @git.transform_options({:s = true})
+    assert_equal ["-s 5"], @git.transform_options({:s = 5})
+    
+    assert_equal ["--max-count"], @git.transform_options({:max_count = true})
     assert_equal ["--max-count=5"], @git.transform_options({:max_count = 5})
+    
+    assert_equal ["-t", "-s"], @git.transform_options({:s = true, :t = true})
   end
 end
\ No newline at end of file
diff --git a/test/test_repo.rb b/test/test_repo.rb
index d53476a51e3286be270c7b515ec1d65e5c1716e0..114a4464fa248550be10cc4abe0735d6025b5fca 100644
--- a/test/test_repo.rb
+++ b/test/test_repo.rb
@@ -59,9 +59,11 @@ class TestRepo  Test::Unit::TestCase
     assert_equal '4c8124ffcf4039d292442eeccabdeca5af5c5017', c.id
     assert_equal ["634396b2f541a9f2d58b00be1a07f0c358b999b3"], c.parents.map { |p| p.id }
     assert_equal "672eca9b7f9e09c22dcb128c283e8c3c8d7697a4", c.tree.id
-    assert_equal "Tom Preston-Werner tom@mojombo.com", c.author
+    assert_equal "Tom Preston-Werner", c.author.name
+    assert_equal "tom@mojombo.com", c.author.email
     assert_equal Time.at(1191999972), c.authored_date
-    assert_equal "Tom Preston-Werner tom@mojombo.com", c.committer
+    assert_equal "Tom Preston-Werner", c.committer.name
+    assert_equal "tom@mojombo.com", c.committer.email
     assert_equal Time.at(1191999972), c.committed_date
     assert_equal "implement Grit#heads", c.message
     
@@ -125,4 +127,18 @@ class TestRepo  Test::Unit::TestCase
   def test_inspect
     assert_equal %Q{#Grit::Repo "#{File.expand_path(GRIT_REPO)}/.git"}, @r.inspect
   end
-end
\ No newline at end of file
+
+  # log
+
+  def test_log
+    Git.any_instance.expects(:log).times(2).with({:pretty = 'raw'}, 'master').returns(fixture('rev_list'))
+
+    assert_equal '4c8124ffcf4039d292442eeccabdeca5af5c5017', @r.log.first.id
+    assert_equal 'ab25fd8483882c3bda8a458ad2965d2248654335', @r.log.last.id
+  end
+
+  def test_log_with_path_and_options
+    Git.any_instance.expects(:log).with({:pretty = 'raw', :max_count = 1}, 'master -- file.rb').returns(fixture('rev_list'))
+    @r.log('master', 'file.rb', :max_count = 1)
+  end
+end
</content>
		</actual_file>
		<actual_file>
			<filename>diff_renames</filename>
			<content>diff --git a/LICENSE b/MIT-LICENSE
similarity index 90%
rename from LICENSE
rename to MIT-LICENSE
index a4ed2f5..edb5635 100644
--- a/LICENSE
+++ b/MIT-LICENSE
@@ -1,6 +1,6 @@
 (The MIT License)
 
-Copyright (c) 2007-2009 Tom Preston-Werner
+Copyright (c) 2007-2010 Tom Preston-Werner
 
 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
@@ -19,4 +19,4 @@ MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
\ No newline at end of file
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/README.md b/README.md
index 5412622..715d797 100644
--- a/README.md
+++ b/README.md
@@ -1,4 +1,4 @@
-Grit
+Grit!
 ====
 
 Grit gives you object oriented read/write access to Git repositories via Ruby.
diff --git a/Rakefile b/Rakefile
deleted file mode 100644
index f2fa932..0000000
--- a/Rakefile
+++ /dev/null
@@ -1,149 +0,0 @@
-require 'rubygems'
-require 'rake'
-require 'date'
-
-#############################################################################
-#
-# Helper functions
-#
-#############################################################################
-
-def name
-  @name ||= Dir['*.gemspec'].first.split('.').first
-end
-
-def version
-  line = File.read("lib/#{name}.rb")[/^\s*VERSION\s*=\s*.*/]
-  line.match(/.*VERSION\s*=\s*['"](.*)['"]/)[1]
-end
-
-def date
-  Date.today.to_s
-end
-
-def rubyforge_project
-  name
-end
-
-def gemspec_file
-  "#{name}.gemspec"
-end
-
-def gem_file
-  "#{name}-#{version}.gem"
-end
-
-def replace_header(head, header_name)
-  head.sub!(/(\.#{header_name}\s*= ').*'/) { "#{$1}#{send(header_name)}'"}
-end
-
-#############################################################################
-#
-# Standard tasks
-#
-#############################################################################
-
-task :default = :test
-
-require 'rake/testtask'
-Rake::TestTask.new(:test) do |test|
-  test.libs  'lib'  'test'
-  test.pattern = 'test/**/test_*.rb'
-  test.verbose = true
-end
-
-desc "Generate RCov test coverage and open in your browser"
-task :coverage do
-  require 'rcov'
-  sh "rm -fr coverage"
-  sh "rcov test/test_*.rb"
-  sh "open coverage/index.html"
-end
-
-require 'rake/rdoctask'
-Rake::RDocTask.new do |rdoc|
-  rdoc.rdoc_dir = 'rdoc'
-  rdoc.title = "#{name} #{version}"
-  rdoc.rdoc_files.include('README*')
-  rdoc.rdoc_files.include('lib/**/*.rb')
-end
-
-desc "Open an irb session preloaded with this library"
-task :console do
-  sh "irb -rubygems -r ./lib/#{name}.rb"
-end
-
-#############################################################################
-#
-# Custom tasks (add your own tasks here)
-#
-#############################################################################
-
-desc "Upload site to Rubyforge"
-task :site do
-  sh "scp -r doc/* mojombo@grit.rubyforge.org:/var/www/gforge-projects/grit"
-end
-
-#############################################################################
-#
-# Packaging tasks
-#
-#############################################################################
-
-task :release = :build do
-  unless `git branch` =~ /^\* master$/
-    puts "You must be on the master branch to release!"
-    exit!
-  end
-  sh "git commit --allow-empty -a -m 'Release #{version}'"
-  sh "git tag v#{version}"
-  sh "git push origin master"
-  sh "git push v#{version}"
-  sh "gem push pkg/#{name}-#{version}.gem"
-end
-
-task :build = :gemspec do
-  sh "mkdir -p pkg"
-  sh "gem build #{gemspec_file}"
-  sh "mv #{gem_file} pkg"
-end
-
-task :gemspec = :validate do
-  # read spec file and split out manifest section
-  spec = File.read(gemspec_file)
-  head, manifest, tail = spec.split("  # = MANIFEST =\n")
-
-  # replace name version and date
-  replace_header(head, :name)
-  replace_header(head, :version)
-  replace_header(head, :date)
-  #comment this out if your rubyforge_project has a different name
-  replace_header(head, :rubyforge_project)
-
-  # determine file list from git ls-files
-  files = `git ls-files`.
-    split("\n").
-    sort.
-    reject { |file| file =~ /^\./ }.
-    reject { |file| file =~ /^(rdoc|pkg|test)/ }.
-    map { |file| "    #{file}" }.
-    join("\n")
-
-  # piece file back together and write
-  manifest = "  s.files = %w[\n#{files}\n  ]\n"
-  spec = [head, manifest, tail].join("  # = MANIFEST =\n")
-  File.open(gemspec_file, 'w') { |io| io.write(spec) }
-  puts "Updated #{gemspec_file}"
-end
-
-task :validate do
-  libfiles = Dir['lib/*'] - ["lib/#{name}.rb", "lib/#{name}"]
-  unless libfiles.empty?
-    puts "Directory `lib` should only contain a `#{name}.rb` file and `#{name}` dir."
-    exit!
-  end
-  unless Dir['VERSION*'].empty?
-    puts "A `VERSION` file at root level violates Gem best practices."
-    exit!
-  end
-end
diff --git a/PURE_TODO b/TODO
similarity index 100%
rename from PURE_TODO
rename to TODO
diff --git a/foobar b/foobar
new file mode 100644
index 0000000..45b983b
--- /dev/null
+++ b/foobar
@@ -0,0 +1 @@
+hi</content>
		</actual_file>
		<actual_file>
			<filename>gitmodules</filename>
			<content>[submodule "god"]
	path = god
	url = git://github.com/mojombo/god
[submodule "test/glowstick"]
	path = test/glowstick
	url = git://github.com/mojombo/glowstick
</content>
		</actual_file>
		<actual_file>
			<filename>log</filename>
			<content>commit a49b96b339c525d7fd455e0ad4f6fe7b550c9543
Author: Scott Chacon schacon@gmail.com
Date:   Thu May 29 15:56:41 2008 -0700

    added examples

13      0       examples/ex_add_commit.rb
1       1       examples/ex_index.rb

commit 8f19810374686ad23dd63342b08d4ad1e65204c4
Author: Scott Chacon schacon@gmail.com
Date:   Thu May 29 15:16:16 2008 -0700

    rewrote the index implementation to write in pure ruby, which both speeds things up and deals with content mu

14      0       examples/ex_index.rb
1       1       lib/grit/git-ruby.rb
1       5       lib/grit/git-ruby/repository.rb
31      12      lib/grit/index.rb
2       2       lib/grit/ref.rb

commit 28f28c504f3ebb647dadd5d504aaf8133aecadd9
Author: Scott Chacon schacon@gmail.com
Date:   Thu May 29 11:33:09 2008 -0700

    added some simple write ops : add, remove, commit

101     0       API.txt
1       0       PURE_TODO
129     0       benchmarks.rb</content>
		</actual_file>
		<actual_file>
			<filename>ls_files</filename>
			<content>100644 ae0786b99fc23d5a227bcfb54f12252f109ce39f 0	test/helper.rb
100644 9bd6016010e5ad9e787104e75ac2ab5ad7e04096 0	test/profile.rb
100644 373baa48adf7da63ec6bddc4adfece673c8bc2ad 0	test/suite.rb
100644 e728ef8034c6a16ff9a8dbe154b21d45b43458e6 0	test/test_actor.rb
100644 3d7bf379e880c962d1928a12b13a488c786f57ab 0	test/test_blob.rb
100644 48412bac5814d476ba98550b4674189ecf514087 0	test/test_commit.rb
100644 0886764b03db9b4b767e94d819d1516f23f19d49 0	test/test_config.rb
100644 5841f89c4aee4ec2091c3d545b01a9ca904408eb 0	test/test_diff.rb
100644 adbdc6d61b8caba532e13af64f6c7caea801b417 0	test/test_git.rb
100644 baaae854addf9b0443ac7f0021dda4344b868819 0	test/test_head.rb
100644 7b6d1b20c3f46a4549c6d21912fa8158466d865b 0	test/test_real.rb
100644 bc11beb6f14c103416914d8745529051b2100e7c 0	test/test_reality.rb
100644 7dc25bc3da321c75066af3f7188dc70e56e2523d 0	test/test_remote.rb
100644 8b5830199233034dd6a86e21cd0aff6a08138b23 0	test/test_repo.rb
100644 c6506397912dc8664a9829d2b20e23f32af8582f 0	test/test_rubygit.rb
100644 2e3b0cbcb019040f13785c113583e389a2c121b5 0	test/test_tag.rb
100644 4d06a9930d5ee4e1568b62446d313654377bc35b 0	test/test_tree.rb</content>
		</actual_file>
		<actual_file>
			<filename>ls_tree_a</filename>
			<content>100644 blob 81d2c27608b352814cbe979a6acd678d30219678	History.txt
100644 blob 641972d82c6d1b51122274ae8f6a0ecdfb56ee22	Manifest.txt
100644 blob 8b1e02c0fb554eed2ce2ef737a68bb369d7527df	README.txt
100644 blob 735d7338b7cb208563aa282f0376c5c4049453a7	Rakefile
040000 tree c3d07b0083f01a6e1ac969a0f32b8d06f20c62e5	bin
040000 tree aa06ba24b4e3f463b3c4a85469d0fb9e5b421cf8	lib
040000 tree 650fa3f0c17f1edb4ae53d8dcca4ac59d86e6c44	test
</content>
		</actual_file>
		<actual_file>
			<filename>ls_tree_b</filename>
			<content>100644 blob aa94e396335d2957ca92606f909e53e7beaf3fbb	grit.rb
040000 tree 34868e6e7384cb5ee51c543a8187fdff2675b5a7	grit
</content>
		</actual_file>
		<actual_file>
			<filename>ls_tree_commit</filename>
			<content>040000 tree 2afb47bcedf21663580d5e6d2f406f08f3f65f19	foo
160000 commit d35b34c6e931b9da8f6941007a92c9c9a9b0141a	bar
040000 tree f623ee576a09ca491c4a27e48c0dfe04be5f4a2e	baz
</content>
		</actual_file>
		<actual_file>
			<filename>ls_tree_paths_ruby</filename>
			<content>100644 blob 4232d073306f01cf0b895864e5a5cfad7dd76fce	History.txt
040000 tree a93f4c338734259d8ae577b16537ad6b99a90937	lib
</content>
		</actual_file>
		<actual_file>
			<filename>ls_tree_paths_ruby_deep</filename>
			<content>100644 blob 4232d073306f01cf0b895864e5a5cfad7dd76fce	History.txt
100644 blob 6afcf64c80da8253fa47228eb09bc0eea217e5d1	lib/grit.rb</content>
		</actual_file>
		<actual_file>
			<filename>ls_tree_recursive</filename>
			<content>100644 blob baaa47163a922b716898936f4ab032db4e08ae8a	.gitignore
100644 blob 4232d073306f01cf0b895864e5a5cfad7dd76fce	History.txt
100644 blob 22158f1075113476d332d6f5112cf948f38ae658	Manifest.txt
100644 blob dd53bb4983125be6a5b2cc7ac9e89d75804a6a73	README.txt
100644 blob fdbea19c6688404f2a65767d8f889a0acdb0b25a	Rakefile
100644 blob 6afcf64c80da8253fa47228eb09bc0eea217e5d1	lib/grit.rb
100644 blob aea9a6bcd6387582d608dee28b364f7598cfffcd	lib/grit/actor.rb
100644 blob 3fb4076a1bbf70beb7b0c2f799e41996a4d19263	lib/grit/blob.rb
100644 blob 8c271ef2014e5633c5a38dddc196fd24c7f91f4f	lib/grit/commit.rb
100644 blob 4dd88a9f7f33730514cd84fd519dcb42644676b7	lib/grit/config.rb
100644 blob a572e57783475b70d8e71abbbe55b74c6fecfdfa	lib/grit/diff.rb
100644 blob 61742a7573852a41cfa1e30e0d05ecd58139eab8	lib/grit/errors.rb
100644 blob aa50f09c8d855e75effed0ea480f407ab6a2b2b2	lib/grit/git.rb
100644 blob 6865bf036695bed006fdfb2a8abd8a6b83fb149e	lib/grit/head.rb
100644 blob 15494f9e1bb59ddafe38d9229a3099d1c40f6919	lib/grit/lazy.rb
100644 blob 2708835b0ec94d20c13159b0839e2c915231437b	lib/grit/repo.rb
100644 blob dff53aba698d8223739151fedb4df60a78369e47	lib/grit/tag.rb
100644 blob 0a0871f51c10ec8be1fc7620968521a028aab875	lib/grit/tree.rb
100644 blob 10c141ddad72cf3d1b4d453b3a3f404fc89618b5	test/fixtures/blame
100644 blob 70c379b63ffa0795fdbfbc128e5a2818397b7ef8	test/fixtures/cat_file_blob
100644 blob b4de3947675361a7770d29b8982c407b0ec6b2a0	test/fixtures/cat_file_blob_size
100644 blob 1f060c70c1faa94ca1aa252ad941761a83d0f51d	test/fixtures/diff_2
100644 blob 5246cd6b9ac9b25fd749000e3e2ca3c83e517703	test/fixtures/diff_2f
100644 blob 48a49256b8df9cfff4ac9525a27a5748e8461ea8	test/fixtures/diff_f
100644 blob c6a2189cc56d325f8e52ef1ed6771478416dab49	test/fixtures/diff_i
100644 blob 6fc18f69e9b74eafb4a58a6fcbd218adc0d80c36	test/fixtures/diff_mode_only
100644 blob 7fa694e9e5cb6323218f45e35fa48b2fa6477cf0	test/fixtures/diff_new_mode
100644 blob e1a3e5502109aed83ff4fad63a21667069355a40	test/fixtures/diff_p
100644 blob 9f3bece3da6b8793a75384d35f583eac1abb506d	test/fixtures/for_each_ref
100644 blob c4df85c6216036926df44a108f9689094f095533	test/fixtures/for_each_ref_tags
100644 blob 69b76f4a366b6675ddc2765a73a5db515e45ce84	test/fixtures/ls_tree_a
100644 blob 329aff399afe21e6bc4ed06d35476b4e949d4c9c	test/fixtures/ls_tree_b
100644 blob d97aca04f64f0fea0888c848c39d92c5aee15f38	test/fixtures/ls_tree_commit
100644 blob c488ba936ed5a336413a2b99b32f46ee43a74aa7	test/fixtures/rev_list
100644 blob a802c139d4767c89dcad79d836d05f7004d39aac	test/fixtures/rev_list_count
100644 blob d8c6431e0a82b6b1bd4db339ee536f8bd4099c8f	test/fixtures/rev_list_single
100644 blob a639d89e68c58bb3e7c1ffa0f4c71f7f9d468e7d	test/fixtures/rev_parse
100644 blob ea25e32a409fdf74c1b9268820108d1c16dcc553	test/fixtures/show_empty_commit
100644 blob c1304b2b12781201d2ac145a1d2fe7534cc2605f	test/fixtures/simple_config
100644 blob ae0786b99fc23d5a227bcfb54f12252f109ce39f	test/helper.rb
100644 blob c752791a0bbde35b5951d3645e3b39af4e8f4abf	test/profile.rb
100644 blob 373baa48adf7da63ec6bddc4adfece673c8bc2ad	test/suite.rb
100644 blob e728ef8034c6a16ff9a8dbe154b21d45b43458e6	test/test_actor.rb
100644 blob 3d7bf379e880c962d1928a12b13a488c786f57ab	test/test_blob.rb
100644 blob 48412bac5814d476ba98550b4674189ecf514087	test/test_commit.rb
100644 blob 0886764b03db9b4b767e94d819d1516f23f19d49	test/test_config.rb
100644 blob 5841f89c4aee4ec2091c3d545b01a9ca904408eb	test/test_diff.rb
100644 blob adbdc6d61b8caba532e13af64f6c7caea801b417	test/test_git.rb
100644 blob baaae854addf9b0443ac7f0021dda4344b868819	test/test_head.rb
100644 blob 104e00e0f6a6bf25d6471f312125e596d301d25f	test/test_real.rb
100644 blob bc11beb6f14c103416914d8745529051b2100e7c	test/test_reality.rb
100644 blob 8818d637f1d39d4cddfd0dc1d8b3578ae4689778	test/test_repo.rb
100644 blob 2e3b0cbcb019040f13785c113583e389a2c121b5	test/test_tag.rb
100644 blob 4d06a9930d5ee4e1568b62446d313654377bc35b	test/test_tree.rb
</content>
		</actual_file>
		<actual_file>
			<filename>ls_tree_subdir</filename>
			<content>100644 blob aea9a6bcd6387582d608dee28b364f7598cfffcd	lib/grit/actor.rb
100644 blob 3fb4076a1bbf70beb7b0c2f799e41996a4d19263	lib/grit/blob.rb
100644 blob 8c271ef2014e5633c5a38dddc196fd24c7f91f4f	lib/grit/commit.rb
100644 blob 4dd88a9f7f33730514cd84fd519dcb42644676b7	lib/grit/config.rb
100644 blob a572e57783475b70d8e71abbbe55b74c6fecfdfa	lib/grit/diff.rb
100644 blob 61742a7573852a41cfa1e30e0d05ecd58139eab8	lib/grit/errors.rb
100644 blob ad42ff593e936be1ec7ac17346beab0a0761e278	lib/grit/git.rb
100644 blob 6865bf036695bed006fdfb2a8abd8a6b83fb149e	lib/grit/head.rb
100644 blob 15494f9e1bb59ddafe38d9229a3099d1c40f6919	lib/grit/lazy.rb
100644 blob 2708835b0ec94d20c13159b0839e2c915231437b	lib/grit/repo.rb
100644 blob dff53aba698d8223739151fedb4df60a78369e47	lib/grit/tag.rb
100644 blob 0a0871f51c10ec8be1fc7620968521a028aab875	lib/grit/tree.rb</content>
		</actual_file>
		<actual_file>
			<filename>ls_tree_submodule</filename>
			<content>160000 commit 5acd419b806424c0da883aa2e474cfe4177e8d48	god</content>
		</actual_file>
		<actual_file>
			<filename>merge_result</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestRepo  Test::Unit::TestCase
  def setup
    @r = Repo.new(GRIT_REPO)
  end
  
  # init_bar
  
  def test_init_bare
    Git.any_instance.expects(:init).returns(true)
    Repo.expects(:new).with("/foo/bar.git")
    Repo.init_bare("/foo/bar.git")
  end
  
 /var/folders/rX/rXo+hpkxGhuGDjRsHj5Plk+++TI/-Tmp-/merge1.584.1
	def test_tree
	  Git.any_instance.expects(:ls_tree).returns(fixture('ls_tree_a'))
	  tree = @r.tree('master')
  
	  assert_equal 4, tree.contents.select { |c| c.instance_of?(Blob) }.size
	  assert_equal 3, tree.contents.select { |c| c.instance_of?(Tree) }.size
	end

	# blob

	def test_blob
	  Git.any_instance.expects(:cat_file).returns(fixture('cat_file_blob'))
	  blob = @r.blob("abc")
	  assert_equal "Hello world", blob.data
	end
=======
  def test_init_bare_with_options
    Git.any_instance.expects(:init).with(
      :template = "/baz/sweet").returns(true)
    Repo.expects(:new).with("/foo/bar.git")
    Repo.init_bare("/foo/bar.git", :template = "/baz/sweet")
  end
  
  # fork_bare
  
  def test_fork_bare
    Git.any_instance.expects(:clone).with(
      {:bare = true, :shared = true}, 
      '/Users/tom/dev/mojombo/grit/.git',
      "/foo/bar.git").returns(nil)
    Repo.expects(:new)
      
    @r.fork_bare("/foo/bar.git")
  end
  
  def test_fork_bare_with_options
    Git.any_instance.expects(:clone).with(
      {:bare = true, :shared = true, :template = '/awesome'}, 
      '/Users/tom/dev/mojombo/grit/.git',
      "/foo/bar.git").returns(nil)
    Repo.expects(:new)
      
    @r.fork_bare("/foo/bar.git", :template = '/awesome')
  end
 /var/folders/rX/rXo+hpkxGhuGDjRsHj5Plk+++TI/-Tmp-/merge3.584.1
  # diff
  
  def test_diff
    Git.any_instance.expects(:diff).with({}, 'master^', 'master', '--')
    @r.diff('master^', 'master')
    
    Git.any_instance.expects(:diff).with({}, 'master^', 'master', '--', 'foo/bar')
    @r.diff('master^', 'master', 'foo/bar')
    
    Git.any_instance.expects(:diff).with({}, 'master^', 'master', '--', 'foo/bar', 'foo/baz')
    @r.diff('master^', 'master', 'foo/bar', 'foo/baz')
  end
  

end
</content>
		</actual_file>
		<actual_file>
			<filename>rev_list</filename>
			<content>commit 4c8124ffcf4039d292442eeccabdeca5af5c5017
tree 672eca9b7f9e09c22dcb128c283e8c3c8d7697a4
parent 634396b2f541a9f2d58b00be1a07f0c358b999b3
author Tom Preston-Werner tom@mojombo.com 1191999972 -0700
committer Tom Preston-Werner tom@mojombo.com 1191999972 -0700

    implement Grit#heads

commit 634396b2f541a9f2d58b00be1a07f0c358b999b3
tree b35b4bf642d667fdd613eebcfe4e17efd420fb8a
author Tom Preston-Werner tom@mojombo.com 1191997100 -0700
committer Tom Preston-Werner tom@mojombo.com 1191997100 -0700

    initial grit setup

commit ab25fd8483882c3bda8a458ad2965d2248654335
tree c20b5ec543bde1e43a931449b196052c06ed8acc
parent 6e64c55896aabb9a7d8e9f8f296f426d21a78c2c
parent 7f874954efb9ba35210445be456c74e037ba6af2
author Tom Preston-Werner tom@mojombo.com 1182645538 -0700
committer Tom Preston-Werner tom@mojombo.com 1182645538 -0700

    Merge branch 'site'
    
      * Some other stuff
      * just one more
</content>
		</actual_file>
		<actual_file>
			<filename>rev_list_all</filename>
			<content>commit ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a
tree 81a18c36ebe04e406ab84ccc911d79e65e14d1c0
parent 3fa4e130fa18c92e3030d4accb5d3e0cadd40157
author Scott Chacon schacon@gmail.com 1208561228 -0700
committer Scott Chacon schacon@gmail.com 1208561228 -0700

    added a pure-ruby git library and converted the cat_file commands to use it

commit 3fa4e130fa18c92e3030d4accb5d3e0cadd40157
tree b36d57789486dabe2309bd7819f7793ef2e7487c
parent 2d3acf90f35989df8f262dc50beadc4ee3ae1560
author Scott Chacon schacon@gmail.com 1208561167 -0700
committer Scott Chacon schacon@gmail.com 1208561167 -0700

    added a git directory to the testing dir for current and future testing
    
    sorry the directory is so large, but I wanted to use a real one and this
    was easier than anything else.  It's not huge, but it is bigger than it
    really needs to be.

commit 2d3acf90f35989df8f262dc50beadc4ee3ae1560
tree cd7422af5a2e0fff3e94d6fb1a8fff03b2841881
parent 5e3ee1198672257164ce3fe31dea3e40848e68d5
author Tom Preston-Werner tom@mojombo.com 1208054341 -0700
committer Tom Preston-Werner tom@mojombo.com 1208054341 -0700

    ignore errors from SIGCHLD on trap

commit 5e3ee1198672257164ce3fe31dea3e40848e68d5
tree 77fc9894c0904279fde93adc9c0ba231515ce68a
parent 30e367cef2203eba2b341dc9050993b06fd1e108
parent 420eac97a826bfac8724b6b0eef35c20922124b7
author Tom Preston-Werner tom@mojombo.com 1208054148 -0700
committer Tom Preston-Werner tom@mojombo.com 1208054148 -0700

    Merge branch 'master' of git://github.com/dustin/grit

commit 420eac97a826bfac8724b6b0eef35c20922124b7
tree e20cd1de2a022aef9ddae66e3f8dd8184f156c0f
parent d6016bc9fa3950ad18e3028f9d2d26f831061a62
author Dustin Sallings dustin@spy.net 1207072323 -0700
committer Dustin Sallings dustin@spy.net 1207072323 -0700

    Added a method for getting the current branch.

commit 30e367cef2203eba2b341dc9050993b06fd1e108
tree 064fac18d116198ab6fd036f8b17aceac6d424f6
parent 5a0943123f6872e75a9b1dd0b6519dd42a186fda
author Chris Wanstrath chris@ozmm.org 1206935408 -0700
committer Chris Wanstrath chris@ozmm.org 1206935408 -0700

    timeout code and tests

commit 5a0943123f6872e75a9b1dd0b6519dd42a186fda
tree 5518ba132764c66c355352e7bd770b49813bfbe6
parent e1193f8092ae9ece0ba336b7aa4c29dcde78777f
author Chris Wanstrath chris@ozmm.org 1206919880 -0700
committer Chris Wanstrath chris@ozmm.org 1206919880 -0700

    add timeout protection to grit

commit e1193f8092ae9ece0ba336b7aa4c29dcde78777f
tree 2974dc0e066657e130a47805119da0d8aa196fc6
parent d6016bc9fa3950ad18e3028f9d2d26f831061a62
author Chris Wanstrath chris@ozmm.org 1206847883 -0700
committer Chris Wanstrath chris@ozmm.org 1206847883 -0700

    support for heads with slashes in them

commit d6016bc9fa3950ad18e3028f9d2d26f831061a62
tree 1debe02029de82bd5be9c8912a0b3e388ef43cf8
parent 11d191ef3f04012a78222cb118619c16d5581886
author Tom Preston-Werner tom@mojombo.com 1206505949 -0700
committer Tom Preston-Werner tom@mojombo.com 1206505949 -0700

    require time for xmlschema

commit 11d191ef3f04012a78222cb118619c16d5581886
tree abbd88b5eb9c6a2113cc61f16255ebb0e5541331
parent f11ceb37cbd72b8c7627aa9e2a7b8dbcbf10d107
parent ad44b88d69c4b7b61a9ec12445f00f082ca19f41
author Tom Preston-Werner tom@mojombo.com 1206505512 -0700
committer Tom Preston-Werner tom@mojombo.com 1206505512 -0700

    Merge branch 'defunkt' into local

commit f11ceb37cbd72b8c7627aa9e2a7b8dbcbf10d107
tree 3c539330583d953e3178f1f2172881d2c5fe0dcb
parent 28e7a1d3dd172a8e757ff777ab205a538b80385e
parent ccc8ba203bfb6b6051bfa083f73969f680ced61a
author Tom Preston-Werner tom@mojombo.com 1206500121 -0700
committer Tom Preston-Werner tom@mojombo.com 1206500121 -0700

    Merge branch 'master' of git://github.com/halorgium/grit into halorgium

commit 28e7a1d3dd172a8e757ff777ab205a538b80385e
tree 767ea252bae0f66ac8f07efc2b9e01e0eef37c64
parent be3178ec3bf47bbdc69bd6023443fb6c4ac5385c
parent 4aa3410e2d458b00b0f41920ffc2aa21f019d13d
author Tom Preston-Werner tom@mojombo.com 1206499866 -0700
committer Tom Preston-Werner tom@mojombo.com 1206499866 -0700

    Merge branch 'master' of git://github.com/evilchelu/grit into evilchelu

commit be3178ec3bf47bbdc69bd6023443fb6c4ac5385c
tree bf41c8e3c2797b469ca1ad7a27fe2e9923ec2e3f
parent 22825175e37f22c9418d756ca69b574d75602994
parent 472e4f3d6f54514c560487ce6bde30405a84ffa7
author Tom Preston-Werner tom@mojombo.com 1206499650 -0700
committer Tom Preston-Werner tom@mojombo.com 1206499650 -0700

    Merge branch 'master' of git://github.com/kamal/grit into kamal

commit 22825175e37f22c9418d756ca69b574d75602994
tree 21219d280aaa0c38935f2542c3f7addd143098e3
parent 179f919876a255a8e09d32a95c8209d66c7ed660
author Tom Preston-Werner tom@mojombo.com 1206499348 -0700
committer Tom Preston-Werner tom@mojombo.com 1206499348 -0700

    do not screw up diffs that have files with spaces in them

commit ad44b88d69c4b7b61a9ec12445f00f082ca19f41
tree 3694a0e49cf01cc4b5b87536b969dceb796c78ae
parent 78617eaee2ca3b88cd9bb5361d29a99b5555a3d2
author Chris Wanstrath chris@ozmm.org 1205197842 -0700
committer Chris Wanstrath chris@ozmm.org 1205197842 -0700

    Touch up Commit#to_hash
    
    * Use string instead of symbol keys
    * Return parents as 'id' = ID rather than array of id strings

commit 78617eaee2ca3b88cd9bb5361d29a99b5555a3d2
tree f109df8b76219dc40ac02908293e237e76054c40
parent a55a698345a3f27a981ada27c7486d89e374bc21
parent 179f919876a255a8e09d32a95c8209d66c7ed660
author Chris Wanstrath chris@ozmm.org 1205191591 -0700
committer Chris Wanstrath chris@ozmm.org 1205191591 -0700

    Merge branch 'master' of git://github.com/mojombo/grit into mojombo/master
    
    Conflicts:
    
    	lib/grit/commit.rb

commit a55a698345a3f27a981ada27c7486d89e374bc21
tree f0aa2f741d6f0677330bd8eb68e4ed7b2f840648
parent 4f0ea0c7c8985c48c94269886ba93c0ea73636cc
author Chris Wanstrath chris@ozmm.org 1205182982 -0700
committer Chris Wanstrath chris@ozmm.org 1205182982 -0700

    add in Commit#to_hash method

commit ccc8ba203bfb6b6051bfa083f73969f680ced61a
tree a12c4a3bee1bcb9e820f798fc9fcf4776eadf5a3
parent 3dc4f654a697467692478f502817dfc3e0248378
author Tim Carey-Smith tim@spork.in 1205034630 +1300
committer Tim Carey-Smith tim@spork.in 1205034630 +1300

    Add write support to the git configuration

commit 3dc4f654a697467692478f502817dfc3e0248378
tree 701dd1ad5da076d8c1905bf7df35216313ca6bed
parent f1964ad1919180dd1d9eae9d21a1a1f68ac60e77
author Tim Carey-Smith tim@spork.in 1204849678 +1300
committer Tim Carey-Smith tim@spork.in 1204849678 +1300

    Don't add .git to "bare" repositories as it is unnecessary.
    
    Repo#path is the full path to the .git directory regardless of whether it is bare or not

commit f1964ad1919180dd1d9eae9d21a1a1f68ac60e77
tree 8612a93b202cf0c9078d4e9163a6fdcf18eab3c7
parent 179f919876a255a8e09d32a95c8209d66c7ed660
author Tim Carey-Smith tim@spork.in 1204849330 +1300
committer Tim Carey-Smith tim@spork.in 1204849330 +1300

    Add support for accessing repository configuration values

commit 4aa3410e2d458b00b0f41920ffc2aa21f019d13d
tree 5fe8964e26fc7136289ab531f04a2ecb8b829559
parent ca78e948410d39b690a76a7c613b83b70de64eeb
author Cristi Balan evil@che.lu 1204844586 +0200
committer Cristi Balan evil@che.lu 1204844586 +0200

    don't crash when diffing and last pair only contains file mode changes

commit ca78e948410d39b690a76a7c613b83b70de64eeb
tree 3659fff21dc0603037e901ad2be8a5dc1314c964
parent 179f919876a255a8e09d32a95c8209d66c7ed660
author Cristi Balan evil@che.lu 1204843570 +0200
committer Cristi Balan evil@che.lu 1204843570 +0200

    allow letters in git version test
    
    git from git has versions like "1.5.4.19.ge375"

commit 179f919876a255a8e09d32a95c8209d66c7ed660
tree b1281e51087f91e527efbeb2872903585c747fee
parent 55737f3f9128b02bf3519f5f70b6118234454c65
author Tom Preston-Werner tom@mojombo.com 1204792712 -0800
committer Tom Preston-Werner tom@mojombo.com 1204792712 -0800

    enable --all for Commit.find_all

commit 472e4f3d6f54514c560487ce6bde30405a84ffa7
tree 788638e5d2d62aa7e136f5051cc2aac7da26ba0d
parent 55737f3f9128b02bf3519f5f70b6118234454c65
author Kamal Fariz Mahyuddin kamal.fariz@gmail.com 1204644737 +0800
committer Kamal Fariz Mahyuddin kamal.fariz@gmail.com 1204644737 +0800

    Tiny fix to add mime-types as a dependency in Hoe's extra_deps

commit 55737f3f9128b02bf3519f5f70b6118234454c65
tree 55498bb71d91548a3b853e600f322ef51782e28d
parent f6b346156dd19a9fe46004a3efce4fc8d66addf9
author Tom Preston-Werner tom@mojombo.com 1204347482 -0800
committer Tom Preston-Werner tom@mojombo.com 1204347482 -0800

    do not strip leading spaces from commit messages

commit f6b346156dd19a9fe46004a3efce4fc8d66addf9
tree ec4aab5726569a38c74b7f17df19f94840f4c6b3
parent ff3f41fe66bd482281347314ed1cd1cb4b853c38
author Tom Preston-Werner tom@mojombo.com 1203907527 -0800
committer Tom Preston-Werner tom@mojombo.com 1203907527 -0800

    repsect blank lines in commit messages

commit ff3f41fe66bd482281347314ed1cd1cb4b853c38
tree b675fe87a6276810e8c8a77d688379c9f180c3b8
parent 242253bdce7ae94d34b2af702e3618eea8ed9754
author Tom Preston-Werner tom@mojombo.com 1203893541 -0800
committer Tom Preston-Werner tom@mojombo.com 1203893541 -0800

    get full message from commits as well

commit 4f0ea0c7c8985c48c94269886ba93c0ea73636cc
tree e9f01d3b5f99a186f9e648e4ee6e20a7f2cbed62
parent 991ac754cafa7c87ccf25d77225154d16d4f4be6
parent 4c596908ce1136e8c32174ba13892c6fe68a010d
author Chris Wanstrath chris@ozmm.org 1203757972 -0800
committer Chris Wanstrath chris@ozmm.org 1203757972 -0800

    Merge branch 'lazy_delegator'
    
    Conflicts:
    
    	lib/grit.rb
    	lib/grit/tree.rb

commit 991ac754cafa7c87ccf25d77225154d16d4f4be6
tree 0eee584493ed8eafb398a317ce8b60e9fa2c2fa8
parent 4ceb8e966103ba1c0cf442f90b476367b0302347
parent 242253bdce7ae94d34b2af702e3618eea8ed9754
author Chris Wanstrath chris@ozmm.org 1203668665 -0800
committer Chris Wanstrath chris@ozmm.org 1203668665 -0800

    Merge branch 'mojombo'

commit 242253bdce7ae94d34b2af702e3618eea8ed9754
tree 0eee584493ed8eafb398a317ce8b60e9fa2c2fa8
parent 3c230a377740b6beb679a6b57a1e2b7e9940d321
author Tom Preston-Werner tom@mojombo.com 1203581897 -0800
committer Tom Preston-Werner tom@mojombo.com 1203581897 -0800

    fix diffs for mode only changes

commit 3c230a377740b6beb679a6b57a1e2b7e9940d321
tree 0c5393477e9d87b948100516fd449430440ddf36
parent e8ea908dd932eb21856495db140e27efb014bf3e
parent 182a706d083de61af95c3dba0d59dd3f91fe31b2
author Tom Preston-Werner tom@mojombo.com 1203498128 -0800
committer Tom Preston-Werner tom@mojombo.com 1203498128 -0800

    merge from technoweenie

commit e8ea908dd932eb21856495db140e27efb014bf3e
tree fc7f7a4a922021cdb0930157e7830befc9eeaeed
parent e8e7b385fd00a7e9609cf2f270d021f19f08f17f
author Wayne Larsen wayne@larsen.st 1203285956 -0500
committer Tom Preston-Werner tom@mojombo.com 1203325906 -0800

    Update tests to not use fixed absolute paths
    
    Signed-off-by: Tom Preston-Werner tom@mojombo.com

commit 182a706d083de61af95c3dba0d59dd3f91fe31b2
tree 2bdb7f089a890008730e239f2b894c71ac0d0693
parent 125c3f885f9041a48b2828cd1c707dbaff78a825
author rick technoweenie@gmail.com 1203324957 -0800
committer rick technoweenie@gmail.com 1203324957 -0800

    compact Commit contents from Trees so that #/(path_to_commit) doesn't raise a NoMethodError on NilClass#name.

commit 125c3f885f9041a48b2828cd1c707dbaff78a825
tree 58ecbd29348e6194379989ff43fecc220bb32d41
parent 3ea514188523ae9e8ecd603f760442f147042d6c
author Tom Preston-Werner tom@mojombo.com 1203049106 -0800
committer rick technoweenie@gmail.com 1203319151 -0800

    better alternates behavior

commit 3ea514188523ae9e8ecd603f760442f147042d6c
tree d03ebb928ede2410e267dcd6e4464a1843d458ff
parent f32458940ef496d61946d4e3d63bc5edd1ae0af7
author Tom Preston-Werner tom@mojombo.com 1203048371 -0800
committer rick technoweenie@gmail.com 1203319141 -0800

    add alternates getter and setter

commit e8e7b385fd00a7e9609cf2f270d021f19f08f17f
tree fbe0635ee7d51c3e4fb7e515fd161d79fde9ec96
parent c6d10852bf3cca44f17c0e3f3abb721c6fe7ec27
author Tom Preston-Werner tom@mojombo.com 1203049106 -0800
committer Tom Preston-Werner tom@mojombo.com 1203049106 -0800

    better alternates behavior

commit c6d10852bf3cca44f17c0e3f3abb721c6fe7ec27
tree c06c147aa36feb8ee8c3ae3cc578aaf2d0f4603a
parent 7a8d32cb18a0ba2ff8bf86cadacc3fd2816da219
author Tom Preston-Werner tom@mojombo.com 1203048371 -0800
committer Tom Preston-Werner tom@mojombo.com 1203048371 -0800

    add alternates getter and setter

commit f32458940ef496d61946d4e3d63bc5edd1ae0af7
tree 11805290045f0f3918e86cb469446da1dff30125
parent c9cf68fc61bd2634e90a4f6a12d88744e6297c4e
author rick technoweenie@gmail.com 1202712848 -0800
committer rick technoweenie@gmail.com 1202712848 -0800

    add to Commit::Diff tests so we know the right filename is parsed

commit c9cf68fc61bd2634e90a4f6a12d88744e6297c4e
tree 4929b022c7094614b84a2533022c6dfa07a69ef6
parent 460b3216db32a55d07b1de0570bbb8427611b599
author rick technoweenie@gmail.com 1202712678 -0800
committer rick technoweenie@gmail.com 1202712678 -0800

    allow Grit::Commit.diff to specify an optional array of paths

commit 7a8d32cb18a0ba2ff8bf86cadacc3fd2816da219
tree c419308ba70d36105336ddde1070209e516df853
parent 80238dccfb24b5dee8f6d6c99fc8d272486e0946
author Tom Preston-Werner tom@mojombo.com 1202698149 -0800
committer Tom Preston-Werner tom@mojombo.com 1202698149 -0800

    add tag support

commit 80238dccfb24b5dee8f6d6c99fc8d272486e0946
tree bad72bdba95db74888a8775cff30bdc81d82bab8
parent 460b3216db32a55d07b1de0570bbb8427611b599
author Tom Preston-Werner tom@mojombo.com 1200212521 -0800
committer Tom Preston-Werner tom@mojombo.com 1202696651 -0800

    wip

commit 460b3216db32a55d07b1de0570bbb8427611b599
tree 8ebeecb1d594925499506a9711fd8b7620629970
parent 59ddc32609925a9fb7e3b2e2cee04b7afd204d00
author Tom Preston-Werner tom@mojombo.com 1202690531 -0800
committer Tom Preston-Werner tom@mojombo.com 1202690531 -0800

    fix bug in diff caused by new mode

commit 59ddc32609925a9fb7e3b2e2cee04b7afd204d00
tree 1b4b064125f711c5aa6d7b9f451adf154c49e183
parent 13d27d5cea4d0d787163dd97f8ee63d200d2a663
author Tom Preston-Werner tom@mojombo.com 1202608769 -0800
committer Tom Preston-Werner tom@mojombo.com 1202608769 -0800

    deal with empty initial commit

commit 13d27d5cea4d0d787163dd97f8ee63d200d2a663
tree 7d0aa3121eb66d2bfbaef5f2ad8539f3b74af956
parent 7235ace853d766d2c4a39d5e505c05497b1b7fb7
parent c45fa0feea864d535f77d39caa735820aa720caa
author Tom Preston-Werner tom@mojombo.com 1202605425 -0800
committer Tom Preston-Werner tom@mojombo.com 1202605425 -0800

    Merge branch 'master' of git://github.com/defunkt/grit into d3

commit 7235ace853d766d2c4a39d5e505c05497b1b7fb7
tree 978b80d57aac2acc932f8a93a6654b697cd545f4
parent 3ed8c6eb935326c8de850dae4be5e2493a2a8c2e
author Tom Preston-Werner tom@mojombo.com 1202602376 -0800
committer Tom Preston-Werner tom@mojombo.com 1202602376 -0800

    add Repo#commit_count

commit 3ed8c6eb935326c8de850dae4be5e2493a2a8c2e
tree 4344af33cce729b84f0c380496cfeb1dee3c2a3a
parent 301edd42ff7a55dffb86446349b33d6d4198d192
author Tom Preston-Werner tom@mojombo.com 1201772154 -0800
committer Tom Preston-Werner tom@mojombo.com 1201772154 -0800

    fix quoting problem for Repo#log

commit 4ceb8e966103ba1c0cf442f90b476367b0302347
tree 75a6b13626a6d971529252309a693960a09a4137
parent c45fa0feea864d535f77d39caa735820aa720caa
parent 301edd42ff7a55dffb86446349b33d6d4198d192
author Chris Wanstrath chris@ozmm.org 1201770150 -0800
committer Chris Wanstrath chris@ozmm.org 1201770150 -0800

    Merge branch 'mojombo'

commit 301edd42ff7a55dffb86446349b33d6d4198d192
tree d606412db39af09b92badecb2451c728a629db32
parent 6f6cb7cd4ab707c2273dd97113d9891da7a11885
author Tom Preston-Werner tom@mojombo.com 1201758430 -0800
committer Tom Preston-Werner tom@mojombo.com 1201758430 -0800

    quote all git parameters

commit 6f6cb7cd4ab707c2273dd97113d9891da7a11885
tree 99aa245831a84469897317ffd2f29baaedc41396
parent 02879cf62c803fd706dc45ab85dbc2e7efe5acc1
author Tom Preston-Werner tom@mojombo.com 1201313728 -0800
committer Tom Preston-Werner tom@mojombo.com 1201313728 -0800

    add commits_since

commit c45fa0feea864d535f77d39caa735820aa720caa
tree 8196528d03eb59920ba6e4f69860fc06c2d1e6d5
parent 3c413f1d3879a80ee3cbd8c7cd8033f7f04afa68
author Chris Wanstrath chris@ozmm.org 1200780948 -0800
committer Chris Wanstrath chris@ozmm.org 1200780948 -0800

    display the first commit of a repo without dying

commit 3c413f1d3879a80ee3cbd8c7cd8033f7f04afa68
tree 0ffed5403914d1031d67cc0a0c38f07461c4c8d5
parent db64b1265cb572d3b97cde164312194b83449ef2
parent 02879cf62c803fd706dc45ab85dbc2e7efe5acc1
author Chris Wanstrath chris@ozmm.org 1200780765 -0800
committer Chris Wanstrath chris@ozmm.org 1200780765 -0800

    Merge branch 'mojombo'

commit 02879cf62c803fd706dc45ab85dbc2e7efe5acc1
tree 0ffed5403914d1031d67cc0a0c38f07461c4c8d5
parent 8f24479836ada10f08846678a59d79609ce3d14f
author Tom Preston-Werner tom@mojombo.com 1200778557 -0800
committer Tom Preston-Werner tom@mojombo.com 1200778557 -0800

    add enable/disable daemon serve

commit 8f24479836ada10f08846678a59d79609ce3d14f
tree 4bdec4e8d370119fd0a54903b7fec5b61c35a2ec
parent 275a2b7c7aeadbd03fae865a5f67900a7ee1bfc6
author Tom Preston-Werner tom@mojombo.com 1200213518 -0800
committer Tom Preston-Werner tom@mojombo.com 1200213518 -0800

    add options to Repo.init_bare

commit 275a2b7c7aeadbd03fae865a5f67900a7ee1bfc6
tree 6f837e3f4598cfdfa28a65f809f10478b8241a74
parent 18e19dbbe8b7e152f762af65799bb19429e0d349
author Tom Preston-Werner tom@mojombo.com 1200210616 -0800
committer Tom Preston-Werner tom@mojombo.com 1200210686 -0800

    update readme with github location

commit 18e19dbbe8b7e152f762af65799bb19429e0d349
tree 6c7fc8d41d1585a999ddcd77fc340eb7a7d54b7d
parent fb49d370b21ed9214677d812dcde243cfeaf2303
author Tom Preston-Werner tom@mojombo.com 1200021682 -0800
committer Tom Preston-Werner tom@mojombo.com 1200021682 -0800

    add options to fork_bare

commit fb49d370b21ed9214677d812dcde243cfeaf2303
tree 112b15ec2bdf73bfb3d91005386d73b930666950
parent e631529f2525180e49b7b90fd0198d90d8106de0
parent 62e423d6d27b3c5016072c94e72bee1be37aea6d
author Tom Preston-Werner tom@mojombo.com 1200018956 -0800
committer Tom Preston-Werner tom@mojombo.com 1200018956 -0800

    Merge branch 'master' of git://github.com/defunkt/grit into defunkt2

commit e631529f2525180e49b7b90fd0198d90d8106de0
tree 46bba7656462c3618686aad62d7d09efa1284052
parent fe3bf3660ac64d86f2855ac3185eb5953ea2c3bd
author Tom Preston-Werner tom@mojombo.com 1200018565 -0800
committer Tom Preston-Werner tom@mojombo.com 1200018565 -0800

    add fork_bare

commit fe3bf3660ac64d86f2855ac3185eb5953ea2c3bd
tree 526e68e86b2ffe53166d4087bc3754088e24fe3d
parent 6c38e553796a965fe62397350c537d0a795c9fd6
author Tom Preston-Werner tom@mojombo.com 1199870442 -0800
committer Tom Preston-Werner tom@mojombo.com 1199870442 -0800

    add Repo#commits_between

commit 6c38e553796a965fe62397350c537d0a795c9fd6
tree fe1fbec65bf99dc442780e4431b3d7defc6645fb
parent 7bcc0ee821cdd133d8a53e8e7173a334fef448aa
author Tom Preston-Werner tom@mojombo.com 1199768869 -0800
committer Tom Preston-Werner tom@mojombo.com 1199768869 -0800

    rake site

commit 7bcc0ee821cdd133d8a53e8e7173a334fef448aa
tree 7d09edb3825b5edff295fad85ac3ace7bfe31fdd
parent 3e0955045cb189a7112015c26132152a94f637bf
author Tom Preston-Werner tom@mojombo.com 1199767315 -0800
committer Tom Preston-Werner tom@mojombo.com 1199767315 -0800

    prepare for public release

commit db64b1265cb572d3b97cde164312194b83449ef2
tree 0955b8d93ab4758376d500ad692ca19549ae5174
parent 62e423d6d27b3c5016072c94e72bee1be37aea6d
parent 3e0955045cb189a7112015c26132152a94f637bf
author Chris Wanstrath chris@ozmm.org 1199690014 -0800
committer Chris Wanstrath chris@ozmm.org 1199690014 -0800

    Merge branch 'mojombo'

commit 3e0955045cb189a7112015c26132152a94f637bf
tree 54f2aa4afa386748e129d209103b1235e8de4aaa
parent b86b48e3520a106739035b149dbed97445152868
author Tom Preston-Werner tom@mojombo.com 1199674791 -0800
committer Tom Preston-Werner tom@mojombo.com 1199674791 -0800

    add Commit#mime_type

commit 62e423d6d27b3c5016072c94e72bee1be37aea6d
tree e9ec095207155c95573defc2626b9276b16b6015
parent 1d22e6fde59c9ded9b8093cf26213a5bd9d4c5ec
parent b86b48e3520a106739035b149dbed97445152868
author Chris Wanstrath chris@ozmm.org 1199671761 -0800
committer Chris Wanstrath chris@ozmm.org 1199671761 -0800

    Merge branch 'mojombo'

commit b86b48e3520a106739035b149dbed97445152868
tree f42108d0fd3b3930131c29b7f27a72878448430b
parent 80f136f500dfdb8c3e8abf4ae716f875f0a1b57f
author Tom Preston-Werner tom@mojombo.com 1198889662 -0600
committer Tom Preston-Werner tom@mojombo.com 1198889662 -0600

    abbreviated sha1 and archiving

commit 80f136f500dfdb8c3e8abf4ae716f875f0a1b57f
tree 3fffd0fce0655433c945e6bdc5e9f338b087b211
parent 44f82e5ac93ba322161019dce44b78c5bd1fdce2
author tom tom@taco.(none) 1195608462 -0800
committer tom tom@taco.(none) 1195608462 -0800

    fix tests on other machines

commit 4c596908ce1136e8c32174ba13892c6fe68a010d
tree b2c79656afd10d9e8fe1191891b57710a306fbf3
parent 1d22e6fde59c9ded9b8093cf26213a5bd9d4c5ec
author Chris Wanstrath chris@ozmm.org 1193660410 -0700
committer Chris Wanstrath chris@ozmm.org 1193660410 -0700

    rework lazy some to be more of a delegator

commit 1d22e6fde59c9ded9b8093cf26213a5bd9d4c5ec
tree 9ad5126eba69a9ab519e7bafe9328caff5c614cd
parent 44f82e5ac93ba322161019dce44b78c5bd1fdce2
author Chris Wanstrath chris@ozmm.org 1193650959 -0700
committer Chris Wanstrath chris@ozmm.org 1193650959 -0700

    add #diffs to commit object

commit 44f82e5ac93ba322161019dce44b78c5bd1fdce2
tree c8f24bdaf32a822a8ff96d4a87924125608b32e2
parent 46291865ba0f6e0c9818b11be799fe2db6964d56
author Tom Preston-Werner tom@mojombo.com 1193642849 -0700
committer Tom Preston-Werner tom@mojombo.com 1193642849 -0700

    fix commit-diff deleted file bug

commit 46291865ba0f6e0c9818b11be799fe2db6964d56
tree e5d730ad9f05808195b0e2d8f9b14614d5bc881d
parent 02617bd0f7cae462e71be075c99385f709279533
author Tom Preston-Werner tom@mojombo.com 1193642198 -0700
committer Tom Preston-Werner tom@mojombo.com 1193642330 -0700

    implement commit diff

commit 02617bd0f7cae462e71be075c99385f709279533
tree faa81ee0f836ea8d954fba1fa088a40cfbe9cdf4
parent 5f141d9c0181b8732c0ec2fab4967f0ffa24fa3f
author Chris Wanstrath chris@ozmm.org 1193635446 -0700
committer Chris Wanstrath chris@ozmm.org 1193635446 -0700

    add Actor#to_s as alias to Actor#name

commit 5f141d9c0181b8732c0ec2fab4967f0ffa24fa3f
tree 318f0f8dfad4fcd19adf10742898642ddccf3156
parent 337539e896b8c85cc043a923c8fbb927f58e6450
author Chris Wanstrath chris@ozmm.org 1193616774 -0700
committer Chris Wanstrath chris@ozmm.org 1193616774 -0700

    git-log support

commit 337539e896b8c85cc043a923c8fbb927f58e6450
tree 16eb2a18985f5f5bb8945d051c4f1abb9b3a96e1
parent 8c7f4e1d8cb66590825701b758160e3721003dde
author Tom Preston-Werner tom@mojombo.com 1193329381 -0700
committer Tom Preston-Werner tom@mojombo.com 1193329381 -0700

    prepare for packaging as gem

commit 8c7f4e1d8cb66590825701b758160e3721003dde
tree acc8645713a107f3b755d6c721aa9e0a3fd658d9
parent b5d4f15a4dd41646405f11fb107aa8efb16c98a4
author Tom Preston-Werner tom@mojombo.com 1193328783 -0700
committer Tom Preston-Werner tom@mojombo.com 1193328783 -0700

    dynamically rewrite ruby style git options

commit b5d4f15a4dd41646405f11fb107aa8efb16c98a4
tree 98d3a51546524761b31c6411f36d2f883fef6803
parent f1ec1aea10986159456846b8a05615b87828d6c6
author Tom Preston-Werner tom@mojombo.com 1193293172 -0700
committer Tom Preston-Werner tom@mojombo.com 1193293172 -0700

    more readme

commit f1ec1aea10986159456846b8a05615b87828d6c6
tree f6105060dcd58ee588c4e8ecc22ac869b8b6a1b9
parent ec037431382e83c3e95d4f2b3d145afbac8ea55d
author Tom Preston-Werner tom@mojombo.com 1193289601 -0700
committer Tom Preston-Werner tom@mojombo.com 1193289601 -0700

    begin readme

commit ec037431382e83c3e95d4f2b3d145afbac8ea55d
tree de82ff44049069c5e6431d0f7ca1d1947c61b6f8
parent e80bbd2ce67651aa18e57fb0b43618ad4baf7750
author Tom Preston-Werner tom@mojombo.com 1193288551 -0700
committer Tom Preston-Werner tom@mojombo.com 1193288551 -0700

    add Actor inspect

commit e80bbd2ce67651aa18e57fb0b43618ad4baf7750
tree 3536eb9abac69c3e4db583ad38f3d30f8db4771f
parent 91169e1f5fa4de2eaea3f176461f5dc784796769
author Tom Preston-Werner tom@mojombo.com 1193286556 -0700
committer Tom Preston-Werner tom@mojombo.com 1193286556 -0700

    add Actor class to encapsulate name and email

commit 91169e1f5fa4de2eaea3f176461f5dc784796769
tree 802ed53edbf6f02ad664af3f7e5900f514024b2f
parent 038af8c329ef7c1bae4568b98bd5c58510465493
author Tom Preston-Werner tom@mojombo.com 1193200199 -0700
committer Tom Preston-Werner tom@mojombo.com 1193200199 -0700

    fix some initialization warnings

commit 038af8c329ef7c1bae4568b98bd5c58510465493
tree 890b57e86a663ad5f5943efe7cbce842724d3821
parent 40d3057d09a7a4d61059bca9dca5ae698de58cbe
author Tom Preston-Werner tom@mojombo.com 1193198877 -0700
committer Tom Preston-Werner tom@mojombo.com 1193198877 -0700

    implement repo level diff

commit 40d3057d09a7a4d61059bca9dca5ae698de58cbe
tree 35e282bc46bad194cab4d895f96543e514926710
parent 4ea50f4754937bf19461af58ce3b3d24c77311d9
author Tom Preston-Werner tom@mojombo.com 1192920277 -0700
committer Tom Preston-Werner tom@mojombo.com 1192920277 -0700

    add Tree./ to ease getting subtrees

commit 4ea50f4754937bf19461af58ce3b3d24c77311d9
tree 193a54188f5d18fb36a40ca39d4459b9e7f52b91
parent 1fddfabeaa0b62cb4becdb44980ec6cfa48ebd87
author Tom Preston-Werner tom@mojombo.com 1192917830 -0700
committer Tom Preston-Werner tom@mojombo.com 1192917830 -0700

    better errors for Repo.new

commit 1fddfabeaa0b62cb4becdb44980ec6cfa48ebd87
tree cb2a50044adef599a7ae90ec8f389a479cf8b0de
parent 01a1b4f1cbf0f4d9c13618a3ca9c9f429c8dd0e8
author Tom Preston-Werner tom@mojombo.com 1192871465 -0700
committer Tom Preston-Werner tom@mojombo.com 1192871465 -0700

    clear info hash in Blob.blame and update the doc

commit 01a1b4f1cbf0f4d9c13618a3ca9c9f429c8dd0e8
tree 5a367d4bedd38762f4ba47c5e30082a094dd19de
parent b6e1b765e0c15586a2c5b9832854f95defd71e1f
author Tom Preston-Werner tom@mojombo.com 1192870968 -0700
committer Tom Preston-Werner tom@mojombo.com 1192870968 -0700

    implement Blob.blame

commit b6e1b765e0c15586a2c5b9832854f95defd71e1f
tree 04c36f85f3a6c491cb6cdbbc459006f6e92ecbbf
parent ebdf4716e38c810b06b6e1fbc2ce3a6da2821f7a
author Tom Preston-Werner tom@mojombo.com 1192860483 -0700
committer Tom Preston-Werner tom@mojombo.com 1192860483 -0700

    implement Repo.init_bare

commit ebdf4716e38c810b06b6e1fbc2ce3a6da2821f7a
tree d2d6d6c99155b82e2bcfb1b11e97ba8b6c6a614c
parent 34a87f9a723cc51b6b74e0fe095c9046a826ef3b
author Tom Preston-Werner tom@mojombo.com 1192408450 -0700
committer Tom Preston-Werner tom@mojombo.com 1192408450 -0700

    add Repo.blob

commit 34a87f9a723cc51b6b74e0fe095c9046a826ef3b
tree d341f7ff79790dd059eddff582a98cbc553ac83c
parent fc128af28cb263bf1f524f84609a7a75ffa27a9b
author Tom Preston-Werner tom@mojombo.com 1192323935 -0700
committer Tom Preston-Werner tom@mojombo.com 1192323935 -0700

    implement Blob.data and Blob.size

commit fc128af28cb263bf1f524f84609a7a75ffa27a9b
tree e17421e5d7f9c7f791da1b87069f784c2570ebc5
parent c12f398c2f3c4068ca5e01d736b1c9ae994b2138
author Tom Preston-Werner tom@mojombo.com 1192318328 -0700
committer Tom Preston-Werner tom@mojombo.com 1192318328 -0700

    commit now returns Tree object for tree attribute

commit c12f398c2f3c4068ca5e01d736b1c9ae994b2138
tree 23ddf701b1cc7a4eb8861da83bd944fb6011cf6f
parent 74fd66519e983a0f29e16a342a6059dbffe36020
author Tom Preston-Werner tom@mojombo.com 1192317474 -0700
committer Tom Preston-Werner tom@mojombo.com 1192317474 -0700

    add inspects to objects

commit 74fd66519e983a0f29e16a342a6059dbffe36020
tree b400fbfadf631b5ae8547522e30c4fa001acfe7a
parent 2ac1712b56771dd2ca6420eb5319765c1827e13e
author Tom Preston-Werner tom@mojombo.com 1192317005 -0700
committer Tom Preston-Werner tom@mojombo.com 1192317005 -0700

    add Blob

commit 2ac1712b56771dd2ca6420eb5319765c1827e13e
tree 8a6316e1f43bc0327f8208a96ba16ed7ce2bbef6
parent b17b974691f0a26f26908495d24d9c4c718920f8
author Tom Preston-Werner tom@mojombo.com 1192312613 -0700
committer Tom Preston-Werner tom@mojombo.com 1192312613 -0700

    add lazy computation of tree contents

commit b17b974691f0a26f26908495d24d9c4c718920f8
tree 642389ee051c07987b97bb3124e0046d2663153d
parent 917522c4572a6237897e9a554cde21b8c6292dd3
author Tom Preston-Werner tom@mojombo.com 1192271832 -0700
committer Tom Preston-Werner tom@mojombo.com 1192271832 -0700

    started implementing Tree

commit 917522c4572a6237897e9a554cde21b8c6292dd3
tree f2a8e42a8cfbe614c71c789f716719f0f61fcf09
parent 4aa0e11f540c42a32ba24988966e9b1efbba6de3
author Tom Preston-Werner tom@mojombo.com 1192269257 -0700
committer Tom Preston-Werner tom@mojombo.com 1192269257 -0700

    more code comments throughout

commit 4aa0e11f540c42a32ba24988966e9b1efbba6de3
tree c2bd22b8d10bce2fa568f125094943827b6f6a00
parent 3b1930208a82457747d76729ae088e90edca4673
author Tom Preston-Werner tom@mojombo.com 1192268181 -0700
committer Tom Preston-Werner tom@mojombo.com 1192268181 -0700

    add comments and make Comment.parents return Commits

commit 3b1930208a82457747d76729ae088e90edca4673
tree 303706575c597fce0a9975ad22aa32092214e3fb
parent 6ffe534098dacefb3633efafff01eb0296f26725
author Tom Preston-Werner tom@mojombo.com 1192267241 -0700
committer Tom Preston-Werner tom@mojombo.com 1192267241 -0700

    big refactor to do lazy loading

commit 6ffe534098dacefb3633efafff01eb0296f26725
tree 03bb17629f49a3f745f7c81ef31e6c3f0b3b3239
parent 8bfefdbc0d901a6e8ccd27b9f20879d109f49c03
author Tom Preston-Werner tom@mojombo.com 1192259702 -0700
committer Tom Preston-Werner tom@mojombo.com 1192259702 -0700

    branches is alias of heads

commit 8bfefdbc0d901a6e8ccd27b9f20879d109f49c03
tree e41a446722f0e103818a660a51c6d1805c556920
parent de8ecf488033fb75504bf5179608f90d750f8759
author Tom Preston-Werner tom@mojombo.com 1192118973 -0700
committer Tom Preston-Werner tom@mojombo.com 1192118973 -0700

    implement Repo#commit and begin on Repo#tree

commit de8ecf488033fb75504bf5179608f90d750f8759
tree d224e6997c212a6306656ccbb7afdb823a8ec203
parent 404b7a0dea6406545f9969232049ff8119d3ac6f
author Tom Preston-Werner tom@mojombo.com 1192089079 -0700
committer Tom Preston-Werner tom@mojombo.com 1192089079 -0700

    more commits tests

commit 404b7a0dea6406545f9969232049ff8119d3ac6f
tree 176de8041f29d7ba67a5a12cfc9a518a4b4b25e5
parent a911921efe39c4f6fdce8571c1828eaf45d5551e
author Tom Preston-Werner tom@mojombo.com 1192088426 -0700
committer Tom Preston-Werner tom@mojombo.com 1192088426 -0700

    handle multiline commit messages

commit a911921efe39c4f6fdce8571c1828eaf45d5551e
tree d9fac0495032ed31cb52754d8a1bdc791126f70e
parent 2c6af5a45ddf8b539e8481d7bf9dff4bc71dde78
author Tom Preston-Werner tom@mojombo.com 1192083766 -0700
committer Tom Preston-Werner tom@mojombo.com 1192083766 -0700

    move heads logic into Head

commit 2c6af5a45ddf8b539e8481d7bf9dff4bc71dde78
tree f86a29df0aa853135af8eb3593ed38766542b86d
parent d837bd432d63b740b62d964dda48818bd97e778b
author Tom Preston-Werner tom@mojombo.com 1192083654 -0700
committer Tom Preston-Werner tom@mojombo.com 1192083654 -0700

    implement Repo.commits

commit d837bd432d63b740b62d964dda48818bd97e778b
tree f58593a0a776b92171214ea9af5095fde9edbb9f
parent d01a4cfad6ea50285c4710243e3cbe019d381eba
author Tom Preston-Werner tom@mojombo.com 1192033923 -0700
committer Tom Preston-Werner tom@mojombo.com 1192033923 -0700

    implement Repo#branches

commit d01a4cfad6ea50285c4710243e3cbe019d381eba
tree fb1e576fc4cf9822a47c331738fb27c4ebb9caef
parent a47fd41f3aa4610ea527dcc1669dfdb9c15c5425
author Tom Preston-Werner tom@mojombo.com 1192032303 -0700
committer Tom Preston-Werner tom@mojombo.com 1192032303 -0700

    convert to Grit module, refactor to be more OO

commit a47fd41f3aa4610ea527dcc1669dfdb9c15c5425
tree 34c16407fd62230585cacb0238061d4777d1a699
parent 5057e76a11abd02e83b7d3d3171c4b68d9c88480
author Tom Preston-Werner tom@mojombo.com 1192002639 -0700
committer Tom Preston-Werner tom@mojombo.com 1192002639 -0700

    add more comments throughout

commit 5057e76a11abd02e83b7d3d3171c4b68d9c88480
tree efab3b1bbd3c233778d0f912bb78e25c2e8c5b9f
parent 06f63b43050935962f84fe54473a7c5de7977325
author Tom Preston-Werner tom@mojombo.com 1192000700 -0700
committer Tom Preston-Werner tom@mojombo.com 1192000700 -0700

    clean up heads test

commit 06f63b43050935962f84fe54473a7c5de7977325
tree 81d34f133988acb07bc4f6a2f592d4f3bf7bbce0
parent 4c8124ffcf4039d292442eeccabdeca5af5c5017
author Tom Preston-Werner tom@mojombo.com 1192000262 -0700
committer Tom Preston-Werner tom@mojombo.com 1192000262 -0700

    stub git call for Grit#heads test

commit 4c8124ffcf4039d292442eeccabdeca5af5c5017
tree 672eca9b7f9e09c22dcb128c283e8c3c8d7697a4
parent 634396b2f541a9f2d58b00be1a07f0c358b999b3
author Tom Preston-Werner tom@mojombo.com 1191999972 -0700
committer Tom Preston-Werner tom@mojombo.com 1191999972 -0700

    implement Grit#heads

commit 634396b2f541a9f2d58b00be1a07f0c358b999b3
tree b35b4bf642d667fdd613eebcfe4e17efd420fb8a
author Tom Preston-Werner tom@mojombo.com 1191997100 -0700
committer Tom Preston-Werner tom@mojombo.com 1191997100 -0700

    initial grit setup

</content>
		</actual_file>
		<actual_file>
			<filename>rev_list_count</filename>
			<content>72223ed47d7792924083f1966e550694a0259d36
f7cd338ee316482c478805aa8b636a33df3e4299
994566139b90fffdc449c3f1104f42626e90f89f
e34590b7a2d186b3bb9a1170d02d52b36c791c78
8977833d74f8681aa0d9a5e84b0dd3d81519774d
6f5561530cb3a94e4c86454e84732197325be172
ee419e04a961543444be6db66aef52e6e37936d6
d845de9d438e1a249a0c2fcb778e8ea3b7e06cef
0bba4a6c10060405a94d52533af2f9bdacd4f29c
77711c0722964ead965e0ba2ee9ed4a03cb3d292
501d23cac6dd911511f15d091ee031a15b90ebde
07c9bd0abcd47cf9ca68af5d2403e28de33154f1
103ca320fc8bd48fed16e074df6ace6562bed4b5
55544624fb9be54a3b9f9e2ec85ef59e08bd0376
e5c8246dec64eccad0c095c67f5a8bbea7f11aca
1b54d9f82ee6f3f2129294c85fad910178bef185
36062a1634fb25de2c4b8f6b406ae3643805baf5
0896bb9b8d2217163e78b5f1f75022a330d9ddc8
6646dfce607b043ab7bbe36e51321422673b7c56
f0bad592abc255fabe6c6d6c62b604b3de5cdce2
5705e15c71f9e10ca617c0a234b37609cfb74d23
b006d8b73912eb028355c49e7bfe53a29f97ce7c
b21eb6173dbe07cac63f4571e353188dde46f049
a3256f3150ccec73c50b61b85d54e30e39a65848
c5a32e937166d65757f3dd4c1b6fd4f5ecc10970
1e90e2c654aab0d81088f615c090d6d46f03ca4c
924e7685fcd62d83aac19480837e4edd9c4bae5e
489e1468aea658a333481132957069708127c69f
970b6b13726889f6883e4347e34d8f9d66deb7c9
df74c45e8fdb4d29a7de265ac08d0bff76b78a83
936aa0b946155b2d47528073433fc08b17a4c7cc
3b6a5e8f12b6269a0a3e0eaeede81abfb3fc4896
8e0f306dae96d78aa1ea9a08e82647fd95fc1a74
5eb099e5e274be44c0fd27ce8928d2dc8483dab7
050fbed693d4806ac6c03460103777b2a4befcf8
c5d4b6dac74e323d474fa8878a7ea0c233d57019
8e5daf911943d5ef025025c137fcf97164467141
bcdf7c2421302b15f4ee4ebbdeae7b644a4518e7
e2874a42835cbb2fe8856a398f5c4b49a9cd8d30
f50ea97159e4ae7132e057fbf5ea1e75ec961282
5dbd614c20e9473240082239894d99c24de42282
0490e1ac1ffafcb9117029286b224ab39671a015
ad3620d47f0ea96f24904227d3c7a7f9548c34dd
fd37e7191ae3d312ced0877a1492cd2ea4578275
b7f8cc51c9056a469006b5601a4993b67c07e099
1d849af5083073b8864487938a9a2a8e21d71529
26d0bb4c9ee3d8591fe291c86f495b2d1900bf9b
7a25e3056a7225c1ff8542c2c2c1cf6f3a8e13d4
d0e0de0b13b9c81d2bcf9d54eecdb20591fd6d2f
0bf82343ade1e07c0aebd14ee66df688a4cc0e87
d81de0fb6a19342a90cdba9a664659da66296162
9105667175797bbadea80879e98a5cf849a40065
12f5af2a169c658cfae1677ceafd527d3775873f
00ae94689600b5949bd0fcf68205f31f95a36aa4
8f5d34224e4620c51c16c01578786e76567d025d
3385eb31651c84384b4c7e93d82bc5b592edf9fb
eda9179b9af0275d62c4074480e7a0103d356435
982c2d1e55165fddb4f4c69065e2c4ac39542c84
7117495ef012719769582939ea59a5533077fc8f
b7dae75dab5b59a320b8df8a67060d238fed3a8e
37c684e1a46599fe4d34d1601875685a70b1b879
0a694fa0cb044a31bb844564776b490c151ac317
e77c6b459f01ce078aa59183189226a6d48fdf38
dd0c0eaefdebc38610bb1986e51324a0392e829a
d8bc2414e9504172da640f29db1b2d29d834a94b
a9f1119667dd0f5aa9413dec23965a747d1dac05
f52775f6bc21d999382f4b9b38b108b814114ea1
e82c77ac679887140867e471a9f47fd3b2d95039
2db3fff5673bbd4bfcc8139d8398727d243c9efd
c1805c000c6233a20ac0824cad21c1fe40f93100
83f7807585cf70018a9a06179af9d89d4a8204b2
730c326beb29cc6d2624915b125633792a40ca36
bea422b653d74dd03ec068dcce938169149aa822
586a57666618299464519c450033eecc3ce89664
82fba8cf4796f2adbec5ad336bd750ad60a075fd
9d9b899f836a199fe854075e99091d1ef083de24
4670357c662596aa2c2922d826de84abd9f877ea
9b562567430544c74009ea4a6173f44ddb4a44e5
013d51fbb5f3a60bc748449b1ab73158da9a3203
3fe67cb90fca9ea76292deb793cb480f4eb5e8d6
91c80e489fee08e71a79bfbea79fcc28e1aa27f2
dd9104095bdb08fe399af46d91b334e760986ddd
a9198904586546a038f855bc6fc0e7cc413722fb
574a7bad1017d9ed466474881e1f068f892207f4
f95acec9297b7816284d8b24e984cd5c82104c89
3907dac65a125b7759172a8eae959b0e70220299
e5b44576eb2182b16c7b6770fab5977eedbc03c6
9f4aad9833d0f9a609dd2556e7db784ba813d8fa
579309c96651a1fed75fdd18f80019db8e6624ec
5e1a9a48e6c96099d6a0c3aff1e31c9be16b7b8d
cae4b811038f4e0dd4a8e68122c3db955e10ae81
fccee1c818f5af5fce593de0949f5a8ecd35b443
d4187d5a5f9ffe1f882c74f6ced7e0ba1c260ff2
02ff197aa41d892e623dc668b0055806294bd6c0
3f81af24214761a6ed77fd4dcd6e45a651dd8f84
5cb08c5232a669a881606a6d8c4a4cd23aad6755
5212b25869e0b9aff485af6f5371a159e89f8f07
a778322bb60f8438a68112a73df78e05a97093ff
b55c30c3992a766628dfc4a7e22db4d8d9e46b5f
1d3e4a32e0407f16f641be316c745c1a48f16e2b
7f35ca3333944165e0ec82a3a95c185f67fba904
ef6c5bbe2dffe76e4a9698df03b8ee08af702033
aeb90405ed696c1efcb29d0664b43a52a2bf824f
e0b8bebd78172229666dfd425933f9bc21863928
2a71a55154edf75ab51dcb4f2f7dc63592410e16
a5d25352d326c77d083a2e089c2d80b4ea923624
a3fbc38b9f1b86bb5f5e6540048083fc1dc6062b
bbe67e1bdadf4aff186769145a40727f78e39e01
a02a58c6c6d04001873ba91ac3dc902275879d0f
eb5281d4f40e18b0e21d275ee5c5964bbbcc855c
19e9939a098b9cb93c8c1d0d069d46861afb507a
7a72471f9a4587cc4a7d37da0d26122b0eadaddc
c6a043eb057cd544130b77bf99f39b7738e0a204
723b6223726c6772e034d9f4ba5c710e66a1991f
25b4ff1a26dd3694a98c1ef2eba04a5a500c0b28
7c571ac2c35a7e1f399651242e904596c93beeb0
0c90015733521720688bfcb59ad2a3978b2fbbc3
d6b99183122a97a590e4e54f4617b58f13b90df8
6b663271af39d69082422866e61ff7801c2b3fa7
2e9e6ab7651e4c215110eb381678e0ea2bc0f7d8
967b91e045661c9b6d2a5f011ec152da391db7ec
7fda8d15bdb3d3d61fce49413153a216849721f9
f7d7e83ee1cec103a768ddc9f68b6d5075849894
925953da542a9c21a3fde1ab0891175fb6212a12
ea2f54455427506583437391cbaf470a1ef4edeb
f0bdb2cdddefb3a391ec2e3fa9b78ed06d7c874a
8d289566fa92a96a83ff3c2e24c1f3d12b1718ed
7fb102615532952c6833e87389668831b37a13d6
7f7bbe8473158ab606a89ad66d607ffd0e5ba1f7
a98ea5a00d19406f3e644448039f13db496cefd5
39f03072d9d84d622ae974b09dd11cf7a2515a7c
e2050a1c488fff4b114614d7f75096dd0a149f5b
d2851f113530fbe211b3e948b6181152d30d1fa3
1eef0fe740f6db35a91e790fe77d4ba1c9065e99
9608403b012908cc58223db44962553704cab8af
4911a005ea6b55f34f8b0f504a6a0934c0df896a
a4400fb8e7d0f1261634dbb89588da86b8b6c93f
f310729583f6733ee60f534a9732b7a3a9e414d4
49e78793487ce4d8d7e624b5245fca8a9cc1ba66
2f2501ce5d28e5ada6018504ee8dcecbbee70428
f1e127253e1eb07b537b221e9cc96beb16333790
8bf1684ca9b5a37d91671dd0d63d0ac59bea987a
24838a6042a134b11fe945bbaa5ab1b2b3fc6eb0
f53c57af21fded3735fd479b3785fcf7adf80268
aa8d0a63d61d13524b1395972563b516cd263f05
16803d64332412a66121ef3fd10cd0d88598d3be
5f2715ed4d9416fa4940c2cd29b5ca18b6a79b8c
851ede1f8dceef7d681f35e4769e5693160c0a04
5264588c6c20c38d54394059eef0a854683aa3fc
111800d8e66ff86f0757df7eb6533fc62040a22f
b04de89d31003e468c191cd08dd2a4629d99c38e
6aef629094e9ee6b4fac2431897844c4dddf2f57
d1168c999fdae7d1eaac8c163b2b1190afb1815c
6afc3257929528d9f4de964e8828822d2fa2c93a
436f30ce1b562efe4f34696def45b0145eb98304
9afbf904be0e6154f6c424377ad596e86ea38807
a3cf657305d9283525711e867e03684a2e4b39cc
5813b4d04b25c385359af4437027b4fe763cd2ba
0fa594594c97a0d3579312f4ec073304c1436106
cb7b36c28adb38b1e597fa3f3b5c24c988a25b0e
5b0c867cbda81ce34df1b5fb67557b556ea24e9e
44090e9c550c7c5ded01dc2a681a7c934ba901b6
9ccc89b61736c4a9c02faaa679e97a9ec063dd29
7828d6d18115b0720888a45e3b547b697910c59e
618497e48e46fdc00dee67c07cd0f40860e819f9
69a14ed4f36d880e8322a530d8c5bfd9888a8c13
0a0cd655e40903abff4840c23b57628fb1a88122
cb262098646f47e1d80a89662f1480c216bfd81b
d60e59fce6f698a8bb97e2b4a935c069584621b1
ca77ba0d6d301cee1d45edb24742dc5cdabd4b83
17b598510967922690f5181903f20ddae5758e86
30ad3d9f3164966afb2974640f772387fb796b7d
48964c5dcc94234dea1737d7fa23220f9eab0fb7
0fe241f4db12f455c2f5976c6bf6497cc485f503
04953aca41bd372d990da7f68cc795f4a8b78d94
2dc9a061595a291d8c53168c42da8d14da52d610
68b15d34903038e3f2e327f03f0486b2d38784bc
30ceaaf39b10f9f9c7b4362505144d1650035a40
e75891a5760f6a51f54a33b671951c16fbce1558
b2a35989ad3392f26e070b158f89d1d8b75327f2
8468830b8b37f7c1cdda926a966c0aba2893a7c0
6a6112e8cde1bafebfa12e4c863dab5834c38e12
eafcd2ffc25d17fce41eff2afd5c4521730a23ab
f7eda0752f45c3a4eb13e075b24b86d7e7dd5016
b634d0d48d0a113bc060a47972b10c9353621428
49f95235a174f0a056e44bb5c704fea4ab345353
6eec70a31a6376ffd7d6b143be0968a195ad59d6
7c9ae1a71aa39efe28a678c18c8a03d759deabed
a19fd6f13c16720dc38a1f572eebf960022015ad
87052ac2cbaec195094e1d1a2bad4ac480bd111e
2cde1b0e69f97a8a67bb47d729c53af3ba8e5700
91a06d1a4efb6376959c3b444a536fe6b4fd4d6b
07f73b465b6c509b337c2776fe7a73b56ee178ec
15218bab55236d62fb8b911c2ae1ee05dde1ee60
900180ff2aa70e7d857403412753df6384553d26
a9c43cbeb0542cf6538fe8025edc8863d2526c68
d7d8f0c9b7d56f554d5a5cf5759f30cc3d36771c
d703e5d9ac82b8601b8f4bfe402567b5ce3ebbf9
3905a12ad511ffe157cb893e7769f79335e64181
73a933454b09ee48ffc873b0ee767e0229f2d609
c2c91403aa9d95efa09843bffe83ace4d52d3446
c90f480010097efa3fb7046abe7fac3c9b8b3975
13e888d5624e8087ea63638de7f4375f5c13ac55
19344e551c8c5e56e91de14253b4f08ca05f9e69
b1b8f098bb1e2f0f08cf82805d7bd29d2931f63e
3a3e025bbb2f3e49facac00e270d8afa5d31b962
195116405307f7bd9575f9621fd93344304341d1
31252094210748399f7e43e7b6149190990f4e8c
357e549bf43126e371a1f85c393d2560597cb32d
df1f8ab23f915420e9c48744decbc45375f180d3
f96c2eedf6800b8fc31032a02caf0d2b469ba9ec
73405f0505813ec1bd25f03f2825315f3520bcca
7e2447536c35ae67e3737a031fa1ac57026475a0
970d4c4854dbcc3b0bf9b16edf1d47eabf3be242
3c73519e6b54d3559555ffac40072957041f62d4
46d461676fc1fb16fd7dee027065441d9a8b87d5
f11f64bb55240dcc1767a1ec823aecd3531f1d20
038e91a424078c5d81cba6c820cd981f0be6086b
157d6e98ba894cba5582caeb15b429ca0dcbf2d9
2c768cf9d1bdb6d3d84f662a847966b69c898f59
4fd0f29459ec3ea65625b943b147df85e5826cd9
c7e90c64e580ce5f95147eb4e117b56b5cda254b
cd4f2496b274b0d55b7c48388c2ec0365d9bc266
68b5e288a29ebbcd65e6d0a8eed47702ee4e689c
22abd4a7ed7b061364e002f1fe08857850a309ad
4c3b38be6fda8ba32fe6f29226539e03bd0c55ce
355e946ca8b8a5e4c17317446b12fc374399810a
1fc5c0122fffdada1630febc1f2e42952cdc7e2e
8db042e1faef7be24d62b9287fd3b9add7a1b4cb
1cbea023ce354939ae9082a62810b46f38ab1cd8
f5edf5b99d1bae09314b9680e58766a4e3c1bbc0
58a5ef79958b58736603f47cf211494fe5819601
8f2038bec169ae6d62885f522202d8171e3f5f5c
5488e29e68684648b4d733e90c6e3188d3bd5bad
84c88e813117db46c6ac68b16a7739018eb99e24
789c3655197585ba8771ce68c0117cbdd41ea390
0510404a3c0d337763e90e5315548043bac65b06
2a665d7c6cab59ea8e3bb7fc65249ee947e51fec
d53423de534d3b5e68a7644d4218d835a8bfe6ce
73f2a3f332f23579a29e090f70825dcf84dcdbac
f79ae7f27e750c97c139cdbdd7c3223b39ed1a70
c84a75f7a4b274c5c133b1df3648a5a24ed9f687
cdf8e5a49192b81bcd39d9f4e39aa4812b58b80c
1180461f564674e373222fec3b4fe8c2861ea6a6
150d93bd910597b85500e74b97b96e7eb4bce2f6
ec3b819ffe3392bf193483fea94d4404c88966b1
729fc8ffd38c02a9576640b56376c36b49edf52e
2ee31128fbd86244d547e3ff66b802dda699210f
f87f28c563ad602cba605e84bee95693b77b8840
9e92c5fb59af58867acf5512e95138fc368f7dae
76b1489042e1bb45909832f7064f9a5437b68b18
66f5d86face564c095b3c95848f070f50fe4688a
f9b2b3ec52b88dbd68b2f2c6b246bf07f632b40c
14f689f05c4fae52ac8bb95762ff43b9f7f4e567
5ca84af5f7a3f4533b353c43a332b552cb2fc5e4
c5f33e9eb55201c41691e14fff0d45e32c989a42
9f83cf471949164a6352cb9e3a201b8bb317b89a
5532c7b06a2f02e9cafd6673d5099798c4144690
0d28c20ab4f03b5d8579132048c060affc36c466
cddce1dfd9d4d7f1fc49003aa211f018bf8fad2a
169617e3672bac804a271c0aaff9cdbac7b4b45e
fdebb28d6ae398ccba88f3e2e63ef6d7f10f62f4
0651bfe384a8d5865d6cab808ca0ce803af93878
de89eb007459fd5400cd344dddf240fc33fd0b65
c6a14beb887170d8c901e522f2f4dce3bf0b9ed8
13dd0647b3ee39fae1140f8eff2b15d7f63ee546
9f89105c1462f2a80e620ada1b95c3d08a121c3e
1ed6496751273cf472538779266dcc3dc9797192
4e8dffa66fc7be8f864cb48cf26abcef4cc32379
5543fce145ff28a1c424b730b376fd4e3cfa0956
bd951a4a8574baac21b7e1f3a09d1265aa51850a
3fd1c12fa880ee45b0ff7b794238a8894306a790
830ec14bc9edbd2c6522ff46ed0acfe477e7e32a
e68c3109a709e2b732d0945f860495de161754a2
1e0f4fda735167ff6d27c76a67b8b4a4ab31aaf6
c6c40dd0ff4420708c2e0f5a0e0dadde93eae336
baf0c18ac24acb9ac3d1a7c0030ad5675eeb64d7
8d30906e9f2f68024eb716be9f482de5cec5b302
ec9fce551828795e1dace26a11f57f9aaf1af37a
28fb918d7e9840a7118b7aa0b6151b496f1fc1f0
b9e58c5b98f7c89054ed5c0a0226066ba9d93c8d
0c5db457cdd3852182ce70b96cb376337b8ad7ad
36a48168274cbb6f31c35777a74ee16c06e1a853
07ef3ad40bb01bc7798b241c88fda2eaba7aad19
02aa9f2ba871e9639891986a97618e0917955fc8
5f776d3c74ad532f36ab75a71bcbece6a62c831d
f31ea9eeea91106481e1b2d30026b601555b6699
c3d7f6bac18fbf8041662fbdda4f04e3f3b25e3a
6280c4bcf1195c011d7a7abb5bf689df11d66419
45fc4ef9adaf514bbe21f496cdea8869a147c81b
fa1160786e34c057cf1212efd59a72c3931eb2a3
09b285cc7d7c8768917c7d4e5513e3e73d752b68
a8da5db6094c887f1087162c5ddfddf601560523
b6134a31d236c376193e969a2df65c8427d280a0
793e0d19fef38f8a151622257b13edf6786e469e
e40e6a17b4df5be46a2cafaa3fca5f4c3cec5001
4d82e160cb874da6dbddc27af7dfd1036772b8f6
745ee8e3e74dc0674dd8018999707f025a9634f5
f507baf298549096f08dc33de22f7301e9799814
bd7ebd663da867692f2316b94db73c42c0f9a5d1
697f07726d209cac519b528018559f8957c56069
2297b5172c0c1c83f2d78fc726fac0803be6eeb9
91e3543f82039a446c5be8293d5a79ec767d1444
e997169214440256b5b759f6e7e255a302838c97
77d174ae14afbc6e212eb7d957b11a231a036d96
3e81ee29892006f16d5f1f26d9d6b341a8958fb1
59957e1d84f8fe8117d9697154c3951ba2959480
96c6fa03962edb98a9b6aa7793be4ff54e79bfd5
068a293fd6b4fcf216fb84ca982699095613af37
b3b1804ffad1b7d274bc3f8f5aa11b15049ac030
63e394c13a50de0d9f6cef55a8c91830200c3dac
e7ed33eba96d590bbc7179fd26db707c910d1dc5
6b2084340a988f4123e71c6e30817806ec4cf3a3
da721d3f48f821faa90d1a4778d77b03fd3dcdeb
a433cb8d56a4fcd50bfc74b0204c916e08c9d5e6
067fae6fd778d5b1d6b6436aedc0d25db58334d1
e34c192a5aef80c7e83c78c2372602830671ca5a
861a44dc56a983262caebf909be96c62254930cf
417ed493a824863e30922deda64b9729b1c6d6e7
2df6a0d803ac21f0d20ae9fce0a970b35b3663ec
44bedcfc59292d3ff6b36759b324812fcb779b2f
c620f7e60c8ce4ddee8fc1072b2a161fee862545
82ce5a39b422aec7572d9a773f85be8eaecb1618
dc0ea6defad83a0569896a9c23f11f5052a48107
e1c15f1da71a3aabdd43a8ad669d2a755f315c77
c78ee1aaa5c499019948c9a3dfca3aaa2f897860
e66d0d34c541c6588da3ae06c6aff7e7c9ef5745
c24d513d46b3db5b4c53b36b7e43ce5fdfd5a2e5
a75d0a4bf6d2e1a9c4026586cb707f254691eb3b
41e98ebf4526e78d78ab16182b503f237e77fbd7
2182dce8c27c33f9452e7c910f59750d1e58b1e3
6b7aa9fdbdd0160ec29b6b3b591169c627fd0f01
b39470063e41ee5773f47de325a845666d0721ce
c7941bdc8822ae1842d2a2f42924f31d2d37e864
fad6e836009429e88c788ab7e7a679d422d8cae1
a478917ebcf70c5dd6f56c7cd139832108696189
4101b1ae3b17e229c1a80d9c302b74d215d98f04
b051ec4e69a99e26d6a6e5d7a393014f841eed6a
5298ce551a104605b7d5d9872387f3eb704fe5e9
b14a12bed26d53eaccd1a2c172ca4a38773e1d45
4ae0790397d05a758013e0496ba2c2b23363361f
431f01bf3aea6f8baaf06669172561a3ec9e82db
12476263aa193c7e921ad4b183fc648bd73d2a1e
8e937050fb12a62e99b0cf685578213552774cc4
b85a487787454f6dac84be59f905b8c929f0ee94
dbb2116e0f03fe6d84d2158d67ddd02761938bda
57186ad57242ad0bcd737c4ca4ecb7c063979a95
cdb4a295593cb3ad424b4ab86d74154d7bbb97bd
8e9e1ae0edb776f0a490005b838f8ef82b368be7
73f8f21a69a03cdc2b1031bca214a6b84f4c867c
b913c6d878ac5cf570e6f8ba9b5ff022ed601a8b
b98879530fd51f328441d33c64c6c5f311097e15
325b21b5370a0c179b40fd596b9daea00b3615c3
6e722a5c5393dda24172de6f8e08138bcbfb10b8
44b396caab82c97a6270eb7391d6f96502c9fcf9
4e6ed6d22079b68551bbb83e5dd797517796a438
b611fe79daa20893683475cc459dff98b2d4892b
017d40f9b23f4a4379c74ceeb89ce7b4bccb7460
a31b0a7fc7190218136d6ff6ffb3ee6af3244135
861bd42abb90a61ed757728e1fef7cee2d6aa081
6e9ff586de744d166a9f6f213b609e7386692472
a790ca7384982e872092766c036d6faa86bff71a
13485c50ca4dfd885d516154421bdb23cb034230
c5471e696f3166942a245e77796bcddafe6a607c
600308daf62d0d651fcfc874110e7bd4f5de648a
bada607744ec7f37ba9d05c09bb8f41e7fc3d06a
d3b230b209fd7c3f4a39db965b239ab600fac1fe
6d730b7ae0b662b1f987101e8ccf9c1828554d69
f0757668fcd3f8d1f2fe83ce9f0e2355b6be75f9
40819d9a5631a184a17d38e36240d1171a6fc923
8a6847ca68ec998df0543c4b5bd5c709c05d5f12
d8eb0646ae1360b5b984ba7d99bc64e00dd67016
761bf1cc1e2b86437e71c9a106fc9c341097c3bd
3b620d960d29fa7719f95cf945163b04e43d2dad
6be8590f72c2ef158202486e75f273d8598be6bc
d7f22a15d66139efd65bae28ba780b0bf8d1a914
e1ebbf612cf9d49cb08d0e0770ac1678ce1436ab
4db9912f07ce63e4519053f52dbe521ec95c0fba
b9fd4f4760ef65934b5d38e8b7c0eb2f77822861
0e0178ecfacd553526afd221734607971b6911f1
8cd4823a8ac9f846930408ad1759da4496384f9d
e96cf22a972cc3185739ef1c1ce74a978ab71d11
a9d63829aa54049801d37429b597eb04c9e1412d
2519d617e18fa35974e20d10414f1262013501bb
d02fc8d8483903871d9f65261b32c6acd2e4362d
569456505d5c97934344d4f989a08fdcdb522de9
f56d4c60ffb8df8fc1516d32a0512def0b6f8296
745e899452ec746d3ffbb7b082995b7939a85387
8c11f9ca2433bf9381840696218c245ec700666c
bc2a868d1ba12b485a6eac460cefee67bd9ee899
e628b072d054d982ecbbd7aa7fec628e0d9ee8d6
e3390afd65e721dd8ef228f48fd4244228de2986
35102507bd653296eaaa5e7d475405cc1feafbe3
e2e5342f92148238391665fba101b1ca7dad5582
621f4743f0165c6ca3f1571773867d2e0da67961
5f558819695a49bbb92d5d1e07b9f12072874024
eb45e9da84875e2d1325b78157d2f9e96374bdae
bc0ab7e4f643e779cf9554f03e567d4f4708bd4d
fd55e896d6df035cba49a20e26ed6ddd2d7b6024
dcb9d95840c9a0514f8fd0a7b3b17cc228950c7e
0bedc3d7a01f9819171c0b664e16900d9965c3ae
94f6e372fd90e96cfd9a393a5952aa850485de66
0b889a9cf37997c58a9f8979850da1f4bc84de9b
b70ec5facdea7fc681c2a10dfb14ca0d8fed6f1d
03e0192fb34134f25784a2b14791fbfdf69461bf
9266cc52df3725107edf513aea4a02c131aa153c
0820a412fdc9941567d86cba02793ca6a6378275
f1a72254956f63393f6039a7d5da5fca943fcd2c
abeb9e16d924c1a87c5b525ed12c43031ef1cb2f
d5813fad322c97bc31d7dd37f838c7442aa68f35
428b26fdca0ba98a3a01e89629bdb778dec9e8ab
19ff672db65a7ee25ee0d48baa3f9bbf2d145ecd
d1eb6283ece7d9c814b0d3d5223207b905d3d720
9ba934b83a40d26ebc5e8d7304ff29c32541e82d
9b600cbf0209ad6079d00dd5d6a5270d858d5929
0f22868d790bfab8a41894fc7eca161256ab6854
fba092070b6e03432f6d47154f5ae4734e935a05
11b1bf011fc24c2ca6dd8c81206c7338ac2b2915
d93c82b17d7416e4c57ed036d6b75a323859d837
27f762e8d3f1ed8bd0254800c121d0f16e914c2e
e252d9d270330072e9e5e91257e90f255e7e968d
e55c3c30785eb50b5dc36f9568e6b6ae39e6de11
63491807090d814bd7ffccfe44cb05795830eb3b
8111dbaeb71c53132229c4064c34247746a3769e
8fe37ca0d79dd1f8132e9add06aa206d371964e3
eb32fae4665b9f11ffd06a342e763b9d212e1353
4e923698ee5566143fc6d32fdcc6fb46fcda2d23
2e3910e29142382f9bbd1705ab9c605d1937a1ae
533cc5f884885f771d3f6df4164fbfa29bae0e6d
3fea0404fc58822cfc60d4f10ca404e3223f82a4
733404a081eda804707c3dde1d6b8161e7a34b3d
d2be0ea2923344abed57aa21f13dc816d4537eda
7884465bb9da51c8b6e95a1cbc9888ed696ff68d
6e63e5a03bfbba52dc3b4f504e6bc41951f56707
44a9d3ed75c44e817a6e4b56e30be06a15f453c9
91e12aff0f988bf414e64b97a8c20b9699440309
008119e510f6a7f8714e63d2ec33ca7cd7776ea2
27822b01ad020374ff6169428649fd667abf7f8b
0c972fb8903c656cb7e750b1d5c1ea1f26bd8c50
3d8f3e1fae697a905e87250aa5c0ae1f6c60ad66
744421b6f1d3aa30c7558570da8aa1d52f11d39d
ac017796cd3a5558dd78f73ecb82a6b961d8a3ec
e11f534a2fd666ecd841f657faf0751d5fe02034
eca5d275376911916c3e018c2d163cb8eb914263
a3144ddce360b6ac1b55fc27d19a318be1f224c4
84fc7d68bf3a309b3687da768f0dc206e647e653
fd5132bf8e99230a9074ce9bb3d950cd26b3d25b
720ceb5e566d26803db85af3ef69fc4fa14d355e
e97f338a79e2248afd3a2b9077d8ac1c334cdf38
0173ccf8d04014bcc4cc53df4d6574540f4231e4
52da09b8812d96c14d3e57a77784d56e5749a8ae
5169648c7429788c777947e21527e121d35aebe9
41c8c94cdd1c646296946a00dc72dff8fcb6556f
9b341f77b72b55674a030ad0209ac297e41c5570
6aacd7b9b8fc571e930d18da63efc8be46e31bdc
9875e5d15c0750b6ee4c41b0e1321e1dc0bb7810
fd60909d92b0e124957aa0783ea03471c73fd732
2f299011d707ffd8502e5a597f38f0d25ab3099b
6c10423816abd3b0f327863c9b8fcf55cd6265bf
14cc60568455ac2210f00ccb238ae41ddb473fcb
74cf0e9a42bf241d3f76f25aaed46e4b6550d842
9a0eacdab0398ced7d729f5c7a9b173eada2dcaf
3057f2e5ac8cd11cd018780c062da7c2bb11d2f7
dab224a6b259d9d7e16af4cf7e2718af8ba4a74c
fe6dc165cde8c826a3935b536c8cfd1c10ba7d62
7f3572bca7fd48b66649d761a054412b8369deba
2ea30dde468795a3ccb307343cd50eb7041f5ee3
5d4099ededa31d823a355d4ef0e53bed6b833539
69eb5257143b2de63c8c7471216ba6f025b6d7ef
e4c7387b32e314cca7e0ee2b1df197340272fad1
01f14dd38700098d97f933008327c8456c75af34
94040e25d5aacae0e55c3e9a91fe24d7daaaaaca
cd64f093886bf092b8d88c75ccd2e2f9118d3ba9
ceb96f9512f80188fafc61ec8d8d61c93d51a5c2
9a4e9bf98bd371cee2b69ef62a1189c24cd8baa4
dd861f56b65404a625538978d50819924f384a60
b2960c129e39d30f446d27e38f726975bef7b4f0
8351c6b1293bb0cc4a2e1235995c16433c84c463
008ba61116504d01558fe8afea0d5b3e90944b76
cce20d2824a877ffed6a912e3f22d7db3d8e5043
5e02e12edf58e1dfe37ed770fb32171e64993a81
7966a56b3a3c9c9ac6db5b9355ba5e96558ea7b6
5dea2f86730665894cf03f2b1fac98c1217a9fb4
451a4d8118d2c9c746c687efceaacac799e67ad9
059dfb5adcde569a19a9260c2ff85c7b47f8c516
da7449db2898c567fcfb40c595c0c21536c901b8
db97ce996b09b15049a9f818ce27a680e585bd11
e1f95b9a8fe2394e1cfb41fe83f130bdb68fe6b4
fc2c03e29a331cafc8b08abd5eade336904f40dc
385b11a95469f7477bdcf5b9c743982c4a866c65
d7e31d19b9ed766048ccf9129723ebe36b4842dc
9c9af56fb29f510ef75221a39964c128448526bd
83e3c642af5648aaaa119cce34dfef6ef3c560bc
a831fc506ca30a11c9d9b33c9cb2c43f6f01a446
62c5ebf183a0cc2332f04c1ee3323005a9878438
6bb31edda343bbbc4410e2f780c432129e610b47
846ef94e8af8f09340a740d11c93157c81079bc0
47aec581139d8a3ab4f2969b481868c1485e2ac6
e3f68d2cd84e15063c4f73c8420a444f9fb64a7a
3db1240470361a7314ea096f63c0fde74810caba
ae951371c666cc605ef69b5ca3f5f31d0cd30298
8ec035e739f01aeaa09742a92154f02ab3dbfe93
4737a65f7c1e125ba37ef35acbc6e99c4db2bed6
7005d4cae81a16a5a860fcd3c259d6ec07597072
d98807cb107ad2e9bf95138ee4bfb566bf75cb50
1e8cbd548f12e1ec861f3aed5fa9f080cf2782c4
25c2b2cad9cf873edc80747cd2df5874034282aa
676749cf8f76eadb469289b1d918cb5e485cd56b
8cba76ab8a5034ee21e95a99196f257b7e527b49
0151aa85f5a178da21ddf7d5e81398fff87604dc
f881500552171b5a8a8c3ec7a2dc06e493a1ebbe
8d39edf2ae13ed33d0529164d4e172bd4d060d7a
b5c3f29c81e524e860e5f9ebefdc573f83fc600d
b686bc7a882e461987ffb7bf1a25bdc6f82ccdd3
ebc1f42a059e7863adb57890562878f652922b56
b30835cea58d0b827cb56aaf9e4d5f6e673a1bf1
a2cf1028df49cbf53c57d0f599083fec59cc38b7
6efa045dbdfb4272f075255411f54fe436c31b8a
0c3f085a4044e9231287c11e34504624b04ee7cf
b8e628fdc2a7627283e0601ebfe8e978e91dfc00
d84e30103d59d6bace53223fc0d5787f03d7f028
2e0e70d0466bde79d134a215a399b20c2a9d0981
142de640101e2bee71fe2dc98e567d688c7e3aa7
8b02a5e91092f7363443a1cf96933dc445f0ce51
753c065260b1659c0d8d247b62f6b0fbe986c7b2
1113b6978475c9941be9b140e8cd6bc267469657
0a01d10b21c039484410c7898250afc4079db28d
b9bd23fa584a8f1900ada4addb96eeb750ef0a68
5ecc9b675c4cc5c1bdcd8f84e1a52457ad30144d
d91b0a31122b251998915b4eb274350fd42a841e
a829cb9c850cc75546547aa95fa3ca6100ce16f7
4b9bba5d1063d986be6463e4c5740eb18befc7b6
ffb2f17926143e242efc18b32ee0c630b5447687
3feb18fbff52f17a541abb1ebbb4894beec18d55
4acbde9bdb24bd802ba5bb0ebe19d71c8d753240
c9dba689c67ad7b16c8f6b1bf1bd382369fdec4e
ff956cafd71e4787e9ef7b64725142fe8838a65a
e2c090f1ca171b51d08e6ecbb74b27410bdfa7eb
73aa4812a2effb88bb64a42f93713a54a88e1ccb
8e0e0c69b0adb9a65098b18a7b96d6ed3a43940a
5dc8620cb17c3e606b635f8f95ecebdd66af04ee
18f8afd6fc87b3731145f61818f23b4b766da703
0d2d0bd0680557dc28f4f7b23562495cdbb3afc0
94da53667213590ad9767b335a9f2e51fe1e2c5d
c6cb97a42dcea5461a2931b097ddfd53b9cc5870
62a3d5192232ed847f3c7810344c43607a361e68
aa6992567e763a0b081e6bce753cc42bc287e9d3
1d67358d33250d456040091d8b29083b1b47d9bb
65d399a4ac7dc36df20b8b2bc773bbc6fa67f43b
acf7ea014fd1b7eb351dc6946b199ad2cc98f845
7e4dcbb7f0fc2b051e33b555c4fdc67796dbbab9
a07916245a9c21f3874a7b8c898638ca3b65df42
bb7368d9b07b02aecfbca6d01788a7327743ffed
60454c29275aac27c450323f0141d60ea8202842
c4d0ff10c85ca4c12ddfda1830cee475408205d5
a5da3671524fb761552a4eb5c1e27dd433f80fe4
43142e711f392ae1bcdade749dbaa9dd98664228
7aa0bdd118c78d8929e737392457d14f87d625ae
be921331245c4e04ef9f0ff7e359907e2d101cac
d6f654de1b8c27f84e34fbff12aadffb30342465
fef2680b335ffd861021ceff2a2637f5a360f037
79de53d3b87469e21d510ed6ddb33d809c05a3f6
475b10017d25db725e73eef11ca789ad7dfcf4ac
d14f3734dc27ecccfdb4683cf7ef3334a5a70b3f
f0c394dd6a109b97ba4a9ab16cc71b789d9ee38b
a57cd5c8278e1fd6fae6f02947c13880be4f3b62
83c6e4b636f3bf115955b6eeb3f91a5689e7f00b
b881752a8cc16f49ca605bf6a35af106e7e19c9a
8362e4bcc30e73460ae1b9731bc545fd2b12d8f0
b01216229149bed7c110221551353b54ff8e4704
10ad0e68785b27bab975868b83bc463b9c9c9153
7a66612abaa223ef0410fae66727a8abac3add03
8a7bdba957536b078f0421faf5dfaf8d65ff5add
defd6d03526345a410437eda15cbd067124f9c2c
f7e6c29aa4d1f7a607e0c87ea20105afeee0372a
751363e461257a4036a8f2aa740195401883c1ea
a8d66b5855eda5abf699ebf9c6dd721928007fb8
35ca716114bdf87a89857f2d633be3f4b13cbc70
cf319abfba8fc1b33de4c6a6f99e21864cc72563
4fd36e634e762ff2f94e9d66f24ceabe164f9e26
d0364113a1b57ed5017dbea6126b0cc5a5c2886d
9b3d7bf551d20acae4ee943a86c3cf898b6280ba
b35351d566efdde005747503c7f121d49e864848
57b1dc2b20f2e67c3313f0c6127b05041d125fb4
fadcdf4c98e9167f8f06a45dafa08d3acce7a741
3bcfcb7717bfc0e50c5b8f5c7beaed9f3ddf5478
b8388b7b5973dd3e84902c25c5378f9a412d6147
814f07ea363eb0464380ccfce7b4cf5209f1dcb2
b33315c8551bede3fb867efb3fdb1134cdff5115
c7bade1e7cc239e8fceb2c0b06f880e60eb8ebec
bb193f4f0f5b1b8bdc9cc72967f8fa6387faf7c4
b727e8d9f4a4987cbad41c75c630cfdb445c37a0
a2103d7fe328871d8231f8e07ba5dc9182f637b3
e36d269d16660db5bba028746564b5699721def5
35f9c486cc26bdff903241f4ab2b1dac2536059f
cd5314af7e8e120bceda896a3c17daa8eeedd528
200e09df8f0f7b94eb8941136482cf7c60fffb0d
17a618f241a6236c93af5ba2e09238369fc7d784
15aeb2bb0401d428cb7058e1d6554e20369ed352
40b0a406cc23467af8bb63d9a62378fa871e2031
7abd7f4cb237ef33b9e019f4529b6fb05b84284f
ac614b7506e820457417c3ea15ba99fbc8146155
8afd5a714da3f45389e0e4edeb64f49576c57c76
77d10571047d8b4153180e7a89d5c9aae6a84060
35479ce1706725f73bfe99428c43e8fe2e3f9157
360a0864ece712571d3df95e86251d6883bcdf7d
b5cd910848f592e33efb6de3226c07ae545a2aad
f5a9c28ca029ec5d1c5d3c594afa09374adf04e5
b9fce5928a1c5056f66706b67c01cd564e6c0a90
e5a2250e35706127304cd5ed86b81575f2636b5b
f30cffe4cef93aa190bcb1caf407ca0767107d06
45535f6e0af6785676531c81b4a2a3c480a98e70
740bd201b23beded9ade92a93301cddc67c4d106
70460e9e601171276dd6844cd6addd8db5eb2465
44dff2c35acb4736b183cef9e46155386f579716
46ea31f673bc9365fcca558f15c862ef6a899018
34556caf76c2422a76be3d1cecd223fcf435d93c
fea67ed9483b5cc76dc55eb4dd6f52baf445394d
31b1897ece6222826f379c1aebda891384b4b63a
80dcf3713b85b78979d4eb443fce9e992675b5c0
11993c742658321c0c5c200f48231583216d636c
7b5a089ed3007252e61df0aee3fc17c14d051745
890881c9a552c22f4be01dee16ee902c88f6700f
401ba79da09dded82a73996c8e0609a87cbd728b
e06313f41971de730085dcddf640a4549fc54fc3
054d52e86a954a615ed1f5add7f9d6842737d965
d8a60982c456a9cae3de745a37dc3f5985814f7f
2b39f575a510cf581aa828df494e633cc76fafa6
e11d353191175b329b3c9f9af7fa33e3ef9f837d
32ac2659ce98765aaae9c10cc7216d1f1faf155e
5f7f801227868c7abcce7e58dee3eff855011955
a013eaf0fe38d8689e27278bddd4ebf87ac5476b
401b3f3d2d96fa785c5321bb64c97cfb17c509e3
1fa4fd4321fa708b3db5cfb514e2192b00672aff
77976b24ff839c59c3b20d80cb28351ccb5e59a8
09b76d2966e2370a78ed37a31c2f7c23d08609c3
7000b24511618a21d40b39ee213d397e1d29497d
c2a6adfcd18c0d95dbed6ea62ac9c9a912d18123
6ba3609953d5c46a76ca1d0d3d83018be61454e6
3dff6074fe205e36fae219f277ef87aab097e236
1cdc8437fa6c621d96c4dfa5f6370c8fdb9cbc3d
d471720bc8f7ce7109276b49dd9c76b6163007d9
a67b1bdd027629dfc38601b21dc564272e28712c
20125a6d37d5c1614ffe1de94ca064095968e7f0
2b642751ef86265a1c953186810e118740f8bd2d
e562c1d74e2b6744572184e66a0673e55f9ba0b8
ba9687b5d746dda28d4a19c5c96d0679d7c77b15
f39d7d293c3e342b4f447bb440a9b6f72d2d20cc
95750ad9e700efd15d137963ba0dc443e6c9b6b0
0f76d8445048dc0bfcaf05e30b61b338a08f0e48
1a9a4c61d6a371d9e95eaef44fa2452d17a09d22
912b41aad5983d9735379d322eae8f6d40d8bdca
eea0b559472874ff48c34f16bb805108967e6489
ad4e7ba4032e6b1c047230b3144848dbcf66a127
b6d93107393dee6eebb05376a67f2e4dfcb44311
</content>
		</actual_file>
		<actual_file>
			<filename>rev_list_delta_a</filename>
			<content>e34590b7a2d186b3bb9a1170d02d52b36c791c78
8977833d74f8681aa0d9a5e84b0dd3d81519774d
6f5561530cb3a94e4c86454e84732197325be172
ee419e04a961543444be6db66aef52e6e37936d6
d845de9d438e1a249a0c2fcb778e8ea3b7e06cef
0bba4a6c10060405a94d52533af2f9bdacd4f29c
77711c0722964ead965e0ba2ee9ed4a03cb3d292
501d23cac6dd911511f15d091ee031a15b90ebde
</content>
		</actual_file>
		<actual_file>
			<filename>rev_list_delta_b</filename>
			<content>4c8124ffcf4039d292442eeccabdeca5af5c5017
634396b2f541a9f2d58b00be1a07f0c358b999b3
ab25fd8483882c3bda8a458ad2965d2248654335
e34590b7a2d186b3bb9a1170d02d52b36c791c78
8977833d74f8681aa0d9a5e84b0dd3d81519774d
6f5561530cb3a94e4c86454e84732197325be172
ee419e04a961543444be6db66aef52e6e37936d6
d845de9d438e1a249a0c2fcb778e8ea3b7e06cef
0bba4a6c10060405a94d52533af2f9bdacd4f29c
77711c0722964ead965e0ba2ee9ed4a03cb3d292
501d23cac6dd911511f15d091ee031a15b90ebde
</content>
		</actual_file>
		<actual_file>
			<filename>rev_list_lines</filename>
			<content>ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a
3fa4e130fa18c92e3030d4accb5d3e0cadd40157
2d3acf90f35989df8f262dc50beadc4ee3ae1560
5e3ee1198672257164ce3fe31dea3e40848e68d5
420eac97a826bfac8724b6b0eef35c20922124b7
30e367cef2203eba2b341dc9050993b06fd1e108
5a0943123f6872e75a9b1dd0b6519dd42a186fda
e1193f8092ae9ece0ba336b7aa4c29dcde78777f
d6016bc9fa3950ad18e3028f9d2d26f831061a62
11d191ef3f04012a78222cb118619c16d5581886
f11ceb37cbd72b8c7627aa9e2a7b8dbcbf10d107
28e7a1d3dd172a8e757ff777ab205a538b80385e
be3178ec3bf47bbdc69bd6023443fb6c4ac5385c
22825175e37f22c9418d756ca69b574d75602994
ad44b88d69c4b7b61a9ec12445f00f082ca19f41
78617eaee2ca3b88cd9bb5361d29a99b5555a3d2
a55a698345a3f27a981ada27c7486d89e374bc21
ccc8ba203bfb6b6051bfa083f73969f680ced61a
3dc4f654a697467692478f502817dfc3e0248378
f1964ad1919180dd1d9eae9d21a1a1f68ac60e77
4aa3410e2d458b00b0f41920ffc2aa21f019d13d
ca78e948410d39b690a76a7c613b83b70de64eeb
179f919876a255a8e09d32a95c8209d66c7ed660
472e4f3d6f54514c560487ce6bde30405a84ffa7
55737f3f9128b02bf3519f5f70b6118234454c65
f6b346156dd19a9fe46004a3efce4fc8d66addf9
ff3f41fe66bd482281347314ed1cd1cb4b853c38
4f0ea0c7c8985c48c94269886ba93c0ea73636cc
991ac754cafa7c87ccf25d77225154d16d4f4be6
242253bdce7ae94d34b2af702e3618eea8ed9754
3c230a377740b6beb679a6b57a1e2b7e9940d321
e8ea908dd932eb21856495db140e27efb014bf3e
182a706d083de61af95c3dba0d59dd3f91fe31b2
125c3f885f9041a48b2828cd1c707dbaff78a825
3ea514188523ae9e8ecd603f760442f147042d6c
e8e7b385fd00a7e9609cf2f270d021f19f08f17f
c6d10852bf3cca44f17c0e3f3abb721c6fe7ec27
f32458940ef496d61946d4e3d63bc5edd1ae0af7
c9cf68fc61bd2634e90a4f6a12d88744e6297c4e
7a8d32cb18a0ba2ff8bf86cadacc3fd2816da219
80238dccfb24b5dee8f6d6c99fc8d272486e0946
460b3216db32a55d07b1de0570bbb8427611b599
59ddc32609925a9fb7e3b2e2cee04b7afd204d00
13d27d5cea4d0d787163dd97f8ee63d200d2a663
7235ace853d766d2c4a39d5e505c05497b1b7fb7
3ed8c6eb935326c8de850dae4be5e2493a2a8c2e
4ceb8e966103ba1c0cf442f90b476367b0302347
301edd42ff7a55dffb86446349b33d6d4198d192
6f6cb7cd4ab707c2273dd97113d9891da7a11885
c45fa0feea864d535f77d39caa735820aa720caa
3c413f1d3879a80ee3cbd8c7cd8033f7f04afa68
02879cf62c803fd706dc45ab85dbc2e7efe5acc1
8f24479836ada10f08846678a59d79609ce3d14f
275a2b7c7aeadbd03fae865a5f67900a7ee1bfc6
18e19dbbe8b7e152f762af65799bb19429e0d349
fb49d370b21ed9214677d812dcde243cfeaf2303
e631529f2525180e49b7b90fd0198d90d8106de0
fe3bf3660ac64d86f2855ac3185eb5953ea2c3bd
6c38e553796a965fe62397350c537d0a795c9fd6
7bcc0ee821cdd133d8a53e8e7173a334fef448aa
db64b1265cb572d3b97cde164312194b83449ef2
3e0955045cb189a7112015c26132152a94f637bf
62e423d6d27b3c5016072c94e72bee1be37aea6d
b86b48e3520a106739035b149dbed97445152868
80f136f500dfdb8c3e8abf4ae716f875f0a1b57f
4c596908ce1136e8c32174ba13892c6fe68a010d
1d22e6fde59c9ded9b8093cf26213a5bd9d4c5ec
44f82e5ac93ba322161019dce44b78c5bd1fdce2
46291865ba0f6e0c9818b11be799fe2db6964d56
02617bd0f7cae462e71be075c99385f709279533
5f141d9c0181b8732c0ec2fab4967f0ffa24fa3f
337539e896b8c85cc043a923c8fbb927f58e6450
8c7f4e1d8cb66590825701b758160e3721003dde
b5d4f15a4dd41646405f11fb107aa8efb16c98a4
f1ec1aea10986159456846b8a05615b87828d6c6
ec037431382e83c3e95d4f2b3d145afbac8ea55d
e80bbd2ce67651aa18e57fb0b43618ad4baf7750
91169e1f5fa4de2eaea3f176461f5dc784796769
038af8c329ef7c1bae4568b98bd5c58510465493
40d3057d09a7a4d61059bca9dca5ae698de58cbe
4ea50f4754937bf19461af58ce3b3d24c77311d9
1fddfabeaa0b62cb4becdb44980ec6cfa48ebd87
01a1b4f1cbf0f4d9c13618a3ca9c9f429c8dd0e8
b6e1b765e0c15586a2c5b9832854f95defd71e1f
ebdf4716e38c810b06b6e1fbc2ce3a6da2821f7a
34a87f9a723cc51b6b74e0fe095c9046a826ef3b
fc128af28cb263bf1f524f84609a7a75ffa27a9b
c12f398c2f3c4068ca5e01d736b1c9ae994b2138
74fd66519e983a0f29e16a342a6059dbffe36020
2ac1712b56771dd2ca6420eb5319765c1827e13e
b17b974691f0a26f26908495d24d9c4c718920f8
917522c4572a6237897e9a554cde21b8c6292dd3
4aa0e11f540c42a32ba24988966e9b1efbba6de3
3b1930208a82457747d76729ae088e90edca4673
6ffe534098dacefb3633efafff01eb0296f26725
8bfefdbc0d901a6e8ccd27b9f20879d109f49c03
de8ecf488033fb75504bf5179608f90d750f8759
404b7a0dea6406545f9969232049ff8119d3ac6f
a911921efe39c4f6fdce8571c1828eaf45d5551e
2c6af5a45ddf8b539e8481d7bf9dff4bc71dde78
d837bd432d63b740b62d964dda48818bd97e778b
d01a4cfad6ea50285c4710243e3cbe019d381eba
a47fd41f3aa4610ea527dcc1669dfdb9c15c5425
5057e76a11abd02e83b7d3d3171c4b68d9c88480
06f63b43050935962f84fe54473a7c5de7977325
4c8124ffcf4039d292442eeccabdeca5af5c5017
634396b2f541a9f2d58b00be1a07f0c358b999b3
</content>
		</actual_file>
		<actual_file>
			<filename>rev_list_range</filename>
			<content>3fa4e130fa18c92e3030d4accb5d3e0cadd40157
2d3acf90f35989df8f262dc50beadc4ee3ae1560
5e3ee1198672257164ce3fe31dea3e40848e68d5
420eac97a826bfac8724b6b0eef35c20922124b7
</content>
		</actual_file>
		<actual_file>
			<filename>rev_list_since</filename>
			<content>ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a
3fa4e130fa18c92e3030d4accb5d3e0cadd40157
2d3acf90f35989df8f262dc50beadc4ee3ae1560
5e3ee1198672257164ce3fe31dea3e40848e68d5
420eac97a826bfac8724b6b0eef35c20922124b7
30e367cef2203eba2b341dc9050993b06fd1e108
5a0943123f6872e75a9b1dd0b6519dd42a186fda
e1193f8092ae9ece0ba336b7aa4c29dcde78777f
d6016bc9fa3950ad18e3028f9d2d26f831061a62
11d191ef3f04012a78222cb118619c16d5581886
f11ceb37cbd72b8c7627aa9e2a7b8dbcbf10d107
28e7a1d3dd172a8e757ff777ab205a538b80385e
be3178ec3bf47bbdc69bd6023443fb6c4ac5385c
22825175e37f22c9418d756ca69b574d75602994
ad44b88d69c4b7b61a9ec12445f00f082ca19f41
78617eaee2ca3b88cd9bb5361d29a99b5555a3d2
a55a698345a3f27a981ada27c7486d89e374bc21
ccc8ba203bfb6b6051bfa083f73969f680ced61a
3dc4f654a697467692478f502817dfc3e0248378
f1964ad1919180dd1d9eae9d21a1a1f68ac60e77
4aa3410e2d458b00b0f41920ffc2aa21f019d13d
ca78e948410d39b690a76a7c613b83b70de64eeb
179f919876a255a8e09d32a95c8209d66c7ed660
</content>
		</actual_file>
		<actual_file>
			<filename>rev_list_single</filename>
			<content>commit 4c8124ffcf4039d292442eeccabdeca5af5c5017
tree 672eca9b7f9e09c22dcb128c283e8c3c8d7697a4
parent 634396b2f541a9f2d58b00be1a07f0c358b999b3
author Tom Preston-Werner tom@mojombo.com 1191999972 -0700
committer Tom Preston-Werner tom@mojombo.com 1191999972 -0700

    implement Grit#heads
</content>
		</actual_file>
		<actual_file>
			<filename>rev_parse</filename>
			<content>80f136f
</content>
		</actual_file>
		<actual_file>
			<filename>ruby_diff</filename>
			<content>diff --git a/lib/grit.rb b/lib/grit.rb
index 6afcf64..9e78ddf 100644
--- a/lib/grit.rb
+++ b/lib/grit.rb
@@ -5,12 +5,10 @@ require 'fileutils'
 require 'time'
 
 # stdlib
-require 'timeout'
 
 # third party
 require 'rubygems'
 require 'mime/types'
-require 'open4'
 
 # internal requires
 require 'grit/lazy'
diff --git a/lib/grit/git.rb b/lib/grit/git.rb
index ad42ff5..61919df 100644
--- a/lib/grit/git.rb
+++ b/lib/grit/git.rb
@@ -1,36 +1,18 @@
-trap("CHLD") do
-  begin
-    Process.wait(-1, Process::WNOHANG)
-  rescue Object
-  end
-end
-
 module Grit
   
   class Git
-    class GitTimeout  RuntimeError
-      attr_reader :command, :bytes_read
-
-      def initialize(command = nil, bytes_read = nil)
-        @command = command
-        @bytes_read = bytes_read
-      end
-    end
-
     undef_method :clone
     
     class  self
-      attr_accessor :git_binary, :git_timeout
+      attr_accessor :git_binary
     end
   
-    self.git_binary  = "/usr/bin/env git"
-    self.git_timeout = 5
+    self.git_binary = "/usr/bin/env git"
     
-    attr_accessor :git_dir, :bytes_read
+    attr_accessor :git_dir
     
     def initialize(git_dir)
-      self.git_dir    = git_dir
-      self.bytes_read = 0
+      self.git_dir = git_dir
     end
     
     # Run the given git command with the specified arguments and return
@@ -44,43 +26,16 @@ module Grit
     #
     # Returns String
     def method_missing(cmd, options = {}, *args)
-      timeout  = options.delete(:timeout)
-      timeout  = true if timeout.nil?
-
       opt_args = transform_options(options)
       ext_args = args.map { |a| a == '--' ? a : "'#{a}'" }
       
       call = "#{Git.git_binary} --git-dir='#{self.git_dir}' #{cmd.to_s.gsub(/_/, '-')} #{(opt_args + ext_args).join(' ')}"
       puts call if Grit.debug
-      response = timeout ? sh(call) : wild_sh(call)
+      response = `#{call}`
       puts response if Grit.debug
       response
     end
-
-    def sh(command)
-      pid, _, io, _ = Open4.popen4(command)
-      ret = Timeout.timeout(self.class.git_timeout) { io.read }
-      @bytes_read += ret.size
-
-      if @bytes_read  5242880 # 5.megabytes
-        bytes = @bytes_read
-        @bytes_read = 0
-        raise GitTimeout.new(command, bytes) 
-      end
-
-      ret
-    rescue Object = e
-      Process.kill('KILL', pid) rescue nil
-      bytes = @bytes_read
-      @bytes_read = 0
-      raise GitTimeout.new(command, bytes)
-    end
-
-    def wild_sh(command)
-      pid, _, io, _ = Open4.popen4(command)
-      io.read
-    end
-
+    
     # Transform Ruby style options into git command line options
     #   +options+ is a hash of Ruby style options
     #
@@ -109,4 +64,4 @@ module Grit
     end
   end # Git
   
-end # Grit
+end # Grit
\ No newline at end of file
diff --git a/lib/grit/head.rb b/lib/grit/head.rb
index 6865bf0..86f29c2 100644
--- a/lib/grit/head.rb
+++ b/lib/grit/head.rb
@@ -1,5 +1,4 @@
 module Grit
-  HEAD_PREFIX = 'refs/heads'
   
   # A Head is a named reference to a Commit. Every Head instance contains a name
   # and a Commit object.
@@ -34,7 +33,7 @@ module Grit
                          
       actual_options = default_options.merge(options)
       
-      output = repo.git.for_each_ref(actual_options, HEAD_PREFIX)
+      output = repo.git.for_each_ref(actual_options, "refs/heads")
                  
       self.list_from_string(repo, output)
     end
@@ -78,7 +77,7 @@ module Grit
     # Returns Grit::Head (baked)
     def self.from_string(repo, line)
       full_name, id = line.split("\0")
-      name = full_name.sub("#{HEAD_PREFIX}/", '')
+      name = full_name.split("/").last
       commit = Commit.create(repo, :id = id)
       self.new(name, commit)
     end
diff --git a/test/fixtures/for_each_ref b/test/fixtures/for_each_ref
index 9f3bece..e56f526 100644
Binary files a/test/fixtures/for_each_ref and b/test/fixtures/for_each_ref differ
diff --git a/test/test_git.rb b/test/test_git.rb
index adbdc6d..dcc5fdc 100644
--- a/test/test_git.rb
+++ b/test/test_git.rb
@@ -18,35 +18,4 @@ class TestGit  Test::Unit::TestCase
     
     assert_equal ["-s", "-t"], @git.transform_options({:s = true, :t = true}).sort
   end
-
-  def test_uses_custom_sh_method
-    @git.expects(:sh)
-    @git.something
-  end
-
-  def test_can_skip_timeout
-    @git.expects(:wild_sh)
-    @git.something(:timeout = false)
-  end
-
-  def test_raises_if_too_many_bytes
-    @git.instance_variable_set(:@bytes_read, 6000000)
-    assert_raises Grit::Git::GitTimeout do
-      @git.something
-    end
-  end
-
-  def test_raises_on_slow_shell
-    Grit::Git.git_timeout = 0.5
-    Open4.expects(:popen4).returns([ nil, nil, mock(:read = proc { sleep 1 }), nil ])
-    assert_raises Grit::Git::GitTimeout do
-      @git.something
-    end
-  end
-
-  def test_works_fine_if_quick
-    output = 'output'
-    Open4.expects(:popen4).returns([ nil, nil, mock(:read = output), nil ])
-    assert_equal output, @git.something
-  end
 end
diff --git a/test/test_head.rb b/test/test_head.rb
index baaae85..6b97822 100644
--- a/test/test_head.rb
+++ b/test/test_head.rb
@@ -3,20 +3,15 @@ require File.dirname(__FILE__) + '/helper'
 class TestHead  Test::Unit::TestCase
   def setup
     @r = Repo.new(GRIT_REPO)
-    Git.any_instance.expects(:for_each_ref).returns(fixture('for_each_ref'))
   end
   
   # inspect
   
   def test_inspect
+    Git.any_instance.expects(:for_each_ref).returns(fixture('for_each_ref'))
+    
     head = @r.heads.first
+    
     assert_equal %Q{#Grit::Head "#{head.name}"}, head.inspect
   end
-
-  # heads with slashes
-
-  def test_heads_with_slashes
-    head = @r.heads.last
-    assert_equal %Q{#Grit::Head "mojombo/master"}, head.inspect
-  end
-end
+end
\ No newline at end of file
</content>
		</actual_file>
		<actual_file>
			<filename>ruby_diff_full_index</filename>
			<content>diff --git a/lib/grit.rb b/lib/grit.rb
index 6afcf64c80da8253fa47228eb09bc0eea217e5d1..9e78ddfaabf79f8314cc9a53a2f59775aee06bd7 100644
--- a/lib/grit.rb
+++ b/lib/grit.rb
@@ -5,12 +5,10 @@ require 'fileutils'
 require 'time'
 
 # stdlib
-require 'timeout'
 
 # third party
 require 'rubygems'
 require 'mime/types'
-require 'open4'
 
 # internal requires
 require 'grit/lazy'
diff --git a/lib/grit/git.rb b/lib/grit/git.rb
index ad42ff593e936be1ec7ac17346beab0a0761e278..61919dff16ff3962ce857a0e723f083c73793273 100644
--- a/lib/grit/git.rb
+++ b/lib/grit/git.rb
@@ -1,36 +1,18 @@
-trap("CHLD") do
-  begin
-    Process.wait(-1, Process::WNOHANG)
-  rescue Object
-  end
-end
-
 module Grit
   
   class Git
-    class GitTimeout  RuntimeError
-      attr_reader :command, :bytes_read
-
-      def initialize(command = nil, bytes_read = nil)
-        @command = command
-        @bytes_read = bytes_read
-      end
-    end
-
     undef_method :clone
     
     class  self
-      attr_accessor :git_binary, :git_timeout
+      attr_accessor :git_binary
     end
   
-    self.git_binary  = "/usr/bin/env git"
-    self.git_timeout = 5
+    self.git_binary = "/usr/bin/env git"
     
-    attr_accessor :git_dir, :bytes_read
+    attr_accessor :git_dir
     
     def initialize(git_dir)
-      self.git_dir    = git_dir
-      self.bytes_read = 0
+      self.git_dir = git_dir
     end
     
     # Run the given git command with the specified arguments and return
@@ -44,43 +26,16 @@ module Grit
     #
     # Returns String
     def method_missing(cmd, options = {}, *args)
-      timeout  = options.delete(:timeout)
-      timeout  = true if timeout.nil?
-
       opt_args = transform_options(options)
       ext_args = args.map { |a| a == '--' ? a : "'#{a}'" }
       
       call = "#{Git.git_binary} --git-dir='#{self.git_dir}' #{cmd.to_s.gsub(/_/, '-')} #{(opt_args + ext_args).join(' ')}"
       puts call if Grit.debug
-      response = timeout ? sh(call) : wild_sh(call)
+      response = `#{call}`
       puts response if Grit.debug
       response
     end
-
-    def sh(command)
-      pid, _, io, _ = Open4.popen4(command)
-      ret = Timeout.timeout(self.class.git_timeout) { io.read }
-      @bytes_read += ret.size
-
-      if @bytes_read  5242880 # 5.megabytes
-        bytes = @bytes_read
-        @bytes_read = 0
-        raise GitTimeout.new(command, bytes) 
-      end
-
-      ret
-    rescue Object = e
-      Process.kill('KILL', pid) rescue nil
-      bytes = @bytes_read
-      @bytes_read = 0
-      raise GitTimeout.new(command, bytes)
-    end
-
-    def wild_sh(command)
-      pid, _, io, _ = Open4.popen4(command)
-      io.read
-    end
-
+    
     # Transform Ruby style options into git command line options
     #   +options+ is a hash of Ruby style options
     #
@@ -109,4 +64,4 @@ module Grit
     end
   end # Git
   
-end # Grit
+end # Grit
\ No newline at end of file
diff --git a/lib/grit/head.rb b/lib/grit/head.rb
index 6865bf036695bed006fdfb2a8abd8a6b83fb149e..86f29c26ae054aea7134c71168538928d23864fc 100644
--- a/lib/grit/head.rb
+++ b/lib/grit/head.rb
@@ -1,5 +1,4 @@
 module Grit
-  HEAD_PREFIX = 'refs/heads'
   
   # A Head is a named reference to a Commit. Every Head instance contains a name
   # and a Commit object.
@@ -34,7 +33,7 @@ module Grit
                          
       actual_options = default_options.merge(options)
       
-      output = repo.git.for_each_ref(actual_options, HEAD_PREFIX)
+      output = repo.git.for_each_ref(actual_options, "refs/heads")
                  
       self.list_from_string(repo, output)
     end
@@ -78,7 +77,7 @@ module Grit
     # Returns Grit::Head (baked)
     def self.from_string(repo, line)
       full_name, id = line.split("\0")
-      name = full_name.sub("#{HEAD_PREFIX}/", '')
+      name = full_name.split("/").last
       commit = Commit.create(repo, :id = id)
       self.new(name, commit)
     end
diff --git a/test/fixtures/for_each_ref b/test/fixtures/for_each_ref
index 9f3bece3da6b8793a75384d35f583eac1abb506d..e56f5262621ebe2a5a903dde14e149845c963930 100644
Binary files a/test/fixtures/for_each_ref and b/test/fixtures/for_each_ref differ
diff --git a/test/test_git.rb b/test/test_git.rb
index adbdc6d61b8caba532e13af64f6c7caea801b417..dcc5fdc1ca60422ca59d32a3c60b360ddc0d0ed7 100644
--- a/test/test_git.rb
+++ b/test/test_git.rb
@@ -18,35 +18,4 @@ class TestGit  Test::Unit::TestCase
     
     assert_equal ["-s", "-t"], @git.transform_options({:s = true, :t = true}).sort
   end
-
-  def test_uses_custom_sh_method
-    @git.expects(:sh)
-    @git.something
-  end
-
-  def test_can_skip_timeout
-    @git.expects(:wild_sh)
-    @git.something(:timeout = false)
-  end
-
-  def test_raises_if_too_many_bytes
-    @git.instance_variable_set(:@bytes_read, 6000000)
-    assert_raises Grit::Git::GitTimeout do
-      @git.something
-    end
-  end
-
-  def test_raises_on_slow_shell
-    Grit::Git.git_timeout = 0.5
-    Open4.expects(:popen4).returns([ nil, nil, mock(:read = proc { sleep 1 }), nil ])
-    assert_raises Grit::Git::GitTimeout do
-      @git.something
-    end
-  end
-
-  def test_works_fine_if_quick
-    output = 'output'
-    Open4.expects(:popen4).returns([ nil, nil, mock(:read = output), nil ])
-    assert_equal output, @git.something
-  end
 end
diff --git a/test/test_head.rb b/test/test_head.rb
index baaae854addf9b0443ac7f0021dda4344b868819..6b97822eb2ba0194bddd194f670f62853061ac9a 100644
--- a/test/test_head.rb
+++ b/test/test_head.rb
@@ -3,20 +3,15 @@ require File.dirname(__FILE__) + '/helper'
 class TestHead  Test::Unit::TestCase
   def setup
     @r = Repo.new(GRIT_REPO)
-    Git.any_instance.expects(:for_each_ref).returns(fixture('for_each_ref'))
   end
   
   # inspect
   
   def test_inspect
+    Git.any_instance.expects(:for_each_ref).returns(fixture('for_each_ref'))
+    
     head = @r.heads.first
+    
     assert_equal %Q{#Grit::Head "#{head.name}"}, head.inspect
   end
-
-  # heads with slashes
-
-  def test_heads_with_slashes
-    head = @r.heads.last
-    assert_equal %Q{#Grit::Head "mojombo/master"}, head.inspect
-  end
-end
+end
\ No newline at end of file
</content>
		</actual_file>
		<actual_file>
			<filename>ruby_for_each_ref</filename>
			<content>ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a commit	refs/heads/master
2d3acf90f35989df8f262dc50beadc4ee3ae1560 commit	refs/heads/testing
ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a commit	refs/remotes/origin/HEAD
ca8a30f5a7f0f163bbe3b6f0abf18a6c83b0687a commit	refs/remotes/origin/master
2d3acf90f35989df8f262dc50beadc4ee3ae1560 commit	refs/remotes/tom/master
f0055fda16c18fd8b27986dbf038c735b82198d7 tag	refs/tags/v0.7.0
</content>
		</actual_file>
		<actual_file>
			<filename>show_cc</filename>
			<content>commit f8dd1f0b48e1106a62b47cc2927609ca589dc39a
tree 4c23a5137714e62c52f22e99b3104122868400ab
parent a0710955e70cbceef8cf805645a447f1b370b966
parent b724247612be9f55df7914cb86b64703810d7b73
author administrator gmalamid@thoughtworks.com 1224499981 +0100
committer administrator gmalamid@thoughtworks.com 1224499981 +0100

    imported William Morgans utilities too, which are very very nice

diff --cc git-publish-branch
index 0000000000000000000000000000000000000000,0000000000000000000000000000000000000000..b28b4fde621dff1c72bcb570183bbe923e4a24b2
new file mode 100755
--- /dev/null
+++ b/git-publish-branch
@@@ -1,0 -1,0 +1,70 @@@
++#!/usr/bin/env ruby
++
++## git-publish-branch: a simple script to ease the unnecessarily complex
++## task of "publishing" a branch, i.e., taking a local branch, creating a
++## reference to it on a remote repo, and setting up the local branch to
++## track the remote one, all in one go. you can even delete that remote
++## reference.
++##
++## Usage: git publish-branch [-d] branch [repository]
++##
++## '-d' signifies deletion. branch is the branch to publish, and
++## [repository] defaults to "origin". The remote branch name will be the
++## same as the local branch name. Don't make life unnecessarily complex
++## for yourself.
++##
++## Note that unpublishing a branch doesn't delete the local branch.
++## Safety first!
++##
++## git-publish-branch Copyright 2008 William Morgan wmorgan-git-wt-add@masanjin.net. 
++## This program is free software: you can redistribute it and/or modify
++## it under the terms of the GNU General Public License as published by
++## the Free Software Foundation, either version 3 of the License, or (at
++## your option) any later version.
++##
++## This program is distributed in the hope that it will be useful,
++## but WITHOUT ANY WARRANTY; without even the implied warranty of
++## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++## GNU General Public License for more details.
++##
++## You can find the GNU General Public License at:
++##   http://www.gnu.org/licenses/
++
++def exec cmd
++  puts cmd
++  system cmd or die unless $fake
++end
++
++def die s=nil
++  $stderr.puts s if s
++  exit(-1)
++end
++
++head = `git symbolic-ref HEAD`.chomp.gsub(/refs\/heads\//, "")
++delete = ARGV.delete "-d"
++$fake = ARGV.delete "-n"
++branch = (ARGV.shift || head).gsub(/refs\/heads\//, "")
++remote = ARGV.shift || "origin"
++local_ref = `git show-ref heads/#{branch}`
++remote_ref = `git show-ref remotes/#{remote}/#{branch}`
++remote_config = `git config branch.#{branch}.merge`
++
++if delete
++  ## we don't do any checking here because the remote branch might actually
++  ## exist, whether we actually know about it or not.
++  exec "git push #{remote} :refs/heads/#{branch}"
++
++  unless local_ref.empty?
++    exec "git config --unset branch.#{branch}.remote"
++    exec "git config --unset branch.#{branch}.merge"
++  end
++else
++  die "No local branch #{branch} exists!" if local_ref.empty?
++  die "A remote branch #{branch} on #{remote} already exists!" unless remote_ref.empty?
++  die "Local branch #{branch} is already a tracking branch!" unless remote_config.empty?
++
++  exec "git push #{remote} #{branch}:refs/heads/#{branch}"
++  exec "git config branch.#{branch}.remote #{remote}"
++  exec "git config branch.#{branch}.merge refs/heads/#{branch}"
++end
++
diff --cc git-rank-contributors
index 0000000000000000000000000000000000000000,0000000000000000000000000000000000000000..3b272206d185e2f9b8089e6aaa00fde6acc308ef
new file mode 100755
--- /dev/null
+++ b/git-rank-contributors
@@@ -1,0 -1,0 +1,60 @@@
++#!/usr/bin/env ruby
++
++## git-rank-contributors: a simple script to trace through the logs and
++## rank contributors by the total size of the diffs they're responsible for.
++## A change counts twice as much as a plain addition or deletion.
++##
++## Output may or may not be suitable for inclusion in a CREDITS file.
++## Probably not without some editing, because people often commit from more
++## than one address.
++##
++## git-rank-contributors Copyright 2008 William Morgan wmorgan-git-wt-add@masanjin.net. 
++## This program is free software: you can redistribute it and/or modify
++## it under the terms of the GNU General Public License as published by
++## the Free Software Foundation, either version 3 of the License, or (at
++## your option) any later version.
++##
++## This program is distributed in the hope that it will be useful,
++## but WITHOUT ANY WARRANTY; without even the implied warranty of
++## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++## GNU General Public License for more details.
++##
++## You can find the GNU General Public License at:
++##   http://www.gnu.org/licenses/
++
++class String
++  def obfuscate; gsub(/@/, " at the ").gsub(/\.(\w+)(|$)/, ' dot \1s\2') end
++  def htmlize; gsub("&", "&amp;").gsub("", "&lt;").gsub("", "&gt;") end
++end
++
++lines = {}
++verbose = ARGV.delete("-v")
++obfuscate = ARGV.delete("-o")
++htmlize = ARGV.delete("-h")
++
++author = nil
++state = :pre_author
++`git log -M -C -C -p --no-color`.each do |l|
++  case
++  when (state == :pre_author || state == :post_author) && l =~ /Author: (.*)$/
++    author = $1
++    state = :post_author
++    lines[author] ||= 0
++  when state == :post_author && l =~ /^\+\+\+/
++    state = :in_diff
++  when state == :in_diff && l =~ /^[\+\-]/
++    lines[author] += 1
++  when state == :in_diff && l =~ /^commit /
++    state = :pre_author
++  end
++end
++
++lines.sort_by { |a, c| -c }.each do |a, c|
++  a = a.obfuscate if obfuscate
++  a = a.htmlize if htmlize
++  if verbose
++    puts "#{a}: #{c} lines of diff"
++  else
++    puts a
++  end
++end
diff --cc git-show-merges
index 0000000000000000000000000000000000000000,0000000000000000000000000000000000000000..12907502a6c6885e7183a0e71d9cfeed77917824
new file mode 100755
--- /dev/null
+++ b/git-show-merges
@@@ -1,0 -1,0 +1,49 @@@
++#!/usr/bin/env ruby
++
++## git-show-merges: a simple script to show you which topic branches have
++## been merged into the current branch, and which haven't. (Or, specify
++## the set of merge branches you're interested in on the command line.)
++##
++## git-show-merges Copyright 2008 William Morgan wmorgan-git-wt-add@masanjin.net. 
++## This program is free software: you can redistribute it and/or modify
++## it under the terms of the GNU General Public License as published by
++## the Free Software Foundation, either version 3 of the License, or (at
++## your option) any later version.
++##
++## This program is distributed in the hope that it will be useful,
++## but WITHOUT ANY WARRANTY; without even the implied warranty of
++## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++## GNU General Public License for more details.
++##
++## You can find the GNU General Public License at:
++##   http://www.gnu.org/licenses/
++heads = if ARGV.empty?
++  [`git symbolic-ref HEAD`.chomp]
++else
++  ARGV
++end.map { |r| r.gsub(/refs\/heads\//, "") }
++
++branches = `git show-ref --heads`.
++  scan(/^\S+ refs\/heads\/(\S+)$/).
++  map { |a| a.first }
++
++unknown = heads - branches
++unless unknown.empty?
++  $stderr.puts "Unknown branch: #{unknown.first}"
++  exit(-1)
++end
++
++branches -= heads
++
++heads.each do |h|
++  merged = branches.select { |b| `git log #{h}..#{b}` == "" }
++  unmerged = branches - merged
++
++  puts "merged into #{h}:"
++  merged.each { |b| puts "  #{b}" }
++  puts
++  puts "not merged into #{h}: "
++  unmerged.each { |b| puts "  #{b}" }
++
++  puts
++end
diff --cc git-wt-add
index 0000000000000000000000000000000000000000,0000000000000000000000000000000000000000..3125ab5495e5f2ab55ed48af5303031fae02c2ac
new file mode 100755
--- /dev/null
+++ b/git-wt-add
@@@ -1,0 -1,0 +1,196 @@@
++#!/usr/bin/env ruby
++
++## git-wt-add: A darcs-style interactive staging script for git. As the
++## name implies, git-wt-add walks you through unstaged changes on a
++## hunk-by-hunk basis and allows you to pick the ones you'd like staged.
++##
++## git-wt-add Copyright 2007 William Morgan wmorgan-git-wt-add@masanjin.net.
++## This program is free software: you can redistribute it and/or modify
++## it under the terms of the GNU General Public License as published by
++## the Free Software Foundation, either version 3 of the License, or
++## (at your option) any later version.
++##
++## This program is distributed in the hope that it will be useful,
++## but WITHOUT ANY WARRANTY; without even the implied warranty of
++## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++## GNU General Public License for more details.
++##
++## You can find the GNU General Public License at:
++##   http://www.gnu.org/licenses/
++
++COLOR = /\e\[\d*m/
++
++class Hunk
++  attr_reader :file, :file_header, :diff
++  attr_accessor :disposition
++
++  def initialize file, file_header, diff
++    @file = file
++    @file_header = file_header
++    @diff = diff
++    @disposition = :unknown
++  end
++
++  def self.make_from diff
++    ret = []
++    state = :outside
++    file_header = hunk = file = nil
++
++    diff.each do |l| # a little state machine to parse git diff output
++      reprocess = false
++      begin
++        reprocess = false
++        case
++        when state == :outside && l =~ /^(#{COLOR})*diff --git a\/(.+) b\/(\2)/
++          file = $2
++          file_header = ""
++        when state == :outside && l =~ /^(#{COLOR})*index /
++        when state == :outside && l =~ /^(#{COLOR})*(---|\+\+\+) /
++          file_header += l + "\n"
++        when state == :outside && l =~ /^(#{COLOR})*@@ /
++          state = :in_hunk
++          hunk = l + "\n"
++        when state == :in_hunk && l =~ /^(#{COLOR})*(@@ |diff --git a)/
++          ret  Hunk.new(file, file_header, hunk)
++          state = :outside
++          reprocess = true
++        when state == :in_hunk
++          hunk += l + "\n"
++        else
++          raise "unparsable diff input: #{l.inspect}"
++        end
++      end while reprocess
++    end
++
++    ## add the final hunk
++    ret  Hunk.new(file, file_header, hunk) if hunk
++
++    ret
++  end
++end
++
++def help
++  puts EOS
++y: record this patch
++n: don't record it
++w: wait and decide later, defaulting to no
++
++s: don't record the rest of the changes to this file
++f: record the rest of the changes to this file
++
++d: record selected patches, skipping all the remaining patches
++a: record all the remaining patches
++q: cancel record
++
++j: skip to next patch
++k: back up to previous patch
++c: calculate number of patches
++h or ?: show this help
++
++Space: accept the current default (which is capitalized)
++EOS
++end
++
++def walk_through hunks
++  skip_files, record_files = {}, {}
++  skip_rest = record_rest = false
++
++  while hunks.any? { |h| h.disposition == :unknown }
++    pos = 0
++    until pos = hunks.length
++      h = hunks[pos]
++      if h.disposition != :unknown
++        pos += 1
++        next
++      elsif skip_rest || skip_files[h.file]
++        h.disposition = :ignore
++        pos += 1
++        next
++      elsif record_rest || record_files[h.file]
++        h.disposition = :record
++        pos += 1
++        next
++      end
++
++      puts "Hunk from #{h.file}"
++      puts h.diff
++      print "Shall I stage this change? (#{pos + 1}/#{hunks.length}) [ynWsfqadk], or ? for help: "
++      c = $stdin.getc
++      puts
++      case c
++      when ?y: h.disposition = :record
++      when ?n: h.disposition = :ignore
++      when ?w, ?\ : h.disposition = :unknown
++      when ?s
++        h.disposition = :ignore
++        skip_files[h.file] = true
++      when ?f
++        h.disposition = :record
++        record_files[h.file] = true
++      when ?d: skip_rest = true
++      when ?a: record_rest = true
++      when ?q: exit
++      when ?k
++        if pos  0
++          hunks[pos - 1].disposition = :unknown
++          pos -= 2 # double-bah
++        end
++      else
++        help
++        pos -= 1 # bah
++      end
++
++      pos += 1
++      puts
++    end
++  end
++end
++
++def make_patch hunks
++  patch = ""
++  did_header = {}
++  hunks.each do |h|
++    next unless h.disposition == :record
++    unless did_header[h.file]
++      patch += h.file_header
++      did_header[h.file] = true
++    end
++    patch += h.diff
++  end
++
++  patch.gsub COLOR, ""
++end
++
++### execution starts here ###
++
++diff = `git diff`.split(/\r?\n/)
++if diff.empty?
++  puts "No unstaged changes."
++  exit
++end
++hunks = Hunk.make_from diff
++
++## unix-centric!
++state = `stty -g`
++begin
++  `stty -icanon` # immediate keypress mode
++  walk_through hunks
++ensure
++  `stty #{state}`
++end
++
++patch = make_patch hunks
++if patch.empty?
++  puts "No changes selected for staging."
++else
++  IO.popen("git apply --cached", "w") { |f| f.puts patch }
++  puts EOS
++Staged patch of #{patch.split("\n").size} lines.
++
++Possible next commands:
++  git diff --cached: see staged changes
++         git commit: commit staged changes
++          git reset: unstage changes
++EOS
++end
++
diff --cc git-wtf
index 0000000000000000000000000000000000000000,0000000000000000000000000000000000000000..ea4b27f6812cf9daf84b047bff4443cc554f92bf
new file mode 100755
--- /dev/null
+++ b/git-wtf
@@@ -1,0 -1,0 +1,223 @@@
++#!/usr/bin/env ruby
++
++## git-wtf: display the state of your repository in a readable and easy-to-scan
++## format.
++##
++## git-wtf tries to ease the task of having many git branches. It's also useful
++## for getting a summary of how tracking branches relate to a remote server.
++##
++## git-wtf shows you:
++## - How your branch relates to the remote repo, if it's a tracking branch.
++## - How your branch relates to non-feature ("version") branches, if it's a
++##   feature branch.
++## - How your branch relates to the feature branches, if it's a version branch.
++##
++## For each of these relationships, git-wtf displays the commits pending on
++## either side, if any. It displays checkboxes along the side for easy scanning
++## of merged/non-merged branches.
++##
++## If you're working against a remote repo, git-wtf is best used between a 'git
++## fetch' and a 'git merge' (or 'git pull' if you don't mind the redundant
++## network access).
++##
++## Usage: git wtf [branch+] [-l|--long] [-a|--all] [--dump-config]
++##
++## If [branch] is not specified, git-wtf will use the current branch.  With
++## --long, you'll see author info and date for each commit. With --all, you'll
++## see all commits, not just the first 5. With --dump-config, git-wtf will
++## print out its current configuration in YAML format and exit.
++##
++## git-wtf uses some heuristics to determine which branches are version
++## branches, and which are feature branches. (Specifically, it assumes the
++## version branches are named "master", "next" and "edge".) If it guesses
++## incorrectly, you will have to create a .git-wtfrc file.
++##
++## git-wtf looks for a .git-wtfrc file starting in the current directory, and
++## recursively up to the root. The config file is a YAML file that specifies
++## the version branches, any branches to ignore, and the max number of commits
++## to display when --all isn't used. To start building a configuration file,
++## run "git-wtf --dump-config  .git-wtfrc" and edit it.
++##
++## IMPORTANT NOTE: all local branches referenced in .git-wtfrc must be prefixed
++## with heads/, e.g. "heads/master". Remote branches must be of the form
++## remotes/remote/branch.
++##
++## git-wtf Copyright 2008 William Morgan wmorgan-git-wt-add@masanjin.net.
++## This program is free software: you can redistribute it and/or modify it
++## under the terms of the GNU General Public License as published by the Free
++## Software Foundation, either version 3 of the License, or (at your option)
++## any later version.
++##
++## This program is distributed in the hope that it will be useful, but WITHOUT
++## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
++## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
++## more details.
++##
++## You can find the GNU General Public License at: http://www.gnu.org/licenses/
++
++
++require 'yaml'
++CONFIG_FN = ".git-wtfrc"
++
++class Numeric; def pluralize s; "#{to_s} #{s}" + (self != 1 ? "s" : "") end end
++
++$long = ARGV.delete("--long") || ARGV.delete("-l")
++$all = ARGV.delete("--all") || ARGV.delete("-a")
++$dump_config = ARGV.delete("--dump-config")
++
++## find config file
++$config = { "versions" = %w(heads/master heads/next heads/edge), "ignore" = [], "max_commits" = 5 }.merge begin
++  p = File.expand_path "."
++  fn = while true
++    fn = File.join p, CONFIG_FN
++    break fn if File.exist? fn
++    pp = File.expand_path File.join(p, "..")
++    break if p == pp
++    p = pp
++  end
++
++  (fn && YAML::load_file(fn)) || {} # YAML turns empty files into false
++end
++
++if $dump_config
++  puts $config.to_yaml
++  exit(0)
++end
++
++## the set of commits in 'to' that aren't in 'from'.
++## if empty, 'to' has been merged into 'from'.
++def commits_between from, to
++  if $long
++    `git log --pretty=format:"- %s [%h] (%ae; %ar)" #{from}..#{to}`
++  else
++    `git log --pretty=format:"- %s [%h]" #{from}..#{to}`
++  end.split(/[\r\n]+/)
++end
++
++def show_commits commits, prefix="    "
++  if commits.empty?
++    puts "#{prefix} none"
++  else
++    max = $all ? commits.size : $config["max_commits"]
++    max -= 1 if max == commits.size - 1 # never show "and 1 more"
++    commits[0 ... max].each { |c| puts "#{prefix}#{c}" }
++    puts "#{prefix}... and #{commits.size - max} more." if commits.size  max
++  end
++end
++
++def ahead_behind_string ahead, behind
++  [ahead.empty? ? nil : "#{ahead.size.pluralize 'commit'} ahead",
++   behind.empty? ? nil : "#{behind.size.pluralize 'commit'} behind"].
++   compact.join("; ")
++end
++
++def show b, all_branches
++  puts "Local branch: #{b[:local_branch]}"
++  both = false
++
++  if b[:remote_branch]
++    pushc = commits_between b[:remote_branch], b[:local_branch]
++    pullc = commits_between b[:local_branch], b[:remote_branch]
++
++    both = !pushc.empty? && !pullc.empty?
++    if pushc.empty?
++      puts "[x] in sync with remote"
++    else
++      action = both ? "push after rebase / merge" : "push"
++      puts "[ ] NOT in sync with remote (needs #{action})"
++      show_commits pushc
++    end
++
++    puts "\nRemote branch: #{b[:remote_branch]} (#{b[:remote_url]})"
++
++    if pullc.empty?
++      puts "[x] in sync with local"
++    else
++      action = pushc.empty? ? "merge" : "rebase / merge"
++      puts "[ ] NOT in sync with local (needs #{action})"
++      show_commits pullc
++
++      both = !pushc.empty? && !pullc.empty?
++    end
++  end
++
++  vbs, fbs = all_branches.partition { |name, br| $config["versions"].include? br[:local_branch] }
++  if $config["versions"].include? b[:local_branch]
++    puts "\nFeature branches:" unless fbs.empty?
++    fbs.each do |name, br|
++      remote_ahead = b[:remote_branch] ? commits_between(b[:remote_branch], br[:local_branch]) : []
++      local_ahead = commits_between b[:local_branch], br[:local_branch]
++      if local_ahead.empty? && remote_ahead.empty?
++        puts "[x] #{br[:name]} is merged in"
++      elsif local_ahead.empty? && b[:remote_branch]
++        puts "(x) #{br[:name]} merged in (only locally)"
++      else
++        behind = commits_between br[:local_branch], b[:local_branch]
++        puts "[ ] #{br[:name]} is NOT merged in (#{ahead_behind_string local_ahead, behind})"
++        show_commits local_ahead
++      end
++    end
++  else
++    puts "\nVersion branches:" unless vbs.empty? # unlikely
++    vbs.each do |v, br|
++      ahead = commits_between v, b[:local_branch]
++      if ahead.empty?
++        puts "[x] merged into #{v}"
++      else
++        #behind = commits_between b[:local_branch], v
++        puts "[ ] NOT merged into #{v} (#{ahead.size.pluralize 'commit'} ahead)"
++        show_commits ahead
++      end
++    end
++  end
++
++  puts "\nWARNING: local and remote branches have diverged. A merge will occur unless you rebase." if both
++end
++
++branches = `git show-ref`.inject({}) do |hash, l|
++  sha1, ref = l.chomp.split " refs/"
++  next hash if $config["ignore"].member? ref
++  next hash unless ref =~ /^heads\/(.+)/
++  name = $1
++  hash[name] = { :name = name, :local_branch = ref }
++  hash
++end
++
++remotes = `git config --get-regexp ^remote\.\*\.url`.inject({}) do |hash, l|
++  l =~ /^remote\.(.+?)\.url (.+)$/ or next hash
++  hash[$1] ||= $2
++  hash
++end
++
++`git config --get-regexp ^branch\.`.each do |l|
++  case l
++  when /branch\.(.*?)\.remote (.+)/
++    branches[$1] ||= {}
++    branches[$1][:remote] = $2
++    branches[$1][:remote_url] = remotes[$2]
++  when /branch\.(.*?)\.merge ((refs\/)?heads\/)?(.+)/
++    branches[$1] ||= {}
++    branches[$1][:remote_mergepoint] = $4
++  end
++end
++
++branches.each { |k, v| v[:remote_branch] = "#{v[:remote]}/#{v[:remote_mergepoint]}" if v[:remote] && v[:remote_mergepoint] }
++
++show_dirty = ARGV.empty?
++targets = if ARGV.empty?
++  [`git symbolic-ref HEAD`.chomp.sub(/^refs\/heads\//, "")]
++else
++  ARGV
++end.map { |t| branches[t] or abort "Error: can't find branch #{t.inspect}." }
++
++targets.each { |t| show t, branches }
++
++modified = show_dirty && `git ls-files -m` != ""
++uncommitted = show_dirty &&  `git diff-index --cached HEAD` != ""
++
++puts if modified || uncommitted
++puts "NOTE: working directory contains modified files" if modified
++puts "NOTE: staging area contains staged but uncommitted files" if uncommitted
++
++# the end!
++
</content>
		</actual_file>
		<actual_file>
			<filename>show_empty_commit</filename>
			<content>commit 1e3824339762bd48316fe87bfafc853732d43264
tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904
author Tom Preston-Werner tom@mojombo.com 1157392833 +0000
committer Tom Preston-Werner tom@mojombo.com 1157392833 +0000

    initial directory structure
</content>
		</actual_file>
		<actual_file>
			<filename>simple_config</filename>
			<content>core.bare=false
remote.origin.url=git://github.com/mojombo/grit.git</content>
		</actual_file>
		<actual_file>
			<filename>COMMIT_EDITMSG</filename>
			<content>good patch
</content>
		</actual_file>
		<actual_file>
			<filename>config</filename>
			<content>[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
	ignorecase = true
</content>
		</actual_file>
		<actual_file>
			<filename>description</filename>
			<content>Unnamed repository; edit this file 'description' to name the repository.
</content>
		</actual_file>
		<actual_file>
			<filename>HEAD</filename>
			<content>ref: refs/heads/master
</content>
		</actual_file>
		<actual_file>
			<filename>exclude</filename>
			<content># git ls-files --others --exclude-from=.git/info/exclude
# Lines that start with '#' are comments.
# For a project mostly in C, the following would be a good set of
# exclude patterns (uncomment them if you want to use them):
# *.[oa]
# *~
</content>
		</actual_file>
		<actual_file>
			<filename>HEAD</filename>
			<content>0000000000000000000000000000000000000000 5da862ffd84e42b687b65605788f4158f4610400 rick technoweenie@gmail.com 1294902968 -0800	commit (initial): initial
5da862ffd84e42b687b65605788f4158f4610400 5da862ffd84e42b687b65605788f4158f4610400 rick technoweenie@gmail.com 1294902973 -0800	checkout: moving from master to bad
5da862ffd84e42b687b65605788f4158f4610400 f252f9a68245f465d27b31fcdbf63ab55de58b06 rick technoweenie@gmail.com 1294902998 -0800	commit: bad patch
f252f9a68245f465d27b31fcdbf63ab55de58b06 5da862ffd84e42b687b65605788f4158f4610400 rick technoweenie@gmail.com 1294902999 -0800	checkout: moving from bad to master
5da862ffd84e42b687b65605788f4158f4610400 cf75ecfce82fb2a8723f86b140980994f0065ecd rick technoweenie@gmail.com 1294903011 -0800	commit: update
cf75ecfce82fb2a8723f86b140980994f0065ecd cf75ecfce82fb2a8723f86b140980994f0065ecd rick technoweenie@gmail.com 1294903013 -0800	checkout: moving from master to good
cf75ecfce82fb2a8723f86b140980994f0065ecd f3c031e78b368d1b9b03c3eb1b90d8a122277e67 rick technoweenie@gmail.com 1294903038 -0800	commit: good patch
f3c031e78b368d1b9b03c3eb1b90d8a122277e67 cf75ecfce82fb2a8723f86b140980994f0065ecd rick technoweenie@gmail.com 1294903041 -0800	checkout: moving from good to master
</content>
		</actual_file>
		<actual_file>
			<filename>bad</filename>
			<content>0000000000000000000000000000000000000000 5da862ffd84e42b687b65605788f4158f4610400 rick technoweenie@gmail.com 1294902973 -0800	branch: Created from HEAD
5da862ffd84e42b687b65605788f4158f4610400 f252f9a68245f465d27b31fcdbf63ab55de58b06 rick technoweenie@gmail.com 1294902998 -0800	commit: bad patch
</content>
		</actual_file>
		<actual_file>
			<filename>good</filename>
			<content>0000000000000000000000000000000000000000 cf75ecfce82fb2a8723f86b140980994f0065ecd rick technoweenie@gmail.com 1294903013 -0800	branch: Created from HEAD
cf75ecfce82fb2a8723f86b140980994f0065ecd f3c031e78b368d1b9b03c3eb1b90d8a122277e67 rick technoweenie@gmail.com 1294903038 -0800	commit: good patch
</content>
		</actual_file>
		<actual_file>
			<filename>master</filename>
			<content>0000000000000000000000000000000000000000 5da862ffd84e42b687b65605788f4158f4610400 rick technoweenie@gmail.com 1294902968 -0800	commit (initial): initial
5da862ffd84e42b687b65605788f4158f4610400 cf75ecfce82fb2a8723f86b140980994f0065ecd rick technoweenie@gmail.com 1294903011 -0800	commit: update
</content>
		</actual_file>
		<actual_file>
			<filename>bad</filename>
			<content>f252f9a68245f465d27b31fcdbf63ab55de58b06
</content>
		</actual_file>
		<actual_file>
			<filename>good</filename>
			<content>f3c031e78b368d1b9b03c3eb1b90d8a122277e67
</content>
		</actual_file>
		<actual_file>
			<filename>master</filename>
			<content>cf75ecfce82fb2a8723f86b140980994f0065ecd
</content>
		</actual_file>
	</actual_files>
</repo>
<repo>
	<id>26</id>
	<name>merb-core</name>
	<description>Merb Core: All you need. None you don't.</description>n	<owner>wycats</owner>
	<main_language>Ruby</main_language>
	<created_at>2008-01-12T05:50:53Z</created_at>
	<updated_at>2014-01-13T16:21:57Z</updated_at>
	<clone_url>https://github.com/wycats/merb-core.git</clone_url>
	<languages>
		<language>Ruby</language>
		<language>JavaScript</language>
	</languages>
	<branches>
		<branch>conditional_get</branch>
		<branch>dispatcher_fixes</branch>
		<branch>dispatcher_refactor</branch>
		<branch>djwonk/master</branch>
		<branch>experiments</branch>
		<branch>extlib</branch>
		<branch>forking_bootloader</branch>
		<branch>forking_runner</branch>
		<branch>local/yard-doc</branch>
		<branch>master</branch>
		<branch>new-sessions</branch>
		<branch>sprint</branch>
		<branch>wycats</branch>
		<branch>yard-doc</branch>
	</branches>
	<contributors>
		<contributor>michaelklishin</contributor>
		<contributor>wycats</contributor>
		<contributor>fabien</contributor>
		<contributor>ivey</contributor>
		<contributor>benburkert</contributor>
		<contributor>hassox</contributor>
		<contributor>wayneeseguin</contributor>
		<contributor>adelcambre</contributor>
		<contributor>jnicklas</contributor>
		<contributor>mtodd</contributor>
		<contributor>dudleyf</contributor>
		<contributor>wvl</contributor>
		<contributor>daikini</contributor>
		<contributor>lsegal</contributor>
		<contributor>shayarnett</contributor>
		<contributor>gabriel</contributor>
		<contributor>jackdempsey</contributor>
		<contributor>antarestrader</contributor>
		<contributor>mlangenberg</contributor>
		<contributor>wzph</contributor>
		<contributor>mholub</contributor>
		<contributor>tdreyno</contributor>
		<contributor>techbelly</contributor>
		<contributor>tohchye</contributor>
		<contributor>lancecarlson</contributor>
		<contributor>maseb</contributor>
		<contributor>technicalpickles</contributor>
		<contributor>tarvaina</contributor>
		<contributor>dsiem</contributor>
		<contributor>jherdman</contributor>
	</contributors>
	<commits>
		<commit>
			<sha>91c1bdf8617ae9a73bb3d426b64eae81e7b103d1</sha>
			<message>More deletions</message>
			<author_name>Yehuda Katz</author_name>
			<author_date>2008-10-29T20:31:08Z</author_date>
			<author_email>wycats@gmail.com</author_email>
			<committer_name>Yehuda Katz</committer_name>
			<committer_date>2008-10-29T20:31:08Z</committer_date>
			<committer_email>wycats@gmail.com</committer_email>
			<files>
				<file>
					<file_name>lib/merb-core/controller/status_codes.rb</file_name>
					<diff>@@ -1,92 +0,0 @@
-module Merb
-
-  module StatusCodes
-
-    STATUS_CODES = []
-
-    class Base
-      def self.status; nil end
-
-      class  self
-        alias :to_i :status
-        
-        def inherited(subclass)
-          STATUS_CODES  {
-            :child_class = subclass,
-            :child_name  = subclass.to_s.split('::').last,
-            :parent_name = self.to_s.split('::').last
-          }
-          # Note: Since inherited fires immediately after the subclass
-          # definition itself -- but before the definition of methods inside,
-          # we cannot set :status here.
-        end
-      end
-    end
-
-    # ===== 1xx
-    class Informational                Merb::StatusCodes::Base; end
-    class Continue                     Merb::StatusCodes::Informational; def self.status; 100 end end
-    class SwitchingProtocols           Merb::StatusCodes::Informational; def self.status; 101 end end
-
-    # ===== 2xx
-    class Successful                   Merb::StatusCodes::Base; end
-    class OK                           Merb::StatusCodes::Successful; def self.status; 200 end end
-    class Created                      Merb::StatusCodes::Successful; def self.status; 201 end end
-    class Accepted                     Merb::StatusCodes::Successful; def self.status; 202 end end
-    class NonAuthoritativeInformation  Merb::StatusCodes::Successful; def self.status; 203 end end
-    class NoContent                    Merb::StatusCodes::Successful; def self.status; 204 end end
-    class ResetContent                 Merb::StatusCodes::Successful; def self.status; 205 end end
-    class PartialContent               Merb::StatusCodes::Successful; def self.status; 206 end end
-
-    # ===== 3xx
-    class Redirection                  Merb::StatusCodes::Base; end
-    class MultipleChoices              Merb::StatusCodes::Redirection; def self.status; 300 end end
-    class MovedPermanently             Merb::StatusCodes::Redirection; def self.status; 301 end end
-    class Found                        Merb::StatusCodes::Redirection; def self.status; 302 end end # HTTP 1.1
-    class MovedTemporarily             Merb::StatusCodes::Redirection; def self.status; 302 end end # HTTP 1.0
-    class SeeOther                     Merb::StatusCodes::Redirection; def self.status; 303 end end
-    class NotModified                  Merb::StatusCodes::Redirection; def self.status; 304 end end
-    class UseProxy                     Merb::StatusCodes::Redirection; def self.status; 305 end end
-    class TemporaryRedirect            Merb::StatusCodes::Redirection; def self.status; 307 end end
-
-    # ===== 4xx
-    class ClientError                  Merb::StatusCodes::Base; end
-    class BadRequest                   Merb::StatusCodes::ClientError; def self.status; 400 end end
-    class MultiPartParseError          Merb::StatusCodes::BadRequest; end
-    class Unauthorized                 Merb::StatusCodes::ClientError; def self.status; 401 end end
-    class PaymentRequired              Merb::StatusCodes::ClientError; def self.status; 402 end end
-    class Forbidden                    Merb::StatusCodes::ClientError; def self.status; 403 end end
-    class NotFound                     Merb::StatusCodes::ClientError; def self.status; 404 end end
-    class ActionNotFound               Merb::StatusCodes::NotFound; end
-    class TemplateNotFound             Merb::StatusCodes::NotFound; end
-    class LayoutNotFound               Merb::StatusCodes::NotFound; end
-    class MethodNotAllowed             Merb::StatusCodes::ClientError; def self.status; 405 end end
-    class NotAcceptable                Merb::StatusCodes::ClientError; def self.status; 406 end end
-    class ProxyAuthenticationRequired  Merb::StatusCodes::ClientError; def self.status; 407 end end
-    class RequestTimeout               Merb::StatusCodes::ClientError; def self.status; 408 end end
-    class Conflict                     Merb::StatusCodes::ClientError; def self.status; 409 end end
-    class Gone                         Merb::StatusCodes::ClientError; def self.status; 410 end end
-    class LengthRequired               Merb::StatusCodes::ClientError; def self.status; 411 end end
-    class PreconditionFailed           Merb::StatusCodes::ClientError; def self.status; 412 end end
-    class RequestEntityTooLarge        Merb::StatusCodes::ClientError; def self.status; 413 end end
-    class RequestURITooLarge           Merb::StatusCodes::ClientError; def self.status; 414 end end
-    class UnsupportedMediaType         Merb::StatusCodes::ClientError; def self.status; 415 end end
-    class RequestRangeNotSatisfiable   Merb::StatusCodes::ClientError; def self.status; 416 end end
-    class ExpectationFailed            Merb::StatusCodes::ClientError; def self.status; 417 end end
-
-    # ===== 5xx
-    class ServerError                  Merb::StatusCodes::Base; end
-    class InternalServerError          Merb::StatusCodes::ServerError; def self.status; 500 end end
-    class NotImplemented               Merb::StatusCodes::ServerError; def self.status; 501 end end
-    class BadGateway                   Merb::StatusCodes::ServerError; def self.status; 502 end end
-    class ServiceUnavailable           Merb::StatusCodes::ServerError; def self.status; 503 end end
-    class GatewayTimeout               Merb::StatusCodes::ServerError; def self.status; 504 end end
-    class HTTPVersionNotSupported      Merb::StatusCodes::ServerError; def self.status; 505 end end
-
-    STATUS_CODES.each do |item|
-      item[:status] = item[:child_class].status
-    end
-
-  end # StatusCodes
-  
-end # Merb</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>b9fee4b1f253ff64d5afeddc020476a620452489</sha>
			<message>Notice of new location</message>
			<author_name>Yehuda Katz</author_name>
			<author_date>2008-10-29T20:28:46Z</author_date>
			<author_email>wycats@gmail.com</author_email>
			<committer_name>Yehuda Katz</committer_name>
			<committer_date>2008-10-29T20:30:01Z</committer_date>
			<committer_email>wycats@gmail.com</committer_email>
			<files>
				<file>
					<file_name>README</file_name>
					<diff>@@ -0,0 +1 @@
+merb-core and merb-more have been merged into http://github.com/wycats/merb
\ No newline at end of file</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>9191176c4c189bb793688dcce1f6075182c6ecc0</sha>
			<message>Removes merb-core</message>
			<author_name>Yehuda Katz</author_name>
			<author_date>2008-10-29T20:27:37Z</author_date>
			<author_email>wycats@gmail.com</author_email>
			<committer_name>Yehuda Katz</committer_name>
			<committer_date>2008-10-29T20:30:01Z</committer_date>
			<committer_email>wycats@gmail.com</committer_email>
			<files>
			</files>
		</commit>
		<commit>
			<sha>5078b8bf11f23b1f4e42c701438c37c6140fd93e</sha>
			<message>Fixed warning about STATUS_CODES due to 2 requires.

Signed-off-by: Michael S. Klishin michael@novemberain.com</message>
			<author_name>David James</author_name>
			<author_date>2008-10-13T01:14:07Z</author_date>
			<author_email>djwonk@collectiveinsight.net</author_email>
			<committer_name>Michael S. Klishin</committer_name>
			<committer_date>2008-10-13T02:31:06Z</committer_date>
			<committer_email>michael@novemberain.com</committer_email>
			<files>
				<file>
					<file_name>lib/merb-core/autoload.rb</file_name>
					<diff>@@ -29,7 +29,3 @@ module Merb
 module Merb
   module InlineTemplates; end
 end
-
-# StatusCodes does not autoload properly if placed with the above autoload
-# statements.  ControllerExceptions depends upon StatusCodes loading first.
-require "merb-core/controller/status_codes"</diff>
				</file>
				<file>
					<file_name>lib/merb-core/controller/status_codes.rb</file_name>
					<diff>@@ -1,5 +1,5 @@
 module Merb
-    
+
   module StatusCodes
 
     STATUS_CODES = []
@@ -82,7 +82,7 @@ class BadGateway                   Merb::StatusCodes::ServerError; def self.sta
     class ServiceUnavailable           Merb::StatusCodes::ServerError; def self.status; 503 end end
     class GatewayTimeout               Merb::StatusCodes::ServerError; def self.status; 504 end end
     class HTTPVersionNotSupported      Merb::StatusCodes::ServerError; def self.status; 505 end end
-    
+
     STATUS_CODES.each do |item|
       item[:status] = item[:child_class].status
     end</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>c122ec92e2defdddb6ed1fc6b317990696f74b45</sha>
			<message>Use pointers to frozen strings instead of creating new objects on every request (does not make sense everywhere though).</message>
			<author_name>Michael S. Klishin</author_name>
			<author_date>2008-10-13T01:09:12Z</author_date>
			<author_email>michael@novemberain.com</author_email>
			<committer_name>Michael S. Klishin</committer_name>
			<committer_date>2008-10-13T01:10:06Z</committer_date>
			<committer_email>michael@novemberain.com</committer_email>
			<files>
				<file>
					<file_name>lib/merb-core/constants.rb</file_name>
					<diff>@@ -25,9 +25,16 @@ module Const
     COOKIE_SPLIT             = /[;,] */n.freeze
     COOKIE_REGEXP            = /\s*(.+)=(.*)\s*/.freeze
     COOKIE_EXPIRED_TIME      = Time.at(0).freeze
+    XML_HTTP_REQUEST_REGEXP  = /XMLHttpRequest/i.freeze
+    TRUSTED_IP_REGEXP        = /^unknown$|^(127|10|172\.16|192\.168)\./i.freeze
     HOUR                     = 60 * 60
     DAY                      = HOUR * 24
     WEEK                     = DAY * 7
+    ON                       = "on".freeze
+    COMMA                    = ','.freeze
+    DOT                      = '.'.freeze
+    QUESTION_MARK            = '?'.freeze
+    AMPERSAND                = '&'.freeze    
     MULTIPART_REGEXP         = /\Amultipart\/form-data.*boundary=\"?([^\";,]+)/n.freeze
     HTTP_COOKIE              = 'HTTP_COOKIE'.freeze
     QUERY_STRING             = 'QUERY_STRING'.freeze
@@ -44,24 +51,47 @@ module Const
     GET                      = "GET".freeze
     POST                     = "POST".freeze
     HEAD                     = "HEAD".freeze
+    HTTP                     = "http".freeze
+    HTTPS                    = "https".freeze
+    UPCASE_HTTPS             = "HTTPS".freeze
     CONTENT_LENGTH           = "CONTENT_LENGTH".freeze
+    HTTP_ACCEPT_ENCODING     = "HTTP_ACCEPT_ENCODING".freeze
+    HTTP_ACCEPT_LANGUAGE     = "HTTP_ACCEPT_LANGUAGE".freeze
+    HTTP_ACCEPT_CHARSET      = "HTTP_ACCEPT_CHARSET".freeze
+    HTTP_CACHE_CONTROL       = "HTTP_CACHE_CONTROL".freeze    
     HTTP_X_FORWARDED_FOR     = "HTTP_X_FORWARDED_FOR".freeze
     HTTP_IF_MODIFIED_SINCE   = "HTTP_IF_MODIFIED_SINCE".freeze
+    HTTP_X_FORWARDED_HOST    = "HTTP_X_FORWARDED_HOST".freeze
+    HTTP_X_FORWARDED_PROTO   = "HTTP_X_FORWARDED_PROTO".freeze
+    HTTP_X_REQUESTED_WITH    = "HTTP_X_REQUESTED_WITH".freeze
     HTTP_IF_NONE_MATCH       = "HTTP_IF_NONE_MATCH".freeze
     HTTP_CONTENT_TYPE        = "HTTP_CONTENT_TYPE".freeze
     HTTP_CONTENT_LENGTH      = "HTTP_CONTENT_LENGTH".freeze
+    HTTP_REFERER             = "HTTP_REFERER".freeze
+    HTTP_USER_AGENT          = "HTTP_USER_AGENT".freeze
+    HTTP_CLIENT_IP           = "HTTP_CLIENT_IP".freeze
+    HTTP_CONNECTION          = "HTTP_CONNECTION".freeze
+    HTTP_VERSION             = "HTTP_VERSION".freeze
+    GATEWAY_INTERFACE        = "GATEWAY_INTERFACE".freeze
     UPLOAD_ID                = "upload_id".freeze
     PATH_INFO                = "PATH_INFO".freeze
     SCRIPT_NAME              = "SCRIPT_NAME".freeze
+    SERVER_NAME              = "SERVER_NAME".freeze
+    SERVER_PORT              = "SERVER_PORT".freeze
+    SERVER_SOFTWARE          = "SERVER_SOFTWARE".freeze
     REQUEST_URI              = "REQUEST_URI".freeze
     REQUEST_PATH             = "REQUEST_PATH".freeze
     REQUEST_METHOD           = "REQUEST_METHOD".freeze
     REMOTE_ADDR              = "REMOTE_ADDR".freeze
+    HTTP_HOST                = "HTTP_HOST".freeze
+    HTTP_ACCEPT              = "HTTP_ACCEPT".freeze
+    HTTP_KEEP_ALIVE          = "HTTP_KEEP_ALIVE".freeze
     BREAK_TAG                = "br/".freeze
     EMPTY_STRING             = "".freeze
     NEWLINE                  = "\n".freeze
     DOUBLE_NEWLINE           = "\n\n".freeze
     LOCATION                 = "Location".freeze
     TEXT_SLASH_HTML          = "text/html".freeze
+    RACK_INPUT               = 'rack.input'.freeze
   end
 end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/dispatch/request.rb</file_name>
					<diff>@@ -33,7 +33,8 @@ class Request
     # @api private
     def initialize(rack_env)
       @env  = rack_env
-      @body = rack_env['rack.input']
+      # Merb::Const::RACK_INPUT = 'rack.input'.freeze
+      @body = rack_env[Merb::Const::RACK_INPUT]
       @route_params = {}
     end
     
@@ -53,7 +54,7 @@ def controller
           "segment to route definition?\nHere is what's specified:\n" + 
           route.inspect
       end
-      path = [params[:namespace], params[:controller]].compact.join("/")
+      path = [params[:namespace], params[:controller]].compact.join(Merb::Const::SLASH)
       controller = path.snake_case.to_const_string
       
       begin
@@ -79,7 +80,8 @@ def controller
     # @api public
     def method
       @method ||= begin
-        request_method = @env['REQUEST_METHOD'].downcase.to_sym
+        # Merb::Const::REQUEST_METHOD = "REQUEST_METHOD".freeze
+        request_method = @env[Merb::Const::REQUEST_METHOD].downcase.to_sym
         case request_method
         when :get, :head, :put, :delete, :options
           request_method
@@ -91,7 +93,7 @@ def method
           m.downcase! if m
           METHODS.include?(m) ? m.to_sym : :post
         else
-          raise "Unknown REQUEST_METHOD: #{@env['REQUEST_METHOD']}"
+          raise "Unknown REQUEST_METHOD: #{@env[Merb::Const::REQUEST_METHOD]}"
         end
       end
     end
@@ -179,7 +181,7 @@ def handled?
     # 
     # @api private
     def query_params
-      @query_params ||= self.class.query_parse(query_string || '')
+      @query_params ||= self.class.query_parse(query_string || Merb::Const::EMPTY_STRING)
     end
     
     # Parameters passed in the body of the request. Ajax calls from
@@ -322,7 +324,9 @@ def raw_post
     # 
     # @api public
     def xml_http_request?
-      not /XMLHttpRequest/i.match(@env['HTTP_X_REQUESTED_WITH']).nil?
+      # Merb::Const::XML_HTTP_REQUEST_REGEXP = /XMLHttpRequest/i.freeze
+      # Merb::Const::HTTP_X_REQUESTED_WITH   = "HTTP_X_REQUESTED_WITH".freeze
+      !Merb::Const::XML_HTTP_REQUEST_REGEXP.match(@env[Merb::Const::HTTP_X_REQUESTED_WITH]).nil?
     end
     alias xhr? :xml_http_request?
     alias ajax? :xml_http_request?
@@ -332,16 +336,21 @@ def xml_http_request?
     # 
     # @api public
     def remote_ip
-      return @env['HTTP_CLIENT_IP'] if @env.include?('HTTP_CLIENT_IP')
+      # Merb::Const::HTTP_CLIENT_IP = "HTTP_CLIENT_IP".freeze
+      return @env[Merb::Const::HTTP_CLIENT_IP] if @env.include?(Merb::Const::HTTP_CLIENT_IP)
       
+      # Merb::Const::HTTP_X_FORWARDED_FOR = "HTTP_X_FORWARDED_FOR".freeze
       if @env.include?(Merb::Const::HTTP_X_FORWARDED_FOR) then
-        remote_ips = @env[Merb::Const::HTTP_X_FORWARDED_FOR].split(',').reject do |ip|
-          ip =~ /^unknown$|^(127|10|172\.16|192\.168)\./i
+        # Merb::Const::COMMA = ",".freeze
+        remote_ips = @env[Merb::Const::HTTP_X_FORWARDED_FOR].split(Merb::Const::COMMA).reject do |ip|
+          # Merb::Const::TRUSTED_IP_REGEXP = /^unknown$|^(127|10|172\.16|192\.168)\./i.freeze
+          ip =~ Merb::Const::TRUSTED_IP_REGEXP
         end
         
         return remote_ips.first.strip unless remote_ips.empty?
       end
       
+      # Merb::Const::REMOTE_ADDR = "REMOTE_ADDR".freeze
       return @env[Merb::Const::REMOTE_ADDR]
     end
     
@@ -352,7 +361,9 @@ def remote_ip
     # 
     # @api public
     def protocol
-      ssl? ? 'https' : 'http'
+      # Merb::Const::HTTP         = 'http'.freeze
+      # Merb::Const::HTTPS        = 'https'.freeze
+      ssl? ? Merb::Const::HTTPS : Merb::Const::HTTP
     end
     
     # ==== Returns
@@ -360,7 +371,11 @@ def protocol
     # 
     # @api public
     def ssl?
-      @env['HTTPS'] == 'on' || @env['HTTP_X_FORWARDED_PROTO'] == 'https'
+      # Merb::Const::ON                     = 'on'.freeze
+      # Merb::Const::HTTPS                  = 'https'.freeze
+      # Merb::Const::UPCASE_HTTPS           = 'HTTPS'.freeze
+      # Merb::Const::HTTP_X_FORWARDED_PROTO = 'HTTP_X_FORWARDED_PROTO'.freeze
+      @env[Merb::Const::UPCASE_HTTPS] == Merb::Const::ON || @env[Merb::Const::HTTP_X_FORWARDED_PROTO] == Merb::Const::HTTPS
     end
     
     # ==== Returns
@@ -368,7 +383,7 @@ def ssl?
     # 
     # @api public
     def referer
-      @env['HTTP_REFERER']
+      @env[Merb::Const::HTTP_REFERER]
     end
     
     # ==== Returns
@@ -384,7 +399,7 @@ def full_uri
     # 
     # @api public
     def uri
-      @env['REQUEST_PATH'] || @env['REQUEST_URI'] || path_info
+      @env[Merb::Const::REQUEST_PATH] || @env[Merb::Const::REQUEST_URI] || path_info
     end
     
     # ==== Returns
@@ -392,7 +407,8 @@ def uri
     # 
     # @api public
     def user_agent
-      @env['HTTP_USER_AGENT']
+      # Merb::Const::HTTP_USER_AGENT = "HTTP_USER_AGENT".freeze
+      @env[Merb::Const::HTTP_USER_AGENT]
     end
     
     # ==== Returns
@@ -400,7 +416,8 @@ def user_agent
     # 
     # @api public
     def server_name
-      @env['SERVER_NAME']
+      # Merb::Const::SERVER_NAME = "SERVER_NAME".freeze
+      @env[Merb::Const::SERVER_NAME]
     end
     
     # ==== Returns
@@ -408,7 +425,8 @@ def server_name
     # 
     # @api private
     def accept_encoding
-      @env['HTTP_ACCEPT_ENCODING']
+      # Merb::Const::HTTP_ACCEPT_ENCODING = "HTTP_ACCEPT_ENCODING".freeze
+      @env[Merb::Const::HTTP_ACCEPT_ENCODING]
     end
     
     # ==== Returns
@@ -416,7 +434,8 @@ def accept_encoding
     # 
     # @api public
     def script_name
-      @env['SCRIPT_NAME']
+      # Merb::Const::SCRIPT_NAME = "SCRIPT_NAME".freeze
+      @env[Merb::Const::SCRIPT_NAME]
     end
     
     # ==== Returns
@@ -424,7 +443,8 @@ def script_name
     # 
     # @api public
     def cache_control
-      @env['HTTP_CACHE_CONTROL']
+      # Merb::Const::HTTP_CACHE_CONTROL = "HTTP_CACHE_CONTROL".freeze
+      @env[Merb::Const::HTTP_CACHE_CONTROL]
     end
     
     # ==== Returns
@@ -432,7 +452,8 @@ def cache_control
     # 
     # @api public
     def accept_language
-      @env['HTTP_ACCEPT_LANGUAGE']
+      # Merb::Const::HTTP_ACCEPT_LANGUAGE = "HTTP_ACCEPT_LANGUAGE".freeze
+      @env[Merb::Const::HTTP_ACCEPT_LANGUAGE]
     end
     
     # ==== Returns
@@ -440,7 +461,8 @@ def accept_language
     # 
     # @api public
     def server_software
-      @env['SERVER_SOFTWARE']
+      # Merb::Const::SERVER_SOFTWARE = "SERVER_SOFTWARE".freeze
+      @env[Merb::Const::SERVER_SOFTWARE]
     end
     
     # ==== Returns
@@ -448,7 +470,7 @@ def server_software
     # 
     # @api public
     def keep_alive
-      @env['HTTP_KEEP_ALIVE']
+      @env[Merb::Const::HTTP_KEEP_ALIVE]
     end
     
     # ==== Returns
@@ -456,7 +478,7 @@ def keep_alive
     # 
     # @api public
     def accept_charset
-      @env['HTTP_ACCEPT_CHARSET']
+      @env[Merb::Const::HTTP_ACCEPT_CHARSET]
     end
     
     # ==== Returns
@@ -464,7 +486,7 @@ def accept_charset
     # 
     # @api private
     def version
-      @env['HTTP_VERSION']
+      @env[Merb::Const::HTTP_VERSION]
     end
     
     # ==== Returns
@@ -472,7 +494,7 @@ def version
     # 
     # @api public
     def gateway
-      @env['GATEWAY_INTERFACE']
+      @env[Merb::Const::GATEWAY_INTERFACE]
     end
     
     # ==== Returns
@@ -480,7 +502,7 @@ def gateway
     # 
     # @api private
     def accept
-      @env['HTTP_ACCEPT'].blank? ? "*/*" : @env['HTTP_ACCEPT']
+      @env[Merb::Const::HTTP_ACCEPT].blank? ? "*/*" : @env[Merb::Const::HTTP_ACCEPT]
     end
     
     # ==== Returns
@@ -488,7 +510,7 @@ def accept
     # 
     # @api private
     def connection
-      @env['HTTP_CONNECTION']
+      @env[Merb::Const::HTTP_CONNECTION]
     end
     
     # ==== Returns
@@ -496,7 +518,7 @@ def connection
     # 
     # @api private
     def query_string
-      @env['QUERY_STRING']  
+      @env[Merb::Const::QUERY_STRING]  
     end
     
     # ==== Returns
@@ -504,7 +526,7 @@ def query_string
     # 
     # @api private
     def content_type
-      @env['CONTENT_TYPE']
+      @env[Merb::Const::UPCASE_CONTENT_TYPE]
     end
     
     # ==== Returns
@@ -522,7 +544,7 @@ def content_length
     # 
     # @api public
     def path
-      path = (uri.empty? ? '/' : uri.split('?').first).squeeze("/")
+      path = (uri.empty? ? Merb::Const::SLASH : uri.split(Merb::Const::QUESTION_MARK).first).squeeze(Merb::Const::SLASH)
       path = path[0..-2] if (path[-1] == ?/) && path.size  1
       path
     end
@@ -532,7 +554,7 @@ def path
     # 
     # @api public
     def path_info
-      @path_info ||= self.class.unescape(@env['PATH_INFO'])
+      @path_info ||= self.class.unescape(@env[Merb::Const::PATH_INFO])
     end
     
     # ==== Returns
@@ -540,7 +562,7 @@ def path_info
     # 
     # @api public
     def port
-      @env['SERVER_PORT'].to_i
+      @env[Merb::Const::SERVER_PORT].to_i
     end
     
     # ==== Returns
@@ -548,7 +570,7 @@ def port
     # 
     # @api public
     def host
-      @env['HTTP_X_FORWARDED_HOST'] || @env['HTTP_HOST'] 
+      @env[Merb::Const::HTTP_X_FORWARDED_HOST] || @env[Merb::Const::HTTP_HOST] 
     end
     
     # ==== Parameters
@@ -561,7 +583,7 @@ def host
     # 
     # @api public
     def subdomains(tld_length = 1)
-      parts = host.split('.')
+      parts = host.split(Merb::Const::DOT)
       parts[0..-(tld_length+2)]
     end
     
@@ -575,7 +597,7 @@ def subdomains(tld_length = 1)
     # 
     # @api public
     def domain(tld_length = 1)
-      host.split('.').last(1 + tld_length).join('.').sub(/:\d+$/,'')
+      host.split(Merb::Const::DOT).last(1 + tld_length).join(Merb::Const::DOT).sub(/:\d+$/, Merb::Const::EMPTY_STRING)
     end
     
     # ==== Returns</diff>
				</file>
				<file>
					<file_name>lib/merb-core/rack/handler/mongrel.rb</file_name>
					<diff>@@ -34,7 +34,7 @@ class Mongrel  ::Mongrel::HttpHandler
         def self.run(app, options={})
           @server = ::Mongrel::HttpServer.new(options[:Host] || '0.0.0.0',
                                              options[:Port] || 8080)
-          @server.register('/', ::Merb::Rack::Handler::Mongrel.new(app))
+          @server.register(Merb::Const::SLASH, ::Merb::Rack::Handler::Mongrel.new(app))
           yield @server  if block_given?
           @server.run.join
         end
@@ -60,16 +60,17 @@ def process(request, response)
           env[Merb::Const::SCRIPT_NAME] = Merb::Const::EMPTY_STRING if env[Merb::Const::SCRIPT_NAME] == Merb::Const::SLASH
   
           env.update({"rack.version" = [0,1],
-                       "rack.input" = request.body || StringIO.new(""),
+                       Merb::Const::RACK_INPUT = request.body || StringIO.new(""),
                        "rack.errors" = STDERR,
   
                        "rack.multithread" = true,
                        "rack.multiprocess" = false, # ???
                        "rack.run_once" = false,
-  
-                       "rack.url_scheme" = "http"
+                        
+                       # Merb::Const::HTTP = "http".freeze
+                       "rack.url_scheme" = Merb::Const::HTTP
                      })
-          env[Merb::Const::QUERY_STRING] ||= ""
+          env[Merb::Const::QUERY_STRING] ||= Merb::Const::EMPTY_STRING
           env.delete Merb::Const::PATH_INFO  if env[Merb::Const::PATH_INFO] == Merb::Const::EMPTY_STRING
   
           status, headers, body = @app.call(env)</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>72f7c7ef3a2ce6a0a0f409b2092e64da7d0795cf</sha>
			<message>Added Merb::Router.extensions as an official API.

Merb::Router.extensions is now the official way to add functionality
to the router.</message>
			<author_name>Carl Lerche</author_name>
			<author_date>2008-10-12T23:15:22Z</author_date>
			<author_email>carllerche@mac.com</author_email>
			<committer_name>Carl Lerche</committer_name>
			<committer_date>2008-10-12T23:22:08Z</committer_date>
			<committer_email>carllerche@mac.com</committer_email>
			<files>
				<file>
					<file_name>lib/merb-core/dispatch/router.rb</file_name>
					<diff>@@ -236,8 +236,40 @@ def resource(*args)
         route.generate(params, defaults)
       end
       
-      private
-      
+      # Add functionality to the router. This can be in the form of
+      # including a new module or directly defining new methods.
+      #
+      # ==== Parameters
+      # &blockBlock::
+      #   A block of code used to extend the route builder with. This
+      #   can be including a module or directly defining some new methods
+      #   that should be available to building routes.
+      #
+      # ==== Example
+      # Merb::Router.extensions do
+      #   def domain(name, domain, options={}, &block)
+      #     match(:domain = domain).namespace(name, :path = nil, &block)
+      #   end
+      # end
+      #
+      # In this case, a method 'domain' will be available to the route builder
+      # which will create namespaces around domains instead of path prefixes.
+      #
+      # This can then be used as follows.
+      #
+      # Merb::Router.prepare do
+      #   domain(:admin, "my-admin.com") do
+      #     # ... routes come here ...
+      #   end
+      # end
+      # ---
+      # @api public
+      def extensions(&block)
+        Router::Behavior.class_eval(&block)
+      end
+
+    private
+    
       # Compiles the routes and creates the +match+ method.
       # 
       # @api private</diff>
				</file>
				<file>
					<file_name>lib/merb-core/dispatch/router/resources.rb</file_name>
					<diff>@@ -272,11 +272,7 @@ def resource_block(builders, &block)
       end
 
     end # Resources
-    
-    class Behavior
-      include Resources
-    end
-    
+
     # Adding the collection and member methods to behavior
     class ResourceBehavior  Behavior #:nodoc:
       
@@ -301,5 +297,9 @@ def member(action, options = {})
       end
       
     end
+    
+    class Behavior
+      include Resources
+    end
   end
 end
\ No newline at end of file</diff>
				</file>
				<file>
					<file_name>spec/public/router/router_spec.rb</file_name>
					<diff>@@ -145,7 +145,7 @@
     end
     
     it "should not be able to match routes anymore" do
-      lambda { route_for("/users") }
+      lambda { route_for("/users") }.should raise_error(Merb::Router::NotCompiledError)
     end
     
   end
@@ -157,5 +157,21 @@
     end
 
   end
+  
+  describe "#extensions" do
+    it "should be able to extend the router" do
+      Merb::Router.extensions do
+        def hello_world
+          match("/hello").to(:controller = "world")
+        end
+      end
+      
+      Merb::Router.prepare do
+        hello_world
+      end
+      
+      route_for("/hello").should have_route(:controller = "world")
+    end
+  end
 
 end
\ No newline at end of file</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>209ca502a6e44f3115042f90b90caec6f82580ed</sha>
			<message>Fixes a minor problem with has_tag/with_tag.</message>
			<author_name>Michael S. Klishin</author_name>
			<author_date>2008-10-12T18:24:36Z</author_date>
			<author_email>michael@novemberain.com</author_email>
			<committer_name>Michael S. Klishin</committer_name>
			<committer_date>2008-10-12T18:24:36Z</committer_date>
			<committer_email>michael@novemberain.com</committer_email>
			<files>
				<file>
					<file_name>lib/merb-core/test/matchers/view_matchers.rb</file_name>
					<diff>@@ -278,6 +278,8 @@ def attributes_for_error
     def with_tag(name, attrs={})
       @inner_has_tag = HasTag.new(name, attrs)
       @inner_has_tag.outer_has_tag = self
+      
+      @inner_has_tag
     end
   end
 </diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>11d19c269a029403039b16866aaa8d6bb1a366ff</sha>
			<message>Use frozen constants on the 'hot path' if possible.</message>
			<author_name>Michael S. Klishin</author_name>
			<author_date>2008-10-12T16:23:39Z</author_date>
			<author_email>michael@novemberain.com</author_email>
			<committer_name>Michael S. Klishin</committer_name>
			<committer_date>2008-10-12T16:23:39Z</committer_date>
			<committer_email>michael@novemberain.com</committer_email>
			<files>
				<file>
					<file_name>lib/merb-core/constants.rb</file_name>
					<diff>@@ -48,16 +48,20 @@ module Const
     HTTP_X_FORWARDED_FOR     = "HTTP_X_FORWARDED_FOR".freeze
     HTTP_IF_MODIFIED_SINCE   = "HTTP_IF_MODIFIED_SINCE".freeze
     HTTP_IF_NONE_MATCH       = "HTTP_IF_NONE_MATCH".freeze
+    HTTP_CONTENT_TYPE        = "HTTP_CONTENT_TYPE".freeze
+    HTTP_CONTENT_LENGTH      = "HTTP_CONTENT_LENGTH".freeze
     UPLOAD_ID                = "upload_id".freeze
     PATH_INFO                = "PATH_INFO".freeze
     SCRIPT_NAME              = "SCRIPT_NAME".freeze
     REQUEST_URI              = "REQUEST_URI".freeze
     REQUEST_PATH             = "REQUEST_PATH".freeze
+    REQUEST_METHOD           = "REQUEST_METHOD".freeze
     REMOTE_ADDR              = "REMOTE_ADDR".freeze
     BREAK_TAG                = "br/".freeze
     EMPTY_STRING             = "".freeze
     NEWLINE                  = "\n".freeze
     DOUBLE_NEWLINE           = "\n\n".freeze
     LOCATION                 = "Location".freeze
+    TEXT_SLASH_HTML          = "text/html".freeze
   end
 end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/rack/application.rb</file_name>
					<diff>@@ -16,7 +16,7 @@ def call(env)
         begin
           rack_response = ::Merb::Dispatcher.handle(Merb::Request.new(env))
         rescue Object = e
-          return [500, {Merb::Const::CONTENT_TYPE = "text/html"}, e.message + Merb::Const::BREAK_TAG + e.backtrace.join(Merb::Const::BREAK_TAG)]
+          return [500, {Merb::Const::CONTENT_TYPE = Merb::Const::TEXT_SLASH_HTML}, e.message + Merb::Const::BREAK_TAG + e.backtrace.join(Merb::Const::BREAK_TAG)]
         end
         Merb.logger.info Merb::Const::DOUBLE_NEWLINE
         Merb.logger.flush</diff>
				</file>
				<file>
					<file_name>lib/merb-core/rack/handler/mongrel.rb</file_name>
					<diff>@@ -54,10 +54,10 @@ def initialize(app)
         # responseHTTPResponse:: The response object to write response to.
         def process(request, response)
           env = {}.replace(request.params)
-          env.delete "HTTP_CONTENT_TYPE"
-          env.delete "HTTP_CONTENT_LENGTH"
+          env.delete Merb::Const::HTTP_CONTENT_TYPE
+          env.delete Merb::Const::HTTP_CONTENT_LENGTH
   
-          env["SCRIPT_NAME"] = ""  if env["SCRIPT_NAME"] == "/"
+          env[Merb::Const::SCRIPT_NAME] = Merb::Const::EMPTY_STRING if env[Merb::Const::SCRIPT_NAME] == Merb::Const::SLASH
   
           env.update({"rack.version" = [0,1],
                        "rack.input" = request.body || StringIO.new(""),
@@ -69,8 +69,8 @@ def process(request, response)
   
                        "rack.url_scheme" = "http"
                      })
-          env["QUERY_STRING"] ||= ""
-          env.delete "PATH_INFO"  if env["PATH_INFO"] == ""
+          env[Merb::Const::QUERY_STRING] ||= ""
+          env.delete Merb::Const::PATH_INFO  if env[Merb::Const::PATH_INFO] == Merb::Const::EMPTY_STRING
   
           status, headers, body = @app.call(env)
   
@@ -93,4 +93,4 @@ def process(request, response)
       end
     end
   end
-end
\ No newline at end of file
+end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/rack/middleware/conditional_get.rb</file_name>
					<diff>@@ -7,7 +7,7 @@ def call(env)
 
         if document_not_modified?(env, headers)
           status = 304
-          body = ""
+          body = Merb::Const::EMPTY_STRING
           # set Date header using RFC1123 date format as specified by HTTP
           # RFC2616 section 3.3.1.
         end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/rack/middleware/path_prefix.rb</file_name>
					<diff>@@ -20,12 +20,12 @@ def call(env)
       def strip_path_prefix(env)
         ['PATH_INFO', 'REQUEST_URI'].each do |path_key|
           if env[path_key] =~ @path_prefix
-            env[path_key].sub!(@path_prefix, '')
-            env[path_key] = '/' if env[path_key].empty?
+            env[path_key].sub!(@path_prefix, Merb::Const::EMPTY_STRING)
+            env[path_key] = Merb::Const::SLASH if env[path_key].empty?
           end
         end
       end
       
     end
   end
-end
\ No newline at end of file
+end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/rack/middleware/static.rb</file_name>
					<diff>@@ -8,16 +8,20 @@ def initialize(app,directory)
       end
       
       def call(env)        
-        path = env['PATH_INFO'] ? env['PATH_INFO'].chomp('/') : ""
+        path = if env[Merb::Const::PATH_INFO]
+                 env[Merb::Const::PATH_INFO].chomp(Merb::Const::SLASH)
+               else
+                 Merb::Const::EMPTY_STRING
+               end
         cached_path = (path.empty? ? 'index' : path) + '.html'
         
-        if file_exist?(path) && env['REQUEST_METHOD'] =~ /GET|HEAD/ # Serve the file if it's there and the request method is GET or HEAD
+        if file_exist?(path) && env[Merb::Const::REQUEST_METHOD] =~ /GET|HEAD/ # Serve the file if it's there and the request method is GET or HEAD
           serve_static(env)
-        elsif file_exist?(cached_path) && env['REQUEST_METHOD'] =~ /GET|HEAD/ # Serve the page cache if it's there and the request method is GET or HEAD
-          env['PATH_INFO'] = cached_path
+        elsif file_exist?(cached_path) && env[Merb::Const::REQUEST_METHOD] =~ /GET|HEAD/ # Serve the page cache if it's there and the request method is GET or HEAD
+          env[Merb::Const::PATH_INFO] = cached_path
           serve_static(env)
         elsif path =~ /favicon\.ico/
-          return [404, {"Content-Type"="text/html"}, "404 Not Found."]
+          return [404, { Merb::Const::CONTENT_TYPE = Merb::Const::TEXT_SLASH_HTML }, "404 Not Found."]
         else
           @app.call(env)
         end
@@ -36,10 +40,10 @@ def file_exist?(path)
         # ==== Parameters
         # envHash:: Environment variables to pass on to the server.
         def serve_static(env)
-          env["PATH_INFO"] = ::Merb::Request.unescape(env["PATH_INFO"])        
+          env[Merb::Const::PATH_INFO] = ::Merb::Request.unescape(env[Merb::Const::PATH_INFO])
           @static_server.call(env)
         end
       
     end
   end
-end
\ No newline at end of file
+end</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>ee43bd5f870bb9ad822bdade58cd970fc088b975</sha>
			<message>Resolved conflict, added a note on metaprogramming use in -core. Sometimes it is appropriate.</message>
			<author_name>Michael S. Klishin</author_name>
			<author_date>2008-10-12T15:36:59Z</author_date>
			<author_email>michael@novemberain.com</author_email>
			<committer_name>Michael S. Klishin</committer_name>
			<committer_date>2008-10-12T15:36:59Z</committer_date>
			<committer_email>michael@novemberain.com</committer_email>
			<files>
				<file>
					<file_name>lib/merb-core/autoload.rb</file_name>
					<diff>@@ -29,3 +29,7 @@ module Merb
 module Merb
   module InlineTemplates; end
 end
+
+# StatusCodes does not autoload properly if placed with the above autoload
+# statements.  ControllerExceptions depends upon StatusCodes loading first.
+require "merb-core/controller/status_codes"</diff>
				</file>
				<file>
					<file_name>lib/merb-core/controller/exceptions.rb</file_name>
					<diff>@@ -1,3 +1,7 @@
+# We need to guarantee that status_codes.rb loads first because
+# we are going to borrow the StatusCodes from it.
+require File.join(File.dirname(__FILE__), 'status_codes')
+
 class Exception
   # Returns the action_name that will be invoked on your Exceptions controller when this
   # exception is raised. Override this method to force a different action to be invoked.
@@ -8,7 +12,7 @@ class Exception
   # 
   # @api public
   # @overridable
-  def action_name() self.class.action_name end
+  def action_name; self.class.action_name end
   
   
   # ==== Returns
@@ -54,6 +58,7 @@ def self.status
 end
 
 module Merb
+  
   # ControllerExceptions are a way of simplifying controller code by placing
   # exception logic back into the MVC pattern.
   #
@@ -62,9 +67,8 @@ module Merb
   # the error in a friendly manor.
   #
   # For example you might have an action in your app that raises NotFound
-  # if a resource was not available
+  # if a resource was not available:
   #
-
   #   def show
   #     product = Product.find(params[:id])
   #     raise NotFound if product.nil?
@@ -75,7 +79,6 @@ module Merb
   # Exceptions controller which might look something like:
   #
   # class Exceptions  Application
-
   #   def not_found
   #     render :layout = :none
   #   end
@@ -88,26 +91,25 @@ module Merb
   # with them which is sent to the browser when the action is rendered.
   #
   # Note: If you do not specifiy how to handle raised ControllerExceptions 
-  # or an unhandlable exception occurs within your customised exception action
+  # or an unhandlable exception occurs within your customized exception action
   # then they will be rendered using the built-in error template.
   # In development mode this "built in" template will show stack-traces for
   # any of the ServerError family of exceptions (you can force the stack-trace
-  # to display in production mode using the :exception_details config option in 
-  # merb.yml)
+  # to display in production mode using the :exception_details config option
+  # in merb.yml)
   #
   #
   # ==== Internal Exceptions 
   #
   # Any other rogue errors (not ControllerExceptions) that occur during the 
   # execution of your app will be converted into the ControllerException 
-  # InternalServerError. And like all other exceptions, the ControllerExceptions  
-  # can be caught on your Exceptions controller.
+  # InternalServerError. And like all other exceptions, the
+  # ControllerExceptions can be caught on your Exceptions controller.
   #
   # InternalServerErrors return status 500, a common use for customizing this
   # action might be to send emails to the development team, warning that their
   # application has exploded. Mock example:
   #
-
   #   def internal_server_error
   #     MySpecialMailer.deliver(
   #       "team@cowboys.com", 
@@ -133,7 +135,6 @@ module Merb
   # Add the required action to our Exceptions controller
   #
   #   class Exceptions  Application
-
   #     def admin_access_required
   #       render
   #     end
@@ -158,181 +159,34 @@ def status; self.class.status; end
       alias :to_i :status
 
       class  self
-
-        # Get the actual status-code for an Exception class.
-        #
-        # As usual, this can come from a constant upwards in
-        # the inheritance chain.
-        #
-        # ==== Returns
-        # Fixnum:: The status code of this exception.
-        #
-        # @api public
-        def status
-          const_get(:STATUS) rescue 0
-        end
         alias :to_i :status
-        
-        # Set the actual status-code for an Exception class.
-        #
-        # If possible, set the STATUS constant, and update
-        # any previously registered (inherited) status-code.
-        #
-        # ==== Parameters
-        # num~to_i:: The status code
-        #
-        # ==== Returns
-        # (Integer, nil):: The status set on this exception, or nil if a status was already set.
-        #
-        # @api private
-        def status=(num)
-          unless self.status?
-            register_status_code(self, num)
-            self.const_set(:STATUS, num.to_i)
-          end
-        end
-      
-        # See if a status-code has been defined (on self explicitly).
-        #
-        # ==== Returns
-        # Boolean:: Whether a status code has been set
-        #
-        # @api private
-        def status?
-          self.const_defined?(:STATUS)
-        end
-      
-        # Registers any subclasses with status codes for easy lookup by
-        # set_status in Merb::Controller.
-        #
-        # Inheritance ensures this method gets inherited by any subclasses, so
-        # it goes all the way down the chain of inheritance.
-        #
-        # ==== Parameters
-        # 
-        # subclassMerb::ControllerExceptions::Base::
-        #   The Exception class that is inheriting from Merb::ControllerExceptions::Base
-        #
-        # @api public
-        def inherited(subclass)
-          # don't set the constant yet - any class methods will be called after self.inherited
-          # unless self.status = ... is set explicitly, the status code will be inherited
-          register_status_code(subclass, self.status) if self.status?
-        end
-        
-        private
-        
-        # Register the status-code for an Exception class.
-        #
-        # ==== Parameters
-        # num~to_i:: The status code
-        #
-        # @api privaate
-        def register_status_code(klass, code)
-          name = self.to_s.split('::').last.snake_case
-          STATUS_CODES[name.to_sym] = code.to_i
-        end
-        
       end
     end
 
-    class Informational                  Merb::ControllerExceptions::Base; end
-
-      class Continue                     Merb::ControllerExceptions::Informational; self.status = 100; end
-
-      class SwitchingProtocols           Merb::ControllerExceptions::Informational; self.status = 101; end
-
-    class Successful                     Merb::ControllerExceptions::Base; end
-
-      class OK                           Merb::ControllerExceptions::Successful; self.status = 200; end
-
-      class Created                      Merb::ControllerExceptions::Successful; self.status = 201; end
-
-      class Accepted                     Merb::ControllerExceptions::Successful; self.status = 202; end
-
-      class NonAuthoritativeInformation  Merb::ControllerExceptions::Successful; self.status = 203; end
-
-      class NoContent                    Merb::ControllerExceptions::Successful; self.status = 204; end
-
-      class ResetContent                 Merb::ControllerExceptions::Successful; self.status = 205; end
-
-      class PartialContent               Merb::ControllerExceptions::Successful; self.status = 206; end
-
-    class Redirection                    Merb::ControllerExceptions::Base; end
-
-      class MultipleChoices              Merb::ControllerExceptions::Redirection; self.status = 300; end
-
-      class MovedPermanently             Merb::ControllerExceptions::Redirection; self.status = 301; end
-
-      class MovedTemporarily             Merb::ControllerExceptions::Redirection; self.status = 302; end
-
-      class SeeOther                     Merb::ControllerExceptions::Redirection; self.status = 303; end
-
-      class NotModified                  Merb::ControllerExceptions::Redirection; self.status = 304; end
-
-      class UseProxy                     Merb::ControllerExceptions::Redirection; self.status = 305; end
-
-      class TemporaryRedirect            Merb::ControllerExceptions::Redirection; self.status = 307; end
-
-    class ClientError                    Merb::ControllerExceptions::Base; end
-
-      class BadRequest                   Merb::ControllerExceptions::ClientError; self.status = 400; end
-
-      class MultiPartParseError          Merb::ControllerExceptions::BadRequest; end
-
-      class Unauthorized                 Merb::ControllerExceptions::ClientError; self.status = 401; end
-
-      class PaymentRequired              Merb::ControllerExceptions::ClientError; self.status = 402; end
-
-      class Forbidden                    Merb::ControllerExceptions::ClientError; self.status = 403; end
-
-      class NotFound                     Merb::ControllerExceptions::ClientError; self.status = 404; end
-
-      class ActionNotFound               Merb::ControllerExceptions::NotFound; end
-
-      class TemplateNotFound             Merb::ControllerExceptions::NotFound; end
-
-      class LayoutNotFound               Merb::ControllerExceptions::NotFound; end
-
-      class MethodNotAllowed             Merb::ControllerExceptions::ClientError; self.status = 405; end
-
-      class NotAcceptable                Merb::ControllerExceptions::ClientError; self.status = 406; end
-
-      class ProxyAuthenticationRequired  Merb::ControllerExceptions::ClientError; self.status = 407; end
-
-      class RequestTimeout               Merb::ControllerExceptions::ClientError; self.status = 408; end
-
-      class Conflict                     Merb::ControllerExceptions::ClientError; self.status = 409; end
-
-      class Gone                         Merb::ControllerExceptions::ClientError; self.status = 410; end
-
-      class LengthRequired               Merb::ControllerExceptions::ClientError; self.status = 411; end
-
-      class PreconditionFailed           Merb::ControllerExceptions::ClientError; self.status = 412; end
-
-      class RequestEntityTooLarge        Merb::ControllerExceptions::ClientError; self.status = 413; end
-
-      class RequestURITooLarge           Merb::ControllerExceptions::ClientError; self.status = 414; end
-
-      class UnsupportedMediaType         Merb::ControllerExceptions::ClientError; self.status = 415; end
-
-      class RequestRangeNotSatisfiable   Merb::ControllerExceptions::ClientError; self.status = 416; end
-
-      class ExpectationFailed            Merb::ControllerExceptions::ClientError; self.status = 417; end
-
-    class ServerError                    Merb::ControllerExceptions::Base; end
-
-      class InternalServerError          Merb::ControllerExceptions::ServerError; self.status = 500; end
-
-      class NotImplemented               Merb::ControllerExceptions::ServerError; self.status = 501; end
-
-      class BadGateway                   Merb::ControllerExceptions::ServerError; self.status = 502; end
-
-      class ServiceUnavailable           Merb::ControllerExceptions::ServerError; self.status = 503; end
-
-      class GatewayTimeout               Merb::ControllerExceptions::ServerError; self.status = 504; end
+    # This looks not very readable at first glance,
+    # but what you really want to see is status_codes.rb
+    # next to this file.
+    #
+    # It lists controller exceptions / status codes
+    # used by Merb. This code is executed once on
+    # boot so don't worry *too* much about
+    # this and Merb's philosophy of mostly staying away
+    # from "cool" tricks one can do in Ruby.
+    Merb::StatusCodes::STATUS_CODES.each do |x|
+      if x[:status]
+        assign_constant = "STATUS_CODES[:#{x[:child_name].snake_case}] = #{x[:status]}"
+        define_status_method = "def self.status; #{x[:status]} end"
+      else
+        assign_constant, define_status_method = "", ""
+      end
+      self.class_eval -RUBY, __FILE__, __LINE__ + 1
+        #{assign_constant}
+        class #{x[:child_name]}  #{x[:parent_name]}
+          #{define_status_method}
+        end
+      RUBY
+    end
 
-      class HTTPVersionNotSupported      Merb::ControllerExceptions::ServerError; self.status = 505; end
   end
   
   # Required to show exceptions in the log file</diff>
				</file>
				<file>
					<file_name>lib/merb-core/controller/status_codes.rb</file_name>
					<diff>@@ -0,0 +1,92 @@
+module Merb
+    
+  module StatusCodes
+
+    STATUS_CODES = []
+
+    class Base
+      def self.status; nil end
+
+      class  self
+        alias :to_i :status
+        
+        def inherited(subclass)
+          STATUS_CODES  {
+            :child_class = subclass,
+            :child_name  = subclass.to_s.split('::').last,
+            :parent_name = self.to_s.split('::').last
+          }
+          # Note: Since inherited fires immediately after the subclass
+          # definition itself -- but before the definition of methods inside,
+          # we cannot set :status here.
+        end
+      end
+    end
+
+    # ===== 1xx
+    class Informational                Merb::StatusCodes::Base; end
+    class Continue                     Merb::StatusCodes::Informational; def self.status; 100 end end
+    class SwitchingProtocols           Merb::StatusCodes::Informational; def self.status; 101 end end
+
+    # ===== 2xx
+    class Successful                   Merb::StatusCodes::Base; end
+    class OK                           Merb::StatusCodes::Successful; def self.status; 200 end end
+    class Created                      Merb::StatusCodes::Successful; def self.status; 201 end end
+    class Accepted                     Merb::StatusCodes::Successful; def self.status; 202 end end
+    class NonAuthoritativeInformation  Merb::StatusCodes::Successful; def self.status; 203 end end
+    class NoContent                    Merb::StatusCodes::Successful; def self.status; 204 end end
+    class ResetContent                 Merb::StatusCodes::Successful; def self.status; 205 end end
+    class PartialContent               Merb::StatusCodes::Successful; def self.status; 206 end end
+
+    # ===== 3xx
+    class Redirection                  Merb::StatusCodes::Base; end
+    class MultipleChoices              Merb::StatusCodes::Redirection; def self.status; 300 end end
+    class MovedPermanently             Merb::StatusCodes::Redirection; def self.status; 301 end end
+    class Found                        Merb::StatusCodes::Redirection; def self.status; 302 end end # HTTP 1.1
+    class MovedTemporarily             Merb::StatusCodes::Redirection; def self.status; 302 end end # HTTP 1.0
+    class SeeOther                     Merb::StatusCodes::Redirection; def self.status; 303 end end
+    class NotModified                  Merb::StatusCodes::Redirection; def self.status; 304 end end
+    class UseProxy                     Merb::StatusCodes::Redirection; def self.status; 305 end end
+    class TemporaryRedirect            Merb::StatusCodes::Redirection; def self.status; 307 end end
+
+    # ===== 4xx
+    class ClientError                  Merb::StatusCodes::Base; end
+    class BadRequest                   Merb::StatusCodes::ClientError; def self.status; 400 end end
+    class MultiPartParseError          Merb::StatusCodes::BadRequest; end
+    class Unauthorized                 Merb::StatusCodes::ClientError; def self.status; 401 end end
+    class PaymentRequired              Merb::StatusCodes::ClientError; def self.status; 402 end end
+    class Forbidden                    Merb::StatusCodes::ClientError; def self.status; 403 end end
+    class NotFound                     Merb::StatusCodes::ClientError; def self.status; 404 end end
+    class ActionNotFound               Merb::StatusCodes::NotFound; end
+    class TemplateNotFound             Merb::StatusCodes::NotFound; end
+    class LayoutNotFound               Merb::StatusCodes::NotFound; end
+    class MethodNotAllowed             Merb::StatusCodes::ClientError; def self.status; 405 end end
+    class NotAcceptable                Merb::StatusCodes::ClientError; def self.status; 406 end end
+    class ProxyAuthenticationRequired  Merb::StatusCodes::ClientError; def self.status; 407 end end
+    class RequestTimeout               Merb::StatusCodes::ClientError; def self.status; 408 end end
+    class Conflict                     Merb::StatusCodes::ClientError; def self.status; 409 end end
+    class Gone                         Merb::StatusCodes::ClientError; def self.status; 410 end end
+    class LengthRequired               Merb::StatusCodes::ClientError; def self.status; 411 end end
+    class PreconditionFailed           Merb::StatusCodes::ClientError; def self.status; 412 end end
+    class RequestEntityTooLarge        Merb::StatusCodes::ClientError; def self.status; 413 end end
+    class RequestURITooLarge           Merb::StatusCodes::ClientError; def self.status; 414 end end
+    class UnsupportedMediaType         Merb::StatusCodes::ClientError; def self.status; 415 end end
+    class RequestRangeNotSatisfiable   Merb::StatusCodes::ClientError; def self.status; 416 end end
+    class ExpectationFailed            Merb::StatusCodes::ClientError; def self.status; 417 end end
+
+    # ===== 5xx
+    class ServerError                  Merb::StatusCodes::Base; end
+    class InternalServerError          Merb::StatusCodes::ServerError; def self.status; 500 end end
+    class NotImplemented               Merb::StatusCodes::ServerError; def self.status; 501 end end
+    class BadGateway                   Merb::StatusCodes::ServerError; def self.status; 502 end end
+    class ServiceUnavailable           Merb::StatusCodes::ServerError; def self.status; 503 end end
+    class GatewayTimeout               Merb::StatusCodes::ServerError; def self.status; 504 end end
+    class HTTPVersionNotSupported      Merb::StatusCodes::ServerError; def self.status; 505 end end
+    
+    STATUS_CODES.each do |item|
+      item[:status] = item[:child_class].status
+    end
+
+  end # StatusCodes
+  
+end # Merb</diff>
				</file>
				<file>
					<file_name>spec/public/rack/csrf_middleware_spec.rb</file_name>
					<diff>@@ -54,7 +54,7 @@ def create
     env = Rack::MockRequest.env_for('/users/new')
     status, header, body = @middleware.call(env)
     body.should have_tag(:form, :action = '/users')
-      body.should have_tag(:input, :type = 'hidden', :id = 'csrf_authentication_token')
+    body.should have_tag(:input, :type = 'hidden', :id = 'csrf_authentication_token')
   end
 
   it "should not do anything if there is no form found in the response" do</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>36c7538548f8b511c23a8e75600217edc9fd039b</sha>
			<message>Correct documentation of session_expiry option.</message>
			<author_name>Michael S. Klishin</author_name>
			<author_date>2008-10-12T14:48:15Z</author_date>
			<author_email>michael@novemberain.com</author_email>
			<committer_name>Michael S. Klishin</committer_name>
			<committer_date>2008-10-12T14:48:15Z</committer_date>
			<committer_email>michael@novemberain.com</committer_email>
			<files>
				<file>
					<file_name>lib/merb-core/dispatch/session.rb</file_name>
					<diff>@@ -32,7 +32,7 @@ def self.session_stores
   #                           retrieved; defaults to _session_id
   #
   # :session_expiry           When to expire the session cookie;
-  #                           defaults to 2 weeks
+  #                           by defaults session expires when browser quits.
   #
   # :session_secret_key       A secret string which is used to sign/validate
   #                           session data; min. 16 chars</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>afa48c563f5faf06227e1b6b1b73f7638cfe960c</sha>
			<message>Use frozen constants on the hot path where possible.</message>
			<author_name>Michael S. Klishin</author_name>
			<author_date>2008-10-12T14:45:11Z</author_date>
			<author_email>michael@novemberain.com</author_email>
			<committer_name>Michael S. Klishin</committer_name>
			<committer_date>2008-10-12T14:45:54Z</committer_date>
			<committer_email>michael@novemberain.com</committer_email>
			<files>
				<file>
					<file_name>lib/merb-core/constants.rb</file_name>
					<diff>@@ -1,4 +1,17 @@
 # Most of this list is simply constants frozen for efficiency
+# and lowered memory consumption. Every time Ruby VM comes
+# across a string or a number or a regexp literal,
+# new object is created.
+#
+# This means if you refer to the same string 6 times per request
+# and your application takes 100 requests per second, there are
+# 600 objects for weak MRI garbage collector to work on.
+#
+# GC cycles take up to 80% (!) time of request processing in
+# some cases. Eventually Rubinius and maybe MRI 2.0 gonna
+# improve this situation but at the moment, all commonly used
+# strings, regexp and numbers used as constants so no extra
+# objects created and VM just operate pointers.
 module Merb
     module Const
     
@@ -41,5 +54,10 @@ module Const
     REQUEST_URI              = "REQUEST_URI".freeze
     REQUEST_PATH             = "REQUEST_PATH".freeze
     REMOTE_ADDR              = "REMOTE_ADDR".freeze
+    BREAK_TAG                = "br/".freeze
+    EMPTY_STRING             = "".freeze
+    NEWLINE                  = "\n".freeze
+    DOUBLE_NEWLINE           = "\n\n".freeze
+    LOCATION                 = "Location".freeze
   end
 end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/rack/application.rb</file_name>
					<diff>@@ -16,9 +16,9 @@ def call(env)
         begin
           rack_response = ::Merb::Dispatcher.handle(Merb::Request.new(env))
         rescue Object = e
-          return [500, {Merb::Const::CONTENT_TYPE = "text/html"}, e.message + "br/" + e.backtrace.join("br/")]
+          return [500, {Merb::Const::CONTENT_TYPE = "text/html"}, e.message + Merb::Const::BREAK_TAG + e.backtrace.join(Merb::Const::BREAK_TAG)]
         end
-        Merb.logger.info "\n\n"
+        Merb.logger.info Merb::Const::DOUBLE_NEWLINE
         Merb.logger.flush
 
         # unless controller.headers[Merb::Const::DATE]
@@ -41,7 +41,7 @@ def call(env)
       #
       # @api private
       def deferred?(env)
-        path = env[Merb::Const::PATH_INFO] ? env[Merb::Const::PATH_INFO].chomp('/') : ""
+        path = env[Merb::Const::PATH_INFO] ? env[Merb::Const::PATH_INFO].chomp(Merb::Const::SLASH) : Merb::Const::EMPTY_STRING
         if path =~ Merb.deferred_actions
           Merb.logger.info! "Deferring Request: #{path}"
           true</diff>
				</file>
				<file>
					<file_name>lib/merb-core/rack/helpers.rb</file_name>
					<diff>@@ -24,10 +24,10 @@ def self.redirect(url, options = {})
         Merb.logger.info("Dispatcher redirecting to: #{url} (#{status})")
         Merb.logger.flush
         
-        [status, { "Location" = url },
+        [status, { Merb::Const::LOCATION = url },
          Merb::Rack::StreamWrapper.new("htmlbodyYou are being a href=\"#{url}\"redirected/a./body/html")]
       end
       
     end
   end
-end
\ No newline at end of file
+end</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>173c4a1889afe4fa355cd768b0c8c66ebbe987f6</sha>
			<message>Fixes 2 syntax errors in specs. Forking runner swallowed those.</message>
			<author_name>Michael S. Klishin</author_name>
			<author_date>2008-10-12T04:34:00Z</author_date>
			<author_email>michael@novemberain.com</author_email>
			<committer_name>Michael S. Klishin</committer_name>
			<committer_date>2008-10-12T04:34:00Z</committer_date>
			<committer_email>michael@novemberain.com</committer_email>
			<files>
				<file>
					<file_name>spec/public/router/recognition/deferred_spec.rb</file_name>
					<diff>@@ -22,7 +22,7 @@
     it "should return the param hash returned by the block" do
       Merb::Router.prepare do
         match("/deferred").defer_to do |request, params|
-          :hello = "world"
+          { :hello = "world" }
         end
       end
 
@@ -42,7 +42,7 @@
     it "should be able to define routes after the deferred route" do
       Merb::Router.prepare do
         match("/deferred").defer_to do
-          :hello = "world"
+          { :hello = "world" }
         end
 
         match("/").to(:foo = "bar")
@@ -206,4 +206,4 @@
     route_for("/second") { |req| req.should_receive(:in_block!) }
   end
   
-end
\ No newline at end of file
+end</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>d4739e7620f2f553578009c859de2dae4863c8a4</sha>
			<message>fixed specs for viewmatchers

Signed-off-by: Michael S. Klishin michael@novemberain.com</message>
			<author_name>Michael Holub</author_name>
			<author_date>2008-10-11T14:21:59Z</author_date>
			<author_email>michael.holub@gmail.com</author_email>
			<committer_name>Michael S. Klishin</committer_name>
			<committer_date>2008-10-12T04:31:08Z</committer_date>
			<committer_email>michael@novemberain.com</committer_email>
			<files>
				<file>
					<file_name>spec/public/test/view_matchers_spec.rb</file_name>
					<diff>@@ -37,29 +37,42 @@ module Merb::Test::Rspec::ViewMatchers
           Hpricot.should_receive(:parse).and_return @document
         end
       
-        it "should should pass all found elements to the block" do
+        it "should pass all found elements to the block" do
           @block_called = false
         
           @document.should_receive(:search).and_return [""]
-          HasTag.new("tag").matches?("") {|e| @block_called = true}
-        
-          @block_called.should be_true
+          HasTag.new("tag").matches?("") {|e| e.should == "" }
         end
       
-        it "should not intercept any errors raised in the block" do
+        it 'should intercept errors raised in the block' do
           @document.should_receive(:search).and_return [""]
           lambda {
             HasTag.new("tag").matches?("") {|e| true.should be_false }
-          }.should raise_error(Spec::Expectations::ExpectationNotMetError)
+          }.should_not raise_error(Spec::Expectations::ExpectationNotMetError)
+        end
+
+        it 'should raise ExpectationNotMetError when there are no matched elements' do
+          @document.should_receive(:search).and_return [""]
+          lambda {
+            @document.should have_tag(:tag) {|e| true.should be_false }
+          }.should raise_error(Spec::Expectations::ExpectationNotMetError, "tag:\nexpected false, got true")
+        end
+
+        #part of bugfix for #329
+        it 'should not raise error if block for first of matched elements by xpath expression fails' do
+          @document.should_receive(:search).and_return ["a", "b"]
+          lambda {
+            @document.should have_tag(:tag) { |tag| tag.should == "b" }
+          }.should_not raise_error(Spec::Expectations::ExpectationNotMetError)
         end
       end
     
       describe "#with_tag" do
-        it "should set @inner_tag" do
+        it "should set @outer_has_tag" do
           outer = HasTag.new("outer")
           inner = outer.with_tag("inner")
         
-          outer.selector.should include(inner.selector)
+          inner.selector.should include(outer.selector)
         end
       end
     
@@ -95,15 +108,15 @@ module Merb::Test::Rspec::ViewMatchers
     
       describe "#failure_message" do
         it "should include the tag name" do
-          HasTag.new("anytag").failure_message.should include("anytag")
+          HasTag.new("anytag").failure_message.should include("anytag")
         end
       
         it "should include the tag's id" do
-          HasTag.new("div", :id = :spacer).failure_message.should include("div id=\"spacer\"")
+          HasTag.new("div", :id = :spacer).failure_message.should include("div#spacer")
         end
       
         it "should include the tag's class" do
-          HasTag.new("div", :class = :header).failure_message.should include("div class=\"header\"")
+          HasTag.new("div", :class = :header).failure_message.should include("div.header")
         end
       
         it "should include the tag's custom attributes" do
@@ -113,18 +126,12 @@ module Merb::Test::Rspec::ViewMatchers
       end
     
       describe "id, class, and attributes for error messages" do
-        it "should start with a space for a class, id, or custom attribute" do
-          HasTag.new("tag", :id = "identifier").id_for_error.should =~ /^ /
-          HasTag.new("tag", :class = "classifier").class_for_error.should =~ /^ /
-          HasTag.new("tag", :rand = "attr").attributes_for_error.should =~ /^ /
-        end
-      
-        it "should have 'class=\"classifier\"' in class_for_error" do
-          HasTag.new("tag", :class = "classifier").class_for_error.should include("class=\"classifier\"")
+        it "should have '.classifier' in class_for_error" do
+          HasTag.new("tag", :class = "classifier").class_for_error.should include(".classifier")
         end
       
-        it "should have 'id=\"identifier\" in id_for_error" do
-          HasTag.new("tag", :id = "identifier").id_for_error.should include("id=\"identifier\"")
+        it "should have '#identifier' in id_for_error" do
+          HasTag.new("tag", :id = "identifier").id_for_error.should include("#identifier")
         end
       end
     end</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>ef6092a6ee79d112eccbea1b8862c21d46d51b99</sha>
			<message>Add warning when loading rexml instead of libxml-ruby

Signed-off-by: Michael S. Klishin michael@novemberain.com</message>
			<author_name>Michael Holub</author_name>
			<author_date>2008-10-11T13:42:11Z</author_date>
			<author_email>michael.holub@gmail.com</author_email>
			<committer_name>Michael S. Klishin</committer_name>
			<committer_date>2008-10-12T04:30:57Z</committer_date>
			<committer_email>michael@novemberain.com</committer_email>
			<files>
				<file>
					<file_name>lib/merb-core/test/matchers/view_matchers.rb</file_name>
					<diff>@@ -356,7 +356,12 @@ def have_xpath(expected)
       require "libxml"
       type = "libxml"
     rescue LoadError = e
-      require "rexml/document"
+      if require "rexml/document" # show warning only once
+        warn(-WARN_TEXT)
+Standard REXML library is slow. Please consider to install libxml-ruby.
+Use "sudo gem install libxml-ruby"
+WARN_TEXT
+      end
       type = "rexml"
     end
     HaveXpath.new(expected, type)</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>1f6de2c3a0ec4bf42b4d6883e3898c2cc395f118</sha>
			<message>#329 bug fix

Signed-off-by: Michael S. Klishin michael@novemberain.com</message>
			<author_name>Michael Holub</author_name>
			<author_date>2008-10-11T01:56:39Z</author_date>
			<author_email>michael.holub@gmail.com</author_email>
			<committer_name>Michael S. Klishin</committer_name>
			<committer_date>2008-10-12T04:30:50Z</committer_date>
			<committer_email>michael@novemberain.com</committer_email>
			<files>
				<file>
					<file_name>lib/merb-core/test/matchers/view_matchers.rb</file_name>
					<diff>@@ -168,6 +168,8 @@ def failure_message
   
   class HasTag
     
+    attr_accessor :outer_has_tag, :inner_has_tag
+
     # ==== Parameters
     # tag~to_s:: The tag to look for.
     # attributesHash:: Attributes for the tag (see below).
@@ -197,8 +199,13 @@ def matches?(stringlike, &blk)
 
       unless @blk.nil?
         !@document.search(selector).select do |ele|
-          @blk.call ele
-          true
+          begin
+            @blk.call ele
+            true
+          rescue Spec::Expectations::ExpectationNotMetError
+            @error_message = "#{tag_for_error}:\n" + $!.message
+            false
+          end
         end.empty?
       else
         !@document.search(selector).empty?
@@ -208,12 +215,10 @@ def matches?(stringlike, &blk)
     # ==== Returns
     # String:: The complete selector for element queries.
     def selector
-      @selector = "//#{@tag}#{id_selector}#{class_selector}"
-      @selector  @attributes.map{|a, v| "[@#{a}=\"#{v}\"]"}.join
+      @selector = @outer_has_tag ? @outer_has_tag.selector : ''
 
-      @selector  @inner_has_tag.selector unless @inner_has_tag.nil?
-
-      @selector
+      @selector  "//#{@tag}#{id_selector}#{class_selector}"
+      @selector  @attributes.map{|a, v| "[@#{a}=\"#{v}\"]"}.join
     end
 
     # ==== Returns
@@ -231,45 +236,38 @@ def class_selector
     # ==== Returns
     # String:: The failure message.
     def failure_message
-      "expected following output to contain a #{tag_for_error} tag:\n#{@document}"
+      @error_message || "expected following output to contain a #{tag_for_error} tag:\n#{@document}"
     end
 
     # ==== Returns
     # String:: The failure message to be displayed in negative matches.
     def negative_failure_message
-      "expected following output to omit a #{tag_for_error} tag:\n#{@document}"
+      @error_message || "expected following output to omit a #{tag_for_error} tag:\n#{@document}"
     end
     
     # ==== Returns
     # String:: The tag used in failure messages.
     def tag_for_error
-      "#{inner_failure_message}#{@tag}#{id_for_error}#{class_for_error}#{attributes_for_error}"
-    end
-
-    # ==== Returns
-    # String::
-    #   The failure message to be displayed in negative matches within the
-    #   have_tag block.
-    def inner_failure_message
-      "#{@inner_has_tag.tag_for_error} tag within a " unless @inner_has_tag.nil?
+      result = "#{@tag}#{id_for_error}#{class_for_error}#{attributes_for_error}"
+      inner_has_tag ? result  "  #{inner_has_tag.tag_for_error}" : result
     end
 
     # ==== Returns
     # String:: ID for the error tag.
     def id_for_error
-      " id=\"#{@id}\"" unless @id.nil?
+      "##{@id}" unless @id.nil?
     end
 
     # ==== Returns
     # String:: Class for the error tag.
     def class_for_error
-      " class=\"#{@class}\"" unless @class.nil?
+      ".#{@class}" unless @class.nil?
     end
 
     # ==== Returns
     # String:: Class for the error tag.
     def attributes_for_error
-      @attributes.map{|a,v| " #{a}=\"#{v}\""}.join
+      @attributes.map{|a,v| "[#{a}=\"#{v}\"]"}.join
     end
 
     # Search for a child tag within a have_tag block.
@@ -279,6 +277,7 @@ def attributes_for_error
     # attributesHash:: Attributes for the tag (see below).
     def with_tag(name, attrs={})
       @inner_has_tag = HasTag.new(name, attrs)
+      @inner_has_tag.outer_has_tag = self
     end
   end
 </diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>42da35e9861d0ca0ef228a017316a31d76cf0e29</sha>
			<message>Log syntax errors when loading the app.</message>
			<author_name>Michael S. Klishin</author_name>
			<author_date>2008-10-12T04:30:03Z</author_date>
			<author_email>michael@novemberain.com</author_email>
			<committer_name>Michael S. Klishin</committer_name>
			<committer_date>2008-10-12T04:30:03Z</committer_date>
			<committer_email>michael@novemberain.com</committer_email>
			<files>
				<file>
					<file_name>lib/merb-core/bootloader.rb</file_name>
					<diff>@@ -769,8 +769,8 @@ def load_file(file)
       # the file is changed, it'll be reloaded again
       begin
         load file
-      rescue SyntaxError
-        return
+      rescue SyntaxError = e
+        Merb.logger.error "Cannot load #{file} because of syntax error: #{e.message}"
       ensure
         if Merb::Config[:reload_classes]
           MTIMES[file] = File.mtime(file)</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>3ae019fe96ffaa6cdaa79181279a1f8ef192eb69</sha>
			<message>Since intention/option comment behind workers respawn in -k are not clear, do not let killing master with -k for now.</message>
			<author_name>Michael S. Klishin</author_name>
			<author_date>2008-10-12T04:24:54Z</author_date>
			<author_email>michael@novemberain.com</author_email>
			<committer_name>Michael S. Klishin</committer_name>
			<committer_date>2008-10-12T04:24:54Z</committer_date>
			<committer_email>michael@novemberain.com</committer_email>
			<files>
				<file>
					<file_name>lib/merb-core/config.rb</file_name>
					<diff>@@ -324,7 +324,7 @@ def parse_args(argv = ARGV)
 
           opts.on("-k", "--kill PORT", "Force kill one merb worker " \
                   "by port number. This will cause the worker to" \
-                  "be respawned. If you want to kill ") do |port|
+                  "be respawned.") do |port|
             options[:action] = :kill_9
             port = "main" if port == "all"
             options[:port] = port</diff>
				</file>
				<file>
					<file_name>lib/merb-core/server.rb</file_name>
					<diff>@@ -95,22 +95,6 @@ def kill(port, sig = "INT")
           # turn
           if sig == "INT"
             kill_pid(sig, pid_file("main"))
-          else
-            # order is important here
-            
-            # then reap workers
-            # 
-            # there is no way to handle KILL so
-            # at_exit block does not work and
-            # processes do not clean up their
-            # pid files: lets do it ourselves
-            Dir["#{Merb.log_path}" / "*.pid"].each do |file|
-              kill_pid(sig, file)
-              ::FileUtils.rm_rf file
-            end
-
-            # reap master
-            kill_pid(sig, pid_file("main"))
           end
         else
           kill_pid(sig, pid_file(port))</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>20fd63f05d75d10f8a6afc54c2295da259d89f78</sha>
			<message>(put my Frankenstein voice on) It's alive!</message>
			<author_name>Michael S. Klishin</author_name>
			<author_date>2008-10-12T03:58:20Z</author_date>
			<author_email>michael@novemberain.com</author_email>
			<committer_name>Michael S. Klishin</committer_name>
			<committer_date>2008-10-12T03:58:20Z</committer_date>
			<committer_email>michael@novemberain.com</committer_email>
			<files>
				<file>
					<file_name>lib/merb-core/bootloader.rb</file_name>
					<diff>@@ -562,6 +562,7 @@ def run
       end
 
       @ran = true
+      # process name you see in ps output
       $0 = "merb#{" : " + Merb::Config[:name] if Merb::Config[:name]} : master"
 
       # Log the process configuration user defined signal 1 (SIGUSR1) is received.
@@ -604,7 +605,8 @@ def exit_gracefully
       Process.waitall
       # remove master process pid
       Merb::Server.remove_pid("main")
-      # terminate
+      # terminate, workers remove their own pids
+      # in on exit hook
       exit
     end
 
@@ -632,6 +634,7 @@ def start_transaction
 
       loop do
         # create two connected endpoints
+        # we use them for master/workers communication
         reader, @writer = IO.pipe
         pid = Kernel.fork
 
@@ -640,7 +643,7 @@ def start_transaction
         # writer must be closed so reader can generate EOF condition
         @writer.close
 
-        # master process stores pid to merb.mail.pid
+        # master process stores pid to merb.main.pid
         Merb::Server.store_pid("main")
 
         if Merb::Config[:console_trap]</diff>
				</file>
				<file>
					<file_name>lib/merb-core/server.rb</file_name>
					<diff>@@ -52,17 +52,18 @@ def start(port, cluster=nil)
       #
       # @api private
       def alive?(port)
-        puts "About to check if port #{port} is alive..." if Merb::Config[:verbose]
         pidfile = pid_file(port)
-        puts "Pidfile is #{pidfile}..." if Merb::Config[:verbose]
-        pid = File.read(pidfile).chomp.to_i
-        puts "Process id is #{pid}" if Merb::Config[:verbose]
+        pid     = pid_in_file(pidfile)
         Process.kill(0, pid)
         true
       rescue Errno::ESRCH, Errno::ENOENT
         false
       rescue Errno::EACCES = e
-        Merb.fatal!("You don't have access to the PID file at #{pidfile}.", e)
+        Merb.fatal!("You don't have access to the PID file at #{pidfile}: #{e.message}")
+      end
+
+      def pid_in_file(pidfile)
+        File.read(pidfile).chomp.to_i
       end
 
       # ==== Parameters
@@ -84,9 +85,32 @@ def kill(port, sig = "INT")
         Merb::BootLoader::BuildFramework.run
         # assume that if we kill master,
         # workers should be reaped, too
-        if %w(main all).include?(port)
-          Dir["#{Merb.log_path}" / "*.pid"].each do |file|
-            kill_pid(sig, file)
+        if %w(main master all).include?(port)
+          # if graceful exit is requested,
+          # send INT to master process and
+          # it's gonna do it's job
+          #
+          # Otherwise read pids from pid files
+          # and try to kill each process in
+          # turn
+          if sig == "INT"
+            kill_pid(sig, pid_file("main"))
+          else
+            # order is important here
+            
+            # then reap workers
+            # 
+            # there is no way to handle KILL so
+            # at_exit block does not work and
+            # processes do not clean up their
+            # pid files: lets do it ourselves
+            Dir["#{Merb.log_path}" / "*.pid"].each do |file|
+              kill_pid(sig, file)
+              ::FileUtils.rm_rf file
+            end
+
+            # reap master
+            kill_pid(sig, pid_file("main"))
           end
         else
           kill_pid(sig, pid_file(port))
@@ -97,29 +121,29 @@ def kill(port, sig = "INT")
       # @api private
       def kill_pid(sig, file)
         begin
-          pid = File.read(file).chomp.to_i
+          pid = pid_in_file(file)
           Merb.logger.fatal! "Killing pid #{pid} with #{sig}"
           Process.kill(sig, pid)
           FileUtils.rm(file) if File.exist?(file)
         rescue Errno::EINVAL
-          Merb.fatal! "Failed to kill PID #{pid} with #{sig}: '#{sig}' is an invalid " \
+          Merb.logger.fatal! "Failed to kill PID #{pid} with #{sig}: '#{sig}' is an invalid " \
             "or unsupported signal number."
         rescue Errno::EPERM
-          Merb.fatal! "Failed to kill PID #{pid} with #{sig}: Insufficient permissions."
+          Merb.logger.fatal! "Failed to kill PID #{pid} with #{sig}: Insufficient permissions."
         rescue Errno::ESRCH
           FileUtils.rm file
-          Merb.fatal! "Failed to kill PID #{pid} with #{sig}: Process is " \
+          Merb.logger.fatal! "Failed to kill PID #{pid} with #{sig}: Process is " \
             "deceased or zombie."
         rescue Errno::EACCES = e
-          Merb.fatal! e.message, e
+          Merb.logger.fatal! e.message
         rescue Errno::ENOENT = e
           # This should not cause abnormal exit, that's why
           # we do not use Merb.fatal but instead just
           # log with max level.
-          Merb.logger.fatal! "Could not find a PID file at #{file}. Probably process is no longer running but pid file wasn't cleaned up.", e
+          Merb.logger.fatal! "Could not find a PID file at #{file}. Probably process is no longer running but pid file wasn't cleaned up."
         rescue Exception = e
           if !e.is_a?(SystemExit)
-            Merb.fatal! "Failed to kill PID #{pid} with #{sig}", e
+            Merb.logger.fatal! "Failed to kill PID #{pid.inspect} with #{sig.inspect}: #{e.message}"
           end
         end
       end</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>2d721c48372e8aaf85b5b6c4b653b83df0402915</sha>
			<message>Merge upstream, re-apply stash.</message>
			<author_name>Michael S. Klishin</author_name>
			<author_date>2008-10-11T14:49:52Z</author_date>
			<author_email>michael@novemberain.com</author_email>
			<committer_name>Michael S. Klishin</committer_name>
			<committer_date>2008-10-11T14:49:52Z</committer_date>
			<committer_email>michael@novemberain.com</committer_email>
			<files>
				<file>
					<file_name>lib/merb-core/bootloader.rb</file_name>
					<diff>@@ -566,7 +566,7 @@ def run
 
       # Log the process configuration user defined signal 1 (SIGUSR1) is received.
       Merb.trap("USR1") do
-        Merb.logger.error! "Configuration:\n#{Merb::Config.to_hash.merge(:pid = $$).to_yaml}\n\n"
+        Merb.logger.fatal! "Configuration:\n#{Merb::Config.to_hash.merge(:pid = $$).to_yaml}\n\n"
       end
 
       if Merb::Config[:fork_for_class_load] && !Merb.testing?
@@ -600,8 +600,11 @@ def run
     #
     # @api private
     def exit_gracefully
+      # wait all workers to exit
       Process.waitall
+      # remove master process pid
       Merb::Server.remove_pid("main")
+      # terminate
       exit
     end
 
@@ -643,6 +646,7 @@ def start_transaction
         if Merb::Config[:console_trap]
           Merb.trap("INT") {}
         else
+          # send ABRT to worker on INT
           Merb.trap("INT") do
             Merb.logger.warn! "Reaping Workers"
             begin
@@ -718,7 +722,9 @@ def start_transaction
     # (Does not return.)
     #
     # @api private
-    def reap_workers(status = 0)
+    # @param statusInteger The status code to exit with
+    # @param sigString     The signal to send to workers
+    def reap_workers(status = 0, sig = "ABRT")
       Merb.exiting = true unless status == 128
 
       begin
@@ -731,7 +737,7 @@ def reap_workers(status = 0)
       ($WORKERS || []).each do |p|
         threads  Thread.new do
           begin
-            Process.kill("ABRT", p)
+            Process.kill(sig, p)
             Process.wait2(p)
           rescue SystemCallError
           end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/server.rb</file_name>
					<diff>@@ -74,26 +74,23 @@ def alive?(port)
       # processes.
       #
       # @api private
-      def kill(port, sig="INT")
+      def kill(port, sig = "INT")
+        # 9 = KILL
+        # 2 = INT
+        if sig.is_a?(Integer)
+          sig = Signal.list.invert[sig]
+        end
+        
         Merb::BootLoader::BuildFramework.run
-        if sig == 9 && port == "main"
-          kill_pid("INT", pid_file("main"))
+        # assume that if we kill master,
+        # workers should be reaped, too
+        if %w(main all).include?(port)
           Dir["#{Merb.log_path}" / "*.pid"].each do |file|
-            kill_pid(9, file)
+            kill_pid(sig, file)
           end
         else
           kill_pid(sig, pid_file(port))
         end
-
-        if sig.is_a?(Integer)
-          sig = Signal.list.invert[sig]
-        end
-
-        if sig == "KILL" && port == "main"
-          Merb.fatal! "Killed all PIDs with signal KILL"
-        else
-          Merb.fatal! "Killed #{port} with signal #{sig}"
-        end
       end
 
       # Kills the process pointed at by the provided pid file.
@@ -101,25 +98,28 @@ def kill(port, sig="INT")
       def kill_pid(sig, file)
         begin
           pid = File.read(file).chomp.to_i
-          Merb.logger.warn! "Killing pid #{pid}"
+          Merb.logger.fatal! "Killing pid #{pid} with #{sig}"
           Process.kill(sig, pid)
           FileUtils.rm(file) if File.exist?(file)
         rescue Errno::EINVAL
-          Merb.fatal! "Failed to kill PID #{pid}: '#{sig}' is an invalid " \
+          Merb.fatal! "Failed to kill PID #{pid} with #{sig}: '#{sig}' is an invalid " \
             "or unsupported signal number."
         rescue Errno::EPERM
-          Merb.fatal! "Failed to kill PID #{pid}: Insufficient permissions."
+          Merb.fatal! "Failed to kill PID #{pid} with #{sig}: Insufficient permissions."
         rescue Errno::ESRCH
           FileUtils.rm file
-          Merb.fatal! "Failed to kill PID #{pid}: Process is " \
+          Merb.fatal! "Failed to kill PID #{pid} with #{sig}: Process is " \
             "deceased or zombie."
         rescue Errno::EACCES = e
           Merb.fatal! e.message, e
         rescue Errno::ENOENT = e
-          Merb.fatal! "Could not find a PID file at #{file}", e
+          # This should not cause abnormal exit, that's why
+          # we do not use Merb.fatal but instead just
+          # log with max level.
+          Merb.logger.fatal! "Could not find a PID file at #{file}. Probably process is no longer running but pid file wasn't cleaned up.", e
         rescue Exception = e
           if !e.is_a?(SystemExit)
-            Merb.fatal! "Failed to kill PID #{pid}", e
+            Merb.fatal! "Failed to kill PID #{pid} with #{sig}", e
           end
         end
       end
@@ -156,10 +156,7 @@ def daemonize(port)
       #
       # @api private
       def bootup
-        Merb.trap('TERM') {
-          Merb::BootLoader::LoadClasses.reap_workers if Merb::Config[:fork_for_class_load]
-          exit
-        }
+        Merb.trap('TERM') { shutdown }
 
         puts "Running bootloaders..." if Merb::Config[:verbose]
         BootLoader.run
@@ -170,6 +167,13 @@ def bootup
       # Change process user/group to those specified in Merb::Config.
       #
       # @api private
+      def shutdown(status = 0)
+        # reap_workers does exit but may not be called
+        Merb::BootLoader::LoadClasses.reap_workers(status) if Merb::Config[:fork_for_class_load]
+        # that's why we exit explicitly here
+        exit(status)
+      end
+
       def change_privilege
         if Merb::Config[:user] && Merb::Config[:group]
           Merb.logger.verbose! "About to change privilege to group " \</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>a68e147e759021d2e6ab1bd0e2d89fe4d9b1c2a1</sha>
			<message>Merge branch 'sprint'

* sprint:
  Updated GemManagement</message>
			<author_name>Michael S. Klishin</author_name>
			<author_date>2008-10-11T14:46:29Z</author_date>
			<author_email>michael@novemberain.com</author_email>
			<committer_name>Michael S. Klishin</committer_name>
			<committer_date>2008-10-11T14:46:29Z</committer_date>
			<committer_email>michael@novemberain.com</committer_email>
			<files>
				<file>
					<file_name>lib/merb-core/tasks/gem_management.rb</file_name>
					<diff>@@ -58,7 +58,7 @@ def install_gem(gem, options = {})
       installer = Gem::DependencyInstaller.new(options.merge(:user_install = false))
       
       # Force-refresh certain gems by excluding them from the current index
-      if refresh.respond_to?(:include?) && !refresh.empty?
+      if !options[:ignore_dependencies] && refresh.respond_to?(:include?) && !refresh.empty?
         source_index = installer.instance_variable_get(:@source_index)
         source_index.gems.each do |name, spec| 
           source_index.gems.delete(name) if refresh.include?(spec.name)
@@ -81,7 +81,7 @@ def install_gem(gem, options = {})
         exception = e
       end
       if installer.installed_gems.empty? && exception
-        error "Failed to install gem '#{gem} (#{version})' (#{exception.message})"
+        error "Failed to install gem '#{gem} (#{version || 'any version'})' (#{exception.message})"
       end
       installer.installed_gems.each do |spec|
         success "Successfully installed #{spec.full_name}"
@@ -122,11 +122,13 @@ def install_gem_from_cache(gem, options = {})
   # install_gem_from_source(source_dir, gem_name)
   # install_gem_from_source(source_dir, :skip = [...])
   def install_gem_from_source(source_dir, *args)
+    installed_gems = []
     Dir.chdir(source_dir) do
-      options = args.last.is_a?(Hash) ? args.pop : {}
-      gem_name    = args[0] || File.basename(source_dir)
-      gem_pkg_dir = File.join(source_dir, 'pkg')
-      skip_gems   = options.delete(:skip) || []
+      opts = args.last.is_a?(Hash) ? args.pop : {}
+      gem_name     = args[0] || File.basename(source_dir)
+      gem_pkg_dir  = File.join(source_dir, 'pkg')
+      gem_pkg_glob = File.join(gem_pkg_dir, "#{gem_name}-*.gem")
+      skip_gems    = opts.delete(:skip) || []
 
       # Cleanup what's already there
       clobber(source_dir)
@@ -138,7 +140,7 @@ def install_gem_from_source(source_dir, *args)
       
       if packages.length == 1
         # The are no subpackages for the main package
-        options[:refresh] = [gem_name]
+        refresh = [gem_name]
       else
         # Gather all packages into the top-level pkg directory
         packages.each do |pkg|
@@ -149,24 +151,38 @@ def install_gem_from_source(source_dir, *args)
         package(source_dir, false)
         
         # Gather subgems to refresh during installation of the main gem
-        options[:refresh] = packages.map do |pkg|
+        refresh = packages.map do |pkg|
           File.basename(pkg, '.gem')[/^(.*?)-([\d\.]+)$/, 1] rescue nil
         end.compact
-      end
-    
-      gem_pkg = Dir[File.join(gem_pkg_dir, "#{gem_name}-*.gem")][0]
-      if gem_pkg && File.exists?(gem_pkg)
-        # Needs to be executed from the directory that contains all packages
-        Dir.chdir(File.dirname(gem_pkg)) do 
-          install_gem(gem_pkg, options)
+        
+        # Install subgems explicitly even if ignore_dependencies is set
+        if opts[:ignore_dependencies]
+          refresh.each do |name| 
+            gem_pkg = Dir[File.join(gem_pkg_dir, "#{name}-*.gem")][0]
+            install_pkg(gem_pkg, opts)
+          end
         end
-        options[:refresh]
+      end
+      
+      # Finally install the main gem
+      if install_pkg(Dir[gem_pkg_glob][0], opts.merge(:refresh = refresh))
+        installed_gems = refresh
       else
-        []
+        installed_gems = []
       end
     end
+    installed_gems
   end
-
+  
+  def install_pkg(gem_pkg, opts = {})
+    if (gem_pkg && File.exists?(gem_pkg))
+      # Needs to be executed from the directory that contains all packages
+      Dir.chdir(File.dirname(gem_pkg)) { install_gem(gem_pkg, opts) }
+    else
+      false
+    end
+  end
+  
   # Uninstall a gem.
   def uninstall_gem(gem, options = {})
     if options[:version] && !options[:version].is_a?(Gem::Requirement)
@@ -178,17 +194,17 @@ def uninstall_gem(gem, options = {})
 
   def clobber(source_dir)
     Dir.chdir(source_dir) do 
-      system "#{Gem.ruby} -S rake -s clobber" if File.exists?('Rakefile')
+      system "#{Gem.ruby} -S rake -s clobber" unless File.exists?('Thorfile')
     end
   end
 
   def package(source_dir, clobber = true)
     Dir.chdir(source_dir) do 
-      if File.exists?('Rakefile')
+      if File.exists?('Thorfile')
+        thor ":package"
+      elsif File.exists?('Rakefile')
         rake "clobber" if clobber
         rake "package"
-      elsif
-        thor ":package"
       end
     end
     Dir[File.join(source_dir, 'pkg/*.gem')]
@@ -230,12 +246,12 @@ def partition_dependencies(dependencies, gem_dir)
       ::Gem.clear_paths; ::Gem.path.unshift(gem_dir)
       ::Gem.source_index.refresh!
       dependencies.each do |dep|
-        if gemspec = ::Gem.source_index.search(dep).last
-          if gemspec.loaded_from.index(gem_dir) == 0
-            local_specs   gemspec
-          else
-            system_specs  gemspec
-          end
+        gemspecs = ::Gem.source_index.search(dep)
+        local = gemspecs.reverse.find { |s| s.loaded_from.index(gem_dir) == 0 }
+        if local
+          local_specs   local
+        elsif gemspecs.last
+          system_specs  gemspecs.last
         else
           missing_deps  dep
         end
@@ -313,4 +329,4 @@ def update_source_index(dir)
     Gem.source_index.load_gems_in(File.join(dir, 'specifications'))
   end
   
-end
+end
\ No newline at end of file</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>dad0d934c0294e082d7dc525e61ed547daf4bf64</sha>
			<message>Updated GemManagement</message>
			<author_name>Fabien Franzen</author_name>
			<author_date>2008-10-11T13:37:28Z</author_date>
			<author_email>info@atelierfabien.be</author_email>
			<committer_name>Fabien Franzen</committer_name>
			<committer_date>2008-10-11T13:37:28Z</committer_date>
			<committer_email>info@atelierfabien.be</committer_email>
			<files>
				<file>
					<file_name>lib/merb-core/tasks/gem_management.rb</file_name>
					<diff>@@ -58,7 +58,7 @@ def install_gem(gem, options = {})
       installer = Gem::DependencyInstaller.new(options.merge(:user_install = false))
       
       # Force-refresh certain gems by excluding them from the current index
-      if refresh.respond_to?(:include?) && !refresh.empty?
+      if !options[:ignore_dependencies] && refresh.respond_to?(:include?) && !refresh.empty?
         source_index = installer.instance_variable_get(:@source_index)
         source_index.gems.each do |name, spec| 
           source_index.gems.delete(name) if refresh.include?(spec.name)
@@ -81,7 +81,7 @@ def install_gem(gem, options = {})
         exception = e
       end
       if installer.installed_gems.empty? && exception
-        error "Failed to install gem '#{gem} (#{version})' (#{exception.message})"
+        error "Failed to install gem '#{gem} (#{version || 'any version'})' (#{exception.message})"
       end
       installer.installed_gems.each do |spec|
         success "Successfully installed #{spec.full_name}"
@@ -122,11 +122,13 @@ def install_gem_from_cache(gem, options = {})
   # install_gem_from_source(source_dir, gem_name)
   # install_gem_from_source(source_dir, :skip = [...])
   def install_gem_from_source(source_dir, *args)
+    installed_gems = []
     Dir.chdir(source_dir) do
-      options = args.last.is_a?(Hash) ? args.pop : {}
-      gem_name    = args[0] || File.basename(source_dir)
-      gem_pkg_dir = File.join(source_dir, 'pkg')
-      skip_gems   = options.delete(:skip) || []
+      opts = args.last.is_a?(Hash) ? args.pop : {}
+      gem_name     = args[0] || File.basename(source_dir)
+      gem_pkg_dir  = File.join(source_dir, 'pkg')
+      gem_pkg_glob = File.join(gem_pkg_dir, "#{gem_name}-*.gem")
+      skip_gems    = opts.delete(:skip) || []
 
       # Cleanup what's already there
       clobber(source_dir)
@@ -138,7 +140,7 @@ def install_gem_from_source(source_dir, *args)
       
       if packages.length == 1
         # The are no subpackages for the main package
-        options[:refresh] = [gem_name]
+        refresh = [gem_name]
       else
         # Gather all packages into the top-level pkg directory
         packages.each do |pkg|
@@ -149,24 +151,38 @@ def install_gem_from_source(source_dir, *args)
         package(source_dir, false)
         
         # Gather subgems to refresh during installation of the main gem
-        options[:refresh] = packages.map do |pkg|
+        refresh = packages.map do |pkg|
           File.basename(pkg, '.gem')[/^(.*?)-([\d\.]+)$/, 1] rescue nil
         end.compact
-      end
-    
-      gem_pkg = Dir[File.join(gem_pkg_dir, "#{gem_name}-*.gem")][0]
-      if gem_pkg && File.exists?(gem_pkg)
-        # Needs to be executed from the directory that contains all packages
-        Dir.chdir(File.dirname(gem_pkg)) do 
-          install_gem(gem_pkg, options)
+        
+        # Install subgems explicitly even if ignore_dependencies is set
+        if opts[:ignore_dependencies]
+          refresh.each do |name| 
+            gem_pkg = Dir[File.join(gem_pkg_dir, "#{name}-*.gem")][0]
+            install_pkg(gem_pkg, opts)
+          end
         end
-        options[:refresh]
+      end
+      
+      # Finally install the main gem
+      if install_pkg(Dir[gem_pkg_glob][0], opts.merge(:refresh = refresh))
+        installed_gems = refresh
       else
-        []
+        installed_gems = []
       end
     end
+    installed_gems
   end
-
+  
+  def install_pkg(gem_pkg, opts = {})
+    if (gem_pkg && File.exists?(gem_pkg))
+      # Needs to be executed from the directory that contains all packages
+      Dir.chdir(File.dirname(gem_pkg)) { install_gem(gem_pkg, opts) }
+    else
+      false
+    end
+  end
+  
   # Uninstall a gem.
   def uninstall_gem(gem, options = {})
     if options[:version] && !options[:version].is_a?(Gem::Requirement)
@@ -178,17 +194,17 @@ def uninstall_gem(gem, options = {})
 
   def clobber(source_dir)
     Dir.chdir(source_dir) do 
-      system "#{Gem.ruby} -S rake -s clobber" if File.exists?('Rakefile')
+      system "#{Gem.ruby} -S rake -s clobber" unless File.exists?('Thorfile')
     end
   end
 
   def package(source_dir, clobber = true)
     Dir.chdir(source_dir) do 
-      if File.exists?('Rakefile')
+      if File.exists?('Thorfile')
+        thor ":package"
+      elsif File.exists?('Rakefile')
         rake "clobber" if clobber
         rake "package"
-      elsif
-        thor ":package"
       end
     end
     Dir[File.join(source_dir, 'pkg/*.gem')]
@@ -230,12 +246,12 @@ def partition_dependencies(dependencies, gem_dir)
       ::Gem.clear_paths; ::Gem.path.unshift(gem_dir)
       ::Gem.source_index.refresh!
       dependencies.each do |dep|
-        if gemspec = ::Gem.source_index.search(dep).last
-          if gemspec.loaded_from.index(gem_dir) == 0
-            local_specs   gemspec
-          else
-            system_specs  gemspec
-          end
+        gemspecs = ::Gem.source_index.search(dep)
+        local = gemspecs.reverse.find { |s| s.loaded_from.index(gem_dir) == 0 }
+        if local
+          local_specs   local
+        elsif gemspecs.last
+          system_specs  gemspecs.last
         else
           missing_deps  dep
         end
@@ -313,4 +329,4 @@ def update_source_index(dir)
     Gem.source_index.load_gems_in(File.join(dir, 'specifications'))
   end
   
-end
+end
\ No newline at end of file</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>94e9ff04eb037495ade4d7bd10dd4e3bb540e637</sha>
			<message>Merge branch 'sprint'</message>
			<author_name>Yehuda Katz</author_name>
			<author_date>2008-10-11T07:06:11Z</author_date>
			<author_email>wycats@gmail.com</author_email>
			<committer_name>Yehuda Katz</committer_name>
			<committer_date>2008-10-11T07:06:11Z</committer_date>
			<committer_email>wycats@gmail.com</committer_email>
			<files>
				<file>
					<file_name>lib/merb-core.rb</file_name>
					<diff>@@ -278,11 +278,7 @@ def root_path(*path)
 
     # Logger settings
     def logger
-      Thread.current[:merb_logger] ||= Merb::Logger.new(
-        Merb::Config[:log_stream],
-        Merb::Config[:log_level],
-        Merb::Config[:log_delimiter],
-        Merb::Config[:log_auto_flush])
+      Thread.current[:merb_logger] ||= Merb::Logger.new
     end
 
     def reset_logger!</diff>
				</file>
				<file>
					<file_name>lib/merb-core/controller/merb_controller.rb</file_name>
					<diff>@@ -97,8 +97,6 @@ def self._filter_params(params)
     params
   end
 
-  private
-
   # All methods that are callable as actions.
   #
   # ==== Returns</diff>
				</file>
				<file>
					<file_name>lib/merb-core/logger.rb</file_name>
					<diff>@@ -1,5 +1,16 @@
 # Merb::Logger = Extlib::Logger
 
+class Merb::Logger  Extlib::Logger
+  def verbose!(message, level = :warn)
+    send("#{level}!", message) if Merb::Config[:verbose]
+  end
+
+  def verbose(message, level = :warn)
+    send(level, message) if Merb::Config[:verbose]
+  end
+end
+
+# require "time" # httpdate
 # ==== Public Merb Logger API
 #
 # To replace an existing logger with a new one:
@@ -34,37 +45,168 @@
 #   Merb::Logger.new(log{String, IO},level{Symbol, String})
 module Merb
 
-  class Logger  Extlib::Logger
+  class Logger
+
+    attr_accessor :level
+    attr_accessor :delimiter
+    attr_accessor :auto_flush
+    attr_reader   :buffer
+    attr_reader   :log
+    attr_reader   :init_args
+
+    # ==== Notes
+    # Ruby (standard) logger levels:
+    # :fatal:: An unhandleable error that results in a program crash
+    # :error:: A handleable error condition
+    # :warn:: A warning
+    # :info:: generic (useful) information about system operation
+    # :debug:: low-level information for developers
+    Levels = Mash.new({
+      :fatal = 7,
+      :error = 6,
+      :warn  = 4,
+      :info  = 3,
+      :debug = 0
+    }) unless const_defined?(:Levels)
+
+    @@mutex = {}
 
-    # Appends a message to the log if the specified log level is at least as high as
-    # the log level of the logger if Merb::Config[:verbose]. Then flushes the log 
-    # buffer to disk.
+    private
+
+    # Readies a log for writing.
     #
     # ==== Parameters
-    # messageString:: The message to be logged.
-    # levelSymbol:: The level at which to log. Default is :warn.
+    # logIO, String:: Either an IO object or a name of a logfile.
+    def initialize_log(log)
+      close if @log # be sure that we don't leave open files laying around.
+
+      if log.respond_to?(:write)
+        @log = log
+      elsif File.exist?(log)
+        @log = open(log, (File::WRONLY | File::APPEND))
+        @log.sync = true
+      else
+        FileUtils.mkdir_p(File.dirname(log)) unless File.directory?(File.dirname(log))
+        @log = open(log, (File::WRONLY | File::APPEND | File::CREAT))
+        @log.sync = true
+        @log.write("#{Time.now.httpdate} #{delimiter} info #{delimiter} Logfile created\n")
+      end
+    end
+
+    public
+
+    # To initialize the logger you create a new object, proxies to set_log.
     #
-    # ==== Returns
-    # self:: The logger object for chaining.
+    # ==== Parameters
+    # *args:: Arguments to create the log from. See set_logs for specifics.
+    def initialize(*args)
+      set_log(*args)
+    end
+
+    # Replaces an existing logger with a new one.
     #
-    # @api plugin
-    def verbose!(message, level = :warn)
-      send("#{level}!", message) if Merb::Config[:verbose]
+    # ==== Parameters
+    # logIO, String:: Either an IO object or a name of a logfile.
+    # log_level~to_sym::
+    #   The log level from, e.g. :fatal or :info. Defaults to :error in the
+    #   production environment and :debug otherwise.
+    # delimiterString::
+    #   Delimiter to use between message sections. Defaults to " ~ ".
+    # auto_flushBoolean::
+    #   Whether the log should automatically flush after new messages are
+    #   added. Defaults to false.
+    def set_log(stream = Merb::Config[:log_stream],
+      log_level = Merb::Config[:log_level],
+      delimiter = Merb::Config[:log_delimiter],
+      auto_flush = Merb::Config[:log_auto_flush])
+
+      @buffer                   = []
+      @delimiter                = delimiter
+      @auto_flush               = auto_flush
+
+      if Levels[log_level]
+        @level                  = Levels[log_level]
+      else
+        @level                  = log_level
+      end
+
+      @log                      = stream
+      @mutex = (@@mutex[@log] ||= Mutex.new)
+    end
+
+    # Flush the entire buffer to the log object.
+    def flush
+      return unless @buffer.size  0
+      @mutex.synchronize do
+        @log.write(@buffer.slice!(0..-1).to_s)
+      end
+    end
+
+    # Close and remove the current log object.
+    def close
+      flush
+      @log.close if @log.respond_to?(:close) && !@log.tty?
+      @log = nil
     end
 
-    # Appends a message to the log if the specified log level is at least as high as
-    # the log level of the logger if Merb::Config[:verbose].
+    # Appends a message to the log. The methods yield to an optional block and
+    # the output of this block will be appended to the message.
     #
     # ==== Parameters
-    # messageString:: The message to be logged.
-    # levelSymbol:: The level at which to log. Default is :warn.
+    # stringString:: The message to be logged. Defaults to nil.
     #
     # ==== Returns
-    # self:: The logger object for chaining.
-    #
-    # @api plugin
-    def verbose(message, level = :warn)
-      send(level, message) if Merb::Config[:verbose]
+    # String:: The resulting message added to the log file.
+    def (string = nil)
+      message = ""
+      message  delimiter
+      message  string if string
+      message  "\n" unless message[-1] == ?\n
+      @buffer  message
+      flush if @auto_flush
+
+      message
+    end
+    alias :push :
+
+    # Generate the logging methods for Merb.logger for each log level.
+    Levels.each_pair do |name, number|
+      class_eval -LEVELMETHODS, __FILE__, __LINE__
+
+      # Appends a message to the log if the log level is at least as high as
+      # the log level of the logger.
+      #
+      # ==== Parameters
+      # stringString:: The message to be logged. Defaults to nil.
+      #
+      # ==== Returns
+      # self:: The logger object for chaining.
+      def #{name}(message = nil)
+        self  message if #{number} = level
+        self
+      end
+
+      # Appends a message to the log if the log level is at least as high as
+      # the log level of the logger. The bang! version of the method also auto
+      # flushes the log buffer to disk.
+      #
+      # ==== Parameters
+      # stringString:: The message to be logged. Defaults to nil.
+      #
+      # ==== Returns
+      # self:: The logger object for chaining.
+      def #{name}!(message = nil)
+        self  message if #{number} = level
+        flush if #{number} = level
+        self
+      end
+
+      # ==== Returns
+      # Boolean:: True if this level will be logged by this logger.
+      def #{name}?
+        #{number} = level
+      end
+      LEVELMETHODS
     end
 
   end</diff>
				</file>
				<file>
					<file_name>spec/public/logger/logger_spec.rb</file_name>
					<diff>@@ -21,14 +21,6 @@
 
 describe Merb::Logger do
 
-  describe "Levels" do
-    it "should have the same entries as Extlib::Logger::Levels" do
-      Extlib::Logger::Levels.each do |level, value|
-        Merb::Logger::Levels[level].should == value
-      end
-    end
-  end
-
   describe "#new" do
     it "should call set_log with the arguments it was passed." do
       logger = Merb::Logger.allocate # create an object sans initialization
@@ -49,12 +41,6 @@
       Merb.logger.level.should == 4
     end
 
-    it "should set the log level to a specific numeric value when that value is set into Mer" do
-      Merb::Config[:log_level] = 5
-      Merb.reset_logger!
-      Merb.logger.level.should == 5
-    end
-
     it "should set the log level to :debug (0) when Merb.environment is development" do
       Merb.environment = "development"
       Merb::Config.delete(:log_level)
@@ -294,81 +280,4 @@ def set_level(level)
       Merb.logger.should log_with_method(:fatal)
     end
   end # #fatal
-  
-  describe "#verbose" do
-    before do
-      @stream = Merb::Config[:log_stream] = StringIO.new
-      Merb.reset_logger!
-    end
-    
-    describe "when Merb::Config[:verbose] is false" do
-      it "should not log any messages" do
-        Merb::Config[:verbose] = false
-        Merb::Config[:log_level] = :debug
-        Merb.logger.verbose("message", :fatal)
-        Merb.logger.flush
-        
-        Merb.logger.log.string.should_not include("message")
-      end
-    end
-    
-    describe "when Merb::Config[:verbose] is true" do
-      before do
-        Merb::Config[:verbose] = true
-        Merb::Config[:log_level] = :debug
-      end
-
-      it "adds to the buffer with error level" do
-        set_level(:error)
-        Merb.logger.verbose("message", :error)
-        Merb.logger.flush
-        Merb.logger.log.string.should include("message")
-      end
-
-      it "adds to the buffer with fatal level" do
-        set_level(:fatal)
-        Merb.logger.verbose("message", :error)
-        Merb.logger.flush
-        Merb.logger.log.string.should_not include("message")
-      end
-      
-    end
-  end
-  
-  describe "#verbose!" do
-    before do
-      @stream = Merb::Config[:log_stream] = StringIO.new
-      Merb.reset_logger!
-    end
-    
-    describe "when Merb::Config[:verbose] is false" do
-      it "should not log any messages" do
-        Merb::Config[:verbose] = false
-        Merb::Config[:log_level] = :debug
-        Merb.logger.verbose!("message", :fatal)
-        Merb.logger.log.string.should_not include("message")
-      end
-    end
-    
-    describe "when Merb::Config[:verbose] is true" do
-      before do
-        Merb::Config[:verbose] = true
-        Merb::Config[:log_level] = :debug
-      end
-
-      it "adds to the buffer with error level" do
-        set_level(:error)
-        Merb.logger.verbose!("message", :error)
-        Merb.logger.log.string.should include("message")
-      end
-
-      it "adds to the buffer with fatal level" do
-        set_level(:fatal)
-        Merb.logger.verbose!("message", :error)
-        Merb.logger.log.string.should_not include("message")
-      end
-      
-    end
-  end
-  
 end # Merb::Logger</diff>
				</file>
				<file>
					<file_name>spec/public/router/recognition/deferred_spec.rb</file_name>
					<diff>@@ -6,7 +6,7 @@
     before :each do
       Merb::Router.prepare do      
         match("/deferred/:zoo").defer_to do |request, params|
-          route params.merge(:controller = "w00t") if params[:zoo]
+          params.merge(:controller = "w00t") if params[:zoo]
         end
       end    
     end
@@ -22,7 +22,7 @@
     it "should return the param hash returned by the block" do
       Merb::Router.prepare do
         match("/deferred").defer_to do |request, params|
-          route :hello = "world"
+          :hello = "world"
         end
       end
 
@@ -32,7 +32,7 @@
     it "should accept params" do
       Merb::Router.prepare do
         match("/").defer_to(:controller = "accounts") do |request, params|
-          route params.update(:action = "hello")
+          params.update(:action = "hello")
         end
       end
 
@@ -42,7 +42,7 @@
     it "should be able to define routes after the deferred route" do
       Merb::Router.prepare do
         match("/deferred").defer_to do
-          route :hello = "world"
+          :hello = "world"
         end
 
         match("/").to(:foo = "bar")</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>a7fb18c7f3cf24321ccd8a8e03f6ddafcb6be651</sha>
			<message>Merge commit 'adelcambre/sprint' into sprint</message>
			<author_name>Yehuda Katz</author_name>
			<author_date>2008-10-11T07:06:01Z</author_date>
			<author_email>wycats@gmail.com</author_email>
			<committer_name>Yehuda Katz</committer_name>
			<committer_date>2008-10-11T07:06:01Z</committer_date>
			<committer_email>wycats@gmail.com</committer_email>
			<files>
				<file>
					<file_name>lib/merb-core.rb</file_name>
					<diff>@@ -278,11 +278,7 @@ def root_path(*path)
 
     # Logger settings
     def logger
-      Thread.current[:merb_logger] ||= Merb::Logger.new(
-        Merb::Config[:log_stream],
-        Merb::Config[:log_level],
-        Merb::Config[:log_delimiter],
-        Merb::Config[:log_auto_flush])
+      Thread.current[:merb_logger] ||= Merb::Logger.new
     end
 
     def reset_logger!</diff>
				</file>
				<file>
					<file_name>lib/merb-core/controller/merb_controller.rb</file_name>
					<diff>@@ -97,8 +97,6 @@ def self._filter_params(params)
     params
   end
 
-  private
-
   # All methods that are callable as actions.
   #
   # ==== Returns</diff>
				</file>
				<file>
					<file_name>lib/merb-core/logger.rb</file_name>
					<diff>@@ -1,5 +1,16 @@
 # Merb::Logger = Extlib::Logger
 
+class Merb::Logger  Extlib::Logger
+  def verbose!(message, level = :warn)
+    send("#{level}!", message) if Merb::Config[:verbose]
+  end
+
+  def verbose(message, level = :warn)
+    send(level, message) if Merb::Config[:verbose]
+  end
+end
+
+# require "time" # httpdate
 # ==== Public Merb Logger API
 #
 # To replace an existing logger with a new one:
@@ -34,37 +45,168 @@
 #   Merb::Logger.new(log{String, IO},level{Symbol, String})
 module Merb
 
-  class Logger  Extlib::Logger
+  class Logger
+
+    attr_accessor :level
+    attr_accessor :delimiter
+    attr_accessor :auto_flush
+    attr_reader   :buffer
+    attr_reader   :log
+    attr_reader   :init_args
+
+    # ==== Notes
+    # Ruby (standard) logger levels:
+    # :fatal:: An unhandleable error that results in a program crash
+    # :error:: A handleable error condition
+    # :warn:: A warning
+    # :info:: generic (useful) information about system operation
+    # :debug:: low-level information for developers
+    Levels = Mash.new({
+      :fatal = 7,
+      :error = 6,
+      :warn  = 4,
+      :info  = 3,
+      :debug = 0
+    }) unless const_defined?(:Levels)
+
+    @@mutex = {}
 
-    # Appends a message to the log if the specified log level is at least as high as
-    # the log level of the logger if Merb::Config[:verbose]. Then flushes the log 
-    # buffer to disk.
+    private
+
+    # Readies a log for writing.
     #
     # ==== Parameters
-    # messageString:: The message to be logged.
-    # levelSymbol:: The level at which to log. Default is :warn.
+    # logIO, String:: Either an IO object or a name of a logfile.
+    def initialize_log(log)
+      close if @log # be sure that we don't leave open files laying around.
+
+      if log.respond_to?(:write)
+        @log = log
+      elsif File.exist?(log)
+        @log = open(log, (File::WRONLY | File::APPEND))
+        @log.sync = true
+      else
+        FileUtils.mkdir_p(File.dirname(log)) unless File.directory?(File.dirname(log))
+        @log = open(log, (File::WRONLY | File::APPEND | File::CREAT))
+        @log.sync = true
+        @log.write("#{Time.now.httpdate} #{delimiter} info #{delimiter} Logfile created\n")
+      end
+    end
+
+    public
+
+    # To initialize the logger you create a new object, proxies to set_log.
     #
-    # ==== Returns
-    # self:: The logger object for chaining.
+    # ==== Parameters
+    # *args:: Arguments to create the log from. See set_logs for specifics.
+    def initialize(*args)
+      set_log(*args)
+    end
+
+    # Replaces an existing logger with a new one.
     #
-    # @api plugin
-    def verbose!(message, level = :warn)
-      send("#{level}!", message) if Merb::Config[:verbose]
+    # ==== Parameters
+    # logIO, String:: Either an IO object or a name of a logfile.
+    # log_level~to_sym::
+    #   The log level from, e.g. :fatal or :info. Defaults to :error in the
+    #   production environment and :debug otherwise.
+    # delimiterString::
+    #   Delimiter to use between message sections. Defaults to " ~ ".
+    # auto_flushBoolean::
+    #   Whether the log should automatically flush after new messages are
+    #   added. Defaults to false.
+    def set_log(stream = Merb::Config[:log_stream],
+      log_level = Merb::Config[:log_level],
+      delimiter = Merb::Config[:log_delimiter],
+      auto_flush = Merb::Config[:log_auto_flush])
+
+      @buffer                   = []
+      @delimiter                = delimiter
+      @auto_flush               = auto_flush
+
+      if Levels[log_level]
+        @level                  = Levels[log_level]
+      else
+        @level                  = log_level
+      end
+
+      @log                      = stream
+      @mutex = (@@mutex[@log] ||= Mutex.new)
+    end
+
+    # Flush the entire buffer to the log object.
+    def flush
+      return unless @buffer.size  0
+      @mutex.synchronize do
+        @log.write(@buffer.slice!(0..-1).to_s)
+      end
+    end
+
+    # Close and remove the current log object.
+    def close
+      flush
+      @log.close if @log.respond_to?(:close) && !@log.tty?
+      @log = nil
     end
 
-    # Appends a message to the log if the specified log level is at least as high as
-    # the log level of the logger if Merb::Config[:verbose].
+    # Appends a message to the log. The methods yield to an optional block and
+    # the output of this block will be appended to the message.
     #
     # ==== Parameters
-    # messageString:: The message to be logged.
-    # levelSymbol:: The level at which to log. Default is :warn.
+    # stringString:: The message to be logged. Defaults to nil.
     #
     # ==== Returns
-    # self:: The logger object for chaining.
-    #
-    # @api plugin
-    def verbose(message, level = :warn)
-      send(level, message) if Merb::Config[:verbose]
+    # String:: The resulting message added to the log file.
+    def (string = nil)
+      message = ""
+      message  delimiter
+      message  string if string
+      message  "\n" unless message[-1] == ?\n
+      @buffer  message
+      flush if @auto_flush
+
+      message
+    end
+    alias :push :
+
+    # Generate the logging methods for Merb.logger for each log level.
+    Levels.each_pair do |name, number|
+      class_eval -LEVELMETHODS, __FILE__, __LINE__
+
+      # Appends a message to the log if the log level is at least as high as
+      # the log level of the logger.
+      #
+      # ==== Parameters
+      # stringString:: The message to be logged. Defaults to nil.
+      #
+      # ==== Returns
+      # self:: The logger object for chaining.
+      def #{name}(message = nil)
+        self  message if #{number} = level
+        self
+      end
+
+      # Appends a message to the log if the log level is at least as high as
+      # the log level of the logger. The bang! version of the method also auto
+      # flushes the log buffer to disk.
+      #
+      # ==== Parameters
+      # stringString:: The message to be logged. Defaults to nil.
+      #
+      # ==== Returns
+      # self:: The logger object for chaining.
+      def #{name}!(message = nil)
+        self  message if #{number} = level
+        flush if #{number} = level
+        self
+      end
+
+      # ==== Returns
+      # Boolean:: True if this level will be logged by this logger.
+      def #{name}?
+        #{number} = level
+      end
+      LEVELMETHODS
     end
 
   end</diff>
				</file>
				<file>
					<file_name>spec/public/logger/logger_spec.rb</file_name>
					<diff>@@ -21,14 +21,6 @@
 
 describe Merb::Logger do
 
-  describe "Levels" do
-    it "should have the same entries as Extlib::Logger::Levels" do
-      Extlib::Logger::Levels.each do |level, value|
-        Merb::Logger::Levels[level].should == value
-      end
-    end
-  end
-
   describe "#new" do
     it "should call set_log with the arguments it was passed." do
       logger = Merb::Logger.allocate # create an object sans initialization
@@ -49,12 +41,6 @@
       Merb.logger.level.should == 4
     end
 
-    it "should set the log level to a specific numeric value when that value is set into Mer" do
-      Merb::Config[:log_level] = 5
-      Merb.reset_logger!
-      Merb.logger.level.should == 5
-    end
-
     it "should set the log level to :debug (0) when Merb.environment is development" do
       Merb.environment = "development"
       Merb::Config.delete(:log_level)
@@ -294,81 +280,4 @@ def set_level(level)
       Merb.logger.should log_with_method(:fatal)
     end
   end # #fatal
-  
-  describe "#verbose" do
-    before do
-      @stream = Merb::Config[:log_stream] = StringIO.new
-      Merb.reset_logger!
-    end
-    
-    describe "when Merb::Config[:verbose] is false" do
-      it "should not log any messages" do
-        Merb::Config[:verbose] = false
-        Merb::Config[:log_level] = :debug
-        Merb.logger.verbose("message", :fatal)
-        Merb.logger.flush
-        
-        Merb.logger.log.string.should_not include("message")
-      end
-    end
-    
-    describe "when Merb::Config[:verbose] is true" do
-      before do
-        Merb::Config[:verbose] = true
-        Merb::Config[:log_level] = :debug
-      end
-
-      it "adds to the buffer with error level" do
-        set_level(:error)
-        Merb.logger.verbose("message", :error)
-        Merb.logger.flush
-        Merb.logger.log.string.should include("message")
-      end
-
-      it "adds to the buffer with fatal level" do
-        set_level(:fatal)
-        Merb.logger.verbose("message", :error)
-        Merb.logger.flush
-        Merb.logger.log.string.should_not include("message")
-      end
-      
-    end
-  end
-  
-  describe "#verbose!" do
-    before do
-      @stream = Merb::Config[:log_stream] = StringIO.new
-      Merb.reset_logger!
-    end
-    
-    describe "when Merb::Config[:verbose] is false" do
-      it "should not log any messages" do
-        Merb::Config[:verbose] = false
-        Merb::Config[:log_level] = :debug
-        Merb.logger.verbose!("message", :fatal)
-        Merb.logger.log.string.should_not include("message")
-      end
-    end
-    
-    describe "when Merb::Config[:verbose] is true" do
-      before do
-        Merb::Config[:verbose] = true
-        Merb::Config[:log_level] = :debug
-      end
-
-      it "adds to the buffer with error level" do
-        set_level(:error)
-        Merb.logger.verbose!("message", :error)
-        Merb.logger.log.string.should include("message")
-      end
-
-      it "adds to the buffer with fatal level" do
-        set_level(:fatal)
-        Merb.logger.verbose!("message", :error)
-        Merb.logger.log.string.should_not include("message")
-      end
-      
-    end
-  end
-  
 end # Merb::Logger</diff>
				</file>
				<file>
					<file_name>spec/public/router/recognition/deferred_spec.rb</file_name>
					<diff>@@ -6,7 +6,7 @@
     before :each do
       Merb::Router.prepare do      
         match("/deferred/:zoo").defer_to do |request, params|
-          route params.merge(:controller = "w00t") if params[:zoo]
+          params.merge(:controller = "w00t") if params[:zoo]
         end
       end    
     end
@@ -22,7 +22,7 @@
     it "should return the param hash returned by the block" do
       Merb::Router.prepare do
         match("/deferred").defer_to do |request, params|
-          route :hello = "world"
+          :hello = "world"
         end
       end
 
@@ -32,7 +32,7 @@
     it "should accept params" do
       Merb::Router.prepare do
         match("/").defer_to(:controller = "accounts") do |request, params|
-          route params.update(:action = "hello")
+          params.update(:action = "hello")
         end
       end
 
@@ -42,7 +42,7 @@
     it "should be able to define routes after the deferred route" do
       Merb::Router.prepare do
         match("/deferred").defer_to do
-          route :hello = "world"
+          :hello = "world"
         end
 
         match("/").to(:foo = "bar")</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>d425060afd09ba313ae5fba3568029106009abf8</sha>
			<message>remove the route method from specs</message>
			<author_name>Andy Delcambre</author_name>
			<author_date>2008-10-11T07:00:50Z</author_date>
			<author_email>adelcambre@engineyard.com</author_email>
			<committer_name>Andy Delcambre</committer_name>
			<committer_date>2008-10-11T07:00:50Z</committer_date>
			<committer_email>adelcambre@engineyard.com</committer_email>
			<files>
				<file>
					<file_name>spec/public/router/recognition/deferred_spec.rb</file_name>
					<diff>@@ -6,7 +6,7 @@
     before :each do
       Merb::Router.prepare do      
         match("/deferred/:zoo").defer_to do |request, params|
-          route params.merge(:controller = "w00t") if params[:zoo]
+          params.merge(:controller = "w00t") if params[:zoo]
         end
       end    
     end
@@ -22,7 +22,7 @@
     it "should return the param hash returned by the block" do
       Merb::Router.prepare do
         match("/deferred").defer_to do |request, params|
-          route :hello = "world"
+          :hello = "world"
         end
       end
 
@@ -32,7 +32,7 @@
     it "should accept params" do
       Merb::Router.prepare do
         match("/").defer_to(:controller = "accounts") do |request, params|
-          route params.update(:action = "hello")
+          params.update(:action = "hello")
         end
       end
 
@@ -42,7 +42,7 @@
     it "should be able to define routes after the deferred route" do
       Merb::Router.prepare do
         match("/deferred").defer_to do
-          route :hello = "world"
+          :hello = "world"
         end
 
         match("/").to(:foo = "bar")</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>d4917e085ab21bd15ec1960745f0e5e3449a16aa</sha>
			<message>crap, stray non-comment</message>
			<author_name>Andy Delcambre</author_name>
			<author_date>2008-10-11T06:53:57Z</author_date>
			<author_email>adelcambre@engineyard.com</author_email>
			<committer_name>Andy Delcambre</committer_name>
			<committer_date>2008-10-11T06:53:57Z</committer_date>
			<committer_email>adelcambre@engineyard.com</committer_email>
			<files>
				<file>
					<file_name>lib/merb-core/controller/merb_controller.rb</file_name>
					<diff>@@ -97,8 +97,6 @@ def self._filter_params(params)
     params
   end
 
-  private
-
   # All methods that are callable as actions.
   #
   # ==== Returns</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>c9054d2c03f5daacce44aaedf225e23c9c1ee48f</sha>
			<message>Revert "Move most merb logger code out, into extlib"

This reverts commit 7a73c146dd28f4456b7ef2d1819834c67e04fa2a.</message>
			<author_name>Andy Delcambre</author_name>
			<author_date>2008-10-11T06:38:33Z</author_date>
			<author_email>adelcambre@engineyard.com</author_email>
			<committer_name>Andy Delcambre</committer_name>
			<committer_date>2008-10-11T06:38:33Z</committer_date>
			<committer_email>adelcambre@engineyard.com</committer_email>
			<files>
				<file>
					<file_name>lib/merb-core.rb</file_name>
					<diff>@@ -278,11 +278,7 @@ def root_path(*path)
 
     # Logger settings
     def logger
-      Thread.current[:merb_logger] ||= Merb::Logger.new(
-        Merb::Config[:log_stream],
-        Merb::Config[:log_level],
-        Merb::Config[:log_delimiter],
-        Merb::Config[:log_auto_flush])
+      Thread.current[:merb_logger] ||= Merb::Logger.new
     end
 
     def reset_logger!</diff>
				</file>
				<file>
					<file_name>lib/merb-core/logger.rb</file_name>
					<diff>@@ -1,5 +1,16 @@
 # Merb::Logger = Extlib::Logger
 
+class Merb::Logger  Extlib::Logger
+  def verbose!(message, level = :warn)
+    send("#{level}!", message) if Merb::Config[:verbose]
+  end
+
+  def verbose(message, level = :warn)
+    send(level, message) if Merb::Config[:verbose]
+  end
+end
+
+# require "time" # httpdate
 # ==== Public Merb Logger API
 #
 # To replace an existing logger with a new one:
@@ -34,37 +45,168 @@
 #   Merb::Logger.new(log{String, IO},level{Symbol, String})
 module Merb
 
-  class Logger  Extlib::Logger
+  class Logger
+
+    attr_accessor :level
+    attr_accessor :delimiter
+    attr_accessor :auto_flush
+    attr_reader   :buffer
+    attr_reader   :log
+    attr_reader   :init_args
+
+    # ==== Notes
+    # Ruby (standard) logger levels:
+    # :fatal:: An unhandleable error that results in a program crash
+    # :error:: A handleable error condition
+    # :warn:: A warning
+    # :info:: generic (useful) information about system operation
+    # :debug:: low-level information for developers
+    Levels = Mash.new({
+      :fatal = 7,
+      :error = 6,
+      :warn  = 4,
+      :info  = 3,
+      :debug = 0
+    }) unless const_defined?(:Levels)
+
+    @@mutex = {}
 
-    # Appends a message to the log if the specified log level is at least as high as
-    # the log level of the logger if Merb::Config[:verbose]. Then flushes the log 
-    # buffer to disk.
+    private
+
+    # Readies a log for writing.
     #
     # ==== Parameters
-    # messageString:: The message to be logged.
-    # levelSymbol:: The level at which to log. Default is :warn.
+    # logIO, String:: Either an IO object or a name of a logfile.
+    def initialize_log(log)
+      close if @log # be sure that we don't leave open files laying around.
+
+      if log.respond_to?(:write)
+        @log = log
+      elsif File.exist?(log)
+        @log = open(log, (File::WRONLY | File::APPEND))
+        @log.sync = true
+      else
+        FileUtils.mkdir_p(File.dirname(log)) unless File.directory?(File.dirname(log))
+        @log = open(log, (File::WRONLY | File::APPEND | File::CREAT))
+        @log.sync = true
+        @log.write("#{Time.now.httpdate} #{delimiter} info #{delimiter} Logfile created\n")
+      end
+    end
+
+    public
+
+    # To initialize the logger you create a new object, proxies to set_log.
     #
-    # ==== Returns
-    # self:: The logger object for chaining.
+    # ==== Parameters
+    # *args:: Arguments to create the log from. See set_logs for specifics.
+    def initialize(*args)
+      set_log(*args)
+    end
+
+    # Replaces an existing logger with a new one.
     #
-    # @api plugin
-    def verbose!(message, level = :warn)
-      send("#{level}!", message) if Merb::Config[:verbose]
+    # ==== Parameters
+    # logIO, String:: Either an IO object or a name of a logfile.
+    # log_level~to_sym::
+    #   The log level from, e.g. :fatal or :info. Defaults to :error in the
+    #   production environment and :debug otherwise.
+    # delimiterString::
+    #   Delimiter to use between message sections. Defaults to " ~ ".
+    # auto_flushBoolean::
+    #   Whether the log should automatically flush after new messages are
+    #   added. Defaults to false.
+    def set_log(stream = Merb::Config[:log_stream],
+      log_level = Merb::Config[:log_level],
+      delimiter = Merb::Config[:log_delimiter],
+      auto_flush = Merb::Config[:log_auto_flush])
+
+      @buffer                   = []
+      @delimiter                = delimiter
+      @auto_flush               = auto_flush
+
+      if Levels[log_level]
+        @level                  = Levels[log_level]
+      else
+        @level                  = log_level
+      end
+
+      @log                      = stream
+      @mutex = (@@mutex[@log] ||= Mutex.new)
+    end
+
+    # Flush the entire buffer to the log object.
+    def flush
+      return unless @buffer.size  0
+      @mutex.synchronize do
+        @log.write(@buffer.slice!(0..-1).to_s)
+      end
+    end
+
+    # Close and remove the current log object.
+    def close
+      flush
+      @log.close if @log.respond_to?(:close) && !@log.tty?
+      @log = nil
     end
 
-    # Appends a message to the log if the specified log level is at least as high as
-    # the log level of the logger if Merb::Config[:verbose].
+    # Appends a message to the log. The methods yield to an optional block and
+    # the output of this block will be appended to the message.
     #
     # ==== Parameters
-    # messageString:: The message to be logged.
-    # levelSymbol:: The level at which to log. Default is :warn.
+    # stringString:: The message to be logged. Defaults to nil.
     #
     # ==== Returns
-    # self:: The logger object for chaining.
-    #
-    # @api plugin
-    def verbose(message, level = :warn)
-      send(level, message) if Merb::Config[:verbose]
+    # String:: The resulting message added to the log file.
+    def (string = nil)
+      message = ""
+      message  delimiter
+      message  string if string
+      message  "\n" unless message[-1] == ?\n
+      @buffer  message
+      flush if @auto_flush
+
+      message
+    end
+    alias :push :
+
+    # Generate the logging methods for Merb.logger for each log level.
+    Levels.each_pair do |name, number|
+      class_eval -LEVELMETHODS, __FILE__, __LINE__
+
+      # Appends a message to the log if the log level is at least as high as
+      # the log level of the logger.
+      #
+      # ==== Parameters
+      # stringString:: The message to be logged. Defaults to nil.
+      #
+      # ==== Returns
+      # self:: The logger object for chaining.
+      def #{name}(message = nil)
+        self  message if #{number} = level
+        self
+      end
+
+      # Appends a message to the log if the log level is at least as high as
+      # the log level of the logger. The bang! version of the method also auto
+      # flushes the log buffer to disk.
+      #
+      # ==== Parameters
+      # stringString:: The message to be logged. Defaults to nil.
+      #
+      # ==== Returns
+      # self:: The logger object for chaining.
+      def #{name}!(message = nil)
+        self  message if #{number} = level
+        flush if #{number} = level
+        self
+      end
+
+      # ==== Returns
+      # Boolean:: True if this level will be logged by this logger.
+      def #{name}?
+        #{number} = level
+      end
+      LEVELMETHODS
     end
 
   end</diff>
				</file>
				<file>
					<file_name>spec/public/logger/logger_spec.rb</file_name>
					<diff>@@ -21,14 +21,6 @@
 
 describe Merb::Logger do
 
-  describe "Levels" do
-    it "should have the same entries as Extlib::Logger::Levels" do
-      Extlib::Logger::Levels.each do |level, value|
-        Merb::Logger::Levels[level].should == value
-      end
-    end
-  end
-
   describe "#new" do
     it "should call set_log with the arguments it was passed." do
       logger = Merb::Logger.allocate # create an object sans initialization
@@ -49,12 +41,6 @@
       Merb.logger.level.should == 4
     end
 
-    it "should set the log level to a specific numeric value when that value is set into Mer" do
-      Merb::Config[:log_level] = 5
-      Merb.reset_logger!
-      Merb.logger.level.should == 5
-    end
-
     it "should set the log level to :debug (0) when Merb.environment is development" do
       Merb.environment = "development"
       Merb::Config.delete(:log_level)
@@ -294,81 +280,4 @@ def set_level(level)
       Merb.logger.should log_with_method(:fatal)
     end
   end # #fatal
-  
-  describe "#verbose" do
-    before do
-      @stream = Merb::Config[:log_stream] = StringIO.new
-      Merb.reset_logger!
-    end
-    
-    describe "when Merb::Config[:verbose] is false" do
-      it "should not log any messages" do
-        Merb::Config[:verbose] = false
-        Merb::Config[:log_level] = :debug
-        Merb.logger.verbose("message", :fatal)
-        Merb.logger.flush
-        
-        Merb.logger.log.string.should_not include("message")
-      end
-    end
-    
-    describe "when Merb::Config[:verbose] is true" do
-      before do
-        Merb::Config[:verbose] = true
-        Merb::Config[:log_level] = :debug
-      end
-
-      it "adds to the buffer with error level" do
-        set_level(:error)
-        Merb.logger.verbose("message", :error)
-        Merb.logger.flush
-        Merb.logger.log.string.should include("message")
-      end
-
-      it "adds to the buffer with fatal level" do
-        set_level(:fatal)
-        Merb.logger.verbose("message", :error)
-        Merb.logger.flush
-        Merb.logger.log.string.should_not include("message")
-      end
-      
-    end
-  end
-  
-  describe "#verbose!" do
-    before do
-      @stream = Merb::Config[:log_stream] = StringIO.new
-      Merb.reset_logger!
-    end
-    
-    describe "when Merb::Config[:verbose] is false" do
-      it "should not log any messages" do
-        Merb::Config[:verbose] = false
-        Merb::Config[:log_level] = :debug
-        Merb.logger.verbose!("message", :fatal)
-        Merb.logger.log.string.should_not include("message")
-      end
-    end
-    
-    describe "when Merb::Config[:verbose] is true" do
-      before do
-        Merb::Config[:verbose] = true
-        Merb::Config[:log_level] = :debug
-      end
-
-      it "adds to the buffer with error level" do
-        set_level(:error)
-        Merb.logger.verbose!("message", :error)
-        Merb.logger.log.string.should include("message")
-      end
-
-      it "adds to the buffer with fatal level" do
-        set_level(:fatal)
-        Merb.logger.verbose!("message", :error)
-        Merb.logger.log.string.should_not include("message")
-      end
-      
-    end
-  end
-  
 end # Merb::Logger</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>cc0e6ddec4437027e039731b96242995050f069e</sha>
			<message>Merge branch 'sprint'</message>
			<author_name>Yehuda Katz</author_name>
			<author_date>2008-10-11T06:28:07Z</author_date>
			<author_email>wycats@gmail.com</author_email>
			<committer_name>Yehuda Katz</committer_name>
			<committer_date>2008-10-11T06:28:07Z</committer_date>
			<committer_email>wycats@gmail.com</committer_email>
			<files>
				<file>
					<file_name>lib/merb-core.rb</file_name>
					<diff>@@ -278,7 +278,11 @@ def root_path(*path)
 
     # Logger settings
     def logger
-      Thread.current[:merb_logger] ||= Merb::Logger.new
+      Thread.current[:merb_logger] ||= Merb::Logger.new(
+        Merb::Config[:log_stream],
+        Merb::Config[:log_level],
+        Merb::Config[:log_delimiter],
+        Merb::Config[:log_auto_flush])
     end
 
     def reset_logger!</diff>
				</file>
				<file>
					<file_name>lib/merb-core/bootloader.rb</file_name>
					<diff>@@ -3,8 +3,8 @@ module Merb
   class BootLoader
 
     # def self.subclasses
-    #---
-    # @semipublic
+    #
+    # @api plugin
     cattr_accessor :subclasses, :after_load_callbacks, :before_load_callbacks, :finished
     self.subclasses, self.after_load_callbacks,
       self.before_load_callbacks, self.finished = [], [], [], []
@@ -16,29 +16,44 @@ class  self
       #
       # ==== Parameters
       # klassClass:: The class inheriting from Merb::BootLoader.
+      #
+      # ==== Returns
+      # nil
+      #
+      # @api plugin
       def inherited(klass)
         subclasses  klass.to_s
         super
       end
 
+      # Execute this boot loader after the specified boot loader.
+      #
       # ==== Parameters
       # klass~to_s::
       #   The boot loader class after which this boot loader should be run.
       #
-      #---
-      # @public
+      # ==== Returns
+      # nil
+      # 
+      # @api plugin
       def after(klass)
         move_klass(klass, 1)
+        nil
       end
 
+      # Execute this boot loader before the specified boot loader.
+      #
       # ==== Parameters
       # klass~to_s::
       #   The boot loader class before which this boot loader should be run.
       #
-      #---
-      # @public
+      # ==== Returns
+      # nil
+      #
+      # @api plugin
       def before(klass)
         move_klass(klass, 0)
+        nil
       end
 
       # Move a class that is inside the bootloader to some place in the Array,
@@ -49,15 +64,26 @@ def before(klass)
       #   The klass to move the bootloader relative to
       # whereInteger::
       #   0 means insert it before; 1 means insert it after
+      #
+      # ==== Returns
+      # nil
+      #
+      # @api private
       def move_klass(klass, where)
         index = Merb::BootLoader.subclasses.index(klass.to_s)
         if index
           Merb::BootLoader.subclasses.delete(self.to_s)
           Merb::BootLoader.subclasses.insert(index + where, self.to_s)
         end
+        nil
       end
 
       # Runs all boot loader classes by calling their run methods.
+      #
+      # ==== Returns
+      # nil
+      #
+      # @api plugin
       def run
         Merb.started = true
         subklasses = subclasses.dup
@@ -74,6 +100,7 @@ def run
           self.finished  bootloader
         end
         self.subclasses = subklasses
+        nil
       end
 
       # Determines whether or not a specific bootloader has finished yet.
@@ -83,6 +110,8 @@ def run
       #
       # ==== Returns
       # Boolean:: Whether or not the bootloader has finished.
+      #
+      # @api private
       def finished?(bootloader)
         self.finished.include?(bootloader.to_s)
       end
@@ -92,8 +121,8 @@ def finished?(bootloader)
       # ==== Returns
       # nil
       #
-      #---
-      # @public
+      # @api plugin
+      # @overridable
       def default_framework
         %w[view model helper controller mailer part].each do |component|
           Merb.push_path(component.to_sym, Merb.root_path("app/#{component}s"))
@@ -111,24 +140,26 @@ def default_framework
         nil
       end
 
+      # Execute a block of code after the app loads.
+      #
       # ==== Parameters
       # &block::
       #   A block to be added to the callbacks that will be executed after the
       #   app loads.
       #
-      #---
-      # @public
+      # @api public
       def after_app_loads(&block)
         after_load_callbacks  block
       end
 
+      # Execute a block of code before the app loads but after dependencies load.
+      #
       # ==== Parameters
       # &block::
       #   A block to be added to the callbacks that will be executed before the
       #   app loads.
       #
-      #---
-      # @public
+      # @api public
       def before_app_loads(&block)
         before_load_callbacks  block
       end
@@ -145,6 +176,11 @@ def before_app_loads(&block)
 class Merb::BootLoader::Logger  Merb::BootLoader
 
   # Sets Merb.logger to a new logger created based on the config settings.
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api plugin
   def self.run
     Merb::Config[:log_level] ||= begin
       if Merb.environment == "production"
@@ -157,8 +193,16 @@ def self.run
     Merb::Config[:log_stream] = Merb.log_stream
 
     print_warnings
+    
+    nil
   end
 
+  # Print a warning if the installed version of rubygems is not supported
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api private
   def self.print_warnings
     if Gem::Version.new(Gem::RubyGemsVersion)  Gem::Version.new("1.1")
       Merb.fatal! "Merb requires Rubygems 1.1 and later. " \
@@ -175,19 +219,32 @@ class Merb::BootLoader::DropPidFile  Merb::BootLoader
   class  self
 
     # Stores a PID file if Merb is running daemonized or clustered.
+    #
+    # ==== Returns
+    # nil
+    #
+    # @api plugin
     def run
       Merb::Server.store_pid("main") #if Merb::Config[:daemonize] || Merb::Config[:cluster]
+      nil
     end
   end
 end
 
 # Setup some useful defaults
 class Merb::BootLoader::Defaults  Merb::BootLoader
+  # Sets up the defaults
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api plugin
   def self.run
     Merb::Request.http_method_overrides.concat([
       proc { |c| c.params[:_method] },
       proc { |c| c.env['HTTP_X_HTTP_METHOD_OVERRIDE'] }
     ])
+    nil
   end
 end
 
@@ -231,12 +288,24 @@ class Merb::BootLoader::BuildFramework  Merb::BootLoader
   class  self
 
     # Builds the framework directory structure.
+    #
+    # ==== Returns
+    # nil
     def run
       build_framework
+      nil
     end
 
-    # This method should be overridden in init.rb before Merb.start to set up
-    # a different framework structure.
+    # Sets up merb paths to support the app's file layout. First, config/framework.rb is checked,
+    # next we look for Merb.root/framework.rb, finally we use the default merb layout (Merb::BootLoader.default_framework)
+    #
+    # This method can be overriden to support other application layouts.
+    #
+    # ==== Returns
+    # nil
+    #
+    # @api plugin
+    # @overridable
     def build_framework
       if File.exists?(Merb.root / "config" / "framework.rb")
         require Merb.root / "config" / "framework"
@@ -249,12 +318,17 @@ def build_framework
         path = Array(path)
         Merb.push_path(name, path.first, path.length == 2 ? path[1] : "**/*.rb")
       end
+      nil
     end
   end
 end
 
 class Merb::BootLoader::Dependencies  Merb::BootLoader
 
+  # ==== Returns
+  # Array[Gem::Dependency]:: The dependencies regiestered in init.rb.
+  #
+  # @api plugin
   cattr_accessor :dependencies
   self.dependencies = []
 
@@ -267,7 +341,11 @@ class Merb::BootLoader::Dependencies  Merb::BootLoader
   # before or after insertion methods. Since these are loaded from this
   # bootloader (Dependencies), they can only adapt the bootloaders that
   # haven't been loaded up until this point.
-
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api plugin
   def self.run
     set_encoding
     # this is crucial: load init file with all the preferences
@@ -280,12 +358,24 @@ def self.run
     enable_json_gem unless Merb::disabled?(:json)
     load_dependencies
     update_logger
+    nil
   end
 
+  # Load each dependency that has been declared so far.
+  # 
+  # ==== Returns
+  # nil
+  #
+  # @api private
   def self.load_dependencies
     dependencies.each { |dependency| Kernel.load_dependency(dependency) }
+    nil
   end
 
+  # Loads json or json_pure and requires it.
+  #
+  # ==== Returns
+  # nil
   def self.enable_json_gem
     gem "json"
     require "json/ext"
@@ -294,6 +384,13 @@ def self.enable_json_gem
     require "json/pure"
   end
 
+  # Resets the logger and sets the log_stream to Merb::Config[:log_file] 
+  # if one is specified, falling back to STDOUT.
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api private
   def self.update_logger
     Merb.reset_logger!
 
@@ -306,34 +403,64 @@ def self.update_logger
     else
       Merb::Config[:log_stream] ||= STDOUT
     end
+    
+    nil
   end
 
+  # Default encoding to UTF8 if it has not already been set to something else.
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api private
   def self.set_encoding
     $KCODE = 'UTF8' if $KCODE == 'NONE' || $KCODE.blank?
+    nil
   end
 
   private
 
     # Determines the path for the environment configuration file
+    #
+    # ==== Returns
+    # String:: The path to the config file for the environment
+    #
+    # @api private
     def self.env_config
       Merb.dir_for(:config) / "environments" / (Merb.environment + ".rb")
     end
 
     # Checks to see whether or not an environment configuration exists
+    #
+    # ==== Returns
+    # Boolean:: Whether or not the environment configuration file exists.
+    #
+    # @api private
     def self.env_config?
       Merb.environment && File.exist?(env_config)
     end
 
-    # Loads the environment configuration file, if any
+    # Loads the environment configuration file, if it is present
+    #
+    # ==== Returns
+    # nil
+    #
+    # @api private
     def self.load_env_config
       if env_config?
         STDOUT.puts "Loading #{env_config}" unless Merb.testing?
         load(env_config)
       end
+      nil
     end
 
     # Determines the init file to use, if any.
     # By default Merb uses init.rb from application config directory.
+    #
+    # ==== Returns
+    # nil
+    #
+    # @api private
     def self.initfile
       if Merb::Config[:init_file]
         Merb::Config[:init_file].chomp(".rb") + ".rb"
@@ -343,6 +470,11 @@ def self.initfile
     end
 
     # Loads the init file, should one exist
+    #
+    # ==== Returns
+    # nil
+    #
+    # @api private
     def self.load_initfile
       if File.exists?(initfile)
         STDOUT.puts "Loading init file from #{initfile}" unless Merb.testing?
@@ -352,6 +484,7 @@ def self.load_initfile
           "a flat application and have not specified the init file. If you " \
           "are trying to create a new merb application, use merb-gen app."
       end
+      nil
     end
 end
 
@@ -364,6 +497,11 @@ class Merb::BootLoader::MixinSession  Merb::BootLoader
   #
   # Note: access to Merb::Config is needed, so it needs to run after
   # Merb::BootLoader::Dependencies is done.
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api plugin
   def self.run
     require 'merb-core/dispatch/session'
     Merb::Controller.send(:include, ::Merb::SessionMixin)
@@ -376,8 +514,14 @@ class Merb::BootLoader::BeforeAppLoads  Merb::BootLoader
 
   # Call any before_app_loads hooks that were registered via before_app_loads
   # in any plugins.
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api plugin
   def self.run
     Merb::BootLoader.before_load_callbacks.each { |x| x.call }
+    nil
   end
 end
 
@@ -396,6 +540,18 @@ class Merb::BootLoader::LoadClasses  Merb::BootLoader
   class  self
 
     # Load all classes from Merb's native load paths.
+    #
+    # If fork-based loading is used, every time classes are loaded this will return in a new spawner process
+    # and boot loading will continue from this point in the boot loading process.
+    #
+    # If fork-based loading is not in use, this only returns once and does not fork a new
+    # process.
+    #
+    # ==== Returns
+    # Returns at least once:
+    #   nil
+    #
+    # @api plugin
     def run
       # Add models, controllers, helpers and lib to the load path
       unless @ran
@@ -432,17 +588,37 @@ def run
       end
 
       Merb::Controller.send :include, Merb::GlobalHelpers
+      
+      nil
     end
 
-    # Wait for workers to exit, remove the "main" PID, and exit.
+    # Wait for any children to exit, remove the "main" PID, and
+    # exit.
+    #
+    # ==== Returns
+    # (Does not return.)
+    #
+    # @api private
     def exit_gracefully
       Process.waitall
       Merb::Server.remove_pid("main")
       exit
     end
 
-    # If using fork-based code reloading, set up the BEGIN
-    # point and set up any signals in the parent and worker.
+    # Set up the BEGIN point for fork-based loading and sets up 
+    # any signals in the parent and child. This is done by forking
+    # the app. The child process continues on to run the app. The parent
+    # process waits for the child process to finish and either forks again
+    # 
+    #
+    # ==== Returns
+    # Parent Process:
+    #   (Does not return.)
+    # Child Process returns at least once:
+    #   nil
+    #
+    # @api private
+
     def start_transaction
       Merb.logger.warn! "Parent pid: #{Process.pid}"
       reader, writer = nil, nil
@@ -535,7 +711,13 @@ def start_transaction
     # of 128 when a master process exists will cause the
     # spawner process to be recreated, and the app code reloaded.
     #
-    # @param statusInteger The status code to exit with
+    # ==== Parameters
+    # statusInteger:: The status code to exit with. Defaults to 0.
+    #
+    # ==== Returns
+    # (Does not return.)
+    #
+    # @api private
     def reap_workers(status = 0)
       Merb.exiting = true unless status == 128
 
@@ -559,8 +741,15 @@ def reap_workers(status = 0)
       exit(status)
     end
 
+    # Loads a file, tracking its modified time and, if necessary, the classes it declared.
+    #
     # ==== Parameters
     # fileString:: The file to load.
+    #
+    # ==== Returns
+    # nil
+    #
+    # @api private
     def load_file(file)
       # Don't do this expensive operation unless we need to
       unless Merb::Config[:fork_for_class_load]
@@ -583,12 +772,20 @@ def load_file(file)
       unless Merb::Config[:fork_for_class_load]
         LOADED_CLASSES[file] = ObjectSpace.classes - klasses
       end
+      
+      nil
     end
 
     # Load classes from given paths - using path/glob pattern.
     #
+    # ==== Parameters
     # *pathsArray::
     #   Array of paths to load classes from - may contain glob pattern
+    #
+    # ==== Returns
+    # nil
+    #
+    # @api private
     def load_classes(*paths)
       orphaned_classes = []
       paths.flatten.each do |path|
@@ -602,9 +799,22 @@ def load_classes(*paths)
       end
       load_classes_with_requirements(orphaned_classes)
     end
-
+    
+    # Reloads the classes in the specified file. If fork-based loading is used,
+    # this causes the current processes to be killed and and all classes to be
+    # reloaded. If class-based loading is not in use, the classes declared in that file
+    # are removed and the file is reloaded.
+    #
     # ==== Parameters
     # fileString:: The file to reload.
+    #
+    # ==== Returns
+    # When fork-based loading is used:
+    #   (Does not return.)
+    # When fork-based loading is not in use:
+    #   nil
+    #
+    # @api private
     def reload(file)
       if Merb::Config[:fork_for_class_load]
         reap_workers(128)
@@ -613,9 +823,20 @@ def reload(file)
       end
     end
 
+    # Removes all classes declared in the specified file. Any hashes which use classes as keys
+    # will be protected provided they have been added to Merb.klass_hashes. These hashes have their
+    # keys substituted with placeholders before the file's classes are unloaded. If a block is provided,
+    # it is called before the substituted keys are reconstituted.
+    #
     # ==== Parameters
     # fileString:: The file to remove classes for.
-    # &block:: A block to call with the file that has been removed.
+    # &block:: A block to call with the file that has been removed before klass_hashes are updated
+    # to use the current values of the constants they used as keys.
+    #
+    # ==== Returns
+    # nil
+    #
+    # @api private
     def remove_classes_in_file(file, &block)
       Merb.klass_hashes.each { |x| x.protect_keys! }
       if klasses = LOADED_CLASSES.delete(file)
@@ -623,15 +844,26 @@ def remove_classes_in_file(file, &block)
       end
       yield file if block_given?
       Merb.klass_hashes.each {|x| x.unprotect_keys!}
+      nil
     end
 
+    # Removes the specified class. 
+    #
+    # Additionally, removes the specified class from the subclass list of every superclass that
+    # tracks it's subclasses in an array returned by _subclasses_list. Classes that wish to use this
+    # functionality are required to alias the reader for their list of subclasses
+    # to _subclasses_list. Plugins for ORMs and other libraries should keep this in mind.
+    #
     # ==== Parameters
     # constClass:: The class to remove.
+    #
+    # ==== Returns
+    # nil
+    #
+    # @api private
     def remove_constant(const)
       # This is to support superclasses (like AbstractController) that track
-      # their subclasses in a class variable. Classes that wish to use this
-      # functionality are required to alias it to _subclasses_list. Plugins
-      # for ORMs and other libraries should keep this in mind.
+      # their subclasses in a class variable.
       superklass = const
       until (superklass = superklass.superclass).nil?
         if superklass.respond_to?(:_subclasses_list)
@@ -649,16 +881,22 @@ def remove_constant(const)
       rescue NameError
         Merb.logger.debug("Failed to remove constant #{object} from #{base}")
       end
+      nil
     end
 
     private
 
-    # "Better loading" of classes.  If a class fails to load due to a NameError
+    # "Better loading" of classes.  If a file fails to load due to a NameError
     # it will be added to the failed_classes and load cycle will be repeated unless
     # no classes load.
     #
     # ==== Parameters
     # klassesArray[Class]:: Classes to load.
+    #
+    # ==== Returns
+    # nil
+    #
+    # @api private
     def load_classes_with_requirements(klasses)
       klasses.uniq!
 
@@ -696,26 +934,35 @@ def load_classes_with_requirements(klasses)
         end
         break if(klasses.size == size_at_start || klasses.size == 0)
       end
+      
+      nil
     end
 
   end
 
 end
 
+# Loads the router file. This needs to happen after everything else is loaded while merb is starting up to ensure
+# the router has everything it needs to run.
 class Merb::BootLoader::Router  Merb::BootLoader
   class  self
-
+    
+    # load the router file
+    #
+    # ==== Returns
+    # nil
+    #
+    # @api plugin
     def run
       Merb::BootLoader::LoadClasses.load_file(router_file) if router_file
+      
+      nil
     end
 
-    def reload!
-      if router_file
-        Merb::Router.reset!
-        Merb::BootLoader::LoadClasses.reload(router_file)
-      end
-    end
-
+    # Tries to find the router file.
+    #
+    # ==== Returns
+    # String:: The path to the router file if it exists, nil otherwise.
     def router_file
       @router_file ||= begin
         if File.file?(router = Merb.dir_for(:router) / Merb.glob_for(:router))
@@ -727,18 +974,28 @@ def router_file
   end
 end
 
+# Precompiles all non-partial templates.
 class Merb::BootLoader::Templates  Merb::BootLoader
   class  self
 
-    # Loads the templates into the Merb::InlineTemplates module.
+    # Loads all non-partial templates into the Merb::InlineTemplates module.
+    #
+    # ==== Returns
+    # Array[String]:: The list of template files which were loaded.
+    #
+    # @api plugin
     def run
       template_paths.each do |path|
         Merb::Template.inline_template(File.open(path))
       end
     end
 
+    # Finds a list of templates to load.
+    #
     # ==== Returns
-    # Array[String]:: Template files found.
+    # Array[String]:: All found template files whose basename does not begin with "_".
+    #
+    # @api private
     def template_paths
       extension_glob = "{#{Merb::Template.template_extensions.join(',')}}"
 
@@ -777,6 +1034,11 @@ def template_paths
 class Merb::BootLoader::MimeTypes  Merb::BootLoader
 
   # Registers the default MIME types.
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api plugin
   def self.run
     Merb.add_mime_type(:all,  nil,      %w[*/*])
     Merb.add_mime_type(:yaml, :to_yaml, %w[application/x-yaml text/yaml], :charset = "utf-8")
@@ -785,15 +1047,24 @@ def self.run
     Merb.add_mime_type(:xml,  :to_xml,  %w[application/xml text/xml application/x-xml], {:charset = "utf-8"}, 0.9998)
     Merb.add_mime_type(:js,   :to_json, %w[text/javascript application/javascript application/x-javascript], :charset = "utf-8")
     Merb.add_mime_type(:json, :to_json, %w[application/json text/x-json], :charset = "utf-8")
+    nil
   end
 end
 
+# Set up cookies support in Merb::Controller and Merb::Request
 class Merb::BootLoader::Cookies  Merb::BootLoader
 
+  # Set up cookies support in Merb::Controller and Merb::Request
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api plugin
   def self.run
     require 'merb-core/dispatch/cookies'
     Merb::Controller.send(:include, Merb::CookiesMixin)
     Merb::Request.send(:include, Merb::CookiesMixin::RequestMixin)
+    nil
   end
 
 end
@@ -802,6 +1073,11 @@ class Merb::BootLoader::SetupSession  Merb::BootLoader
 
   # Enable the configured session container(s); any class that inherits from
   # SessionContainer will be considered by its session_store_type attribute.
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api plugin
   def self.run
     # Require all standard session containers.
     Dir[Merb.framework_root / "merb-core" / "dispatch" / "session" / "*.rb"].each do |file|
@@ -826,6 +1102,7 @@ def self.run
 
     # Mixin the Merb::Session module to add app-level functionality to sessions
     Merb::SessionContainer.send(:include, Merb::Session)
+    nil
   end
 
 end
@@ -834,14 +1111,26 @@ class Merb::BootLoader::AfterAppLoads  Merb::BootLoader
 
   # Call any after_app_loads hooks that were registered via after_app_loads in
   # init.rb.
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api plugin
   def self.run
     Merb::BootLoader.after_load_callbacks.each {|x| x.call }
+    nil
   end
 end
 
 # In case someone's running a sparse app, the default exceptions require the
 # Exceptions class.
 class Merb::BootLoader::SetupStubClasses  Merb::BootLoader
+  # Declares empty Application and Exception controllers.
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api plugin
   def self.run
     unless defined?(Exceptions)
       Object.class_eval -RUBY
@@ -853,23 +1142,47 @@ class Exceptions  Application
         end
       RUBY
     end
+    nil
   end
 end
 
 class Merb::BootLoader::ChooseAdapter  Merb::BootLoader
 
   # Choose the Rack adapter/server to use and set Merb.adapter.
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api plugin
   def self.run
     Merb.adapter = Merb::Rack::Adapter.get(Merb::Config[:adapter])
   end
 end
 
+class Merb::BootLoader::StartWorkerThread  Merb::BootLoader
+
+  # Starts the worker thread used by the run_later helper.
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api plugin
+  def self.run
+    Merb::Worker.start
+  end
+end
+
 class Merb::BootLoader::RackUpApplication  Merb::BootLoader
   # Setup the Merb Rack App or read a rackup file located at
   # Merb::Config[:rackup] with the same syntax as the
   # rackup tool that comes with rack. Automatically evals the file in
   # the context of a Rack::Builder.new { } block. Allows for mounting
   # additional apps or middleware.
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api plugin
   def self.run
     require 'rack'
     if File.exists?(Merb.dir_for(:config) / "rack.rb")
@@ -888,13 +1201,24 @@ def self.run
          run Merb::Rack::Application.new
        }.to_app
     end
-
+    
+    nil
   end
 end
 
 class Merb::BootLoader::ReloadClasses  Merb::BootLoader
 
   class TimedExecutor
+    # Executes the associated block every @seconds@ seconds in a separate thread.
+    #
+    # ==== Parameters
+    # secondsInteger:: Number of seconds to sleep in between runs of &block.
+    # &block:: The block to execute periodically.
+    #
+    # ==== Returns
+    # Thread:: The thread executing the block periodically.
+    #
+    # @api private
     def self.every(seconds, &block)
       Thread.abort_on_exception = true
       Thread.new do
@@ -907,7 +1231,14 @@ def self.every(seconds, &block)
     end
   end
 
-  # Setup the class reloader if it's been specified in config.
+  # Set up the class reloader if class reloading is enabled. This checks periodically 
+  # for modifications to files loaded by the LoadClasses BootLoader and reloads them
+  # when they are modified.
+  # 
+  # ==== Returns
+  # nil
+  #
+  # @api plugin
   def self.run
     return unless Merb::Config[:reload_classes]
 
@@ -928,10 +1259,16 @@ def self.run
       GC.start
       reload(paths)
     end
-
+    
+    nil
   end
 
-  # Reloads all files.
+  # Reloads all files which have been modified since they were last loaded.
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api private
   def self.reload(paths)
     paths.each do |file|
       next if LoadClasses::MTIMES[file] &&
@@ -939,5 +1276,7 @@ def self.reload(paths)
 
       LoadClasses.reload(file)
     end
+    
+    nil
   end
 end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/config.rb</file_name>
					<diff>@@ -6,8 +6,12 @@ class Config
 
     class  self
 
+      # Returns the hash of default config values for Merb.
+      #
       # ==== Returns
       # Hash:: The defaults for the config.
+      #
+      # @api private
       def defaults
         @defaults ||= {
           :host                   = "0.0.0.0",
@@ -39,29 +43,45 @@ def defaults
       #     config[:exception_details] = false
       #     config[:log_stream]        = STDOUT
       #   end
+      #
+      # ==== Returns
+      # nil
+      #
+      # @api public
       def use
         @configuration ||= {}
         yield @configuration
+        nil
       end
-
+      
+      # Detects whether the provided key is in the config.
+      #
       # ==== Parameters
       # keyObject:: The key to check.
       #
       # ==== Returns
       # Boolean:: True if the key exists in the config.
+      #
+      # @api public
       def key?(key)
         @configuration.key?(key)
       end
 
+      # Retrieve the value of a config entry.
+      #
       # ==== Parameters
       # keyObject:: The key to retrieve the parameter for.
       #
       # ==== Returns
       # Object:: The value of the configuration parameter.
+      #
+      # @api public
       def [](key)
         (@configuration ||= setup)[key]
       end
 
+      # Set the value of a config entry.
+      #
       # ==== Parameters
       # keyObject:: The key to set the parameter for.
       # valObject:: The value of the parameter.
@@ -69,12 +89,21 @@ def []=(key, val)
         (@configuration ||= setup)[key] = val
       end
 
+      # Remove the value of a config entry.
+      #
       # ==== Parameters
       # keyObject:: The key of the parameter to delete.
+      #
+      # ==== Returns
+      # Object:: The value of the removed entry.
+      #
+      # @api public
       def delete(key)
         @configuration.delete(key)
       end
 
+      # Retrieve the value of a config entry, returning the provided default if the key is not present
+      #
       # ==== Parameters
       # keyObject:: The key to retrieve the parameter for.
       # defaultObject::
@@ -86,14 +115,22 @@ def fetch(key, default)
         @configuration.fetch(key, default)
       end
 
+      # Returns the configuration as a hash.
+      #
       # ==== Returns
       # Hash:: The config as a hash.
+      #
+      # @api public
       def to_hash
         @configuration
       end
 
+      # Returns the config as YAML.
+      #
       # ==== Returns
       # String:: The config as YAML.
+      #
+      # @api public
       def to_yaml
         require "yaml"
         @configuration.to_yaml
@@ -104,6 +141,11 @@ def to_yaml
       # ==== Parameters
       # settingsHash::
       #   Configuration settings to use. These are merged with the defaults.
+      #
+      # ==== Returns
+      # The configuration as a hash.
+      #
+      # @api private
       def setup(settings = {})
         @configuration = defaults.merge(settings)
         
@@ -118,6 +160,11 @@ def setup(settings = {})
       #
       # ==== Parameters
       # argvString:: The command line arguments. Defaults to +ARGV+.
+      #
+      # ==== Returns
+      # The configuration as a hash.
+      #
+      # @api private
       def parse_args(argv = ARGV)
         @configuration ||= {}
         # Our primary configuration hash for the length of this method
@@ -352,8 +399,14 @@ def parse_args(argv = ARGV)
       #     log_level   "debug"
       #     log_file    Merb.root / "log" / "special.log"
       #   end
+      #
+      # ==== Returns
+      # nil
+      #
+      # @api public
       def configure(&block)
         ConfigBlock.new(self, &block) if block_given?
+        nil
       end
 
       # Allows retrieval of single key config values via Merb.config.key
@@ -362,6 +415,11 @@ def configure(&block)
       # ==== Parameters
       # method~to_s:: Method name as hash key value.
       # *args:: Value to set the configuration parameter to.
+      #
+      # ==== Returns
+      # The value of the entry fetched or assigned to.
+      #
+      # @api public
       def method_missing(method, *args)
         if method.to_s[-1,1] == '='
           @configuration[method.to_s.tr('=','').to_sym] = *args
@@ -374,11 +432,26 @@ def method_missing(method, *args)
 
     class ConfigBlock
 
+      # Evaluates the provided block, where any call to a method causes
+      # #[]= to be called on klass with the method name as the key and the arguments
+      # as the value.
+      #
+      # ==== Parameters
+      # klassObject~[]=:: The object on which to assign values.
+      # &block:: The block which specifies the config values to set.
+      #
+      # ==== Returns
+      # nil
+      #
+      # @api private
       def initialize(klass, &block)
         @klass = klass
         instance_eval(&block)
       end
 
+      # Assign args as the value of the entry keyed by method.
+      #
+      # @api private
       def method_missing(method, *args)
         @klass[method] = *args
       end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/controller/abstract_controller.rb</file_name>
					<diff>@@ -124,12 +124,13 @@ class Merb::AbstractController
 
   # ==== Returns
   # String:: The controller name in path form, e.g. "admin/items".
-  #---
-  # @public
+  # @api public
   def self.controller_name() @controller_name ||= self.name.to_const_path end
 
   # ==== Returns
   # String:: The controller name in path form, e.g. "admin/items".
+  #
+  # @api public
   def controller_name()      self.class.controller_name                   end
   
   # This is called after the controller is instantiated to figure out where to
@@ -138,9 +139,9 @@ def controller_name()      self.class.controller_name                   end
   #
   # ==== Parameters
   # context~to_s:: The controller context (the action or template name).
-  # type~to_s:: The content type. Defaults to nil.
+  # type~to_s:: The content type. Could be nil. 
   # controller~to_s::
-  #   The name of the controller. Defaults to controller_name.
+  #   The name of the controller. Defaults to being called with the controller_name.  Set t
   #
   #
   # ==== Returns
@@ -160,29 +161,41 @@ def controller_name()      self.class.controller_name                   end
   #
   # This would look for templates at controller.action.mime.type instead
   # of controller/action.mime.type
-  #---
-  # @public
+  #
+  # @api public
+  # @overridable
   def _template_location(context, type, controller)
     controller ? "#{controller}/#{context}" : context
   end
 
-  # The location to look for a template - stub method for particular behaviour.
+  # The location to look for a template - override this method for particular behaviour. 
   #
   # ==== Parameters
   # templateString:: The absolute path to a template - without template extension.
   # type~to_s::
-  #    The mime-type of the template that will be rendered. Defaults to nil.
+  #    The mime-type of the template that will be rendered. Defaults to being called with nil.
   #
-  # @public
+  # @api public
+  # @overridable
   def _absolute_template_location(template, type)
     template
   end
 
+  # Resets the template roots to the template root passed in.
+  #
+  # ==== Parameters
+  # root~to_s:: 
+  #   The new path to set the template root to.  
+  #
+  # @api public
   def self._template_root=(root)
     @_template_root = root
     _reset_template_roots
   end
 
+  # Reset the template root based on the @_template_root ivar.
+  #
+  # @api private
   def self._reset_template_roots
     self.template_roots = [[self._template_root, :_template_location]]
   end
@@ -191,6 +204,8 @@ def self._reset_template_roots
   # rootsArray[Array]::
   #   Template roots as pairs of template root path and template location
   #   method.
+  #
+  # @api unknown
   def self._template_roots
     self.template_roots || _reset_template_roots
   end
@@ -199,45 +214,62 @@ def self._template_roots
   # rootsArray[Array]::
   #   Template roots as pairs of template root path and template location
   #   method.
+  #
+  # @api unknown
   def self._template_roots=(roots)
     self.template_roots = roots
   end
   
+  # Returns the list of classes that have specifically subclassed AbstractController.  
+  # Does not include all decendents.  
+  #
   # ==== Returns
   # Set:: The subclasses.
+  #
+  # @api private
   def self.subclasses_list() _abstract_subclasses end
   
-  class  self
-    # ==== Parameters
-    # klassMerb::AbstractController::
-    #   The controller that is being inherited from Merb::AbstractController
-    def inherited(klass)
-      _abstract_subclasses  klass.to_s
-      helper_module_name = klass.to_s =~ /^(#|Merb::)/ ? "#{klass}Helper" : "Merb::#{klass}Helper"
-      Object.make_module helper_module_name
-      klass.class_eval -HERE
-        include Object.full_const_get("#{helper_module_name}") rescue nil
-      HERE
-      super
-    end    
-  end
+  # ==== Parameters
+  # klassMerb::AbstractController::
+  #   The controller that is being inherited from Merb::AbstractController
+  #
+  # @api private
+  def self.inherited(klass)
+    _abstract_subclasses  klass.to_s
+    helper_module_name = klass.to_s =~ /^(#|Merb::)/ ? "#{klass}Helper" : "Merb::#{klass}Helper"
+    Object.make_module helper_module_name
+    klass.class_eval -HERE
+      include Object.full_const_get("#{helper_module_name}") rescue nil
+    HERE
+    super
+  end    
   
+  # This will initialize the controller, it is designed to be overridden in subclasses (like MerbController)
   # ==== Parameters
-  # *args:: The args are ignored.
+  # *args:: The args are ignored in this class, but we need this so that subclassed initializes can have parameters
+  #
+  # @overridable
   def initialize(*args)
     @_benchmarks = {}
     @_caught_content = {}
   end
   
-  # This will dispatch the request, calling internal before/after dispatch_callbacks
+  # This will dispatch the request, calling internal before/after dispatch callbacks.  
+  # If the return value of _call_filters is not :filter_chain_completed the action is not called, and the return from the filters is used instead. 
   # 
   # ==== Parameters
   # action~to_s::
   #   The action to dispatch to. This will be #send'ed in _call_action.
   #   Defaults to :to_s.
   #
+  # ==== Returns
+  # ~to_s::
+  #   Returns the string that was returned from the action. 
+  #
   # ==== Raises
-  # MerbControllerError:: Invalid body content caught.
+  # ArgumentError:: Invalid result caught from before filters.
+  #
+  # @api plugin
   def _dispatch(action)
     self._before_dispatch_callbacks.each { |cb| cb.call(self) }
     self.action_name = action
@@ -252,7 +284,8 @@ def _dispatch(action)
     @body = case caught
     when :filter_chain_completed  then _call_action(action_name)
     when String                   then caught
-    when nil                      then _filters_halted
+    # return *something* if you throw halt with nothing
+    when nil                      then "htmlbodyh1Filter Chain Halted!/h1/body/html"
     when Symbol                   then __send__(caught)
     when Proc                     then self.instance_eval(&caught)
     else
@@ -267,14 +300,19 @@ def _dispatch(action)
     @body
   end
   
-  # This method exists to provide an overridable hook for ActionArgs
+  # This method exists to provide an overridable hook for ActionArgs.  It uses #send to call the action method.
   #
   # ==== Parameters
   # action~to_s:: the action method to dispatch to
+  #
+  # @api plugin
+  # @overridable
   def _call_action(action)
     send(action)
   end
   
+  # Calls a filter chain. 
+  #
   # ==== Parameters
   # filter_setArray[Filter]::
   #   A set of filters in the form [[:filter, rule], [:filter, rule]]
@@ -290,6 +328,8 @@ def _call_action(action)
   # Procs::
   #   Execute the +Proc+, in the context of the controller (self will be the
   #   controller)
+  #
+  # @api private
   def _call_filters(filter_set)
     (filter_set || []).each do |filter, rule|
       if _call_filter_for_action?(rule, action_name) && _filter_condition_met?(rule)
@@ -308,6 +348,8 @@ def _call_filters(filter_set)
     return :filter_chain_completed
   end
 
+  # Determine whether the filter should be called for the current action using :only and :exclude.
+  #
   # ==== Parameters
   # ruleHash:: Rules for the filter (see below).
   # action_name~to_s:: The name of the action to be called.
@@ -322,6 +364,8 @@ def _call_filters(filter_set)
   #
   # ==== Returns
   # Boolean:: True if the action should be called.
+  #
+  # @api private
   def _call_filter_for_action?(rule, action_name)
     # Both:
     # * no :only or the current action is in the :only list
@@ -330,6 +374,8 @@ def _call_filter_for_action?(rule, action_name)
     (!rule.key?(:exclude) || !rule[:exclude].include?(action_name))
   end
 
+  # Determines whether the filter should be run based on the conditions passed (:if and :unless)
+  #
   # ==== Parameters
   # ruleHash:: Rules for the filter (see below).
   #
@@ -340,6 +386,8 @@ def _call_filter_for_action?(rule, action_name)
   #
   # ==== Returns
   # Boolean:: True if the conditions are met.
+  #
+  # @api private
   def _filter_condition_met?(rule)
     # Both:
     # * no :if or the if condition evaluates to true
@@ -348,6 +396,8 @@ def _filter_condition_met?(rule)
     (!rule.key?(:unless) || ! _evaluate_condition(rule[:unless]))
   end
 
+  # Evaluates a filter condition (:if or :unless)
+  #
   # ==== Parameters
   # conditionSymbol, Proc:: The condition to evaluate.
   #
@@ -360,6 +410,8 @@ def _filter_condition_met?(rule)
   # ==== Alternatives
   # If condition is a symbol, it will be send'ed. If it is a Proc it will be
   # called directly with self as an argument.
+  #
+  # @api private
   def _evaluate_condition(condition)
     case condition
     when Symbol : self.send(condition)
@@ -370,6 +422,7 @@ def _evaluate_condition(condition)
     end
   end
 
+  # Adds a filter to the after filter chain
   # ==== Parameters
   # filterSymbol, Proc:: The filter to add. Defaults to nil.
   # optsHash::
@@ -377,11 +430,15 @@ def _evaluate_condition(condition)
   # &block:: A block to use as a filter if filter is nil.
   #
   # ==== Notes
-  # If the filter already exists, its options will be replaced with opts.
+  # If the filter already exists, its options will be replaced with opts.;
+  #
+  # @api public
   def self.after(filter = nil, opts = {}, &block)
     add_filter(self._after_filters, filter || block, opts)
   end
 
+  # Adds a filter to the before filter chain.  
+  #
   # ==== Parameters
   # filterSymbol, Proc:: The filter to add. Defaults to nil.
   # optsHash::
@@ -390,44 +447,90 @@ def self.after(filter = nil, opts = {}, &block)
   #
   # ==== Notes
   # If the filter already exists, its options will be replaced with opts.
+  #
+  # @api public
   def self.before(filter = nil, opts = {}, &block)
     add_filter(self._before_filters, filter || block, opts)
   end
      
-  # Skip an after filter that has been previously defined (perhaps in a
-  # superclass)
+  # Removes a filter from the after filter chain.  This removes the 
+  # filter from the filter chain for the whole controller and does not 
+  # take any options. 
   #
   # ==== Parameters
-  # filterSymbol:: A filter name to skip.
+  # filterSymbol, String:: A filter name to skip.
+  #
+  # @api public
   def self.skip_after(filter)
     skip_filter(self._after_filters, filter)
   end
   
-  # Skip a before filter that has been previously defined (perhaps in a
-  # superclass).
+  # Removes a filter from the before filter chain.  This removes the 
+  # filter from the filter chain for the whole controller and does not 
+  # take any options.
   #
   # ==== Parameters
-  # filterSymbol:: A filter name to skip.
+  # filterSymbol, String:: A filter name to skip.
+  #
+  # @api public
   def self.skip_before(filter)
     skip_filter(self._before_filters , filter)
   end  
-  
-  #---
-  # Defaults that can be overridden by plugins, other mixins, or subclasses
-  def _filters_halted()   "htmlbodyh1Filter Chain Halted!/h1/body/html"  end
-  
-  # ==== Parameters
-  # name~to_sym, Hash:: The name of the URL to generate.
-  # rparamsHash:: Parameters for the route generation.
+
+  # There are three possible ways to use this method.  First, if you have a named route, 
+  # you can specify the route as the first parameter as a symbol and any paramters in a 
+  # hash.  Second, you can generate the default route by just passing the params hash, 
+  # just passing the params hash.  Finally, you can use the anonymous parameters.  This 
+  # allows you to specify the parameters to a named route in the order they appear in the 
+  # router.  
+  #
+  # ==== Parameters(Named Route)
+  # nameSymbol:: 
+  #   The name of the route. 
+  # argsHash:: 
+  #   Parameters for the route generation.
+  #
+  # ==== Parameters(Default Route)
+  # argsHash:: 
+  #   Parameters for the route generation.  This route will use the default route. 
+  #
+  # ==== Parameters(Anonymous Parameters)
+  # nameSymbol::
+  #   The name of the route.  
+  # argsArray:: 
+  #   An array of anonymous parameters to generate the route
+  #   with. These parameters are assigned to the route parameters
+  #   in the order that they are passed.
   #
   # ==== Returns
   # String:: The generated URL.
   #
-  # ==== Alternatives
-  # If a hash is used as the first argument, a default route will be
-  # generated based on it and rparams.
-  # ====
-  # TODO: Update this documentation
+  # ==== Examples
+  # Named Route
+  #
+  # Merb::Router.prepare do
+  #   match("/articles/:title").to(:controller = :articles, :action = :show).name("articles")
+  # end
+  #
+  # url(:articles, :title = "new_article")
+  #
+  # Default Route
+  #
+  # Merb::Router.prepare do
+  #   default_routes
+  # end
+  #
+  # url(:controller = "articles", :action = "new")
+  #
+  # Anonymous Paramters
+  #
+  # Merb::Router.prepare do
+  #   match("/articles/:year/:month/:title").to(:controller = :articles, :action = :show).name("articles")
+  # end
+  #
+  # url(:articles, 2008, 10, "test_article")
+  #
+  # @api public
   def url(name, *args)
     args  {}
     Merb::Router.url(name, *args)
@@ -435,22 +538,12 @@ def url(name, *args)
   
   alias_method :relative_url, :url
 
-  # ==== Parameters
-  # name~to_sym, Hash:: The name of the URL to generate.
-  # rparamsHash:: Parameters for the route generation.
-  #
-  # ==== Returns
-  # String:: The generated url with protocol + hostname + URL.
-  #
-  # ==== Options
-  #
-  # :protocol and :host options are special: use them to explicitly
-  # specify protocol and host of resulting url. If you omit them,
-  # protocol and host of request are used.
+  # Returns the absolute url including the passed protocol and host.  
+  # 
+  # This uses the same arguments as the url method, with added requirements 
+  # of protocol and host options. 
   #
-  # ==== Alternatives
-  # If a hash is used as the first argument, a default route will be
-  # generated based on it and rparams.
+  # @api public
   def absolute_url(name, *args)
     # FIXME: arrgh, why request.protocol returns http://?
     # :// is not part of protocol name
@@ -494,8 +587,9 @@ def absolute_url(name, *args)
   # resource(:users, :new)      # = /users/new
   # resource(:@user, :edit)     # = /users/10/edit
   #
+  # @api public
   def resource(*args)
-    args  params
+    args  {}
     Merb::Router.resource(*args)
   end
 
@@ -507,6 +601,8 @@ def resource(*args)
   #
   # ==== Returns
   # String:: The output of a template block or the return value of a non-template block converted to a string.
+  #
+  # @api public
   def capture(*args, &block)
     ret = nil
 
@@ -523,13 +619,16 @@ def capture(*args, &block)
   # ==== Parameters
   # strString:: The string to concatenate to the buffer.
   # bindingBinding:: The binding to use for the buffer.
+  #
+  # @api public
   def concat(str, binding)
     send("concat_#{@_engine}", str, binding)
   end
 
   private
+  # adds a filter to the specified filter chain
   # ==== Parameters
-  # filtersArray[Filter]:: The filter list that this should be added to.
+  # filtersArray[Filter]:: The filter chain that this should be added to.
   # filterFilter:: A filter that should be added.
   # optsHash::
   #   Filter options (see class documentation under ttFilter Options/tt).
@@ -538,6 +637,8 @@ def concat(str, binding)
   # ArgumentError::
   #   Both :only and :exclude, or :if and :unless given, if filter is not a
   #   Symbol, String or Proc, or if an unknown option is passed.
+  #
+  # @api private
   def self.add_filter(filters, filter, opts={})
     raise(ArgumentError,
       "You can specify either :only or :exclude but 
@@ -576,11 +677,13 @@ def self.add_filter(filters, filter, opts={})
   # inheritence hierarchies.
   #
   # ==== Parameters
-  # filtersArray[Filter]:: The filter list that this should be removed from.
+  # filtersArray[Filter]:: The filter chain that this should be removed from.
   # filterFilter:: A filter that should be removed.
   #
   # ==== Raises
   # ArgumentError:: filter not Symbol or String.
+  #
+  # @api private
   def self.skip_filter(filters, filter)
     raise(ArgumentError, 'You can only skip filters that have a String or Symbol name.') unless
       [Symbol, String].include? filter.class
@@ -600,6 +703,8 @@ def self.skip_filter(filters, filter)
   #
   # ==== Examples
   #   normalize_filters!(:only = :new) #= {:only = [:new]}
+  #
+  # @api public
   def self.normalize_filters!(opts={})
     opts[:only]     = Array(opts[:only]).map {|x| x.to_s} if opts[:only]
     opts[:exclude]  = Array(opts[:exclude]).map {|x| x.to_s} if opts[:exclude]</diff>
				</file>
				<file>
					<file_name>lib/merb-core/controller/exceptions.rb</file_name>
					<diff>@@ -1,12 +1,35 @@
 class Exception
+  # Returns the action_name that will be invoked on your Exceptions controller when this
+  # exception is raised. Override this method to force a different action to be invoked.
+  #
+  # ==== Returns
+  # String:: The name of the action in the Exceptions controller which will get invoked
+  #   when this exception is raised during a request.
+  # 
+  # @api public
+  # @overridable
   def action_name() self.class.action_name end
   
+  
+  # ==== Returns
+  # Boolean:: Whether or not this exception is the same as another.
+  #
+  # @api public
   def same?(other)
     self.class == other.class &&
     self.message == other.message &&
     self.backtrace == other.backtrace
   end
   
+  # Returns the action_name that will be invoked on your Exceptions controller when an instance
+  # is raised during a request.
+  #
+  # ==== Returns
+  # String:: The name of the action in the Exceptions controller which will get invoked
+  #   when an instance of this Exception sub/class is raised by an action.
+  # 
+  # @api public
+  # @overridable
   def self.action_name
     if self == Exception
       return nil unless Object.const_defined?(:Exceptions) && 
@@ -17,6 +40,14 @@ def self.action_name
       Exceptions.method_defined?(name) ? name : superclass.action_name
   end
   
+  # The status that will be sent in the response when an instance is
+  # raised during a request. Override this to send a different status.
+  #
+  # ==== Returns
+  # Integer:: The status code to send in the response. Defaults to 500.
+  #
+  # @api public
+  # @overridable
   def self.status
     500
   end
@@ -135,6 +166,8 @@ class  self
         #
         # ==== Returns
         # Fixnum:: The status code of this exception.
+        #
+        # @api public
         def status
           const_get(:STATUS) rescue 0
         end
@@ -147,6 +180,11 @@ def status
         #
         # ==== Parameters
         # num~to_i:: The status code
+        #
+        # ==== Returns
+        # (Integer, nil):: The status set on this exception, or nil if a status was already set.
+        #
+        # @api private
         def status=(num)
           unless self.status?
             register_status_code(self, num)
@@ -157,7 +195,9 @@ def status=(num)
         # See if a status-code has been defined (on self explicitly).
         #
         # ==== Returns
-        # Boolean:: Whether the a status code has been set
+        # Boolean:: Whether a status code has been set
+        #
+        # @api private
         def status?
           self.const_defined?(:STATUS)
         end
@@ -172,6 +212,8 @@ def status?
         # 
         # subclassMerb::ControllerExceptions::Base::
         #   The Exception class that is inheriting from Merb::ControllerExceptions::Base
+        #
+        # @api public
         def inherited(subclass)
           # don't set the constant yet - any class methods will be called after self.inherited
           # unless self.status = ... is set explicitly, the status code will be inherited
@@ -184,6 +226,8 @@ def inherited(subclass)
         #
         # ==== Parameters
         # num~to_i:: The status code
+        #
+        # @api privaate
         def register_status_code(klass, code)
           name = self.to_s.split('::').last.snake_case
           STATUS_CODES[name.to_sym] = code.to_i</diff>
				</file>
				<file>
					<file_name>lib/merb-core/controller/merb_controller.rb</file_name>
					<diff>@@ -15,104 +15,106 @@ def self.subclasses_list() _subclasses end
   include Merb::AuthenticationMixin
   include Merb::ConditionalGetMixin
 
-  class  self
-
-    # ==== Parameters
-    # klassMerb::Controller::
-    #   The Merb::Controller inheriting from the base class.
-    def inherited(klass)
-      _subclasses  klass.to_s
-      super
-      klass._template_root = Merb.dir_for(:view) unless self._template_root
-    end
+  # ==== Parameters
+  # klassMerb::Controller::
+  #   The Merb::Controller inheriting from the base class.
+  #
+  # @api private
+  def self.inherited(klass)
+    _subclasses  klass.to_s
+    super
+    klass._template_root = Merb.dir_for(:view) unless self._template_root
+  end
 
-    # Hide each of the given methods from being callable as actions.
-    #
-    # ==== Parameters
-    # *names~to-s:: Actions that should be added to the list.
-    #
-    # ==== Returns
-    # Array[String]::
-    #   An array of actions that should not be possible to dispatch to.
-    #
-    #---
-    # @public
-    def hide_action(*names)
-      self._hidden_actions = self._hidden_actions | names.map { |n| n.to_s }
-    end
+  # Hide each of the given methods from being callable as actions.
+  #
+  # ==== Parameters
+  # *names~to-s:: Actions that should be added to the list.
+  #
+  # ==== Returns
+  # Array[String]::
+  #   An array of actions that should not be possible to dispatch to.
+  #
+  # @api public
+  def self.hide_action(*names)
+    self._hidden_actions = self._hidden_actions | names.map { |n| n.to_s }
+  end
 
-    # Makes each of the given methods being callable as actions. You can use
-    # this to make methods included from modules callable as actions.
-    #
-    # ==== Parameters
-    # *names~to-s:: Actions that should be added to the list.
-    #
-    # ==== Returns
-    # Array[String]::
-    #   An array of actions that should be dispatched to even if they would not
-    #   otherwise be.
-    #
-    # ==== Example
-    #   module Foo
-    #     def self.included(base)
-    #       base.show_action(:foo)
-    #     end
-    #
-    #     def foo
-    #       # some actiony stuff
-    #     end
-    #
-    #     def foo_helper
-    #       # this should not be an action
-    #     end
-    #   end
-    #
-    #---
-    # @public
-    def show_action(*names)
-      self._shown_actions = self._shown_actions | names.map {|n| n.to_s}
-    end
+  # Makes each of the given methods being callable as actions. You can use
+  # this to make methods included from modules callable as actions.
+  #
+  # ==== Parameters
+  # *names~to-s:: Actions that should be added to the list.
+  #
+  # ==== Returns
+  # Array[String]::
+  #   An array of actions that should be dispatched to even if they would not
+  #   otherwise be.
+  #
+  # ==== Example
+  #   module Foo
+  #     def self.included(base)
+  #       base.show_action(:foo)
+  #     end
+  #
+  #     def foo
+  #       # some actiony stuff
+  #     end
+  #
+  #     def foo_helper
+  #       # this should not be an action
+  #     end
+  #   end
+  #
+  # @api public
+  def self.show_action(*names)
+    self._shown_actions = self._shown_actions | names.map {|n| n.to_s}
+  end
 
-    # The list of actions that are callable, after taking defaults,
-    # _hidden_actions and _shown_actions into consideration. It is calculated
-    # once, the first time an action is dispatched for this controller.
-    #
-    # ==== Returns
-    # SimpleSet[String]:: A set of actions that should be callable.
-    def callable_actions
-      @callable_actions ||= Extlib::SimpleSet.new(_callable_methods)
-    end
+  # The list of actions that are callable, after taking defaults,
+  # _hidden_actions and _shown_actions into consideration. It is calculated
+  # once, the first time an action is dispatched for this controller.
+  #
+  # ==== Returns
+  # SimpleSet[String]:: A set of actions that should be callable.
+  #
+  # @api public
+  def self.callable_actions
+    @callable_actions ||= Extlib::SimpleSet.new(_callable_methods)
+  end
 
-    # This is a stub method so plugins can implement param filtering if they want.
-    #
-    # ==== Parameters
-    # paramsHash{Symbol = String}:: A list of params
-    #
-    # ==== Returns
-    # Hash{Symbol = String}:: A new list of params, filtered as desired
-    #---
-    # @semipublic
-    def _filter_params(params)
-      params
-    end
+  # This is a stub method so plugins can implement param filtering if they want.
+  #
+  # ==== Parameters
+  # paramsHash{Symbol = String}:: A list of params
+  #
+  # ==== Returns
+  # Hash{Symbol = String}:: A new list of params, filtered as desired
+  # 
+  # @api plugin
+  # @overridable
+  def self._filter_params(params)
+    params
+  end
 
-    private
+  private
 
-    # All methods that are callable as actions.
-    #
-    # ==== Returns
-    # Array:: A list of method names that are also actions
-    def _callable_methods
-      callables = []
-      klass = self
-      begin
-        callables  (klass.public_instance_methods(false) + klass._shown_actions) - klass._hidden_actions
-        klass = klass.superclass
-      end until klass == Merb::AbstractController || klass == Object
-      callables.flatten.reject{|action| action =~ /^_.*/}
-    end
+  # All methods that are callable as actions.
+  #
+  # ==== Returns
+  # Array:: A list of method names that are also actions
+  #
+  # @api private
+  def self._callable_methods
+    callables = []
+    klass = self
+    begin
+      callables  (klass.public_instance_methods(false) + klass._shown_actions) - klass._hidden_actions
+      klass = klass.superclass
+    end until klass == Merb::AbstractController || klass == Object
+    callables.flatten.reject{|action| action =~ /^_.*/}
+  end
 
-  end # class  self
 
   # The location to look for a template for a particular controller, context,
   # and mime-type. This is overridden from AbstractController, which defines a
@@ -124,14 +126,14 @@ def _callable_methods
   #    The mime-type of the template that will be rendered. Defaults to nil.
   # controller~to_s::
   #   The name of the controller that will be rendered. Defaults to
-  #   controller_name.
+  #   controller_name.  This will be "layout" for rendering a layout.  
   #
   # ==== Notes
   # By default, this renders ":controller/:action.:type". To change this,
   # override it in your application class or in individual controllers.
   #
-  #---
-  # @public
+  # @api public
+  # @overridable
   def _template_location(context, type, controller)
     _conditionally_append_extension(controller ? "#{controller}/#{context}" : "#{context}", type)
   end
@@ -148,7 +150,7 @@ def _template_location(context, type, controller)
   # type~to_s::
   #    The mime-type of the template that will be rendered. Defaults to nil.
   #
-  # @public
+  # @api public
   def _absolute_template_location(template, type)
     _conditionally_append_extension(template, type)
   end
@@ -164,8 +166,9 @@ def _absolute_template_location(template, type)
   # headersHash{header = value}::
   #   A hash of headers to start the controller with. These headers can be
   #   overridden later by the #headers method.
-  #---
-  # @semipublic
+  # 
+  # @api plugin
+  # @overridable
   def initialize(request, status=200, headers={'Content-Type' = 'text/html; charset=utf-8'})
     super()
     @request, @_status, @headers = request, status, headers
@@ -181,8 +184,8 @@ def initialize(request, status=200, headers={'Content-Type' = 'text/html; chars
   #
   # ==== Raises
   # ActionNotFound:: The requested action was not found in class.
-  #---
-  # @semipublic
+  #
+  # @api plugin
   def _dispatch(action=:index)
     Merb.logger.info("Params: #{self.class._filter_params(request.params).inspect}")
     start = Time.now
@@ -197,6 +200,10 @@ def _dispatch(action=:index)
 
   attr_reader :request, :headers
 
+  # ==== Returns
+  # Fixnum:: The response status code
+  #
+  # @api public
   def status
     @_status
   end
@@ -205,6 +212,8 @@ def status
   #
   # ==== Parameters
   # sFixnum, Symbol:: A status-code or named http-status
+  #
+  # @api public
   def status=(s)
     if s.is_a?(Symbol) && STATUS_CODES.key?(s)
       @_status = STATUS_CODES[s]
@@ -217,27 +226,112 @@ def status=(s)
 
   # ==== Returns
   # Hash:: The parameters from the request object
+  # 
+  # @api public
   def params()  request.params  end
     
-  # ==== Parameters
-  # name~to_sym, Hash:: The name of the URL to generate.
-  # rparamsHash:: Parameters for the route generation.
+  # There are three possible ways to use this method.  First, if you have a named route, 
+  # you can specify the route as the first parameter as a symbol and any paramters in a 
+  # hash.  Second, you can generate the default route by just passing the params hash, 
+  # just passing the params hash.  Finally, you can use the anonymous parameters.  This 
+  # allows you to specify the parameters to a named route in the order they appear in the 
+  # router.  
+  #
+  # ==== Parameters(Named Route)
+  # nameSymbol:: 
+  #   The name of the route. 
+  # argsHash:: 
+  #   Parameters for the route generation.
+  #
+  # ==== Parameters(Default Route)
+  # argsHash:: 
+  #   Parameters for the route generation.  This route will use the default route. 
+  #
+  # ==== Parameters(Anonymous Parameters)
+  # nameSymbol::
+  #   The name of the route.  
+  # argsArray:: 
+  #   An array of anonymous parameters to generate the route
+  #   with. These parameters are assigned to the route parameters
+  #   in the order that they are passed.
   #
   # ==== Returns
   # String:: The generated URL.
   #
-  # ==== Alternatives
-  # If a hash is used as the first argument, a default route will be
-  # generated based on it and rparams.
-  # ====
-  # TODO: Update this documentation
+  # ==== Examples
+  # Named Route
+  #
+  # Merb::Router.prepare do
+  #   match("/articles/:title").to(:controller = :articles, :action = :show).name("articles")
+  # end
+  #
+  # url(:articles, :title = "new_article")
+  #
+  # Default Route
+  #
+  # Merb::Router.prepare do
+  #   default_routes
+  # end
+  #
+  # url(:controller = "articles", :action = "new")
+  #
+  # Anonymous Paramters
+  #
+  # Merb::Router.prepare do
+  #   match("/articles/:year/:month/:title").to(:controller = :articles, :action = :show).name("articles")
+  # end
+  #
+  # url(:articles, 2008, 10, "test_article")
+  #
+  # @api public
   def url(name, *args)
     args  params
     Merb::Router.url(name, *args)
   end
+  
+  # Generates a URL for a single or nested resource.
+  #
+  # ==== Parameters
+  # resourcesSymbol,Object:: The resources for which the URL
+  #   should be generated. These resources should be specified
+  #   in the router.rb file using #resources and #resource.
+  #
+  # optionsHash:: Any extra parameters that are needed to
+  #   generate the URL.
+  #
+  # ==== Returns
+  # String:: The generated URL.
+  #
+  # ==== Examples
+  #
+  # Merb::Router.prepare do
+  #   resources :users do
+  #     resources :comments
+  #   end
+  # end
+  #
+  # resource(:users)            # = /users
+  # resource(@user)             # = /users/10
+  # resource(@user, :comments)  # = /users/10/comments
+  # resource(@user, @comment)   # = /users/10/comments/15
+  # resource(:users, :new)      # = /users/new
+  # resource(:@user, :edit)     # = /users/10/edit
+  #
+  # @api public
+  def resource(*args)
+    args  params
+    Merb::Router.resource(*args)
+  end
+  
 
   alias_method :relative_url, :url
   
+  # Returns the absolute url including the passed protocol and host.  
+  # 
+  # This uses the same arguments as the url method, with added requirements 
+  # of protocol and host options. 
+  #
+  # @api public
   def absolute_url(*args)
     options  = extract_options_from_args!(args) || {}
     options[:protocol] ||= request.protocol
@@ -251,6 +345,8 @@ def absolute_url(*args)
   # ==== Returns
   # Array[Integer, Hash, String]::
   #   The controller's status code, headers, and body
+  #
+  # @api private
   def rack_response
     [status, headers, Merb::Rack::StreamWrapper.new(body)]
   end
@@ -258,6 +354,8 @@ def rack_response
   # Sets a controller to be "abstract" 
   # This controller will not be able to be routed to
   # and is used for super classing only
+  #
+  # @api public
   def self.abstract!
     @_abstract = true
   end
@@ -267,6 +365,8 @@ def self.abstract!
   # === Returns
   # Boolean
   #  true if the controller has been set as abstract
+  #
+  # @api public
   def self.abstract?
     !!@_abstract 
   end
@@ -277,6 +377,15 @@ def self.abstract?
   private
 
   # If not already added, add the proper mime extension to the template path.
+  #
+  # ==== Parameters
+  #
+  # template~to_s ::
+  #   The template path to append the mime type to.
+  # type~to_s ::
+  #   The extension to append to the template path conditionally
+  #
+  # @api private
   def _conditionally_append_extension(template, type)
     type && !template.match(/\.#{type.to_s.escape_regexp}$/) ? "#{template}.#{type}" : template
   end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/controller/mime.rb</file_name>
					<diff>@@ -1,12 +1,32 @@
 module Merb
   class  self
 
+    
+    # Returns a hash of the available mime types. 
+    #
     # ==== Returns
-    # Hash:: The available mime types.
+    # Hash{Symbol = Hash{Symbol = Object}}:: The available mime types.
+    #
+    # ==== Notes
+    # Each entry corresponds to a call to add_mime_type, having the mime type key (:html, :xml, :json, etc.)
+    # as the key and a hash containing the following entries:
+    #   :accepts           # the mime types that will be recognized by this entry
+    #   :transform_method  # the method called on an object to convert it to content of this type (such as to_json)
+    #   :content_type      # the value set to the "Content-Type" HTTP header when this mime is sent in a response
+    #   :response_headers  # sent in a response using this content type
+    #   :default_quality   # the scale factor used in describing content type preference
+    #   :response_block    # the block to be called with the controller when a request responds to this mime type
+    #
+    # @api public
     def available_mime_types
       ResponderMixin::TYPES
     end
 
+    # ==== Returns
+    # Hash{String = Symbol}:: 
+    #   A hash mapping Content-Type values to the mime type key of the appropriate entry in #available_mime_types
+    #
+    # @api public
     def available_accepts
       ResponderMixin::MIMES
     end
@@ -42,6 +62,11 @@ def available_accepts
     #   correctly appended to the mimetype itself.
     # &block:: a block which recieves the current controller when the format
     #   is set (in the controller's #content_type method)
+    #
+    # ==== Returns
+    # nil
+    #
+    # @api public
     def add_mime_type(key, transform_method, mimes, new_response_headers = {}, default_quality = 1, &block) 
       enforce!(key = Symbol, mimes = Array)
       
@@ -69,6 +94,8 @@ def render_#{key}(thing = nil, opts = {})
           render thing, opts
         end
       EOS
+      
+      nil
     end
 
     # Removes a MIME-type from the mime-type list.
@@ -78,6 +105,8 @@ def render_#{key}(thing = nil, opts = {})
     #
     # ==== Notes
     # :all is the key for */*; It can't be removed.
+    #
+    # @api public
     def remove_mime_type(key)
       return false if key == :all
       ResponderMixin::TYPES.delete(key)
@@ -91,21 +120,12 @@ def remove_mime_type(key)
     #
     # ==== Raises
     # ArgumentError:: The requested mime type is not valid.
+    #
+    # @api public
     def mime_transform_method(key)
       raise ArgumentError, ":#{key} is not a valid MIME-type" unless ResponderMixin::TYPES.key?(key)
       ResponderMixin::TYPES[key][:transform_method]
     end
 
-    # The mime-type for a particular inbound Accepts header.
-    #
-    # ==== Parameters
-    # headerString:: The name of the header to find the mime-type for.
-    #
-    # ==== Returns
-    # Hash:: The mime type information.
-    def mime_by_request_header(header)
-      available_mime_types.find {|key,info| info[:accepts].include?(header)}.first
-    end
-    
   end
 end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/controller/mixins/authentication.rb</file_name>
					<diff>@@ -12,6 +12,9 @@ module Merb::AuthenticationMixin
   # realm~to_s:: The realm to authenticate against. Defaults to 'Application'.
   # &authenticator:: A block to check if the authentication is valid.
   #
+  # ==== Returns
+  # Merb::AuthenticationMixin::BasicAuthentication
+  #
   # ==== Examples
   #     class Application  Merb::Controller
   #     
@@ -47,7 +50,7 @@ module Merb::AuthenticationMixin
   #
   # If you need to request basic authentication inside an action you need to use the request! method.
   #
-  # ====Example
+  # ==== Example
   #
   #    class Sessions  Application
   #  
@@ -55,15 +58,24 @@ module Merb::AuthenticationMixin
   #        case content_type
   #        when :html
   #          render
+  #
   #        else
-  #          basic_authentication.request!
+  #         user = basic_authentication.authenticate do |username, password|
+  #           User.authenticate(username, password)
+  #         end
+  #
+  #         if user
+  #           display(user)
+  #         else
+  #           basic_authentication.request
+  #         end
   #        end
   #      end
   # 
   #    end 
   #
-  #---
-  # @public
+  #
+  # @api public
   def basic_authentication(realm = "Application", &authenticator)
     @_basic_authentication ||= BasicAuthentication.new(self, realm, &authenticator)
   end
@@ -72,6 +84,7 @@ class BasicAuthentication
     # So we can have access to the status codes
     include Merb::ControllerExceptions
 
+    # @api private
     def initialize(controller, realm = "Application", &authenticator)
       @controller = controller
       @realm = realm
@@ -79,6 +92,15 @@ def initialize(controller, realm = "Application", &authenticator)
       authenticate_or_request(&authenticator) if authenticator
     end
 
+    # Determines whether or not the user is authenticated using the criteria
+    # in the provided authenticator block.
+    #
+    # ==== Parameters
+    # &authenticator:: A block that decides whether the provided username and password
+    #   are valid.
+    #
+    # ==== Returns
+    # Object:: False if basic auth is not provided, otherwise the return value of the authenticator block.
     def authenticate(&authenticator)
       if @auth.provided? and @auth.basic?
         authenticator.call(*@auth.credentials)
@@ -87,33 +109,56 @@ def authenticate(&authenticator)
       end
     end
 
+    # Request basic authentication and halt the filter chain. This is for use in a before filter.
+    #
+    # ==== Throws
+    # :halt with an "HTTP Basic: Access denied." message with no layout, and sets the status to Unauthorized.
+    #
+    # @api public
     def request
       request!
       throw :halt, @controller.render("HTTP Basic: Access denied.\n", :status = Unauthorized.status, :layout = false)
     end
     
-    # This is a special case for use outside a before filter.  Use this if you need to 
-    # request basic authenticaiton as part of an action
+    # Sets headers to request basic auth.
+    #
+    # ==== Returns
+    # String:: Returns the empty string to provide a response body.
+    #
+    # @api public
     def request!
       @controller.status = Unauthorized.status
       @controller.headers['WWW-Authenticate'] = 'Basic realm="%s"' % @realm
+      ""
     end
     
-    # Checks to see if there has been any basic authentication credentials provided
+    # ==== Returns
+    # Boolean:: Whether there has been any basic authentication credentials provided
+    #
+    # @api public
     def provided?
       @auth.provided?
     end
     
+    # ==== Returns
+    # String:: The username provided in the request.
+    #
+    # @api public
     def username
       provided? ? @auth.credentials.first : nil
     end
     
+    # ==== Returns
+    # String:: The password provided in the request.
+    #
+    # @api public
     def password
       provided? ? @auth.credentials.last : nil
     end
     
     protected
     
+    # @api private
     def authenticate_or_request(&authenticator)
       authenticate(&authenticator) || request
     end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/controller/mixins/conditional_get.rb</file_name>
					<diff>@@ -29,6 +29,8 @@ module Merb::ConditionalGetMixin
   # tag~to_s::
   #   value of ETag header enclosed in double quotes
   #   as required by the RFC
+  #
+  # @api public
   def etag=(tag)
     headers[Merb::Const::ETAG] = %("#{tag}")
   end
@@ -36,6 +38,8 @@ def etag=(tag)
   # ==== Returns
   # String::
   #   Value of ETag response header or nil if it's not set.
+  #
+  # @api public
   def etag
     headers[Merb::Const::ETAG]
   end
@@ -44,6 +48,8 @@ def etag
   # Boolean::
   # true if ETag response header equals If-None-Match request header,
   # false otherwise
+  #
+  # @api public
   def etag_matches?(tag = self.etag)
     tag == self.request.if_none_match
   end
@@ -54,6 +60,8 @@ def etag_matches?(tag = self.etag)
   # tagTime::
   # resource modification timestamp converted into format
   # required by the RFC
+  #
+  # @api public
   def last_modified=(time)
     headers[Merb::Const::LAST_MODIFIED] = time.httpdate
   end
@@ -61,6 +69,8 @@ def last_modified=(time)
   # ==== Returns
   # String::
   #   Value of Last-Modified response header or nil if it's not set.
+  #
+  # @api public
   def last_modified
     Time.rfc2822(headers[Merb::Const::LAST_MODIFIED])
   end
@@ -69,6 +79,8 @@ def last_modified
   # Boolean::
   # true if Last-Modified response header is  than
   # If-Modified-Since request header value, false otherwise.
+  #
+  # @api public
   def not_modified?(time = self.last_modified)
     request.if_modified_since && time && time = request.if_modified_since
   end
@@ -77,6 +89,8 @@ def not_modified?(time = self.last_modified)
   # Boolean::
   # true if either ETag matches or entity is not modified,
   # so request is fresh; false otherwise
+  #
+  # @api public
   def request_fresh?
     etag_matches?(self.etag) || not_modified?(self.last_modified)
   end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/controller/mixins/controller.rb</file_name>
					<diff>@@ -4,26 +4,27 @@ module ControllerMixin
     
     # Enqueu a block to run in a background thread outside of the request
     # response dispatch
-    #
+    # 
     # ==== Parameters
-    # takes a block to run later
-    #
+    # &blk:: proc to run later
+    # 
     # ==== Example
     # run_later do
     #   SomeBackgroundTask.run
     # end
-    #
+    # 
+    # @api public
     def run_later(&blk)
       Merb::Dispatcher.work_queue  blk
     end
     
     # Renders the block given as a parameter using chunked encoding.
-    #
+    # 
     # ==== Parameters
-    # &blk:: 
+    # &blk::
     #   A block that, when called, will use send_chunks to send chunks of data
     #   down to the server. The chunking will terminate once the block returns.
-    #
+    # 
     # ==== Examples
     #   def stream
     #     prefix = 'p'
@@ -44,6 +45,8 @@ def run_later(&blk)
     #       end
     #     end
     #   end
+    # 
+    # @api public
     def render_chunked(&blk)
       must_support_streaming!
       headers['Transfer-Encoding'] = 'chunked'
@@ -55,12 +58,14 @@ def render_chunked(&blk)
         response.write("0\r\n\r\n")
       }
     end
-
+    
     # Writes a chunk from +render_chunked+ to the response that is sent back to
     # the client. This should only be called within a +render_chunked+ block.
     #
     # ==== Parameters
     # dataString:: a chunk of data to return.
+    # 
+    # @api public
     def send_chunk(data)
       only_runs_on_mongrel!
       @response.write('%x' % data.size + "\r\n")
@@ -71,53 +76,59 @@ def send_chunk(data)
     # &blk::
     #   A proc that should get called outside the mutex, and which will return
     #   the value to render.
-    #
+    # 
     # ==== Returns
     # Proc::
-    #   A block that Mongrel can call later, allowing Merb to release the
+    #   A block that the server can call later, allowing Merb to release the
     #   thread lock and render another request.
+    # 
+    # @api public
     def render_deferred(&blk)
-      Proc.new {|response|
+      Proc.new do |response|
         response.write(blk.call)
-      }
+      end
     end
     
     # Renders the passed in string, then calls the block outside the mutex and
     # after the string has been returned to the client.
-    #
+    # 
     # ==== Parameters
     # strString:: A +String+ to return to the client.
     # &blk:: A block that should get called once the string has been returned.
-    #
+    # 
     # ==== Returns
     # Proc::
     #   A block that Mongrel can call after returning the string to the user.
+    # 
+    # @api public
     def render_then_call(str, &blk)
-      Proc.new {|response|
+      Proc.new do |response|
         response.write(str)
-        blk.call        
-      }      
+        blk.call
+      end
     end
-
+    
     # ==== Parameters
     # urlString::
     #   URL to redirect to. It can be either a relative or fully-qualified URL.
     # optsHash:: An options hash (see below)
-    #
+    # 
     # ==== Options (opts)
     # :messageHash::
     #   Messages to pass in url query string as value for "_message"
     # :permanentBoolean::
     #   When true, return status 301 Moved Permanently
-    #
+    # 
     # ==== Returns
     # String:: Explanation of redirect.
-    #
+    # 
     # ==== Examples
     #   redirect("/posts/34")
     #   redirect("/posts/34", :message = { :notice = 'Post updated successfully!' })
     #   redirect("http://www.merbivore.com/")
     #   redirect("http://www.merbivore.com/", :permanent = true)
+    # 
+    # @api public
     def redirect(url, opts = {})
       default_redirect_options = { :message = nil, :permanent = false }
       opts = default_redirect_options.merge(opts)
@@ -131,17 +142,20 @@ def redirect(url, opts = {})
       "htmlbodyYou are being a href=\"#{url}\"redirected/a./body/html"
     end
     
+    # Retreives the redirect message either locally or from the request.
+    # 
+    # @api public
     def message
       @_message = defined?(@_message) ? @_message : request.message
     end
     
     # Sends a file over HTTP.  When given a path to a file, it will set the
     # right headers so that the static file is served directly.
-    #
+    # 
     # ==== Parameters
     # fileString:: Path to file to send to the client.
     # optsHash:: Options for sending the file (see below).
-    #
+    # 
     # ==== Options (opts)
     # :dispositionString::
     #   The disposition of the file send. Defaults to "attachment".
@@ -151,6 +165,8 @@ def message
     #
     # ==== Returns
     # IO:: An I/O stream for the file.
+    # 
+    # @api public
     def send_file(file, opts={})
       opts.update(Merb::Const::DEFAULT_SEND_FILE_OPTIONS.merge(opts))
       disposition = opts[:disposition].dup || 'attachment'
@@ -160,28 +176,30 @@ def send_file(file, opts={})
         'Content-Disposition'       = disposition,
         'Content-Transfer-Encoding' = 'binary'
       )
-      Proc.new {|response|
+      Proc.new do |response|
         file = File.open(file, 'rb')
         while chunk = file.read(16384)
           response.write chunk
-        end  
+        end
         file.close
-      }
+      end
     end
     
     # Send binary data over HTTP to the user as a file download. May set content type,
     # apparent file name, and specify whether to show data inline or download as an attachment.
-    #
+    # 
     # ==== Parameters
     # dataString:: Path to file to send to the client.
     # optsHash:: Options for sending the data (see below).
-    #
+    # 
     # ==== Options (opts)
     # :dispositionString::
     #   The disposition of the file send. Defaults to "attachment".
     # :filenameString::
     #   The name to use for the file. Defaults to the filename of file.
     # :typeString:: The content type.
+    # 
+    # @api public
     def send_data(data, opts={})
       opts.update(Merb::Const::DEFAULT_SEND_FILE_OPTIONS.merge(opts))
       disposition = opts[:disposition].dup || 'attachment'
@@ -195,13 +213,13 @@ def send_data(data, opts={})
     end
     
     # Streams a file over HTTP.
-    #
+    # 
     # ==== Parameters
     # optsHash:: Options for the file streaming (see below).
     # &stream::
     #   A block that, when called, will return an object that responds to
     #   +get_lines+ for streaming.
-    #
+    # 
     # ==== Options
     # :dispositionString::
     #   The disposition of the file send. Defaults to "attachment".
@@ -216,6 +234,8 @@ def send_data(data, opts={})
     #       response.write chunk
     #     end
     #   end
+    # 
+    # @api public
     def stream_file(opts={}, &stream)
       opts.update(Merb::Const::DEFAULT_SEND_FILE_OPTIONS.merge(opts))
       disposition = opts[:disposition].dup || 'attachment'
@@ -227,32 +247,37 @@ def stream_file(opts={}, &stream)
         # Rack specification requires header values to respond to :each
         'CONTENT-LENGTH'            = opts[:content_length].to_s
       )
-      Proc.new{|response|
+      Proc.new do |response|
         stream.call(response)
-      }
+      end
     end
-
+    
     # Uses the nginx specific +X-Accel-Redirect+ header to send a file directly
-    # from nginx. For more information, see the nginx wiki:
+    # from nginx.
+    # 
+    # ==== Notes
+    # Unless Content-Disposition is set before calling this method,
+    # it is set to attachment with streamed file name.
+    # 
+    # For more information, see the nginx wiki:
     # http://wiki.codemongers.com/NginxXSendfile
-    #
+    # 
     # and the following sample gist:
     # http://gist.github.com/11225
-    #
+    # 
     # there's also example application up on GitHub:
-    #
+    # 
     # http://github.com/michaelklishin/nginx-x-accel-redirect-example-application/tree/master
-    #
-    # Unless Content-Disposition is set before calling this method,
-    # it is set to attachment with streamed file name.
-    #
+    # 
     # ==== Parameters
     # pathString:: Path to file to send to the client.
     # content_typeString:: content type header value. By default is set to empty string to let
     #                        Nginx detect it.
-    #
+    # 
     # ==== Return
-    # One space string.
+    # String:: precisely a single space.
+    # 
+    # @api public
     def nginx_send_file(path, content_type = "")
       # Let Nginx detect content type unless it is explicitly set
       headers['Content-Type']        = content_type
@@ -262,17 +287,17 @@ def nginx_send_file(path, content_type = "")
       
       return ' '
     end  
-  
+    
     # Sets a cookie to be included in the response.
-    #
+    # 
     # If you need to set a cookie, then use the +cookies+ hash.
-    #
+    # 
     # ==== Parameters
     # name~to_s:: A name for the cookie.
     # value~to_s:: A value for the cookie.
     # expires~gmtime:~strftime, Hash:: An expiration time for the cookie, or a hash of cookie options.
-    # ---
-    # @public
+    # 
+    # @api public
     def set_cookie(name, value, expires)
       options = expires.is_a?(Hash) ? expires : {:expires = expires}
       cookies.set_cookie(name, value, options)
@@ -280,11 +305,13 @@ def set_cookie(name, value, expires)
     
     # Marks a cookie as deleted and gives it an expires stamp in the past. This
     # method is used primarily internally in Merb.
-    #
+    # 
     # Use the +cookies+ hash to manipulate cookies instead.
-    #
+    # 
     # ==== Parameters
     # name~to_s:: A name for the cookie to delete.
+    # 
+    # @api public
     def delete_cookie(name)
       set_cookie(name, nil, Merb::Const::COOKIE_EXPIRED_TIME)
     end
@@ -296,6 +323,8 @@ def delete_cookie(name)
     #
     # ==== Returns
     # String:: The escaped object.
+    # 
+    # @api public
     def escape_xml(obj)
       Erubis::XmlHelper.escape_xml(obj.to_s)
     end
@@ -303,14 +332,17 @@ def escape_xml(obj)
     alias escape_html escape_xml
     
     private
-      # Marks an output method that only runs on the mongrel webserver.
-      #
-      # ==== Raises
-      # NotImplemented:: The Rack adapter is not mongrel.
-      def only_runs_on_mongrel!
-        unless Merb::Config[:log_stream] == 'mongrel'
-          raise(Merb::ControllerExceptions::NotImplemented, "Current Rack adapter is not mongrel. cannot support this feature")
-        end
+    
+    # Marks an output method that only runs on the Mongrel webserver.
+    # 
+    # ==== Raises
+    # NotImplemented:: The Rack adapter is not mongrel.
+    # 
+    # @api private
+    def only_runs_on_mongrel!
+      unless Merb::Config[:log_stream] == 'mongrel'
+        raise(Merb::ControllerExceptions::NotImplemented, "Current Rack adapter is not mongrel. cannot support this feature")
       end
+    end
   end
 end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/controller/mixins/render.rb</file_name>
					<diff>@@ -4,6 +4,8 @@ module Merb::RenderMixin
 
   # ==== Parameters
   # baseModule:: Module that is including RenderMixin (probably a controller)
+  #
+  # @private
   def self.included(base)
     base.extend(ClassMethods)
     base.class_eval do
@@ -17,6 +19,8 @@ module ClassMethods
     #
     # ==== Returns
     # Hash:: An options hash
+    #
+    # @api public
     def default_render_options
       self._default_render_options ||= {}
     end
@@ -25,6 +29,8 @@ def default_render_options
     #
     # ==== Parameters
     # optsHash:: An options hash
+    #
+    # @api public
     def render_options(opts)
       self._default_render_options = opts
     end
@@ -40,11 +46,18 @@ def render_options(opts)
     #
     # ==== Returns
     # Hash:: The default render options.
+    #
+    # @api public
     def layout(layout)
       self.default_render_options.update(:layout = (layout || false))
     end
 
     # Enable the default layout logic - reset the layout option.
+    #
+    # ==== Returns
+    # ~to_s:: The layout that was previously set.
+    #
+    # @api public
     def default_layout
       self.default_render_options.delete(:layout)
     end
@@ -82,8 +95,8 @@ def default_layout
   # ==== Alternatives
   # If you pass a Hash as the first parameter, it will be moved to opts and
   # "thing" will be the current action
-  #---
-  # @public
+  #
+  # @api public
   def render(thing = nil, opts = {})
     # render :format = :xml means render nil, :format = :xml
     opts, thing = thing, nil if thing.is_a?(Hash)
@@ -188,6 +201,7 @@ def render(thing = nil, opts = {})
   # The transformed object will not be used in a layout unless a :layout is
   # explicitly passed in the opts.
   #
+  # @api public
   def display(object, thing = nil, opts = {})
     template_opt = thing.is_a?(Hash) ? thing.delete(:template) : opts.delete(:template)
 
@@ -268,6 +282,8 @@ def display(object, thing = nil, opts = {})
   #
   # In this case, "one" will be available in the partial through the local
   # variable named +number+.
+  #
+  # @api public
   def partial(template, opts={})
 
     # partial :foo becomes "#{controller_name}/_foo"
@@ -323,6 +339,8 @@ def partial(template, opts={})
   #
   # ==== Returns
   # Hash:: The options hash that was passed in.
+  #
+  # @api private
   def _handle_options!(opts)
     self.status = opts.delete(:status).to_i if opts[:status]
     headers["Location"] = opts.delete(:location) if opts[:location]
@@ -346,6 +364,8 @@ def _handle_options!(opts)
   #   If a layout was specified (either via layout in the class or by passing
   #   one in to this method), and not found. No error will be raised if no
   #   layout was specified, and the default layouts were not found.
+  #
+  # @api private
   def _get_layout(layout = nil)
     return false if layout == false
     
@@ -385,6 +405,8 @@ def _get_layout(layout = nil)
   # ==== Returns
   # Array[Symbol, String]::
   #   A pair consisting of the template method and location.
+  #
+  # @api private
   def _template_for(context, content_type, controller=nil, template=nil, locals=[])
     template_method, template_location = nil, nil
 
@@ -419,6 +441,8 @@ def _template_for(context, content_type, controller=nil, template=nil, locals=[]
   #
   # ==== Returns
   # String:: The method, if it exists. Otherwise return nil.
+  #
+  # @api private
   def _template_method_for(template_location, locals)
     meth = Merb::Template.template_for(template_location, [], locals)
     meth && self.respond_to?(meth) ? meth : nil
@@ -431,8 +455,8 @@ def _template_method_for(template_location, locals)
   #
   # ==== Parameters
   # objObject:: The key in the thrown_content hash. Defaults to :for_layout.
-  #---
-  # @public
+  #
+  # @api public
   def catch_content(obj = :for_layout)
     @_caught_content[obj] || ''
   end
@@ -441,8 +465,8 @@ def catch_content(obj = :for_layout)
   #
   # ==== Parameters
   # objObject:: The key in the thrown_content hash. Defaults to :for_layout.
-  #---
-  # @public
+  #
+  # @api public
   def thrown_content?(obj = :for_layout)
     @_caught_content.key?(obj)
   end
@@ -463,8 +487,8 @@ def thrown_content?(obj = :for_layout)
   # ==== Example
   #   throw_content(:foo, "Foo")
   #   catch_content(:foo) #= "Foo"
-  #---
-  # @public
+  #
+  # @api public
   def throw_content(obj, string = nil, &block)
     unless string || block_given?
       raise ArgumentError, "You must pass a block or a string into throw_content"
@@ -499,8 +523,8 @@ def append_content(obj, string = nil, &block)
   #
   # ==== Parameters
   # objObject:: The key in the thrown_content hash. Defaults to :for_layout.
-  #---
-  # @public
+  #
+  # @api public
   def clear_content(obj = :for_layout)
     @_caught_content.delete(obj) unless @_caught_content[obj].nil?
   end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/controller/template.rb</file_name>
					<diff>@@ -86,7 +86,8 @@ def needs_compilation?(path, locals)
       return true if Merb::Config[:reload_templates] || !METHOD_LIST[path]
       
       current_locals = SUPPORTED_LOCALS_LIST[path]
-      locals.any?{|local| !current_locals.include?(local)}
+      current_locals != locals &&
+        !(locals - current_locals).empty?
     end
     
     # Get all known template extensions</diff>
				</file>
				<file>
					<file_name>lib/merb-core/core_ext/hash.rb</file_name>
					<diff>@@ -1,4 +1,13 @@
 class Hash
+  # Returns the value of self for each argument and deletes those entries.
+  #
+  # ==== Parameters
+  # *args:: the keys whose values should be extracted and deleted.
+  #
+  # ==== Returns
+  # Array[Object]:: The values of the provided arguments in corresponding order.
+  #
+  # @api public
   def extract!(*args)
     args.map do |arg|
       self.delete(arg)</diff>
				</file>
				<file>
					<file_name>lib/merb-core/core_ext/kernel.rb</file_name>
					<diff>@@ -39,13 +39,17 @@ def track_dependency(name, *ver, &blk)
   # If that has already happened, the gem will be activated
   # immediately, but it will still be registered.
   # 
-  # @param nameString The name of the gem to load.
-  # @param *verGem::Requirement, Gem::Version, Array, #to_str
+  # ==== Parameters
+  # nameString The name of the gem to load.
+  # *verGem::Requirement, Gem::Version, Array, #to_str
   #   Version requirements to be passed to Gem::Dependency.new.
   #   If the last argument is a Hash, extract the :immediate option,
   #   forcing a dependency to load immediately.
   #
-  # @return Gem::Dependency The dependency information.
+  # ==== Returns
+  # Gem::Dependency:: The dependency information.
+  #
+  # @api public
   def dependency(name, *ver, &blk)
     immediate = ver.last.is_a?(Hash) && ver.pop[:immediate]
     if immediate || Merb::BootLoader.finished?(Merb::BootLoader::Dependencies)
@@ -71,6 +75,8 @@ def dependency(name, *ver, &blk)
   #   as a library.
   #
   # @return Gem::Dependency The dependency information.
+  #
+  # @api private
   def load_dependency(name, *ver, &blk)
     dep = name.is_a?(Gem::Dependency) ? name : track_dependency(name, *ver)
     gem(dep)
@@ -93,7 +99,14 @@ def load_dependency(name, *ver, &blk)
   # Loads both gem and library dependencies that are passed in as arguments.
   # Execution is deferred to the Merb::BootLoader::Dependencies.run during bootup.
   #
-  # @param *argsString, Hash, Array The dependencies to load.
+  # ==== Parameters
+  # *argsString, Hash, Array The dependencies to load.
+  #
+  # ==== Returns
+  # Array[(Gem::Dependency, Array[Gem::Dependency])]:: Gem::Dependencies for the
+  #   dependencies specified in args.
+  #
+  # @api public
   def dependencies(*args)
     args.map do |arg|
       case arg
@@ -118,6 +131,8 @@ def dependencies(*args)
   # @example dependencies "RedCloth"                 # Loads the the RedCloth gem
   # @example dependencies "RedCloth", "merb_helpers" # Loads RedCloth and merb_helpers
   # @example dependencies "RedCloth" = "3.0"        # Loads RedCloth 3.0
+  #
+  # @api private
   def load_dependencies(*args)
     args.map do |arg|
       case arg
@@ -132,7 +147,12 @@ def load_dependencies(*args)
   #
   # @param libraryto_s The library to attempt to include.
   # @param messageString The error to add to the log upon failure. Defaults to nil.
+  #
+  # @api private
+  # @deprecated
   def rescue_require(library, message = nil)
+    Merb.logger.warn("Deprecation warning: rescue_require is deprecated")
+    sleep 2.0
     require library
   rescue LoadError, RuntimeError
     Merb.logger.error!(message) if message
@@ -142,17 +162,22 @@ def rescue_require(library, message = nil)
   # Mapper) you wish to use. Currently Merb has plugins to support
   # ActiveRecord, DataMapper, and Sequel.
   #
-  # @param ormSymbol The ORM to use.
+  # ==== Parameters
+  # ormSymbol:: The ORM to use.
   #
-  # @example
+  # ==== Returns
+  # nil
+  #
+  # ==== Example
   #   use_orm :datamapper
   #
   #   # This will use the DataMapper generator for your ORM
   #   $ merb-gen model ActivityEvent
   #
-  # @note
+  # ==== Notes
   #   If for some reason this is called more than once, latter
   #   call takes over other.
+  #
   # @api public
   def use_orm(orm)
     begin
@@ -163,24 +188,31 @@ def use_orm(orm)
       Merb.logger.warn!("The #{orm_plugin} gem was not found.  You may need to install it.")
       raise e
     end
+    nil
   end
 
   # Used in Merb.root/config/init.rb to tell Merb which testing framework to
   # use. Currently Merb has plugins to support RSpec and Test::Unit.
   #
-  # @param test_frameworkSymbol
+  # ==== Parameters
+  # test_frameworkSymbol::
   #   The test framework to use. Currently only supports :rspec and :test_unit.
   #
-  # @example
+  # ==== Returns
+  # nil
+  #
+  # ==== Example
   #   use_test :rspec
   #
   #   # This will now use the RSpec generator for tests
   #   $ merb-gen model ActivityEvent
+  #
   # @api public
   def use_testing_framework(test_framework, *test_dependencies)
     Merb.test_framework = test_framework
     
     Kernel.dependencies test_dependencies if Merb.env == "test" || Merb.env.nil?
+    nil
   end
 
   def use_test(*args)
@@ -190,14 +222,19 @@ def use_test(*args)
   # Used in Merb.root/config/init.rb to tell Merb which template engine to
   # prefer.
   #
-  # @param template_engineSymbol
+  # ==== Parameters
+  # template_engineSymbol
   #   The template engine to use.
   #
-  # @example
+  # ==== Returns
+  # nil
+  #
+  # ==== Example
   #   use_template_engine :haml
   #
   #   # This will now use haml templates in generators where available.
   #   $ merb-gen resource_controller Project 
+  #
   # @api public
   def use_template_engine(template_engine)
     Merb.template_engine = template_engine
@@ -210,11 +247,14 @@ def use_template_engine(template_engine)
       end
       Kernel.dependency(template_engine_plugin)
     end
+    
+    nil
   rescue LoadError = e
     Merb.logger.warn!("The #{template_engine_plugin} gem was not found.  You may need to install it.")
     raise e
   end
 
+
   # @param iFixnum The caller number. Defaults to 1.
   #
   # @return Array[Array] The file, line and method of the caller.
@@ -222,6 +262,8 @@ def use_template_engine(template_engine)
   # @example
   #   __caller_info__(1)
   #     # = ['/usr/lib/ruby/1.8/irb/workspace.rb', '52', 'irb_binding']
+  #
+  # @api private
   def __caller_info__(i = 1)
     file, line, meth = caller[i].scan(/(.*?):(\d+):in `(.*?)'/).first
   end
@@ -245,6 +287,8 @@ def __caller_info__(i = 1)
   #       [ 123, "      DEBUGGER__.waiting.push Thread.current",      false ],
   #       [ 124, "      @suspend_next = false",                       false ]
   #     ]
+  #
+  # @api private
   def __caller_lines__(file, line, size = 4)
     line = line.to_i
     if file =~ /\(erubis\)/
@@ -262,26 +306,6 @@ def __caller_lines__(file, line, size = 4)
         yield index + line - size, str.chomp
       end
     end
-    # 
-    # lines = File.readlines(file)
-    # current = line.to_i - 1
-    # 
-    # first = current - size
-    # first = first  0 ? 0 : first
-    # 
-    # last = current + size
-    # last = last  lines.size ? lines.size : last
-    # 
-    # log = lines[first..last]
-    # 
-    # area = []
-    # 
-    # log.each_with_index do |line, index|
-    #   index = index + first + 1
-    #   area  [index, line.chomp, index == current + 1]
-    # end
-    # 
-    # area
   end
 
   # Takes a block, profiles the results of running the block
@@ -309,6 +333,8 @@ def __caller_lines__(file, line, size = 4)
   #   Assuming that the total time taken for #puts calls was less than 5% of the
   #   total time to run, #puts won't appear in the profile report.
   #   The code block will be run 30 times in the example above.
+  #
+  # @api private
   def __profile__(name, min=1, iter=100)
     require 'ruby-prof' unless defined?(RubyProf)
     return_result = ''
@@ -334,6 +360,8 @@ def __profile__(name, min=1, iter=100)
   #     opts = extract_options_from_args!(args) || {}
   #     # [...]
   #   end
+  #
+  # @api public
   def extract_options_from_args!(args)
     args.pop if Hash === args.last
   end
@@ -346,6 +374,8 @@ def extract_options_from_args!(args)
   #
   # @raise ArgumentError
   #   An object failed to quack like a condition.
+  #
+  # @api public
   def enforce!(opts = {})
     opts.each do |k,v|
       raise ArgumentError, "#{k.inspect} doesn't quack like #{v.inspect}" unless k.quacks_like?(v)</diff>
				</file>
				<file>
					<file_name>lib/merb-core/dispatch/dispatcher.rb</file_name>
					<diff>@@ -4,15 +4,19 @@ module Merb
   class Dispatcher
     class  self
       include Merb::ControllerExceptions
-    
+      
       attr_accessor :use_mutex
       
       @@work_queue = Queue.new
-    
+      
+      # ==== Returns
+      # Queue:: the current queue of dispatch jobs.
+      # 
+      # @api private
       def work_queue 
         @@work_queue
       end  
-    
+      
       Merb::Dispatcher.use_mutex = ::Merb::Config[:use_mutex]
       
       # Dispatch the rack environment. ControllerExceptions are rescued here
@@ -25,9 +29,11 @@ def work_queue
       # ==== Returns
       # Merb::Controller::
       #   The Merb::Controller that was dispatched to
+      # 
+      # @api private
       def handle(request)
         request.handle
-      end      
+      end
     end
   end
   
@@ -36,10 +42,16 @@ class Request
     
     @@mutex = Mutex.new
     
+    # Handles request routing and action dispatch.
+    # 
+    # ==== Returns
+    # Merb::Controller:: the controller that handled the action dispatch.
+    # 
+    # @api private
     def handle
       start = Time.now
       Merb.logger.info "Started request handling: #{start.to_s}"
-  
+      
       find_route!
       return rack_response if handled?
       
@@ -57,7 +69,7 @@ def handle
       if klass.abstract?
         raise NotFound, "The '#{klass}' controller has no public actions"
       end
-    
+      
       controller = dispatch_action(klass, params[:action])
       controller._benchmarks[:dispatch_time] = Time.now - start
       Merb.logger.info controller._benchmarks.inspect
@@ -73,13 +85,13 @@ def handle
     # ==== Parameters
     # klassMerb::Controller:: The controller class to dispatch to.
     # actionSymbol:: The action to dispatch.
-    # requestMerb::Request::
-    #   The Merb::Request object that was created in #handle
     # statusInteger:: The status code to respond with.
     #
     # ==== Returns
     # Merb::Controller::
     #   The Merb::Controller that was dispatched to.
+    # 
+    # @api private
     def dispatch_action(klass, action, status=200)
       # build controller
       controller = klass.new(self, status)
@@ -101,8 +113,6 @@ def dispatch_action(klass, action, status=200)
     # StandardError is caught in standard_error).
     #
     # ==== Parameters
-    # requestMerb::Request:: 
-    #   The request object associated with the failed request.
     # exceptionObject::
     #   The exception object that was created when trying to dispatch the
     #   original controller.
@@ -110,6 +120,8 @@ def dispatch_action(klass, action, status=200)
     # ==== Returns
     # Exceptions::
     #   The Merb::Controller that was dispatched to. 
+    # 
+    # @api private
     def dispatch_exception(exception)
       if(exception.is_a?(Merb::ControllerExceptions::Base) &&
          !exception.is_a?(Merb::ControllerExceptions::ServerError))
@@ -117,12 +129,12 @@ def dispatch_exception(exception)
       else
         Merb.logger.error(Merb.exception(exception))
       end
-
+      
       self.exceptions = [exception]
-
+      
       begin
         e = exceptions.first
-
+        
         if action_name = e.action_name
           dispatch_action(Exceptions, action_name, e.class.status)
         else
@@ -134,7 +146,7 @@ def dispatch_exception(exception)
         else
           Merb.logger.error("Dispatching #{e.class} raised another error.")
           Merb.logger.error(Merb.exception(dispatch_issue))
-
+          
           exceptions.unshift dispatch_issue
           retry
         end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/dispatch/request.rb</file_name>
					<diff>@@ -25,16 +25,26 @@ class Request
     self.http_method_overrides = []
     
     # Initialize the request object.
-    #
+    # 
     # ==== Parameters
     # http_request~params:~[], ~body:IO:: 
     #   An object like an HTTP Request.
+    # 
+    # @api private
     def initialize(rack_env)
       @env  = rack_env
       @body = rack_env['rack.input']
       @route_params = {}
     end
     
+    # Returns the controller object for initialization and dispatching the
+    # request.
+    # 
+    # ==== Returns
+    # Class:: The controller class matching the routed request,
+    #   e.g. Posts.
+    # 
+    # @api private
     def controller
       unless params[:controller]
         raise ControllerExceptions::NotFound, 
@@ -58,13 +68,15 @@ def controller
     METHODS = %w{get post put delete head options}
 
     # ==== Returns
-    # Symbol:: The name of the request method, e.g. :get.
+    # Symbol:: The name of the request method, e.g. :get.
     #
     # ==== Notes
     # If the method is post, then the blocks specified in
     # http_method_overrides will be checked for the masquerading method.
     # The block will get the controller yielded to it.  The first matching workaround wins.
     # To disable this behavior, set http_method_overrides = []
+    # 
+    # @api public
     def method
       @method ||= begin
         request_method = @env['REQUEST_METHOD'].downcase.to_sym
@@ -89,20 +101,24 @@ def method
     METHODS.each do |m|
       class_eval "def #{m}?() method == :#{m} end"
     end
-
+    
+    # ==== Notes
     # Find route using requested URI and merges route
     # parameters (:action, :controller and named segments)
     # into request params hash.
+    # 
+    # @api private
     def find_route!
       @route, @route_params = Merb::Router.route_for(self)
       params.merge! @route_params if @route_params.is_a?(Hash)
     end
     
+    # ==== Notes
     # Processes the return value of a deferred router block
     # and returns the current route params for the current
     # request evaluation
-    # ---
-    # @private
+    # 
+    # @api private
     def _process_block_return(retval)
       # If the return value is an array, then it is a redirect
       # so we must set the request as a redirect and extract
@@ -114,33 +130,54 @@ def _process_block_return(retval)
     
     # Sets the request as matched. This will abort evaluating any
     # further deferred procs.
-    # ---
-    # @private
+    # 
+    # @api private
     def matched!
       @matched = true
     end
     
     # Checks whether or not the request has been matched to a route.
-    # ---
-    # @private
+    # 
+    # @api private
     def matched?
       @matched
     end
     
+    # ==== Returns
+    # (Array, Hash):: the route params for the matched route.
+    # 
+    # ==== Notes
+    # If the response is an Array then it is considered a direct Rack response
+    # to be sent back as a response. Otherwise, the route_params is a Hash with
+    # routing data (controller, action, et al).
+    # 
+    # @api private
     def rack_response
       @route_params
     end
     
     # If @route_params is an Array, then it will be the rack response.
-    # In this case, the request has been handled.
+    # In this case, the request is considered handled.
+    # 
+    # ==== Returns
+    # Boolean:: true if @route_params is an Array, false otherwise.
+    # 
+    # @api private
     def handled?
       @route_params.is_a?(Array)
     end
     
+    # == Params
+    # 
+    # Handles processing params from raw data and merging them together to get
+    # the final request params.
+    
     private
     
     # ==== Returns
     # Hash:: Parameters passed from the URL like ?blah=hello.
+    # 
+    # @api private
     def query_params
       @query_params ||= self.class.query_parse(query_string || '')
     end
@@ -150,6 +187,8 @@ def query_params
     #
     # ==== Returns
     # Hash:: The parameters passed in the body.
+    # 
+    # @api private
     def body_params
       @body_params ||= begin
         if content_type && content_type.match(Merb::Const::FORM_URL_ENCODED_REGEXP) # or content_type.nil?
@@ -157,11 +196,13 @@ def body_params
         end
       end
     end
-
+    
     # ==== Returns
     # Mash::
     #   The parameters gathered from the query string and the request body,
     #   with parameters in the body taking precedence.
+    # 
+    # @api private
     def body_and_query_params
       # ^-- FIXME a better name for this method
       @body_and_query_params ||= begin
@@ -170,13 +211,15 @@ def body_and_query_params
         h.to_mash
       end
     end
-
+    
     # ==== Raises
     # ControllerExceptions::MultiPartParseError::
     #   Unable to parse the multipart form data.
     #
     # ==== Returns
     # Hash:: The parsed multipart parameters.
+    # 
+    # @api private
     def multipart_params
       @multipart_params ||= 
         begin
@@ -192,7 +235,7 @@ def multipart_params
           raise e
         end
     end
-
+    
     # ==== Returns
     # Hash:: Parameters from body if this is a JSON request.
     #
@@ -201,6 +244,8 @@ def multipart_params
     # parameters hash.  If it parses to anything else (such as an Array, or
     # if it inflates to an Object) it will be accessible via the inflated_object
     # parameter.
+    # 
+    # @api private
     def json_params
       @json_params ||= begin
         if Merb::Const::JSON_MIME_TYPE_REGEXP.match(content_type)
@@ -209,9 +254,11 @@ def json_params
         end
       end
     end
-
+    
     # ==== Returns
     # Hash:: Parameters from body if this is an XML request.
+    # 
+    # @api private
     def xml_params
       @xml_params ||= begin
         if Merb::Const::XML_MIME_TYPE_REGEXP.match(content_type)
@@ -228,6 +275,8 @@ def xml_params
     # ==== Notes
     # The order of precedence for the params is XML, JSON, multipart, body and
     # request string.
+    # 
+    # @api public
     def params
       @params ||= begin
         h = body_and_query_params.merge(route_params)      
@@ -238,6 +287,10 @@ def params
       end
     end
     
+    # ==== Returns
+    # String:: Returns the redirect message Base64 unencoded.
+    # 
+    # @api public
     def message
       return {} unless params[:_message]
       begin
@@ -246,14 +299,19 @@ def message
         {}
       end
     end
-
+    
+    # ==== Notes
     # Resets the params to a nil value.
+    # 
+    # @api private
     def reset_params!
       @params = nil
     end
     
     # ==== Returns
     # String:: The raw post.
+    # 
+    # @api private
     def raw_post
       @body.rewind if @body.respond_to?(:rewind)
       @raw_post ||= @body.read
@@ -261,6 +319,8 @@ def raw_post
     
     # ==== Returns
     # Boolean:: If the request is an XML HTTP request.
+    # 
+    # @api public
     def xml_http_request?
       not /XMLHttpRequest/i.match(@env['HTTP_X_REQUESTED_WITH']).nil?
     end
@@ -269,17 +329,19 @@ def xml_http_request?
     
     # ==== Returns
     # String:: The remote IP address.
+    # 
+    # @api public
     def remote_ip
       return @env['HTTP_CLIENT_IP'] if @env.include?('HTTP_CLIENT_IP')
-    
+      
       if @env.include?(Merb::Const::HTTP_X_FORWARDED_FOR) then
         remote_ips = @env[Merb::Const::HTTP_X_FORWARDED_FOR].split(',').reject do |ip|
           ip =~ /^unknown$|^(127|10|172\.16|192\.168)\./i
         end
-    
+        
         return remote_ips.first.strip unless remote_ips.empty?
       end
-    
+      
       return @env[Merb::Const::REMOTE_ADDR]
     end
     
@@ -287,126 +349,168 @@ def remote_ip
     # String::
     #   The protocol, i.e. either "https" or "http" depending on the
     #   HTTPS header.
+    # 
+    # @api public
     def protocol
       ssl? ? 'https' : 'http'
     end
     
     # ==== Returns
     # Boolean::: True if the request is an SSL request.
+    # 
+    # @api public
     def ssl?
       @env['HTTPS'] == 'on' || @env['HTTP_X_FORWARDED_PROTO'] == 'https'
     end
     
     # ==== Returns
     # String:: The HTTP referer.
+    # 
+    # @api public
     def referer
       @env['HTTP_REFERER']
     end
     
     # ==== Returns
     # String:: The full URI, including protocol and host
+    # 
+    # @api public
     def full_uri
       protocol + "://" + host + uri
     end
     
     # ==== Returns
     # String:: The request URI.
+    # 
+    # @api public
     def uri
       @env['REQUEST_PATH'] || @env['REQUEST_URI'] || path_info
     end
-
+    
     # ==== Returns
     # String:: The HTTP user agent.
+    # 
+    # @api public
     def user_agent
       @env['HTTP_USER_AGENT']
     end
-
+    
     # ==== Returns
     # String:: The server name.
+    # 
+    # @api public
     def server_name
       @env['SERVER_NAME']
     end
-
+    
     # ==== Returns
     # String:: The accepted encodings.
+    # 
+    # @api private
     def accept_encoding
       @env['HTTP_ACCEPT_ENCODING']
     end
-
+    
     # ==== Returns
     # String:: The script name.
+    # 
+    # @api public
     def script_name
       @env['SCRIPT_NAME']
     end
-
+    
     # ==== Returns
     # String:: HTTP cache control.
+    # 
+    # @api public
     def cache_control
       @env['HTTP_CACHE_CONTROL']
     end
-
+    
     # ==== Returns
     # String:: The accepted language.
+    # 
+    # @api public
     def accept_language
       @env['HTTP_ACCEPT_LANGUAGE']
     end
-
+    
     # ==== Returns
     # String:: The server software.
+    # 
+    # @api public
     def server_software
       @env['SERVER_SOFTWARE']
     end
-
+    
     # ==== Returns
     # String:: Value of HTTP_KEEP_ALIVE.
+    # 
+    # @api public
     def keep_alive
       @env['HTTP_KEEP_ALIVE']
     end
-
+    
     # ==== Returns
     # String:: The accepted character sets.
+    # 
+    # @api public
     def accept_charset
       @env['HTTP_ACCEPT_CHARSET']
     end
-
+    
     # ==== Returns
     # String:: The HTTP version
+    # 
+    # @api private
     def version
       @env['HTTP_VERSION']
     end
-
+    
     # ==== Returns
     # String:: The gateway.
+    # 
+    # @api public
     def gateway
       @env['GATEWAY_INTERFACE']
     end
-
+    
     # ==== Returns
     # String:: The accepted response types. Defaults to "*/*".
+    # 
+    # @api private
     def accept
       @env['HTTP_ACCEPT'].blank? ? "*/*" : @env['HTTP_ACCEPT']
     end
-
+    
     # ==== Returns
     # String:: The HTTP connection.
+    # 
+    # @api private
     def connection
       @env['HTTP_CONNECTION']
     end
-
+    
     # ==== Returns
     # String:: The query string.
+    # 
+    # @api private
     def query_string
       @env['QUERY_STRING']  
     end
-
+    
     # ==== Returns
     # String:: The request content type.
+    # 
+    # @api private
     def content_type
       @env['CONTENT_TYPE']
     end
-
+    
     # ==== Returns
     # Fixnum:: The request content length.
+    # 
+    # @api public
     def content_length
       @content_length ||= @env[Merb::Const::CONTENT_LENGTH].to_i
     end
@@ -415,6 +519,8 @@ def content_length
     # String::
     #   The URI without the query string. Strips trailing "/" and reduces
     #   duplicate "/" to a single "/".
+    # 
+    # @api public
     def path
       path = (uri.empty? ? '/' : uri.split('?').first).squeeze("/")
       path = path[0..-2] if (path[-1] == ?/) && path.size  1
@@ -423,18 +529,24 @@ def path
     
     # ==== Returns
     # String:: The path info.
+    # 
+    # @api public
     def path_info
       @path_info ||= self.class.unescape(@env['PATH_INFO'])
     end
     
     # ==== Returns
     # Fixnum:: The server port.
+    # 
+    # @api public
     def port
       @env['SERVER_PORT'].to_i
     end
     
     # ==== Returns
     # String:: The full hostname including the port.
+    # 
+    # @api public
     def host
       @env['HTTP_X_FORWARDED_HOST'] || @env['HTTP_HOST'] 
     end
@@ -446,6 +558,8 @@ def host
     #
     # ==== Returns
     # Array:: All the subdomain parts of the host.
+    # 
+    # @api public
     def subdomains(tld_length = 1)
       parts = host.split('.')
       parts[0..-(tld_length+2)]
@@ -458,18 +572,24 @@ def subdomains(tld_length = 1)
     #
     # ==== Returns
     # String:: The full domain name without the port number.
+    # 
+    # @api public
     def domain(tld_length = 1)
       host.split('.').last(1 + tld_length).join('.').sub(/:\d+$/,'')
     end
-
+    
     # ==== Returns
     # Value of If-None-Match request header.
+    # 
+    # @api private
     def if_none_match
       @env[Merb::Const::HTTP_IF_NONE_MATCH]
     end
-
+    
     # ==== Returns
     # Value of If-Modified-Since request header.
+    # 
+    # @api private
     def if_modified_since
       if time = @env[Merb::Const::HTTP_IF_MODIFIED_SINCE]
         Time.rfc2822(time)
@@ -497,6 +617,8 @@ class  self
       #     # = "search[page]=10&search[word]=ruby"
       #   params_to_query_string([ "ice-cream", "cake" ], "shopping_list")
       #     # = "shopping_list[]=ice-cream&shopping_list[]=cake"
+      # 
+      # @api private
       def params_to_query_string(value, prefix = nil)
         case value
         when Array
@@ -517,17 +639,21 @@ def params_to_query_string(value, prefix = nil)
       #
       # ==== returns
       # String:: The escaped string.
+      # 
+      # @api private
       def escape(s)
         s.to_s.gsub(/([^ a-zA-Z0-9_.-]+)/n) {
           '%'+$1.unpack('H2'*$1.size).join('%').upcase
         }.tr(' ', '+')
       end
-
+      
       # ==== Parameter
       # sString:: String to URL unescape.
       #
       # ==== returns
       # String:: The unescaped string.
+      # 
+      # @api private
       def unescape(s)
         s.tr('+', ' ').gsub(/((?:%[0-9a-fA-F]{2})+)/n){
           [$1.delete('%')].pack('H*')
@@ -545,6 +671,8 @@ def unescape(s)
       # ==== Examples
       #   query_parse("bar=nik&post[body]=heya")
       #     # = { :bar = "nik", :post = { :body = "heya" } }
+      # 
+      # @api private
       def query_parse(query_string, delimiter = '&;', preserve_order = false)
         query = preserve_order ? Dictionary.new : {}
         for pair in (query_string || '').split(/[#{delimiter}] */n)
@@ -558,13 +686,13 @@ def query_parse(query_string, delimiter = '&;', preserve_order = false)
         end
         preserve_order ? query : query.to_mash
       end
-    
+      
       NAME_REGEX = /Content-Disposition:.* name="?([^\";]*)"?/ni.freeze
       CONTENT_TYPE_REGEX = /Content-Type: (.*)\r\n/ni.freeze
       FILENAME_REGEX = /Content-Disposition:.* filename="?([^\";]*)"?/ni.freeze
       CRLF = "\r\n".freeze
       EOL = CRLF
-
+      
       # ==== Parameters
       # requestIO:: The raw request.
       # boundaryString:: The boundary string.
@@ -575,6 +703,8 @@ def query_parse(query_string, delimiter = '&;', preserve_order = false)
       #
       # ==== Returns
       # Hash:: The parsed request.
+      # 
+      # @api private
       def parse_multipart(request, boundary, content_length)
         boundary = "--#{boundary}"
         paramhsh = {}
@@ -605,19 +735,19 @@ def parse_multipart(request, boundary, content_length)
               filename = head[FILENAME_REGEX, 1]
               content_type = head[CONTENT_TYPE_REGEX, 1]
               name = head[NAME_REGEX, 1]
-            
+              
               if filename && !filename.empty?
                 body = Tempfile.new(:Merb)
                 body.binmode if defined? body.binmode
               end
               next
             end
-          
+            
             # Save the read body part.
             if head && (boundary_size+4  buf.size)
               body  buf.slice!(0, buf.size - (boundary_size+4))
             end
-          
+            
             read_size = bufsize  content_length ? bufsize : content_length
             if( read_size  0 )
               c = input.read(read_size)
@@ -626,15 +756,15 @@ def parse_multipart(request, boundary, content_length)
               content_length -= c.size
             end
           end
-        
+          
           # Save the rest.
           if i = buf.index(rx)
             body  buf.slice!(0, i)
             buf.slice!(0, boundary_size+2)
-          
+            
             content_length = -1  if $1 == "--"
           end
-        
+          
           if filename && !filename.empty?   
             body.rewind
             data = { 
@@ -651,7 +781,7 @@ def parse_multipart(request, boundary, content_length)
         }
         paramhsh
       end
-
+      
       # Converts a query string snippet to a hash and adds it to existing
       # parameters.
       #
@@ -662,6 +792,8 @@ def parse_multipart(request, boundary, content_length)
       #
       # ==== Returns
       # Hash:: Normalized parameters
+      # 
+      # @api private
       def normalize_params(parms, name, val=nil)
         name =~ %r([\[\]]*([^\[\]]+)\]*)
         key = $1 || ''
@@ -687,4 +819,4 @@ def normalize_params(parms, name, val=nil)
       end
     end
   end
-end    
+end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/dispatch/router.rb</file_name>
					<diff>@@ -6,19 +6,19 @@
 module Merb
   # Router stores route definitions and finds the first
   # route that matches the incoming request URL.
-  #
+  # 
   # Then information from route is used by dispatcher to
   # call action on the controller.
-  #
+  # 
   # ==== Routes compilation.
-  #
+  # 
   # The most interesting method of Router (and heart of
   # route matching machinery) is match method generated
   # on the fly from routes definitions. It is called routes
   # compilation. Generated match method body contains
   # one if/elsif statement that picks the first matching route
   # definition and sets values to named parameters of the route.
-  #
+  # 
   # Compilation is synchronized by mutex.
   class Router
     @routes          = []
@@ -26,14 +26,14 @@ class Router
     @resource_routes = {}
     @compiler_mutex  = Mutex.new
     @root_behavior   = Behavior.new.defaults(:action = "index")
-
+    
     # Raised when route lookup fails.
     class RouteNotFound  StandardError; end;
     # Raised when parameters given to generation
     # method do not match route parameters.
     class GenerationError  StandardError; end;
     class NotCompiledError  StandardError; end;
-
+    
     class  self
       # @private
       attr_accessor :routes, :named_routes, :resource_routes, :root_behavior
@@ -41,19 +41,20 @@ class  self
       # Creates a route building context and evaluates the block in it. A
       # copy of +root_behavior+ (and instance of Behavior) is copied as
       # the context.
-      #
+      # 
       # ==== Parameters
       # firstArray::
       #   An array containing routes that should be prepended to the routes
       #   defined in the block.
-      #
       # lastArray::
       #   An array containing routes that should be appended to the routes
       #   defined in the block.
-      #
+      # 
       # ==== Returns
       # Merb::Router::
       #   Returns self to allow chaining of methods.
+      # 
+      # @api public
       def prepare(first = [], last = [], &block)
         @routes = []
         root_behavior._with_proxy(&block)
@@ -63,17 +64,23 @@ def prepare(first = [], last = [], &block)
       end
       
       # Appends route in the block to routing table.
+      # 
+      # @api public
       def append(&block)
         prepare(routes, [], &block)
       end
-
+      
       # Prepends routes in the block to routing table.
+      # 
+      # @api public
       def prepend(&block)
         prepare([], routes, &block)
       end
       
       # Clears the routing table. Route generation and request matching
       # won't work anymore until a new routing table is built.
+      # 
+      # @api private
       def reset!
         class  self
           alias_method :match, :match_before_compilation
@@ -84,18 +91,16 @@ class  self
       # Finds route matching URI of the request and returns a tuple of
       # [route index, route params]. This method is called by the
       # dispatcher and isn't as useful in applications.
-      #
+      # 
       # ==== Parameters
       # requestMerb::Request:: request to match.
-      #
+      # 
       # ==== Returns
-      # Array(Integer, Hash)::
-      #   Two-tuple: route index and route parameters. Route
-      #   parameters are :controller, :action and all the named
-      #   segments of the route.
-      #
-      # ---
-      # @private
+      # Array[Integer, Hash]::
+      #   Two-tuple: route index and route parameters. Route parameters
+      #   are :controller, :action and all the named segments of the route.
+      # 
+      # @api private
       def route_for(request) #:nodoc:
         index, params = match(request)
         route = routes[index] if index
@@ -105,43 +110,85 @@ def route_for(request) #:nodoc:
         end
         [route, params]
       end
-
-      # Just a placeholder for the compiled match method
+      
+      # A placeholder for the compiled match method.
+      # 
+      # ==== Notes
+      # This method is aliased as +match+ but this method gets overridden with
+      # the actual +match+ method (generated from the routes definitions) after
+      # being compiled. This method is only ever called before routes are
+      # compiled.
+      # 
+      # ==== Raises
+      # NotCompiledError:: routes have not been compiled yet.
+      # 
+      # @api private
       def match_before_compilation(request) #:nodoc:
         raise NotCompiledError, "The routes have not been compiled yet"
       end
-
+      
       alias_method :match, :match_before_compilation
       
-      # Generates a URL from the params
+      # There are three possible ways to use this method.  First, if you have a named route, 
+      # you can specify the route as the first parameter as a symbol and any paramters in a 
+      # hash.  Second, you can generate the default route by just passing the params hash, 
+      # just passing the params hash.  Finally, you can use the anonymous parameters.  This 
+      # allows you to specify the parameters to a named route in the order they appear in the 
+      # router.  
       #
-      # ==== Parameters
-      # nameSymbol::
-      #   The name of the route to generate
+      # ==== Parameters(Named Route)
+      # nameSymbol:: 
+      #   The name of the route. 
+      # argsHash:: 
+      #   Parameters for the route generation.
       #
-      # anonymous_paramsObject::
+      # ==== Parameters(Default Route)
+      # argsHash:: 
+      #   Parameters for the route generation.  This route will use the default route. 
+      #
+      # ==== Parameters(Anonymous Parameters)
+      # nameSymbol::
+      #   The name of the route.  
+      # argsArray:: 
       #   An array of anonymous parameters to generate the route
       #   with. These parameters are assigned to the route parameters
       #   in the order that they are passed.
       #
-      # paramsHash::
-      #   Named parameters to generate the route with.
-      #
-      # defaultsHash::
-      #   A hash of default parameters to generate the route with.
-      #   This is usually the request parameters. If there are any
-      #   required params that are missing to generate the route,
-      #   they are pulled from this hash.
       # ==== Returns
-      # String:: The generated URL
-      # ---
-      # @private
+      # String:: The generated URL.
+      #
+      # ==== Examples
+      # Named Route
+      #
+      # Merb::Router.prepare do
+      #   match("/articles/:title").to(:controller = :articles, :action = :show).name("articles")
+      # end
+      #
+      # url(:articles, :title = "new_article")
+      #
+      # Default Route
+      #
+      # Merb::Router.prepare do
+      #   default_routes
+      # end
+      #
+      # url(:controller = "articles", :action = "new")
+      #
+      # Anonymous Paramters
+      #
+      # Merb::Router.prepare do
+      #   match("/articles/:year/:month/:title").to(:controller = :articles, :action = :show).name("articles")
+      # end
+      #
+      # url(:articles, 2008, 10, "test_article")
+      #
+      # @api private
       def url(name, *args)
         unless name.is_a?(Symbol)
           args.unshift(name)
           name = :default
         end
-
+        
         unless route = Merb::Router.named_routes[name]
           raise Merb::Router::GenerationError, "Named route not found: #{name}"
         end
@@ -152,25 +199,25 @@ def url(name, *args)
       end
       
       # Generates a URL from the resource(s)
-      #
+      # 
       # ==== Parameters
       # resourcesSymbol,Object::
       #   The identifiers for the resource route to generate. These
       #   can either be symbols or objects. Symbols denote resource
       #   collection routes and objects denote the members.
-      #
+      # 
       # paramsHash::
       #   Any extra parameters needed to generate the route.
       # ==== Returns
       # String:: The generated URL
-      # ---
-      # @private
+      # 
+      # @api private
       def resource(*args)
         defaults = args.pop
         options  = extract_options_from_args!(args) || {}
         key      = []
         params   = []
-
+        
         args.each do |arg|
           if arg.is_a?(Symbol) || arg.is_a?(String)
             key  arg.to_s
@@ -179,19 +226,21 @@ def resource(*args)
             params  arg
           end
         end
-
+        
         params  options
-
+        
         unless route = Merb::Router.resource_routes[key]
           raise Merb::Router::GenerationError, "Resource route not found: #{args.inspect}"
         end
-
+        
         route.generate(params, defaults)
       end
-
-    private
-    
-      # Defines method with a switch statement that does routes recognition.
+      
+      private
+      
+      # Compiles the routes and creates the +match+ method.
+      # 
+      # @api private
       def compile
         if routes.any?
           eval(compiled_statement, binding, "Generated Code for Router", 1)
@@ -199,18 +248,21 @@ def compile
           reset!
         end
       end
-
-      # Generates method that does route recognition with a switch statement.
+      
+      # Generates the method for evaluation defining a +match+ method to match
+      # a request with the defined routes.
+      # 
+      # @api private
       def compiled_statement
         @compiler_mutex.synchronize do
           condition_keys, if_statements = Set.new, ""
-
+          
           routes.each_with_index do |route, i|
             route.freeze
             route.conditions.keys.each { |key| condition_keys  key }
             if_statements  route.compiled_statement(i == 0)
           end
-
+          
           statement =  "def match(request)\n"
           statement  condition_keys.inject("") do |cached, key|
             cached  "  cached_#{key} = request.#{key}.to_s\n"
@@ -222,7 +274,7 @@ def compiled_statement
           statement  "end"
         end
       end
-
+      
     end # class  self
   end
 end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/dispatch/router/behavior.rb</file_name>
					<diff>@@ -3,31 +3,51 @@ module Merb
   class Router
     
     class Behavior
-
-      class Error  StandardError; end;
+      
+      class Error  StandardError; end
       
       # Proxy catches any methods and proxies them to the current behavior.
       # This allows building routes without constantly having to catching the
       # yielded behavior object
-      # ---
-      # @private
-      class Proxy #:nodoc:
+      # 
+      # @api private
+      class Proxy
+        
         # Undefine as many methods as possible so that everything can be proxied
         # along to the behavior
         instance_methods.each { |m| undef_method m unless %w[ __id__ __send__ class kind_of? respond_to? assert_kind_of should should_not instance_variable_set instance_variable_get instance_eval].include?(m) }
         
+        # @api private
         def initialize
           @behaviors = []
         end
         
+        # Puts a behavior on the bottom of the stack.
+        # 
+        # ==== Notes
+        # The behaviors keep track of nested scopes.
+        # 
+        # @api private
         def push(behavior)
           @behaviors.push(behavior)
         end
         
+        # Removes the top-most behavior.
+        # 
+        # ==== Notes
+        # This occurs at the end of a nested scope (namespace, etc).
+        # 
+        # @api private
         def pop
           @behaviors.pop
         end
         
+        # Tests whether the top-most behavior responds to the arguments.
+        # 
+        # ==== Notes
+        # Behaviors contain the actual functionality of the proxy.
+        # 
+        # @api private
         def respond_to?(*args)
           super || @behaviors.last.respond_to?(*args)
         end
@@ -35,7 +55,7 @@ def respond_to?(*args)
         # Rake does some stuff with methods in the global namespace, so if I don't
         # explicitly define the Behavior methods to proxy here (specifically namespace)
         # Rake's methods take precedence.
-        # ---
+        # 
         # Removing the following:
         # name full_name fixatable redirect
         %w(
@@ -49,25 +69,86 @@ def #{method}(*args, &block)
           }
         end
         
-        # --- These methods are to be used in defer_to blocks
+        # == These methods are to be used in defer_to blocks
         
-        # Generates a URL from the passed arguments. This method is for use
-        # inside of defer_to 
+        # There are three possible ways to use this method.  First, if you have a named route, 
+        # you can specify the route as the first parameter as a symbol and any paramters in a 
+        # hash.  Second, you can generate the default route by just passing the params hash, 
+        # just passing the params hash.  Finally, you can use the anonymous parameters.  This 
+        # allows you to specify the parameters to a named route in the order they appear in the 
+        # router.  
+        #
+        # ==== Parameters(Named Route)
+        # nameSymbol:: 
+        #   The name of the route. 
+        # argsHash:: 
+        #   Parameters for the route generation.
+        #
+        # ==== Parameters(Default Route)
+        # argsHash:: 
+        #   Parameters for the route generation.  This route will use the default route. 
+        #
+        # ==== Parameters(Anonymous Parameters)
+        # nameSymbol::
+        #   The name of the route.  
+        # argsArray:: 
+        #   An array of anonymous parameters to generate the route
+        #   with. These parameters are assigned to the route parameters
+        #   in the order that they are passed.
+        #
+        # ==== Returns
+        # String:: The generated URL.
+        #
+        # ==== Examples
+        # Named Route
+        #
+        # Merb::Router.prepare do
+        #   match("/articles/:title").to(:controller = :articles, :action = :show).name("articles")
+        # end
+        #
+        # url(:articles, :title = "new_article")
+        #
+        # Default Route
+        #
+        # Merb::Router.prepare do
+        #   default_routes
+        # end
+        #
+        # url(:controller = "articles", :action = "new")
+        #
+        # Anonymous Paramters
+        #
+        # Merb::Router.prepare do
+        #   match("/articles/:year/:month/:title").to(:controller = :articles, :action = :show).name("articles")
+        # end
+        #
+        # url(:articles, 2008, 10, "test_article")
+        #
+        # @api public
         def url(name, *args)
           args  {}
           Merb::Router.url(name, *args)
         end
         
+        # Generates a Rack redirection response.
+        # 
+        # ==== Notes
+        # Refer to Merb::Rack::Helpers.redirect for documentation.
+        # 
+        # @api public
         def redirect(url, opts = {})
           Merb::Rack::Helpers.redirect(url, opts)
         end
         
-        def route(params)
-          params
-        end
+        private
         
-      private
-      
+        # Proxies the method calls to the behavior.
+        # 
+        # ==== Notes
+        # Please refer to:
+        # http://ruby-doc.org/core/classes/Kernel.html#M005951
+        # 
+        # @api private
         def method_missing(method, *args, &block)
           behavior = @behaviors.last
           
@@ -78,14 +159,14 @@ def method_missing(method, *args, &block)
           end
         end
       end
-
+      
       # Behavior objects are used for the Route building DSL. Each object keeps
       # track of the current definitions for the level at which it is defined.
       # Each time a method is called on a Behavior object that accepts a block,
       # a new instance of the Behavior class is created.
-      #
+      # 
       # ==== Parameters
-      #
+      # 
       # proxyProxy::
       #   This is the object initialized by Merb::Router.prepare that tracks the
       #   current Behavior object stack so that Behavior methods can be called
@@ -100,11 +181,11 @@ def method_missing(method, *args, &block)
       #   The initial route options. See #options.
       # blocksArray::
       #   The stack of deferred routing blocks for the route
-      #
+      # 
       # ==== Returns
       # Behavior:: The initialized Behavior object
-      #---
-      # @private
+      # 
+      # @api private
       def initialize(proxy = nil, conditions = {}, params = {}, defaults = {}, identifiers = {}, options = {}, blocks = []) #:nodoc:
         @proxy       = proxy
         @conditions  = conditions
@@ -113,130 +194,129 @@ def initialize(proxy = nil, conditions = {}, params = {}, defaults = {}, identif
         @identifiers = identifiers
         @options     = options
         @blocks      = blocks
-
+        
         stringify_condition_values
       end
-
+      
       # Defines the +conditions+ that are required to match a Request. Each
       # +condition+ is applied to a method of the Request object. Conditions
       # can also be applied to segments of the +path+.
-      #
+      # 
       # If #match is passed a block, it will create a new route scope with
       # the conditions passed to it and yield to the block such that all
       # routes that are defined in the block have the conditions applied
       # to them.
-      #
+      # 
       # ==== Parameters
-      #
+      # 
       # pathString, Regexp::
       #   The pattern against which Merb::Request path is matched.
-      #
+      # 
       #   When +path+ is a String, any substring that is wrapped in parenthesis
       #   is considered optional and any segment that begins with a colon, ex.:
       #   ":login", defines both a capture and a named param. Extra conditions
       #   can then be applied each named param individually.
-      #
+      # 
       #   When +path+ is a Regexp, the pattern is left untouched and the
       #   Merb::Request path is matched against it as is.
       #
       #   +path+ is optional.
-      #
+      # 
       # conditionsHash::
       #   Additional conditions that the request must meet in order to match.
       #   The keys must be the names of previously defined path segments or
       #   be methods that the Merb::Request instance will respond to.  The
       #   value is the string or regexp that matched the returned value.
       #   Conditions are inherited by child routes.
-      #
+      # 
       # &block::
       #   All routes defined in the block will be scoped to the conditions
       #   defined by the #match method.
-      #
+      # 
       # ==== Block parameters
       # rBehavior:: +optional+ - The match behavior object.
-      #
+      # 
       # ==== Returns
       # Behavior::
       #   A new instance of Behavior with the specified path and conditions.
-      #
+      # 
       # +Tip+: When nesting always make sure the most inner sub-match registers
-      # a Route and doesn't just returns new Behaviors.
-      #
+      # a Route and doesn't just return new Behaviors.
+      # 
       # ==== Examples
-      #
+      # 
       #   # registers /foo/bar to controller = "foo", :action = "bar"
       #   # and /foo/baz to controller = "foo", :action = "baz"
       #   match("/foo") do
       #     match("/bar").to(:controller = "foo", :action = "bar")
       #     match("/baz").to(:controller = "foo", :action = "caz")
       #   end
-      #
+      # 
       #   # Checks the format of the segments against the specified Regexp
       #   match("/:string/:number", :string = /[a-z]+/, :number = /\d+/).
       #     to(:controller = "string_or_numbers")
-      #
+      # 
       #   # Equivalent to the default_route
       #   match("/:controller(/:action(:id))(.:format)").register
-      #
+      # 
       #   #match only if the browser string contains MSIE or Gecko
       #   match("/foo", :user_agent = /(MSIE|Gecko)/ )
       #        .to(:controller = 'foo', :action = 'popular')
-      #
+      # 
       #   # Route GET and POST requests to different actions (see also #resources)
       #   r.match('/foo', :method = :get).to(:action = 'show')
       #   r.match('/foo', :method = :post).to(:action = 'create')
-      #
+      # 
       #   # match also takes regular expressions
-      #
+      # 
       #   r.match(%r[/account/([a-z]{4,6})]).to(:controller = "account",
       #      :action = "show", :id = "[1]")
-      #
+      # 
       #   r.match(%r{/?(en|es|fr|be|nl)?}).to(:language = "[1]") do
       #     match("/guides/:action/:id").to(:controller = "tour_guides")
       #   end
-      #---
-      # @public
+      # 
+      # @api public
       def match(path = {}, conditions = {}, &block)
         path, conditions = path[:path], path if path.is_a?(Hash)
-
-        raise Error, "The route has already been committed. Further conditions cannot be specified" if @route
         
+        raise Error, "The route has already been committed. Further conditions cannot be specified" if @route
         
         conditions.delete_if { |k, v| v.nil? }
         conditions[:path] = merge_paths(path)
-
+        
         behavior = Behavior.new(@proxy, @conditions.merge(conditions), @params, @defaults, @identifiers, @options, @blocks)
         with_behavior_context(behavior, &block)
       end
       
       # Creates a Route from one or more Behavior objects, unless a +block+ is
       # passed in.
-      #
+      # 
       # ==== Parameters
       # paramsHash:: The parameters the route maps to.
-      #
+      # 
       # &block::
       #   All routes defined in the block will be scoped to the params
       #   defined by the #to method.
-      #
+      # 
       # ==== Block parameters
       # rBehavior:: +optional+ - The to behavior object.
-      #
+      # 
       # ==== Returns
       # Route:: It registers a new route and returns it.
-      #
+      # 
       # ==== Examples
       #   match('/:controller/:id).to(:action = 'show')
-      #
+      # 
       #   to(:controller = 'simple') do
       #     match('/test').to(:action = 'index')
       #     match('/other').to(:action = 'other')
       #   end
-      #---
-      # @public
+      # 
+      # @api public
       def to(params = {}, &block)
         raise Error, "The route has already been committed. Further params cannot be specified" if @route
-
+        
         behavior = Behavior.new(@proxy, @conditions, @params.merge(params), @defaults, @identifiers, @options, @blocks)
         
         if block_given?
@@ -247,7 +327,8 @@ def to(params = {}, &block)
       end
       
       # Equivalent of #to. Allows for some nicer syntax when scoping blocks
-      # --- Ex:
+      # 
+      # ==== Examples
       # Merb::Router.prepare do
       #   with(:controller = "users") do
       #     match("/signup").to(:action = "signup")
@@ -255,32 +336,32 @@ def to(params = {}, &block)
       #     match("/logout").to(:action = "logout")
       #   end
       # end
-      alias_method :with, :to
+      alias :with :to
       
       # Equivalent of #to. Allows for nicer syntax when registering routes with no params
-      # --- Ex:
+      # 
+      # ==== Examples
       # Merb::Router.prepare do
       #   match("/:controller(/:action(/:id))(.:format)").register
       # end
-      #
-      alias_method :register, :to
+      alias :register :to
       
       # Sets default values for route parameters. If no value for the key
       # can be extracted from the request, then the value provided here
       # will be used.
-      #
+      # 
       # ==== Parameters
       # defaultsHash::
       #   The default values for named segments.
-      #
+      # 
       # &block::
       #   All routes defined in the block will be scoped to the defaults defined
       #   by the #default method.
-      #
+      # 
       # ==== Block parameters
       # rBehavior:: +optional+ - The defaults behavior object.
-      # ---
-      # @public
+      # 
+      # @api public
       def default(defaults = {}, &block)
         behavior = Behavior.new(@proxy, @conditions, @params, @defaults.merge(defaults), @identifiers, @options, @blocks)
         with_behavior_context(behavior, &block)
@@ -289,34 +370,34 @@ def default(defaults = {}, &block)
       alias_method :defaults, :default
       
       # Allows the fine tuning of certain router options.
-      #
+      # 
       # ==== Parameters
       # optionsHash::
       #   The options to set for all routes defined in the scope. The currently
       #   supported options are:
       #   * :controller_prefix - The module that the controller is included in.
       #   * :name_prefix       - The prefix added to all routes named with #name
-      #
+      # 
       # &block::
       #   All routes defined in the block will be scoped to the options defined
       #   by the #options method.
-      #
+      # 
       # ==== Block parameters
       # rBehavior:: The options behavior object. This is optional
-      #
+      # 
       # ==== Examples
       #   # If :group is not matched in the path, it will be "registered" instead
       #   # of nil.
       #   match("/users(/:group)").default(:group = "registered")
-      # ---
-      # @public
+      # 
+      # @api public
       def options(opts = {}, &block)
         options = @options.dup
-
+        
         opts.each_pair do |key, value|
           options[key] = (options[key] || []) + [value.freeze] if value
         end
-
+        
         behavior = Behavior.new(@proxy, @conditions, @params, @defaults, @identifiers, options, @blocks)
         with_behavior_context(behavior, &block)
       end
@@ -325,44 +406,47 @@ def options(opts = {}, &block)
       
       # Creates a namespace for a route. This way you can have logical
       # separation to your routes.
-      #
+      # 
       # ==== Parameters
       # name_or_pathString, Symbol::
       #   The name or path of the namespace.
-      #
+      # 
       # optionsHash::
-      #   Optional hash, set :path if you want to override what appears on the url
-      #
+      #   Optional hash (see below)
+      # 
       # &block::
       #   All routes defined in the block will be scoped to the namespace defined
       #   by the #namespace method.
-      #
+      # 
+      # ==== Options (opts)
+      # :pathString:: match against this url
+      # 
       # ==== Block parameters
       # rBehavior:: The namespace behavior object. This is optional
-      #
+      # 
       # ==== Examples
       #   namespace :admin do
       #     resources :accounts
       #     resource :email
       #   end
-      #
+      # 
       #   # /super_admin/accounts
       #   namespace(:admin, :path="super_admin") do
       #     resources :accounts
       #   end
-      # ---
-      # @public
+      # 
+      # @api public
       def namespace(name_or_path, opts = {}, &block)
         name = name_or_path.to_s # We don't want this modified ever
         path = opts.has_key?(:path) ? opts[:path] : name
-
+        
         raise Error, "The route has already been committed. Further options cannot be specified" if @route
-
+        
         # option keys could be nil
         opts[:controller_prefix] = name unless opts.has_key?(:controller_prefix)
         opts[:name_prefix]       = name unless opts.has_key?(:name_prefix)
         opts[:resource_prefix]   = opts[:name_prefix] unless opts.has_key?(:resource_prefix)
-
+        
         behavior = self
         behavior = behavior.match("/#{path}") unless path.nil? || path.empty?
         behavior.options(opts, &block)
@@ -372,22 +456,22 @@ def namespace(name_or_path, opts = {}, &block)
       # insertion into a route. This is useful when using models and want a
       # specific method to be called on it (For example, for ActiveRecord::Base
       # it would be #to_param).
-      #
+      # 
       # The default method called on objects is #to_s.
-      #
+      # 
       # ==== Paramters
       # identifiersHash::
       #   The keys are Classes and the values are the method that instances of the specified
       #   class should have called on.
-      #
+      # 
       # &block::
       #   All routes defined in the block will be call the specified methods during
       #   generation.
-      #
+      # 
       # ==== Block parameters
       # rBehavior:: The identify behavior object. This is optional
-      # ---
-      # @public
+      # 
+      # @api public
       def identify(identifiers = {}, &block)
         identifiers = if Hash === identifiers
           @identifiers.merge(identifiers)
@@ -402,23 +486,23 @@ def identify(identifiers = {}, &block)
       # Creates the most common routes /:controller/:action/:id.format when
       # called with no arguments. You can pass a hash or a block to add parameters
       # or override the default behavior.
-      #
+      # 
       # ==== Parameters
       # paramsHash::
       #   This optional hash can be used to augment the default settings
-      #
+      # 
       # &block::
       #   When passing a block a new behavior is yielded and more refinement is
       #   possible.
-      #
+      # 
       # ==== Returns
       # Route:: the default route
-      #
+      # 
       # ==== Examples
-      #
+      # 
       #   # Passing an extra parameter "mode" to all matches
       #   r.default_routes :mode = "default"
-      #
+      # 
       #   # specifying exceptions within a block
       #   r.default_routes do |nr|
       #     nr.defer_to do |request, params|
@@ -426,31 +510,31 @@ def identify(identifiers = {}, &block)
       #         :action = "new") if request.env["REQUEST_URI"] =~ /\/private\//
       #     end
       #   end
-      #---
-      # @public
+      # 
+      # @api public
       def default_routes(params = {}, &block)
         match("/:controller(/:action(/:id))(.:format)").to(params, &block).name(:default)
       end
       
       # Takes a block and stores it for deferred conditional routes. The block
       # takes the +request+ object and the +params+ hash as parameters.
-      #
+      # 
       # ==== Parameters
       # paramsHash:: Parameters and conditions associated with this behavior.
       # &conditional_block::
       #   A block with the conditions to be met for the behavior to take
       #   effect.
-      #
+      # 
       # ==== Returns
       # Route :: The default route.
-      #
+      # 
       # ==== Examples
       #   defer_to do |request, params|
       #     params.merge :controller = 'here',
       #       :action = 'there' if request.xhr?
       #   end
-      #---
-      # @public
+      # 
+      # @api public
       def defer_to(params = {}, &block)
         defer(block).to(params)
       end
@@ -458,27 +542,39 @@ def defer_to(params = {}, &block)
       # Takes a Proc as a parameter and applies it as a deferred proc for all the
       # routes defined in the block. This is mostly interesting for plugin
       # developers.
+      # 
+      # ==== Examples
+      #   defered_block = proc do |r, p|
+      #     p.merge :controller = 'api/comments' if request.xhr?
+      #   end
+      #   defer(defered_block) do
+      #     resources :comments
+      #   end
+      # 
+      # @api public
       def defer(deferred_block, &block)
         blocks = @blocks + [CachedProc.new(deferred_block)]
         behavior = Behavior.new(@proxy, @conditions, @params, @defaults, @identifiers, @options, blocks)
         with_behavior_context(behavior, &block)
       end
       
-      # Names this route in Router. Name must be a Symbol.
-      #
+      # Registers the route as a named route with the name given.
+      # 
       # ==== Parameters
-      # symbolSymbol:: The name of the route.
-      #
+      # symbolSymbol:: the name of the route.
+      # 
       # ==== Raises
       # ArgumentError:: symbol is not a Symbol.
+      # 
+      # @api public
       def name(prefix, name = nil)
         unless name
           name, prefix = prefix, nil
         end
-
+        
         full_name([prefix, @options[:name_prefix], name].flatten.compact.join('_'))
       end
-
+      
       # Names this route in Router. Name must be a Symbol. The current
       # name_prefix is ignored.
       #
@@ -487,6 +583,8 @@ def name(prefix, name = nil)
       #
       # ==== Raises
       # ArgumentError:: symbol is not a Symbol.
+      # 
+      # @api private
       def full_name(name)
         if @route
           @route.name = name
@@ -496,27 +594,34 @@ def full_name(name)
         end
       end
       
+      # Specifies that a route can be fixatable.
+      # 
       # ==== Parameters
       # enabledBoolean:: True enables fixation on the route.
+      # 
+      # @api public
       def fixatable(enable = true)
         @route.fixation = enable
         self
       end
-
-      # Sets the current route as a redirect.
-      #
+      
+      # Redirects the current route.
+      # 
       # ==== Parameters
-      # pathString::
-      #   The path to redirect to
-      #
+      # pathString:: The path to redirect to.
+      # 
       # optionsHash::
-      #   Options for the redirect
-      #   The supported options are:
-      #   * :permanent: Whether or not the redirect should be permanent.
-      #                 The default value is false.
+      #   Options (see below)
+      # 
+      # ==== Options (opts)
+      # :permanentBoolean::
+      #   Whether or not the redirect should be permanent.
+      #   The default value is false.
+      # 
+      # @api public
       def redirect(url, opts = {})
         raise Error, "The route has already been committed." if @route
-
+        
         status = opts[:permanent] ? 301 : 302
         @route = Route.new(@conditions, {:url = url.freeze, :status = status.freeze}, @blocks, :redirects = true)
         @route.register
@@ -529,6 +634,8 @@ def redirect(url, opts = {})
       # it doesn't affect how/which routes are added.
       #
       # &block:: A context in which routes are generated.
+      # 
+      # @api public
       def capture(&block)
         captured_routes = {}
         name_prefix     = [@options[:name_prefix]].flatten.compact.map { |p| "#{p}_"}
@@ -545,27 +652,42 @@ def capture(&block)
         captured_routes
       end
       
-      # So that Router can have a default route
-      # ---
-      # @private
-      def _with_proxy(&block) #:nodoc:
+      # Proxy routes with the default behaviors.
+      # 
+      # ==== Parameters
+      # &block:: defines routes within the provided context.
+      # 
+      # @api private
+      def _with_proxy(&block)
         proxy = Proxy.new
         proxy.push Behavior.new(proxy, @conditions, @params, @defaults, @identifiers, @options, @blocks)
         proxy.instance_eval(&block)
         proxy
       end
       
-    protected
-    
+      protected
+      
+      # Returns the current route.
+      # 
+      # ==== Returns
+      # Route:: the route.
+      # 
+      # @api private
       def _route
         @route
       end
       
-      def to_route # :nodoc:
+      # Turns a route definition into a Route object.
+      # 
+      # ==== Returns
+      # Route:: the route generated.
+      # 
+      # @api private
+      def to_route
         raise Error, "The route has already been committed." if @route
-
+        
         controller = @params[:controller]
-
+        
         if prefixes = @options[:controller_prefix]
           controller ||= ":controller"
           
@@ -594,12 +716,22 @@ def to_route # :nodoc:
       
       # Allows to insert the route at a certain spot in the list of routes
       # instead of appending to the list.
-      def before(route, &block) #:nodoc:
+      # 
+      # ==== Params
+      # routeRoute:: the route to insert before.
+      # &block:: the route definition to insert.
+      # 
+      # @api plugin
+      def before(route, &block)
         options(:before = route, &block)
       end
-
-    private
-    
+      
+      private
+      
+      # Takes @conditions and turns values into strings (except for Regexp and
+      # Array values).
+      # 
+      # @api private
       def stringify_condition_values # :nodoc:
         @conditions.each do |key, value|
           unless value.nil? || Regexp === value || Array === value
@@ -607,7 +739,18 @@ def stringify_condition_values # :nodoc:
           end
         end
       end
-    
+      
+      # Creates a new context with a given behavior for the route definition in
+      # the block.
+      # 
+      # ==== Params
+      # behaviorBehavior:: the behavior to proxy the calls in the block.
+      # &block:: the routing definitions to be nested within the behavior.
+      # 
+      # ==== Returns
+      # Behavior:: the behavior wrapping.
+      # 
+      # @api private
       def with_behavior_context(behavior, &block) # :nodoc:
         if block_given?
           @proxy.push(behavior)
@@ -616,11 +759,25 @@ def with_behavior_context(behavior, &block) # :nodoc:
         end
         behavior
       end
-
+      
+      # Merges the path elements together into an array to be joined for
+      # generating named routes.
+      # 
+      # ==== Parameters
+      # pathString:: the path to merge at the end.
+      # 
+      # ==== Returns
+      # Array:: array of path elements.
+      # 
+      # ==== Notes
+      # An array of ['a', 'b'] (the 'a' namespace with the 'b' action) will
+      # produce a name of :a_b.
+      # 
+      # @api private
       def merge_paths(path) # :nodoc:
         [@conditions[:path], path.freeze].flatten.compact
       end
-
+      
     end
   end
 end
\ No newline at end of file</diff>
				</file>
				<file>
					<file_name>lib/merb-core/dispatch/session.rb</file_name>
					<diff>@@ -6,6 +6,8 @@ class Config
     # Returns stores list constructed from
     # configured session stores (:session_stores config option)
     # or default one (:session_store config option).
+    # 
+    # @api private
     def self.session_stores
       @session_stores ||= begin
         config_stores = Array(
@@ -15,7 +17,7 @@ def self.session_stores
       end
     end
   end # Config
-
+  
   # The Merb::Session module gets mixed into Merb::SessionContainer to allow
   # app-level functionality (usually found in app/models/merb/session.rb) for
   # session.
@@ -23,35 +25,37 @@ def self.session_stores
   # You can use this module to implement additional methods to simplify
   # building wizard-like application components,
   # authentication frameworks, etc.
+  # 
+  # Session configuration options:
+  #
+  # :session_id_key           The key by which a session value/id is
+  #                           retrieved; defaults to _session_id
+  #
+  # :session_expiry           When to expire the session cookie;
+  #                           defaults to 2 weeks
+  #
+  # :session_secret_key       A secret string which is used to sign/validate
+  #                           session data; min. 16 chars
+  #
+  # :default_cookie_domain    The default domain to write cookies for.
   module Session
   end
-
+  
   # This is mixed into Merb::Controller on framework boot.
   module SessionMixin
     # Raised when no suitable session store has been setup.
     class NoSessionContainer  StandardError; end
-
+    
     # Raised when storing more data than the available space reserved.
     class SessionOverflow  StandardError; end
-
-    # Session configuration options:
-    #
-    # :session_id_key           The key by which a session value/id is
-    #                           retrieved; defaults to _session_id
-    #
-    # :session_expiry           When to expire the session cookie;
-    #                           defaults to 2 weeks
-    #
-    # :session_secret_key       A secret string which is used to sign/validate
-    #                           session data; min. 16 chars
-    #
-    # :default_cookie_domain    The default domain to write cookies for.
+    
+    # @api private
     def self.included(base)
       # Register a callback to finalize sessions - needs to run before the cookie
       # callback extracts Set-Cookie headers from request.cookies.
       base._after_dispatch_callbacks.unshift lambda { |c| c.request.finalize_session }
     end
-
+    
     # ==== Parameters
     # session_storeString:: The type of session store to access.
     #
@@ -60,9 +64,9 @@ def self.included(base)
     def session(session_store = nil)
       request.session(session_store)
     end
-
+    
     # Module methods
-
+    
     # ==== Returns
     # String:: A random 32 character string for use as a unique session ID.
     def rand_uuid
@@ -77,59 +81,76 @@ def rand_uuid
       ]
       "%04x%04x%04x%04x%04x%06x%06x" % values
     end
-
+    
     # Marks this session as needing a new cookie.
+    # 
+    # @api private
     def needs_new_cookie!
       @_new_cookie = true
     end
-
+    
+    # Does session need new cookie?
+    # 
+    # ==== Returns
+    # Boolean:: true if a new cookie is needed, false otherwise.
+    # 
+    # @api private
     def needs_new_cookie?
       @_new_cookie
     end
-
+    
     module_function :rand_uuid, :needs_new_cookie!, :needs_new_cookie?
-
+    
     module RequestMixin
-
+      
+      # Adds class methods to Merb::Request object.
+      # Sets up repository of session store types.
+      # Sets the session ID key and expiry values.
       def self.included(base)
         base.extend ClassMethods
-
+        
         # Keep track of all known session store types.
         base.cattr_accessor :registered_session_types
         base.registered_session_types = Dictionary.new
         base.class_inheritable_accessor :_session_id_key, :_session_secret_key,
                                         :_session_expiry
-
+        
         base._session_id_key        = Merb::Config[:session_id_key] || '_session_id'
         base._session_expiry        = Merb::Config[:session_expiry] || 0
         base._session_secret_key    = Merb::Config[:session_secret_key]
       end
-
+      
       module ClassMethods
-
+        
         # ==== Parameters
         # name~to_sym:: Name of the session type to register.
         # class_nameString:: The corresponding class name.
         #
         # === Notres
         # This is automatically called when Merb::SessionContainer is subclassed.
+        # 
+        # @api private
         def register_session_type(name, class_name)
           self.registered_session_types[name.to_sym] = class_name
         end
-
+        
       end
-
+      
       # The default session store type.
+      # 
+      # @api private
       def default_session_store
         Merb::Config[:session_store] && Merb::Config[:session_store].to_sym
       end
-
+      
       # ==== Returns
       # Hash:: All active session stores by type.
+      # 
+      # @api private
       def session_stores
         @session_stores ||= {}
       end
-
+      
       # Returns session container. Merb is able to handle multiple session
       # stores, hence a parameter to pick it.
       #
@@ -140,6 +161,12 @@ def session_stores
       # === Notes
       # If no suitable session store type is given, it defaults to
       # cookie-based sessions.
+      # 
+      # ==== Returns
+      # SessionContainer::
+      #   an instance of a session store extending Merb::SessionContainer.
+      # 
+      # @api public
       def session(session_store = nil)
         session_store ||= default_session_store
         if class_name = self.class.registered_session_types[session_store]
@@ -154,12 +181,14 @@ def session(session_store = nil)
           raise NoSessionContainer, msg            
         end
       end
-
+      
       # ==== Parameters
       # new_sessionMerb::SessionContainer:: A session store instance.
       #
       # === Notes
       # The session is assigned internally by its session_store_type key.
+      # 
+      # @api private
       def session=(new_session)
         if self.session?(new_session.class.session_store_type)
           original_session_id = self.session(new_session.class.session_store_type).session_id
@@ -169,21 +198,30 @@ def session=(new_session)
         end
         session_stores[new_session.class.session_store_type] = new_session
       end
-
+      
       # Whether a session has been setup
+      # 
+      # ==== Returns
+      # Boolean:: true if the session is part of the session stores configured.
+      # 
+      # @api private
       def session?(session_store = nil)
         (session_store ? [session_store] : session_stores).any? do |type, store|
           store.is_a?(Merb::SessionContainer)
         end
       end
-
+      
       # Teardown and/or persist the current sessions.
+      # 
+      # @api private
       def finalize_session
         session_stores.each { |name, store| store.finalize(self) }
       end
       alias :finalize_sessions :finalize_session
-
+      
       # Assign default cookie values
+      # 
+      # @api private
       def default_cookies
         defaults = {}
         if route && route.allow_fixation? && params.key?(_session_id_key)
@@ -198,6 +236,8 @@ def default_cookies
       # ==== Parameters
       # valueString:: The value of the session cookie; either the session id or the actual encoded data.
       # optionsHash:: Cookie options like domain, path and expired.
+      # 
+      # @api private
       def set_session_cookie_value(value, options = {})
         defaults = {}
         defaults[:expires] = Time.now + _session_expiry if _session_expiry  0
@@ -207,12 +247,16 @@ def set_session_cookie_value(value, options = {})
 
       # ==== Returns
       # String:: The value of the session cookie; either the session id or the actual encoded data.
+      # 
+      # @api private
       def session_cookie_value
         cookies[_session_id_key]
       end
       alias :session_id :session_cookie_value
       
       # Destroy the session cookie.
+      # 
+      # @api private
       def destroy_session_cookie
         cookies.delete(_session_id_key)
       end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/dispatch/session/container.rb</file_name>
					<diff>@@ -1,41 +1,49 @@
 module Merb
   class SessionContainer  Mash
-  
+    
     class_inheritable_accessor :session_store_type
     cattr_accessor :subclasses 
     self.subclasses = []
-  
+    
     attr_reader :session_id
     attr_accessor :needs_new_cookie
-  
+    
     class  self
-  
+      
       # Register the subclass as an available session store type.
       def inherited(klass)
         self.subclasses  klass.to_s
         super
       end
-
+      
       # Generates a new session ID and creates a new session.
       #
       # ==== Returns
       # SessionContainer:: The new session.
+      # 
+      # @api private
       def generate
       end
-    
+      
       # ==== Parameters
       # requestMerb::Request:: The Merb::Request that came in from Rack.
       #
+      # ==== Notes
+      # If no sessions were found, a new SessionContainer will be generated.
+      # 
       # ==== Returns
-      # SessionContainer:: a SessionContainer. If no sessions were found, 
-      # a new SessionContainer will be generated.
+      # SessionContainer:: a SessionContainer.
+      # 
+      # @api private
       def setup(request)
-      end    
-    
+      end
+      
     end
-  
+    
     # ==== Parameters
     # session_idString:: A unique identifier for this session.
+    # 
+    # @api private
     def initialize(session_id)
       @_destroy = false
       self.session_id = session_id
@@ -45,11 +53,13 @@ def initialize(session_id)
     #
     # Recreates the cookie with the default expiration time. Useful during log
     # in for pushing back the expiration date.
+    # 
+    # @api private
     def session_id=(sid)
       self.needs_new_cookie = (@session_id && @session_id != sid)
       @session_id = sid
     end
-  
+    
     # Teardown and/or persist the current session.
     #
     # If @_destroy is true, clear out the session completely, including
@@ -57,18 +67,24 @@ def session_id=(sid)
     #
     # ==== Parameters
     # requestMerb::Request:: The Merb::Request that came in from Rack.
+    # 
+    # @api private
     def finalize(request)
     end
-  
+    
     # Destroy the current session - clears data and removes session cookie.
+    # 
+    # @api private
     def clear!
       @_destroy = true
       self.clear
     end
-  
+    
     # Regenerate the session_id.
+    # 
+    # @api private
     def regenerate
     end
-
+    
   end
 end
\ No newline at end of file</diff>
				</file>
				<file>
					<file_name>lib/merb-core/dispatch/session/cookie.rb</file_name>
					<diff>@@ -1,7 +1,7 @@
 require 'base64'        # to convert Marshal.dump to ASCII
 require 'openssl'       # to generate the HMAC message digest
 module Merb
-
+  
   # If you have more than 4K of session data or don't want your data to be
   # visible to the user, pick another session store.
   #
@@ -19,31 +19,33 @@ class CookieSession  SessionContainer
     # TODO (maybe):
     # include request ip address
     # AES encrypt marshaled data
-
+    
     # Raised when storing more than 4K of session data.
     class CookieOverflow  StandardError; end
-
+    
     # Raised when the cookie fails its integrity check.
     class TamperedWithCookie  StandardError; end
-
+    
     # Cookies can typically store 4096 bytes.
     MAX = 4096
     DIGEST = OpenSSL::Digest::Digest.new('SHA1') # or MD5, RIPEMD160, SHA256?
-
+    
     attr_accessor :_original_session_data
-
+    
     # The session store type
     self.session_store_type = :cookie
-
+    
     class  self
       # Generates a new session ID and creates a new session.
       #
       # ==== Returns
       # SessionContainer:: The new session.
+      # 
+      # @api private
       def generate
         self.new(Merb::SessionMixin.rand_uuid, "", Merb::Request._session_secret_key)
       end
-
+      
       # Set up a new session on request: make it available on request instance.
       #
       # ==== Parameters
@@ -52,22 +54,26 @@ def generate
       # ==== Returns
       # SessionContainer:: a SessionContainer. If no sessions were found,
       # a new SessionContainer will be generated.
+      # 
+      # @api private
       def setup(request)
         session = self.new(Merb::SessionMixin.rand_uuid,
           request.session_cookie_value, request._session_secret_key)
         session._original_session_data = session.to_cookie
         request.session = session
       end
-
+      
     end
-
+    
     # ==== Parameters
     # session_idString:: A unique identifier for this session.
     # cookieString:: The raw cookie data.
     # secretString:: A session secret.
     #
     # ==== Raises
-    # ArgumentError:: Nil or blank secret.
+    # ArgumentError:: blank or insufficiently long secret.
+    # 
+    # @api private
     def initialize(session_id, cookie, secret)
       super session_id
       if secret.blank? || secret.length  16
@@ -78,7 +84,7 @@ def initialize(session_id, cookie, secret)
       @secret = secret
       self.update(unmarshal(cookie))
     end
-
+    
     # Teardown and/or persist the current session.
     #
     # If @_destroy is true, clear out the session completely, including
@@ -86,6 +92,8 @@ def initialize(session_id, cookie, secret)
     #
     # ==== Parameters
     # requestMerb::Request:: request object created from Rack environment.
+    # 
+    # @api private
     def finalize(request)
       if @_destroy
         request.destroy_session_cookie
@@ -95,10 +103,12 @@ def finalize(request)
     end
     
     # Regenerate the session_id.
+    # 
+    # @api private
     def regenerate
       self.session_id = Merb::SessionMixin.rand_uuid
     end
-
+    
     # Create the raw cookie string; includes an HMAC keyed message digest.
     #
     # ==== Returns
@@ -111,6 +121,8 @@ def regenerate
     # Session data is converted to a Hash first, since a container might
     # choose to marshal it, which would make it persist
     # attributes like 'needs_new_cookie', which it shouldn't.
+    # 
+    # @api private
     def to_cookie
       unless self.empty?
         data = self.serialize
@@ -123,24 +135,31 @@ def to_cookie
         value
       end
     end
-
+    
     private
-
+    
     # Generate the HMAC keyed message digest. Uses SHA1.
+    # 
+    # ==== Returns
+    # String:: an HMAC digest of the cookie data.
+    # 
+    # @api private
     def generate_digest(data)
       OpenSSL::HMAC.hexdigest(DIGEST, @secret, data)
     end
-
+    
     # Unmarshal cookie data to a hash and verify its integrity.
-    #
+    # 
     # ==== Parameters
     # cookie~to_s:: The cookie to unmarshal.
-    #
+    # 
     # ==== Raises
     # TamperedWithCookie:: The digests don't match.
-    #
+    # 
     # ==== Returns
     # Hash:: The stored session data.
+    # 
+    # @api private
     def unmarshal(cookie)
       if cookie.blank?
         {}
@@ -156,16 +175,26 @@ def unmarshal(cookie)
         unserialize(data)
       end
     end
-
+    
     protected
-
+    
     # Serialize current session data as a Hash.
     # Uses Base64 encoding for integrity.
+    # 
+    # ==== Returns
+    # String:: Base64 encoded dump of the session hash.
+    # 
+    # @api private
     def serialize
       Base64.encode64(Marshal.dump(self.to_hash)).chop
     end
-
+    
     # Unserialize the raw cookie data to a Hash
+    # 
+    # ==== Returns
+    # Hash:: the session hash Base64 decoded from the data dump.
+    # 
+    # @api private
     def unserialize(data)
       Marshal.load(Base64.decode64(data)) rescue {}
     end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/dispatch/session/memcached.rb</file_name>
					<diff>@@ -28,33 +28,37 @@ class MemcacheSession  SessionStoreContainer
   end
   
   module MemcacheStore
-
+    
     # Make the Memcached gem conform to the SessionStoreContainer interface
-
+    
     # ==== Parameters
     # session_idString:: ID of the session to retrieve.
     #
     # ==== Returns
     # ContainerSession:: The session corresponding to the ID.
+    # 
+    # @api private
     def retrieve_session(session_id)
       get("session:#{session_id}")
     end
-
+    
     # ==== Parameters
     # session_idString:: ID of the session to set.
     # dataContainerSession:: The session to set.
+    # 
+    # @api private
     def store_session(session_id, data)
       set("session:#{session_id}", data)
     end
-
+    
     # ==== Parameters
     # session_idString:: ID of the session to delete.
     def delete_session(session_id)
       delete("session:#{session_id}")
     end
-
+    
   end
-
+  
 end
 
 # For the memcached gem.</diff>
				</file>
				<file>
					<file_name>lib/merb-core/dispatch/session/memory.rb</file_name>
					<diff>@@ -34,9 +34,11 @@ def self.store
   
   # Used for handling multiple sessions stored in memory.
   class MemorySessionStore
-
+    
     # ==== Parameters
     # ttlFixnum:: Session validity time in seconds. Defaults to 1 hour.
+    # 
+    # @api private
     def initialize(ttl=nil)
       @sessions = Hash.new
       @timestamps = Hash.new
@@ -50,41 +52,51 @@ def initialize(ttl=nil)
     #
     # ==== Returns
     # ContainerSession:: The session corresponding to the ID.
+    # 
+    # @api private
     def retrieve_session(session_id)
       @mutex.synchronize {
         @timestamps[session_id] = Time.now
         @sessions[session_id]
       }
     end
-
+    
     # ==== Parameters
     # session_idString:: ID of the session to set.
     # dataContainerSession:: The session to set.
+    # 
+    # @api private
     def store_session(session_id, data)
       @mutex.synchronize {
         @timestamps[session_id] = Time.now
         @sessions[session_id] = data
       }
     end
-
+    
     # ==== Parameters
     # session_idString:: ID of the session to delete.
+    # 
+    # @api private
     def delete_session(session_id)
       @mutex.synchronize {
         @timestamps.delete(session_id)
         @sessions.delete(session_id)
       }
     end
-
+    
     # Deletes any sessions that have reached their maximum validity.
+    # 
+    # @api private
     def reap_expired_sessions
       @timestamps.each do |session_id,stamp|
         delete_session(session_id) if (stamp + @session_ttl)  Time.now 
       end
       GC.start
     end
-
+    
     # Starts the timer that will eventually reap outdated sessions.
+    # 
+    # @api private
     def start_timer
       Thread.new do
         loop {</diff>
				</file>
				<file>
					<file_name>lib/merb-core/dispatch/session/store_container.rb</file_name>
					<diff>@@ -45,25 +45,31 @@ class SessionStoreContainer  SessionContainer
     self.session_store_type = :store
     
     class  self
-
+      
       # Generates a new session ID and creates a new session.
-      #
+      # 
       # ==== Returns
       # SessionStoreContainer:: The new session.
+      # 
+      # @api private
       def generate
         session = new(Merb::SessionMixin.rand_uuid)
         session.needs_new_cookie = true
         session
       end
-
-      # Setup a new session.
-      #
+      
+      # Setup a new session or retreive an existing session.
+      # 
       # ==== Parameters
       # requestMerb::Request:: The Merb::Request that came in from Rack.
-      #
+      # 
+      # ==== Notes
+      # If no sessions were found, a new SessionContainer will be generated.
+      # 
       # ==== Returns
-      # SessionContainer:: a SessionContainer. If no sessions were found, 
-      # a new SessionContainer will be generated.
+      # SessionContainer:: a SessionContainer.
+      # 
+      # @api private
       def setup(request)
         session = retrieve(request.session_id)
         request.session = session
@@ -84,6 +90,8 @@ def setup(request)
       # ==== Notes
       # If there are persisted exceptions callbacks to execute, they all get executed
       # when Memcache library raises an exception.
+      # 
+      # @api private
       def retrieve(session_id)
         unless session_id.blank?
           begin
@@ -121,6 +129,8 @@ def retrieve(session_id)
     # The data (self) is converted to a Hash first, since a container might 
     # choose to do a full Marshal on the data, which would make it persist 
     # attributes like 'needs_new_cookie', which it shouldn't.
+    # 
+    # @api private
     def finalize(request)
       if @_destroy
         store.delete_session(self.session_id)
@@ -138,8 +148,10 @@ def finalize(request)
         end
       end
     end
-
+    
     # Regenerate the session ID.
+    # 
+    # @api private
     def regenerate
       store.delete_session(self.session_id)
       self.session_id = Merb::SessionMixin.rand_uuid</diff>
				</file>
				<file>
					<file_name>lib/merb-core/dispatch/worker.rb</file_name>
					<diff>@@ -3,14 +3,24 @@ class Worker
     
     attr_accessor :thread
     
+    # ==== Returns
+    # Merb::Worker:: instance of a worker.
+    # 
+    # @api private
     def self.start
       new
     end
     
+    # Creates a new worker thread that loops over the work queue.
+    # 
+    # @api private
     def initialize
       @thread = Thread.new { loop { process_queue } }
     end
     
+    # Processes tasks in the Merb::Dispatcher.work_queue.
+    # 
+    # @api private
     def process_queue
       begin
         while blk = Merb::Dispatcher.work_queue.pop
@@ -25,8 +35,8 @@ def process_queue
       rescue Exception = e
         Merb.logger.warn! %Q!Worker Thread Crashed with Exception:\n#{Merb.exception(e)}\nRestarting Worker Thread!
         retry
-      end    
+      end
     end
     
   end
-end    
\ No newline at end of file
+end
\ No newline at end of file</diff>
				</file>
				<file>
					<file_name>lib/merb-core/gem_ext/erubis.rb</file_name>
					<diff>@@ -1,5 +1,9 @@
 require 'erubis'
 module Erubis
+  # This adds support for embedding the return value of a block call:
+  #   %= foo do %...% end =%
+  #
+  # @api private
   module Basic::Converter
     def convert_input(src, input)
       pat = @pattern</diff>
				</file>
				<file>
					<file_name>lib/merb-core/logger.rb</file_name>
					<diff>@@ -1,16 +1,5 @@
 # Merb::Logger = Extlib::Logger
 
-class Merb::Logger  Extlib::Logger
-  def verbose!(message, level = :warn)
-    send("#{level}!", message) if Merb::Config[:verbose]
-  end
-
-  def verbose(message, level = :warn)
-    send(level, message) if Merb::Config[:verbose]
-  end
-end
-
-# require "time" # httpdate
 # ==== Public Merb Logger API
 #
 # To replace an existing logger with a new one:
@@ -45,168 +34,37 @@ def verbose(message, level = :warn)
 #   Merb::Logger.new(log{String, IO},level{Symbol, String})
 module Merb
 
-  class Logger
-
-    attr_accessor :level
-    attr_accessor :delimiter
-    attr_accessor :auto_flush
-    attr_reader   :buffer
-    attr_reader   :log
-    attr_reader   :init_args
-
-    # ==== Notes
-    # Ruby (standard) logger levels:
-    # :fatal:: An unhandleable error that results in a program crash
-    # :error:: A handleable error condition
-    # :warn:: A warning
-    # :info:: generic (useful) information about system operation
-    # :debug:: low-level information for developers
-    Levels = Mash.new({
-      :fatal = 7,
-      :error = 6,
-      :warn  = 4,
-      :info  = 3,
-      :debug = 0
-    }) unless const_defined?(:Levels)
-
-    @@mutex = {}
+  class Logger  Extlib::Logger
 
-    private
-
-    # Readies a log for writing.
+    # Appends a message to the log if the specified log level is at least as high as
+    # the log level of the logger if Merb::Config[:verbose]. Then flushes the log 
+    # buffer to disk.
     #
     # ==== Parameters
-    # logIO, String:: Either an IO object or a name of a logfile.
-    def initialize_log(log)
-      close if @log # be sure that we don't leave open files laying around.
-
-      if log.respond_to?(:write)
-        @log = log
-      elsif File.exist?(log)
-        @log = open(log, (File::WRONLY | File::APPEND))
-        @log.sync = true
-      else
-        FileUtils.mkdir_p(File.dirname(log)) unless File.directory?(File.dirname(log))
-        @log = open(log, (File::WRONLY | File::APPEND | File::CREAT))
-        @log.sync = true
-        @log.write("#{Time.now.httpdate} #{delimiter} info #{delimiter} Logfile created\n")
-      end
-    end
-
-    public
-
-    # To initialize the logger you create a new object, proxies to set_log.
+    # messageString:: The message to be logged.
+    # levelSymbol:: The level at which to log. Default is :warn.
     #
-    # ==== Parameters
-    # *args:: Arguments to create the log from. See set_logs for specifics.
-    def initialize(*args)
-      set_log(*args)
-    end
-
-    # Replaces an existing logger with a new one.
+    # ==== Returns
+    # self:: The logger object for chaining.
     #
-    # ==== Parameters
-    # logIO, String:: Either an IO object or a name of a logfile.
-    # log_level~to_sym::
-    #   The log level from, e.g. :fatal or :info. Defaults to :error in the
-    #   production environment and :debug otherwise.
-    # delimiterString::
-    #   Delimiter to use between message sections. Defaults to " ~ ".
-    # auto_flushBoolean::
-    #   Whether the log should automatically flush after new messages are
-    #   added. Defaults to false.
-    def set_log(stream = Merb::Config[:log_stream],
-      log_level = Merb::Config[:log_level],
-      delimiter = Merb::Config[:log_delimiter],
-      auto_flush = Merb::Config[:log_auto_flush])
-
-      @buffer                   = []
-      @delimiter                = delimiter
-      @auto_flush               = auto_flush
-
-      if Levels[log_level]
-        @level                  = Levels[log_level]
-      else
-        @level                  = log_level
-      end
-
-      @log                      = stream
-      @mutex = (@@mutex[@log] ||= Mutex.new)
-    end
-
-    # Flush the entire buffer to the log object.
-    def flush
-      return unless @buffer.size  0
-      @mutex.synchronize do
-        @log.write(@buffer.slice!(0..-1).to_s)
-      end
-    end
-
-    # Close and remove the current log object.
-    def close
-      flush
-      @log.close if @log.respond_to?(:close) && !@log.tty?
-      @log = nil
+    # @api plugin
+    def verbose!(message, level = :warn)
+      send("#{level}!", message) if Merb::Config[:verbose]
     end
 
-    # Appends a message to the log. The methods yield to an optional block and
-    # the output of this block will be appended to the message.
+    # Appends a message to the log if the specified log level is at least as high as
+    # the log level of the logger if Merb::Config[:verbose].
     #
     # ==== Parameters
-    # stringString:: The message to be logged. Defaults to nil.
+    # messageString:: The message to be logged.
+    # levelSymbol:: The level at which to log. Default is :warn.
     #
     # ==== Returns
-    # String:: The resulting message added to the log file.
-    def (string = nil)
-      message = ""
-      message  delimiter
-      message  string if string
-      message  "\n" unless message[-1] == ?\n
-      @buffer  message
-      flush if @auto_flush
-
-      message
-    end
-    alias :push :
-
-    # Generate the logging methods for Merb.logger for each log level.
-    Levels.each_pair do |name, number|
-      class_eval -LEVELMETHODS, __FILE__, __LINE__
-
-      # Appends a message to the log if the log level is at least as high as
-      # the log level of the logger.
-      #
-      # ==== Parameters
-      # stringString:: The message to be logged. Defaults to nil.
-      #
-      # ==== Returns
-      # self:: The logger object for chaining.
-      def #{name}(message = nil)
-        self  message if #{number} = level
-        self
-      end
-
-      # Appends a message to the log if the log level is at least as high as
-      # the log level of the logger. The bang! version of the method also auto
-      # flushes the log buffer to disk.
-      #
-      # ==== Parameters
-      # stringString:: The message to be logged. Defaults to nil.
-      #
-      # ==== Returns
-      # self:: The logger object for chaining.
-      def #{name}!(message = nil)
-        self  message if #{number} = level
-        flush if #{number} = level
-        self
-      end
-
-      # ==== Returns
-      # Boolean:: True if this level will be logged by this logger.
-      def #{name}?
-        #{number} = level
-      end
-      LEVELMETHODS
+    # self:: The logger object for chaining.
+    #
+    # @api plugin
+    def verbose(message, level = :warn)
+      send(level, message) if Merb::Config[:verbose]
     end
 
   end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/plugins.rb</file_name>
					<diff>@@ -2,10 +2,15 @@ module Merb
 
   module Plugins
 
+    # Returns the configuration settings hash for plugins. This is prepopulated from
+    # Merb.root / "config/plugins.yml" if it is present.
+    #
     # ==== Returns
     # Hash::
     #   The configuration loaded from Merb.root / "config/plugins.yml" or, if
     #   the load fails, an empty hash whose default value is another Hash.
+    #
+    # @api plugin
     def self.config
       @config ||= begin
         # this is so you can do Merb.plugins.config[:helpers][:awesome] = "bar"
@@ -25,12 +30,16 @@ def self.config
 
     # ==== Returns
     # Array(String):: All Rakefile load paths Merb uses for plugins.
+    #
+    # @api plugin
     def self.rakefiles
       Merb.rakefiles
     end
     
     # ==== Returns
     # Array(String):: All Generator load paths Merb uses for plugins.
+    #
+    # @api plugin
     def self.generators
       Merb.generators
     end
@@ -49,6 +58,8 @@ def self.generators
     # if defined(Merb::Plugins)
     #   Merb::Plugins.add_rakefiles "merb_sequel" / "merbtasks"
     # end
+    #
+    # @api plugin
     def self.add_rakefiles(*rakefiles)
       Merb.add_rakefiles(*rakefiles)
     end
@@ -60,6 +71,8 @@ def self.add_rakefiles(*rakefiles)
     #
     # This is the recommended way to register your plugin's generators
     # in Merb.
+    #
+    # @api plugin
     def self.add_generators(*generators)
       Merb.add_generators(*generators)
     end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/rack/adapter.rb</file_name>
					<diff>@@ -5,6 +5,7 @@ module Rack
     class Adapter
 
       class  self
+        # Get a rack adapter by id. 
         # ==== Parameters
         # idString:: The identifier of the Rack adapter class to retrieve.
         #</diff>
				</file>
				<file>
					<file_name>lib/merb-core/rack/adapter/abstract.rb</file_name>
					<diff>@@ -2,7 +2,51 @@ module Merb
   module Rack
     class AbstractAdapter
 
+      # This method is designed to be overridden in a rack adapter.  It 
+      # will be called to start a server created with the new_server method.
+      # This is called from the AbstractAdapter start method.
+      #
+      # @api plugin
+      # @overridable
+      def self.start_server
+        raise NotImplemented
+      end
+      
+      # This method is designed to be overridden in a rack adapter.  It will
+      # be called to create a new instance of the server for the adapter to 
+      # start.  The adapter should attempt to bind to a port at this point. 
+      # This is called from the AbstractAdapter start method.
+      #
+      # ==== Parameters
+      # portInteger:: The port the server should listen on
+      #
+      # @api plugin
+      # @overridable
+      def self.new_server(port)
+        raise NotImplemented
+      end
+      
+      # This method is designed to be overridden in a rack adapter.  It will
+      # be called to stop the adapter server.  
+      #
+      # ==== Parameters
+      # statusInteger:: The exit status the adapter should exit with. 
+      #
+      # ==== Returns
+      # Boolean:: True if the server was properly stopped.  
+      #
+      # @api plugin
+      # @overridable
+      def self.stop(status)
+        raise NotImplemented
+      end
+
       # Spawn a new worker process at a port.
+      #
+      # ==== Parameters
+      # portInteger:: The port to start the worker process on. 
+      #
+      # @api private
       def self.spawn_worker(port)
         worker_pid = Kernel.fork
         start_at_port(port, @opts) unless worker_pid
@@ -15,6 +59,17 @@ def self.spawn_worker(port)
       end
 
       # The main start method for bootloaders that support forking.
+      # This method launches the adapters which inherit using the 
+      # new_server and start_server methods.  This method should not
+      # be overridden in adapters which want to fork.  
+      #
+      # ==== Parameters
+      # optsHash:: A hash of options
+      #   socket: the socket to bind to
+      #   port: the port to bind to
+      #   cluster: the number 
+      #
+      # @api private
       def self.start(opts={})
         @opts = opts
         $WORKERS ||= []
@@ -88,6 +143,14 @@ def self.start(opts={})
 
       end
 
+      # Fork a server on the specified port and start the app.
+      #
+      # ==== Parameters
+      # portInteger:: The port to start the server on
+      # optsHash:: The hash of options, defaults to the @opts 
+      #   instance variable.  
+      #
+      # @api private
       def self.start_at_port(port, opts = @opts)
         at_exit do
           Merb::Server.remove_pid(port)
@@ -167,11 +230,24 @@ def self.start_at_port(port, opts = @opts)
         start_server
       end
 
-      # This can be overridden in adapters, but shouldn't need to be.
+      # Exit the process with the specified status.  
+      #
+      # ==== Parameters
+      # statusInteger:: The exit code of the process.
+      # 
+      # @api private
       def self.exit_process(status = 0)
         exit(status)
       end
 
+      # Set the process title.
+      #
+      # ==== Parameters
+      # whoamiSymbol:: Either :spawner for the master process or :worker for any of the worker
+      #   processes. 
+      # portInteger:: The base port that the app is running on. 
+      #
+      # @api private
       def self.process_title(whoami, port)
         name = Merb::Config[:name]
         app  = "merb#{" : #{name}" if (name && name != "merb")}"</diff>
				</file>
				<file>
					<file_name>lib/merb-core/rack/adapter/irb.rb</file_name>
					<diff>@@ -1,15 +1,60 @@
 module Merb
   module Rack
     class Console
-      # ==== Parameters
-      # name~to_sym, Hash:: The name of the route to generate.
-      # paramsHash:: The params to use in the route generation.
+      # There are three possible ways to use this method.  First, if you have a named route, 
+      # you can specify the route as the first parameter as a symbol and any paramters in a 
+      # hash.  Second, you can generate the default route by just passing the params hash, 
+      # just passing the params hash.  Finally, you can use the anonymous parameters.  This 
+      # allows you to specify the parameters to a named route in the order they appear in the 
+      # router.  
+      #
+      # ==== Parameters(Named Route)
+      # nameSymbol:: 
+      #   The name of the route. 
+      # argsHash:: 
+      #   Parameters for the route generation.
+      #
+      # ==== Parameters(Default Route)
+      # argsHash:: 
+      #   Parameters for the route generation.  This route will use the default route. 
+      #
+      # ==== Parameters(Anonymous Parameters)
+      # nameSymbol::
+      #   The name of the route.  
+      # argsArray:: 
+      #   An array of anonymous parameters to generate the route
+      #   with. These parameters are assigned to the route parameters
+      #   in the order that they are passed.
       #
       # ==== Returns
       # String:: The generated URL.
       #
-      # ==== Alternatives
-      # If name is a hash, it will be merged with params.
+      # ==== Examples
+      # Named Route
+      #
+      # Merb::Router.prepare do
+      #   match("/articles/:title").to(:controller = :articles, :action = :show).name("articles")
+      # end
+      #
+      # url(:articles, :title = "new_article")
+      #
+      # Default Route
+      #
+      # Merb::Router.prepare do
+      #   default_routes
+      # end
+      #
+      # url(:controller = "articles", :action = "new")
+      #
+      # Anonymous Paramters
+      #
+      # Merb::Router.prepare do
+      #   match("/articles/:year/:month/:title").to(:controller = :articles, :action = :show).name("articles")
+      # end
+      #
+      # url(:articles, 2008, 10, "test_article")
+      #
+      # @api public
       def url(name, *args)
         args  {}
         Merb::Router.url(name, *args)</diff>
				</file>
				<file>
					<file_name>lib/merb-core/rack/application.rb</file_name>
					<diff>@@ -2,6 +2,16 @@ module Merb
   module Rack
     class Application
       
+      # The main rack application call method.  This is the entry point from rack (and the webserver) 
+      # to your application.  
+      #
+      # ==== Parameters
+      # envHash:: A rack request of parameters.  
+      #
+      # ==== Returns
+      # Array:: A rack response of [statusInteger, headersHash, bodyString, Stream]
+      #
+      # @api private
       def call(env) 
         begin
           rack_response = ::Merb::Dispatcher.handle(Merb::Request.new(env))
@@ -18,6 +28,18 @@ def call(env)
         rack_response
       end
 
+      # Determines whether this request is a "deferred_action", usually a long request. 
+      # Rack uses this method to detemine whether to use an evented request or a deferred 
+      # request in evented rack handlers.  
+      #
+      # ==== Parameters
+      # envHash:: The rack request
+      #
+      # ==== Returns
+      # Boolean::
+      #   True if the request should be deferred.  
+      #
+      # @api private
       def deferred?(env)
         path = env[Merb::Const::PATH_INFO] ? env[Merb::Const::PATH_INFO].chomp('/') : ""
         if path =~ Merb.deferred_actions</diff>
				</file>
				<file>
					<file_name>lib/merb-core/rack/helpers.rb</file_name>
					<diff>@@ -2,6 +2,20 @@ module Merb
   module Rack
     module Helpers
       
+      # A helper to build a rack response which implements a redirect.  The status will be set to 
+      # the passed in status if passed.  If you pass in permanent it will be a 301, permanent redirect,
+      # otherwise it defaults to a temporary 302 redirect.  
+      #
+      # ==== Parameters
+      # url~to_s:: The url to redirect to.
+      # optionsHash:: A hash of options for the redirect
+      #   status: The status code to use for the redirect
+      #   permanent:  True if this is a permanent redirect (301)
+      #
+      # ==== Returns
+      # Array:: A rack response to redirect to the specified url.  
+      #
+      # @api plugin
       def self.redirect(url, options = {})
         # Build the rack array
         status   = options.delete(:status)</diff>
				</file>
				<file>
					<file_name>lib/merb-core/server.rb</file_name>
					<diff>@@ -18,6 +18,8 @@ class  self
       # ==== Alternatives
       # If cluster is left out, then one process will be started. This process
       # will be daemonized if Merb::Config[:daemonize] is true.
+      #
+      # @api private
       def start(port, cluster=nil)
 
         @port = port
@@ -47,6 +49,8 @@ def start(port, cluster=nil)
       # ==== Returns
       # Boolean::
       #   True if Merb is running on the specified port.
+      #
+      # @api private
       def alive?(port)
         puts "About to check if port #{port} is alive..." if Merb::Config[:verbose]
         pidfile = pid_file(port)
@@ -68,6 +72,8 @@ def alive?(port)
       # ==== Alternatives
       # If you pass "all" as the port, the signal will be sent to all Merb
       # processes.
+      #
+      # @api private
       def kill(port, sig="INT")
         Merb::BootLoader::BuildFramework.run
         if sig == 9 && port == "main"
@@ -90,6 +96,8 @@ def kill(port, sig="INT")
         end
       end
 
+      # Kills the process pointed at by the provided pid file.
+      # @api private
       def kill_pid(sig, file)
         begin
           pid = File.read(file).chomp.to_i
@@ -118,6 +126,8 @@ def kill_pid(sig, file)
 
       # ==== Parameters
       # port~to_s:: The port of the Merb process to daemonize.
+      #
+      # @api private
       def daemonize(port)
         puts "About to fork..." if Merb::Config[:verbose]
         fork do
@@ -142,6 +152,9 @@ def daemonize(port)
         Merb.fatal! "Daemonized mode is not supported on your platform", e
       end
 
+      # Starts up Merb by running the bootloader and starting the adapter.
+      #
+      # @api private
       def bootup
         Merb.trap('TERM') {
           Merb::BootLoader::LoadClasses.reap_workers if Merb::Config[:fork_for_class_load]
@@ -154,6 +167,9 @@ def bootup
         Merb.adapter.start(Merb::Config.to_hash)
       end
 
+      # Change process user/group to those specified in Merb::Config.
+      #
+      # @api private
       def change_privilege
         if Merb::Config[:user] && Merb::Config[:group]
           Merb.logger.verbose! "About to change privilege to group " \
@@ -179,6 +195,8 @@ def change_privilege
       # ==== Alternatives
       # If Merb::Config[:pid_file] has been specified, that will be used
       # instead of the port based PID file.
+      #
+      # @api private
       def remove_pid_file(port)
         pidfile = pid_file(port)
         if File.exist?(pidfile)
@@ -198,14 +216,32 @@ def remove_pid_file(port)
       # ==== Alternatives
       # If Merb::Config[:pid_file] has been specified, that will be used
       # instead of the port based PID file.
+      #
+      # @api private
       def store_pid(port)
         store_details(port)
       end
 
+      # Delete the pidfile for the specified port.
+      #
+      # @api private
       def remove_pid(port)
         FileUtils.rm(pid_file(port)) if File.file?(pid_file(port))
       end
 
+      # Stores a PID file on the filesystem.
+      # This uses :pid_file options from configuration when provided
+      # or merb.port.pid in log directory by default.
+      #
+      # ==== Parameters
+      # port~to_s::
+      #   The port of the Merb process to whom the the PID file belongs to.
+      #
+      # ==== Alternatives
+      # If Merb::Config[:pid_file] has been specified, that will be used
+      # instead of the port based PID file.
+      #
+      # @api private
       def store_details(port = nil)
         file = pid_file(port)
         begin
@@ -233,6 +269,8 @@ def store_details(port = nil)
       # String::
       #   Location of pid file for specified port. If clustered and pid_file option
       #   is specified, it adds the port value to the path.
+      #
+      # @api private
       def pid_file(port)
         pidfile = Merb::Config[:pid_file] || (Merb.log_path / "merb.%s.pid")
         pidfile % port
@@ -243,6 +281,8 @@ def pid_file(port)
       # ==== Returns
       # Array::
       #   List of pid file paths. If not clustered, array contains a single path.
+      #
+      # @api private
       def pid_files
         if Merb::Config[:pid_file]
           if Merb::Config[:cluster]
@@ -263,6 +303,8 @@ def pid_files
       #
       # ==== Alternatives
       # If group is left out, the user will be used as the group.
+      #
+      # @api private
       def _change_privilege(user, group=user)
 
         Merb.logger.warn! "Changing privileges to #{user}:#{group}"
@@ -297,6 +339,7 @@ def _change_privilege(user, group=user)
         false
       end
 
+      # @api private
       def add_irb_trap
         Merb.trap('INT') do
           if @interrupted</diff>
				</file>
				<file>
					<file_name>lib/merb-core/test/helpers/route_helper.rb</file_name>
					<diff>@@ -3,14 +3,60 @@ module Test
     module RouteHelper
       include RequestHelper
       
-      # Mimics the url method available to controllers.
+      # There are three possible ways to use this method.  First, if you have a named route, 
+      # you can specify the route as the first parameter as a symbol and any paramters in a 
+      # hash.  Second, you can generate the default route by just passing the params hash, 
+      # just passing the params hash.  Finally, you can use the anonymous parameters.  This 
+      # allows you to specify the parameters to a named route in the order they appear in the 
+      # router.  
       #
-      # ==== Parameters
-      # name~to_sym:: The name of the URL to generate.
-      # paramsHash:: Parameters for the route generation.
+      # ==== Parameters(Named Route)
+      # nameSymbol:: 
+      #   The name of the route. 
+      # argsHash:: 
+      #   Parameters for the route generation.
+      #
+      # ==== Parameters(Default Route)
+      # argsHash:: 
+      #   Parameters for the route generation.  This route will use the default route. 
+      #
+      # ==== Parameters(Anonymous Parameters)
+      # nameSymbol::
+      #   The name of the route.  
+      # argsArray:: 
+      #   An array of anonymous parameters to generate the route
+      #   with. These parameters are assigned to the route parameters
+      #   in the order that they are passed.
       #
       # ==== Returns
       # String:: The generated URL.
+      #
+      # ==== Examples
+      # Named Route
+      #
+      # Merb::Router.prepare do
+      #   match("/articles/:title").to(:controller = :articles, :action = :show).name("articles")
+      # end
+      #
+      # url(:articles, :title = "new_article")
+      #
+      # Default Route
+      #
+      # Merb::Router.prepare do
+      #   default_routes
+      # end
+      #
+      # url(:controller = "articles", :action = "new")
+      #
+      # Anonymous Paramters
+      #
+      # Merb::Router.prepare do
+      #   match("/articles/:year/:month/:title").to(:controller = :articles, :action = :show).name("articles")
+      # end
+      #
+      # url(:articles, 2008, 10, "test_article")
+      #
+      # @api public
       def url(*args)
         args  (@request_params || {})
         Merb::Router.url(*args)</diff>
				</file>
				<file>
					<file_name>spec/private/core_ext/kernel_spec.rb</file_name>
					<diff>@@ -1,19 +1,5 @@
 require File.dirname(__FILE__) + '/../../spec_helper'
 
-describe "Kernel#require" do
-  before do
-    @logger = StringIO.new
-  end
-
-  it "should be able to require and throw a useful error message" do
-    Kernel.stub!(:require).with("redcloth").and_raise(LoadError)
-    Merb.logger.should_receive(:error!).with("foo")
-    Kernel.rescue_require("redcloth", "foo")
-  end
-end
-
-
-
 describe "Kernel#caller" do
   it "should be able to determine caller info" do
     __caller_info__.should be_kind_of(Array)
@@ -71,7 +57,7 @@
     end
   end
 
-  it "deferres load of dependencies given as Hash" do
+  it "defers load of dependencies given as Hash" do
     self.should_receive(:dependency).with("hpricot", "0.6").and_return(true)
     self.should_receive(:dependency).with("rake", "0.8.1").and_return(true)
 </diff>
				</file>
				<file>
					<file_name>spec/private/dispatch/bootloader_spec.rb</file_name>
					<diff>@@ -5,14 +5,16 @@
   it "should default to rack config (rack.rb)" do
     options = {:merb_root = File.dirname(__FILE__) / 'fixture'}
     Merb::Config.setup(options)
-    app = Merb::BootLoader::RackUpApplication.run
+    Merb::BootLoader::RackUpApplication.run
+    app = Merb::Config[:app]
     app.class.should == Merb::Rack::Static
   end
 
   it "should use rackup config that we specified" do
     options = {:rackup = File.dirname(__FILE__) / 'fixture' / 'config' / 'black_hole.rb'}
     Merb::Config.setup(options)
-    app = Merb::BootLoader::RackUpApplication.run
+    Merb::BootLoader::RackUpApplication.run
+    app = Merb::Config[:app]
     app.class.should == Rack::Adapter::BlackHole
 
     env = Rack::MockRequest.env_for("/black_hole")</diff>
				</file>
				<file>
					<file_name>spec/public/logger/logger_spec.rb</file_name>
					<diff>@@ -21,6 +21,14 @@
 
 describe Merb::Logger do
 
+  describe "Levels" do
+    it "should have the same entries as Extlib::Logger::Levels" do
+      Extlib::Logger::Levels.each do |level, value|
+        Merb::Logger::Levels[level].should == value
+      end
+    end
+  end
+
   describe "#new" do
     it "should call set_log with the arguments it was passed." do
       logger = Merb::Logger.allocate # create an object sans initialization
@@ -41,6 +49,12 @@
       Merb.logger.level.should == 4
     end
 
+    it "should set the log level to a specific numeric value when that value is set into Mer" do
+      Merb::Config[:log_level] = 5
+      Merb.reset_logger!
+      Merb.logger.level.should == 5
+    end
+
     it "should set the log level to :debug (0) when Merb.environment is development" do
       Merb.environment = "development"
       Merb::Config.delete(:log_level)
@@ -280,4 +294,81 @@ def set_level(level)
       Merb.logger.should log_with_method(:fatal)
     end
   end # #fatal
+  
+  describe "#verbose" do
+    before do
+      @stream = Merb::Config[:log_stream] = StringIO.new
+      Merb.reset_logger!
+    end
+    
+    describe "when Merb::Config[:verbose] is false" do
+      it "should not log any messages" do
+        Merb::Config[:verbose] = false
+        Merb::Config[:log_level] = :debug
+        Merb.logger.verbose("message", :fatal)
+        Merb.logger.flush
+        
+        Merb.logger.log.string.should_not include("message")
+      end
+    end
+    
+    describe "when Merb::Config[:verbose] is true" do
+      before do
+        Merb::Config[:verbose] = true
+        Merb::Config[:log_level] = :debug
+      end
+
+      it "adds to the buffer with error level" do
+        set_level(:error)
+        Merb.logger.verbose("message", :error)
+        Merb.logger.flush
+        Merb.logger.log.string.should include("message")
+      end
+
+      it "adds to the buffer with fatal level" do
+        set_level(:fatal)
+        Merb.logger.verbose("message", :error)
+        Merb.logger.flush
+        Merb.logger.log.string.should_not include("message")
+      end
+      
+    end
+  end
+  
+  describe "#verbose!" do
+    before do
+      @stream = Merb::Config[:log_stream] = StringIO.new
+      Merb.reset_logger!
+    end
+    
+    describe "when Merb::Config[:verbose] is false" do
+      it "should not log any messages" do
+        Merb::Config[:verbose] = false
+        Merb::Config[:log_level] = :debug
+        Merb.logger.verbose!("message", :fatal)
+        Merb.logger.log.string.should_not include("message")
+      end
+    end
+    
+    describe "when Merb::Config[:verbose] is true" do
+      before do
+        Merb::Config[:verbose] = true
+        Merb::Config[:log_level] = :debug
+      end
+
+      it "adds to the buffer with error level" do
+        set_level(:error)
+        Merb.logger.verbose!("message", :error)
+        Merb.logger.log.string.should include("message")
+      end
+
+      it "adds to the buffer with fatal level" do
+        set_level(:fatal)
+        Merb.logger.verbose!("message", :error)
+        Merb.logger.log.string.should_not include("message")
+      end
+      
+    end
+  end
+  
 end # Merb::Logger</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>5e4a862e856bd0a5b90deebbf2be3340a8955b6a</sha>
			<message>Merge commit 'adelcambre/sprint' into sprint</message>
			<author_name>Yehuda Katz</author_name>
			<author_date>2008-10-11T06:27:59Z</author_date>
			<author_email>wycats@gmail.com</author_email>
			<committer_name>Yehuda Katz</committer_name>
			<committer_date>2008-10-11T06:27:59Z</committer_date>
			<committer_email>wycats@gmail.com</committer_email>
			<files>
				<file>
					<file_name>lib/merb-core.rb</file_name>
					<diff>@@ -278,7 +278,11 @@ def root_path(*path)
 
     # Logger settings
     def logger
-      Thread.current[:merb_logger] ||= Merb::Logger.new
+      Thread.current[:merb_logger] ||= Merb::Logger.new(
+        Merb::Config[:log_stream],
+        Merb::Config[:log_level],
+        Merb::Config[:log_delimiter],
+        Merb::Config[:log_auto_flush])
     end
 
     def reset_logger!</diff>
				</file>
				<file>
					<file_name>lib/merb-core/bootloader.rb</file_name>
					<diff>@@ -3,8 +3,8 @@ module Merb
   class BootLoader
 
     # def self.subclasses
-    #---
-    # @semipublic
+    #
+    # @api plugin
     cattr_accessor :subclasses, :after_load_callbacks, :before_load_callbacks, :finished
     self.subclasses, self.after_load_callbacks,
       self.before_load_callbacks, self.finished = [], [], [], []
@@ -16,29 +16,44 @@ class  self
       #
       # ==== Parameters
       # klassClass:: The class inheriting from Merb::BootLoader.
+      #
+      # ==== Returns
+      # nil
+      #
+      # @api plugin
       def inherited(klass)
         subclasses  klass.to_s
         super
       end
 
+      # Execute this boot loader after the specified boot loader.
+      #
       # ==== Parameters
       # klass~to_s::
       #   The boot loader class after which this boot loader should be run.
       #
-      #---
-      # @public
+      # ==== Returns
+      # nil
+      # 
+      # @api plugin
       def after(klass)
         move_klass(klass, 1)
+        nil
       end
 
+      # Execute this boot loader before the specified boot loader.
+      #
       # ==== Parameters
       # klass~to_s::
       #   The boot loader class before which this boot loader should be run.
       #
-      #---
-      # @public
+      # ==== Returns
+      # nil
+      #
+      # @api plugin
       def before(klass)
         move_klass(klass, 0)
+        nil
       end
 
       # Move a class that is inside the bootloader to some place in the Array,
@@ -49,15 +64,26 @@ def before(klass)
       #   The klass to move the bootloader relative to
       # whereInteger::
       #   0 means insert it before; 1 means insert it after
+      #
+      # ==== Returns
+      # nil
+      #
+      # @api private
       def move_klass(klass, where)
         index = Merb::BootLoader.subclasses.index(klass.to_s)
         if index
           Merb::BootLoader.subclasses.delete(self.to_s)
           Merb::BootLoader.subclasses.insert(index + where, self.to_s)
         end
+        nil
       end
 
       # Runs all boot loader classes by calling their run methods.
+      #
+      # ==== Returns
+      # nil
+      #
+      # @api plugin
       def run
         Merb.started = true
         subklasses = subclasses.dup
@@ -74,6 +100,7 @@ def run
           self.finished  bootloader
         end
         self.subclasses = subklasses
+        nil
       end
 
       # Determines whether or not a specific bootloader has finished yet.
@@ -83,6 +110,8 @@ def run
       #
       # ==== Returns
       # Boolean:: Whether or not the bootloader has finished.
+      #
+      # @api private
       def finished?(bootloader)
         self.finished.include?(bootloader.to_s)
       end
@@ -92,8 +121,8 @@ def finished?(bootloader)
       # ==== Returns
       # nil
       #
-      #---
-      # @public
+      # @api plugin
+      # @overridable
       def default_framework
         %w[view model helper controller mailer part].each do |component|
           Merb.push_path(component.to_sym, Merb.root_path("app/#{component}s"))
@@ -111,24 +140,26 @@ def default_framework
         nil
       end
 
+      # Execute a block of code after the app loads.
+      #
       # ==== Parameters
       # &block::
       #   A block to be added to the callbacks that will be executed after the
       #   app loads.
       #
-      #---
-      # @public
+      # @api public
       def after_app_loads(&block)
         after_load_callbacks  block
       end
 
+      # Execute a block of code before the app loads but after dependencies load.
+      #
       # ==== Parameters
       # &block::
       #   A block to be added to the callbacks that will be executed before the
       #   app loads.
       #
-      #---
-      # @public
+      # @api public
       def before_app_loads(&block)
         before_load_callbacks  block
       end
@@ -145,6 +176,11 @@ def before_app_loads(&block)
 class Merb::BootLoader::Logger  Merb::BootLoader
 
   # Sets Merb.logger to a new logger created based on the config settings.
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api plugin
   def self.run
     Merb::Config[:log_level] ||= begin
       if Merb.environment == "production"
@@ -157,8 +193,16 @@ def self.run
     Merb::Config[:log_stream] = Merb.log_stream
 
     print_warnings
+    
+    nil
   end
 
+  # Print a warning if the installed version of rubygems is not supported
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api private
   def self.print_warnings
     if Gem::Version.new(Gem::RubyGemsVersion)  Gem::Version.new("1.1")
       Merb.fatal! "Merb requires Rubygems 1.1 and later. " \
@@ -175,19 +219,32 @@ class Merb::BootLoader::DropPidFile  Merb::BootLoader
   class  self
 
     # Stores a PID file if Merb is running daemonized or clustered.
+    #
+    # ==== Returns
+    # nil
+    #
+    # @api plugin
     def run
       Merb::Server.store_pid("main") #if Merb::Config[:daemonize] || Merb::Config[:cluster]
+      nil
     end
   end
 end
 
 # Setup some useful defaults
 class Merb::BootLoader::Defaults  Merb::BootLoader
+  # Sets up the defaults
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api plugin
   def self.run
     Merb::Request.http_method_overrides.concat([
       proc { |c| c.params[:_method] },
       proc { |c| c.env['HTTP_X_HTTP_METHOD_OVERRIDE'] }
     ])
+    nil
   end
 end
 
@@ -231,12 +288,24 @@ class Merb::BootLoader::BuildFramework  Merb::BootLoader
   class  self
 
     # Builds the framework directory structure.
+    #
+    # ==== Returns
+    # nil
     def run
       build_framework
+      nil
     end
 
-    # This method should be overridden in init.rb before Merb.start to set up
-    # a different framework structure.
+    # Sets up merb paths to support the app's file layout. First, config/framework.rb is checked,
+    # next we look for Merb.root/framework.rb, finally we use the default merb layout (Merb::BootLoader.default_framework)
+    #
+    # This method can be overriden to support other application layouts.
+    #
+    # ==== Returns
+    # nil
+    #
+    # @api plugin
+    # @overridable
     def build_framework
       if File.exists?(Merb.root / "config" / "framework.rb")
         require Merb.root / "config" / "framework"
@@ -249,12 +318,17 @@ def build_framework
         path = Array(path)
         Merb.push_path(name, path.first, path.length == 2 ? path[1] : "**/*.rb")
       end
+      nil
     end
   end
 end
 
 class Merb::BootLoader::Dependencies  Merb::BootLoader
 
+  # ==== Returns
+  # Array[Gem::Dependency]:: The dependencies regiestered in init.rb.
+  #
+  # @api plugin
   cattr_accessor :dependencies
   self.dependencies = []
 
@@ -267,7 +341,11 @@ class Merb::BootLoader::Dependencies  Merb::BootLoader
   # before or after insertion methods. Since these are loaded from this
   # bootloader (Dependencies), they can only adapt the bootloaders that
   # haven't been loaded up until this point.
-
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api plugin
   def self.run
     set_encoding
     # this is crucial: load init file with all the preferences
@@ -280,12 +358,24 @@ def self.run
     enable_json_gem unless Merb::disabled?(:json)
     load_dependencies
     update_logger
+    nil
   end
 
+  # Load each dependency that has been declared so far.
+  # 
+  # ==== Returns
+  # nil
+  #
+  # @api private
   def self.load_dependencies
     dependencies.each { |dependency| Kernel.load_dependency(dependency) }
+    nil
   end
 
+  # Loads json or json_pure and requires it.
+  #
+  # ==== Returns
+  # nil
   def self.enable_json_gem
     gem "json"
     require "json/ext"
@@ -294,6 +384,13 @@ def self.enable_json_gem
     require "json/pure"
   end
 
+  # Resets the logger and sets the log_stream to Merb::Config[:log_file] 
+  # if one is specified, falling back to STDOUT.
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api private
   def self.update_logger
     Merb.reset_logger!
 
@@ -306,34 +403,64 @@ def self.update_logger
     else
       Merb::Config[:log_stream] ||= STDOUT
     end
+    
+    nil
   end
 
+  # Default encoding to UTF8 if it has not already been set to something else.
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api private
   def self.set_encoding
     $KCODE = 'UTF8' if $KCODE == 'NONE' || $KCODE.blank?
+    nil
   end
 
   private
 
     # Determines the path for the environment configuration file
+    #
+    # ==== Returns
+    # String:: The path to the config file for the environment
+    #
+    # @api private
     def self.env_config
       Merb.dir_for(:config) / "environments" / (Merb.environment + ".rb")
     end
 
     # Checks to see whether or not an environment configuration exists
+    #
+    # ==== Returns
+    # Boolean:: Whether or not the environment configuration file exists.
+    #
+    # @api private
     def self.env_config?
       Merb.environment && File.exist?(env_config)
     end
 
-    # Loads the environment configuration file, if any
+    # Loads the environment configuration file, if it is present
+    #
+    # ==== Returns
+    # nil
+    #
+    # @api private
     def self.load_env_config
       if env_config?
         STDOUT.puts "Loading #{env_config}" unless Merb.testing?
         load(env_config)
       end
+      nil
     end
 
     # Determines the init file to use, if any.
     # By default Merb uses init.rb from application config directory.
+    #
+    # ==== Returns
+    # nil
+    #
+    # @api private
     def self.initfile
       if Merb::Config[:init_file]
         Merb::Config[:init_file].chomp(".rb") + ".rb"
@@ -343,6 +470,11 @@ def self.initfile
     end
 
     # Loads the init file, should one exist
+    #
+    # ==== Returns
+    # nil
+    #
+    # @api private
     def self.load_initfile
       if File.exists?(initfile)
         STDOUT.puts "Loading init file from #{initfile}" unless Merb.testing?
@@ -352,6 +484,7 @@ def self.load_initfile
           "a flat application and have not specified the init file. If you " \
           "are trying to create a new merb application, use merb-gen app."
       end
+      nil
     end
 end
 
@@ -364,6 +497,11 @@ class Merb::BootLoader::MixinSession  Merb::BootLoader
   #
   # Note: access to Merb::Config is needed, so it needs to run after
   # Merb::BootLoader::Dependencies is done.
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api plugin
   def self.run
     require 'merb-core/dispatch/session'
     Merb::Controller.send(:include, ::Merb::SessionMixin)
@@ -376,8 +514,14 @@ class Merb::BootLoader::BeforeAppLoads  Merb::BootLoader
 
   # Call any before_app_loads hooks that were registered via before_app_loads
   # in any plugins.
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api plugin
   def self.run
     Merb::BootLoader.before_load_callbacks.each { |x| x.call }
+    nil
   end
 end
 
@@ -396,6 +540,18 @@ class Merb::BootLoader::LoadClasses  Merb::BootLoader
   class  self
 
     # Load all classes from Merb's native load paths.
+    #
+    # If fork-based loading is used, every time classes are loaded this will return in a new spawner process
+    # and boot loading will continue from this point in the boot loading process.
+    #
+    # If fork-based loading is not in use, this only returns once and does not fork a new
+    # process.
+    #
+    # ==== Returns
+    # Returns at least once:
+    #   nil
+    #
+    # @api plugin
     def run
       # Add models, controllers, helpers and lib to the load path
       unless @ran
@@ -432,17 +588,37 @@ def run
       end
 
       Merb::Controller.send :include, Merb::GlobalHelpers
+      
+      nil
     end
 
-    # Wait for workers to exit, remove the "main" PID, and exit.
+    # Wait for any children to exit, remove the "main" PID, and
+    # exit.
+    #
+    # ==== Returns
+    # (Does not return.)
+    #
+    # @api private
     def exit_gracefully
       Process.waitall
       Merb::Server.remove_pid("main")
       exit
     end
 
-    # If using fork-based code reloading, set up the BEGIN
-    # point and set up any signals in the parent and worker.
+    # Set up the BEGIN point for fork-based loading and sets up 
+    # any signals in the parent and child. This is done by forking
+    # the app. The child process continues on to run the app. The parent
+    # process waits for the child process to finish and either forks again
+    # 
+    #
+    # ==== Returns
+    # Parent Process:
+    #   (Does not return.)
+    # Child Process returns at least once:
+    #   nil
+    #
+    # @api private
+
     def start_transaction
       Merb.logger.warn! "Parent pid: #{Process.pid}"
       reader, writer = nil, nil
@@ -535,7 +711,13 @@ def start_transaction
     # of 128 when a master process exists will cause the
     # spawner process to be recreated, and the app code reloaded.
     #
-    # @param statusInteger The status code to exit with
+    # ==== Parameters
+    # statusInteger:: The status code to exit with. Defaults to 0.
+    #
+    # ==== Returns
+    # (Does not return.)
+    #
+    # @api private
     def reap_workers(status = 0)
       Merb.exiting = true unless status == 128
 
@@ -559,8 +741,15 @@ def reap_workers(status = 0)
       exit(status)
     end
 
+    # Loads a file, tracking its modified time and, if necessary, the classes it declared.
+    #
     # ==== Parameters
     # fileString:: The file to load.
+    #
+    # ==== Returns
+    # nil
+    #
+    # @api private
     def load_file(file)
       # Don't do this expensive operation unless we need to
       unless Merb::Config[:fork_for_class_load]
@@ -583,12 +772,20 @@ def load_file(file)
       unless Merb::Config[:fork_for_class_load]
         LOADED_CLASSES[file] = ObjectSpace.classes - klasses
       end
+      
+      nil
     end
 
     # Load classes from given paths - using path/glob pattern.
     #
+    # ==== Parameters
     # *pathsArray::
     #   Array of paths to load classes from - may contain glob pattern
+    #
+    # ==== Returns
+    # nil
+    #
+    # @api private
     def load_classes(*paths)
       orphaned_classes = []
       paths.flatten.each do |path|
@@ -602,9 +799,22 @@ def load_classes(*paths)
       end
       load_classes_with_requirements(orphaned_classes)
     end
-
+    
+    # Reloads the classes in the specified file. If fork-based loading is used,
+    # this causes the current processes to be killed and and all classes to be
+    # reloaded. If class-based loading is not in use, the classes declared in that file
+    # are removed and the file is reloaded.
+    #
     # ==== Parameters
     # fileString:: The file to reload.
+    #
+    # ==== Returns
+    # When fork-based loading is used:
+    #   (Does not return.)
+    # When fork-based loading is not in use:
+    #   nil
+    #
+    # @api private
     def reload(file)
       if Merb::Config[:fork_for_class_load]
         reap_workers(128)
@@ -613,9 +823,20 @@ def reload(file)
       end
     end
 
+    # Removes all classes declared in the specified file. Any hashes which use classes as keys
+    # will be protected provided they have been added to Merb.klass_hashes. These hashes have their
+    # keys substituted with placeholders before the file's classes are unloaded. If a block is provided,
+    # it is called before the substituted keys are reconstituted.
+    #
     # ==== Parameters
     # fileString:: The file to remove classes for.
-    # &block:: A block to call with the file that has been removed.
+    # &block:: A block to call with the file that has been removed before klass_hashes are updated
+    # to use the current values of the constants they used as keys.
+    #
+    # ==== Returns
+    # nil
+    #
+    # @api private
     def remove_classes_in_file(file, &block)
       Merb.klass_hashes.each { |x| x.protect_keys! }
       if klasses = LOADED_CLASSES.delete(file)
@@ -623,15 +844,26 @@ def remove_classes_in_file(file, &block)
       end
       yield file if block_given?
       Merb.klass_hashes.each {|x| x.unprotect_keys!}
+      nil
     end
 
+    # Removes the specified class. 
+    #
+    # Additionally, removes the specified class from the subclass list of every superclass that
+    # tracks it's subclasses in an array returned by _subclasses_list. Classes that wish to use this
+    # functionality are required to alias the reader for their list of subclasses
+    # to _subclasses_list. Plugins for ORMs and other libraries should keep this in mind.
+    #
     # ==== Parameters
     # constClass:: The class to remove.
+    #
+    # ==== Returns
+    # nil
+    #
+    # @api private
     def remove_constant(const)
       # This is to support superclasses (like AbstractController) that track
-      # their subclasses in a class variable. Classes that wish to use this
-      # functionality are required to alias it to _subclasses_list. Plugins
-      # for ORMs and other libraries should keep this in mind.
+      # their subclasses in a class variable.
       superklass = const
       until (superklass = superklass.superclass).nil?
         if superklass.respond_to?(:_subclasses_list)
@@ -649,16 +881,22 @@ def remove_constant(const)
       rescue NameError
         Merb.logger.debug("Failed to remove constant #{object} from #{base}")
       end
+      nil
     end
 
     private
 
-    # "Better loading" of classes.  If a class fails to load due to a NameError
+    # "Better loading" of classes.  If a file fails to load due to a NameError
     # it will be added to the failed_classes and load cycle will be repeated unless
     # no classes load.
     #
     # ==== Parameters
     # klassesArray[Class]:: Classes to load.
+    #
+    # ==== Returns
+    # nil
+    #
+    # @api private
     def load_classes_with_requirements(klasses)
       klasses.uniq!
 
@@ -696,26 +934,35 @@ def load_classes_with_requirements(klasses)
         end
         break if(klasses.size == size_at_start || klasses.size == 0)
       end
+      
+      nil
     end
 
   end
 
 end
 
+# Loads the router file. This needs to happen after everything else is loaded while merb is starting up to ensure
+# the router has everything it needs to run.
 class Merb::BootLoader::Router  Merb::BootLoader
   class  self
-
+    
+    # load the router file
+    #
+    # ==== Returns
+    # nil
+    #
+    # @api plugin
     def run
       Merb::BootLoader::LoadClasses.load_file(router_file) if router_file
+      
+      nil
     end
 
-    def reload!
-      if router_file
-        Merb::Router.reset!
-        Merb::BootLoader::LoadClasses.reload(router_file)
-      end
-    end
-
+    # Tries to find the router file.
+    #
+    # ==== Returns
+    # String:: The path to the router file if it exists, nil otherwise.
     def router_file
       @router_file ||= begin
         if File.file?(router = Merb.dir_for(:router) / Merb.glob_for(:router))
@@ -727,18 +974,28 @@ def router_file
   end
 end
 
+# Precompiles all non-partial templates.
 class Merb::BootLoader::Templates  Merb::BootLoader
   class  self
 
-    # Loads the templates into the Merb::InlineTemplates module.
+    # Loads all non-partial templates into the Merb::InlineTemplates module.
+    #
+    # ==== Returns
+    # Array[String]:: The list of template files which were loaded.
+    #
+    # @api plugin
     def run
       template_paths.each do |path|
         Merb::Template.inline_template(File.open(path))
       end
     end
 
+    # Finds a list of templates to load.
+    #
     # ==== Returns
-    # Array[String]:: Template files found.
+    # Array[String]:: All found template files whose basename does not begin with "_".
+    #
+    # @api private
     def template_paths
       extension_glob = "{#{Merb::Template.template_extensions.join(',')}}"
 
@@ -777,6 +1034,11 @@ def template_paths
 class Merb::BootLoader::MimeTypes  Merb::BootLoader
 
   # Registers the default MIME types.
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api plugin
   def self.run
     Merb.add_mime_type(:all,  nil,      %w[*/*])
     Merb.add_mime_type(:yaml, :to_yaml, %w[application/x-yaml text/yaml], :charset = "utf-8")
@@ -785,15 +1047,24 @@ def self.run
     Merb.add_mime_type(:xml,  :to_xml,  %w[application/xml text/xml application/x-xml], {:charset = "utf-8"}, 0.9998)
     Merb.add_mime_type(:js,   :to_json, %w[text/javascript application/javascript application/x-javascript], :charset = "utf-8")
     Merb.add_mime_type(:json, :to_json, %w[application/json text/x-json], :charset = "utf-8")
+    nil
   end
 end
 
+# Set up cookies support in Merb::Controller and Merb::Request
 class Merb::BootLoader::Cookies  Merb::BootLoader
 
+  # Set up cookies support in Merb::Controller and Merb::Request
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api plugin
   def self.run
     require 'merb-core/dispatch/cookies'
     Merb::Controller.send(:include, Merb::CookiesMixin)
     Merb::Request.send(:include, Merb::CookiesMixin::RequestMixin)
+    nil
   end
 
 end
@@ -802,6 +1073,11 @@ class Merb::BootLoader::SetupSession  Merb::BootLoader
 
   # Enable the configured session container(s); any class that inherits from
   # SessionContainer will be considered by its session_store_type attribute.
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api plugin
   def self.run
     # Require all standard session containers.
     Dir[Merb.framework_root / "merb-core" / "dispatch" / "session" / "*.rb"].each do |file|
@@ -826,6 +1102,7 @@ def self.run
 
     # Mixin the Merb::Session module to add app-level functionality to sessions
     Merb::SessionContainer.send(:include, Merb::Session)
+    nil
   end
 
 end
@@ -834,14 +1111,26 @@ class Merb::BootLoader::AfterAppLoads  Merb::BootLoader
 
   # Call any after_app_loads hooks that were registered via after_app_loads in
   # init.rb.
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api plugin
   def self.run
     Merb::BootLoader.after_load_callbacks.each {|x| x.call }
+    nil
   end
 end
 
 # In case someone's running a sparse app, the default exceptions require the
 # Exceptions class.
 class Merb::BootLoader::SetupStubClasses  Merb::BootLoader
+  # Declares empty Application and Exception controllers.
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api plugin
   def self.run
     unless defined?(Exceptions)
       Object.class_eval -RUBY
@@ -853,23 +1142,47 @@ class Exceptions  Application
         end
       RUBY
     end
+    nil
   end
 end
 
 class Merb::BootLoader::ChooseAdapter  Merb::BootLoader
 
   # Choose the Rack adapter/server to use and set Merb.adapter.
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api plugin
   def self.run
     Merb.adapter = Merb::Rack::Adapter.get(Merb::Config[:adapter])
   end
 end
 
+class Merb::BootLoader::StartWorkerThread  Merb::BootLoader
+
+  # Starts the worker thread used by the run_later helper.
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api plugin
+  def self.run
+    Merb::Worker.start
+  end
+end
+
 class Merb::BootLoader::RackUpApplication  Merb::BootLoader
   # Setup the Merb Rack App or read a rackup file located at
   # Merb::Config[:rackup] with the same syntax as the
   # rackup tool that comes with rack. Automatically evals the file in
   # the context of a Rack::Builder.new { } block. Allows for mounting
   # additional apps or middleware.
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api plugin
   def self.run
     require 'rack'
     if File.exists?(Merb.dir_for(:config) / "rack.rb")
@@ -888,13 +1201,24 @@ def self.run
          run Merb::Rack::Application.new
        }.to_app
     end
-
+    
+    nil
   end
 end
 
 class Merb::BootLoader::ReloadClasses  Merb::BootLoader
 
   class TimedExecutor
+    # Executes the associated block every @seconds@ seconds in a separate thread.
+    #
+    # ==== Parameters
+    # secondsInteger:: Number of seconds to sleep in between runs of &block.
+    # &block:: The block to execute periodically.
+    #
+    # ==== Returns
+    # Thread:: The thread executing the block periodically.
+    #
+    # @api private
     def self.every(seconds, &block)
       Thread.abort_on_exception = true
       Thread.new do
@@ -907,7 +1231,14 @@ def self.every(seconds, &block)
     end
   end
 
-  # Setup the class reloader if it's been specified in config.
+  # Set up the class reloader if class reloading is enabled. This checks periodically 
+  # for modifications to files loaded by the LoadClasses BootLoader and reloads them
+  # when they are modified.
+  # 
+  # ==== Returns
+  # nil
+  #
+  # @api plugin
   def self.run
     return unless Merb::Config[:reload_classes]
 
@@ -928,10 +1259,16 @@ def self.run
       GC.start
       reload(paths)
     end
-
+    
+    nil
   end
 
-  # Reloads all files.
+  # Reloads all files which have been modified since they were last loaded.
+  #
+  # ==== Returns
+  # nil
+  #
+  # @api private
   def self.reload(paths)
     paths.each do |file|
       next if LoadClasses::MTIMES[file] &&
@@ -939,5 +1276,7 @@ def self.reload(paths)
 
       LoadClasses.reload(file)
     end
+    
+    nil
   end
 end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/config.rb</file_name>
					<diff>@@ -6,8 +6,12 @@ class Config
 
     class  self
 
+      # Returns the hash of default config values for Merb.
+      #
       # ==== Returns
       # Hash:: The defaults for the config.
+      #
+      # @api private
       def defaults
         @defaults ||= {
           :host                   = "0.0.0.0",
@@ -39,29 +43,45 @@ def defaults
       #     config[:exception_details] = false
       #     config[:log_stream]        = STDOUT
       #   end
+      #
+      # ==== Returns
+      # nil
+      #
+      # @api public
       def use
         @configuration ||= {}
         yield @configuration
+        nil
       end
-
+      
+      # Detects whether the provided key is in the config.
+      #
       # ==== Parameters
       # keyObject:: The key to check.
       #
       # ==== Returns
       # Boolean:: True if the key exists in the config.
+      #
+      # @api public
       def key?(key)
         @configuration.key?(key)
       end
 
+      # Retrieve the value of a config entry.
+      #
       # ==== Parameters
       # keyObject:: The key to retrieve the parameter for.
       #
       # ==== Returns
       # Object:: The value of the configuration parameter.
+      #
+      # @api public
       def [](key)
         (@configuration ||= setup)[key]
       end
 
+      # Set the value of a config entry.
+      #
       # ==== Parameters
       # keyObject:: The key to set the parameter for.
       # valObject:: The value of the parameter.
@@ -69,12 +89,21 @@ def []=(key, val)
         (@configuration ||= setup)[key] = val
       end
 
+      # Remove the value of a config entry.
+      #
       # ==== Parameters
       # keyObject:: The key of the parameter to delete.
+      #
+      # ==== Returns
+      # Object:: The value of the removed entry.
+      #
+      # @api public
       def delete(key)
         @configuration.delete(key)
       end
 
+      # Retrieve the value of a config entry, returning the provided default if the key is not present
+      #
       # ==== Parameters
       # keyObject:: The key to retrieve the parameter for.
       # defaultObject::
@@ -86,14 +115,22 @@ def fetch(key, default)
         @configuration.fetch(key, default)
       end
 
+      # Returns the configuration as a hash.
+      #
       # ==== Returns
       # Hash:: The config as a hash.
+      #
+      # @api public
       def to_hash
         @configuration
       end
 
+      # Returns the config as YAML.
+      #
       # ==== Returns
       # String:: The config as YAML.
+      #
+      # @api public
       def to_yaml
         require "yaml"
         @configuration.to_yaml
@@ -104,6 +141,11 @@ def to_yaml
       # ==== Parameters
       # settingsHash::
       #   Configuration settings to use. These are merged with the defaults.
+      #
+      # ==== Returns
+      # The configuration as a hash.
+      #
+      # @api private
       def setup(settings = {})
         @configuration = defaults.merge(settings)
         
@@ -118,6 +160,11 @@ def setup(settings = {})
       #
       # ==== Parameters
       # argvString:: The command line arguments. Defaults to +ARGV+.
+      #
+      # ==== Returns
+      # The configuration as a hash.
+      #
+      # @api private
       def parse_args(argv = ARGV)
         @configuration ||= {}
         # Our primary configuration hash for the length of this method
@@ -352,8 +399,14 @@ def parse_args(argv = ARGV)
       #     log_level   "debug"
       #     log_file    Merb.root / "log" / "special.log"
       #   end
+      #
+      # ==== Returns
+      # nil
+      #
+      # @api public
       def configure(&block)
         ConfigBlock.new(self, &block) if block_given?
+        nil
       end
 
       # Allows retrieval of single key config values via Merb.config.key
@@ -362,6 +415,11 @@ def configure(&block)
       # ==== Parameters
       # method~to_s:: Method name as hash key value.
       # *args:: Value to set the configuration parameter to.
+      #
+      # ==== Returns
+      # The value of the entry fetched or assigned to.
+      #
+      # @api public
       def method_missing(method, *args)
         if method.to_s[-1,1] == '='
           @configuration[method.to_s.tr('=','').to_sym] = *args
@@ -374,11 +432,26 @@ def method_missing(method, *args)
 
     class ConfigBlock
 
+      # Evaluates the provided block, where any call to a method causes
+      # #[]= to be called on klass with the method name as the key and the arguments
+      # as the value.
+      #
+      # ==== Parameters
+      # klassObject~[]=:: The object on which to assign values.
+      # &block:: The block which specifies the config values to set.
+      #
+      # ==== Returns
+      # nil
+      #
+      # @api private
       def initialize(klass, &block)
         @klass = klass
         instance_eval(&block)
       end
 
+      # Assign args as the value of the entry keyed by method.
+      #
+      # @api private
       def method_missing(method, *args)
         @klass[method] = *args
       end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/controller/abstract_controller.rb</file_name>
					<diff>@@ -124,12 +124,13 @@ class Merb::AbstractController
 
   # ==== Returns
   # String:: The controller name in path form, e.g. "admin/items".
-  #---
-  # @public
+  # @api public
   def self.controller_name() @controller_name ||= self.name.to_const_path end
 
   # ==== Returns
   # String:: The controller name in path form, e.g. "admin/items".
+  #
+  # @api public
   def controller_name()      self.class.controller_name                   end
   
   # This is called after the controller is instantiated to figure out where to
@@ -138,9 +139,9 @@ def controller_name()      self.class.controller_name                   end
   #
   # ==== Parameters
   # context~to_s:: The controller context (the action or template name).
-  # type~to_s:: The content type. Defaults to nil.
+  # type~to_s:: The content type. Could be nil. 
   # controller~to_s::
-  #   The name of the controller. Defaults to controller_name.
+  #   The name of the controller. Defaults to being called with the controller_name.  Set t
   #
   #
   # ==== Returns
@@ -160,29 +161,41 @@ def controller_name()      self.class.controller_name                   end
   #
   # This would look for templates at controller.action.mime.type instead
   # of controller/action.mime.type
-  #---
-  # @public
+  #
+  # @api public
+  # @overridable
   def _template_location(context, type, controller)
     controller ? "#{controller}/#{context}" : context
   end
 
-  # The location to look for a template - stub method for particular behaviour.
+  # The location to look for a template - override this method for particular behaviour. 
   #
   # ==== Parameters
   # templateString:: The absolute path to a template - without template extension.
   # type~to_s::
-  #    The mime-type of the template that will be rendered. Defaults to nil.
+  #    The mime-type of the template that will be rendered. Defaults to being called with nil.
   #
-  # @public
+  # @api public
+  # @overridable
   def _absolute_template_location(template, type)
     template
   end
 
+  # Resets the template roots to the template root passed in.
+  #
+  # ==== Parameters
+  # root~to_s:: 
+  #   The new path to set the template root to.  
+  #
+  # @api public
   def self._template_root=(root)
     @_template_root = root
     _reset_template_roots
   end
 
+  # Reset the template root based on the @_template_root ivar.
+  #
+  # @api private
   def self._reset_template_roots
     self.template_roots = [[self._template_root, :_template_location]]
   end
@@ -191,6 +204,8 @@ def self._reset_template_roots
   # rootsArray[Array]::
   #   Template roots as pairs of template root path and template location
   #   method.
+  #
+  # @api unknown
   def self._template_roots
     self.template_roots || _reset_template_roots
   end
@@ -199,45 +214,62 @@ def self._template_roots
   # rootsArray[Array]::
   #   Template roots as pairs of template root path and template location
   #   method.
+  #
+  # @api unknown
   def self._template_roots=(roots)
     self.template_roots = roots
   end
   
+  # Returns the list of classes that have specifically subclassed AbstractController.  
+  # Does not include all decendents.  
+  #
   # ==== Returns
   # Set:: The subclasses.
+  #
+  # @api private
   def self.subclasses_list() _abstract_subclasses end
   
-  class  self
-    # ==== Parameters
-    # klassMerb::AbstractController::
-    #   The controller that is being inherited from Merb::AbstractController
-    def inherited(klass)
-      _abstract_subclasses  klass.to_s
-      helper_module_name = klass.to_s =~ /^(#|Merb::)/ ? "#{klass}Helper" : "Merb::#{klass}Helper"
-      Object.make_module helper_module_name
-      klass.class_eval -HERE
-        include Object.full_const_get("#{helper_module_name}") rescue nil
-      HERE
-      super
-    end    
-  end
+  # ==== Parameters
+  # klassMerb::AbstractController::
+  #   The controller that is being inherited from Merb::AbstractController
+  #
+  # @api private
+  def self.inherited(klass)
+    _abstract_subclasses  klass.to_s
+    helper_module_name = klass.to_s =~ /^(#|Merb::)/ ? "#{klass}Helper" : "Merb::#{klass}Helper"
+    Object.make_module helper_module_name
+    klass.class_eval -HERE
+      include Object.full_const_get("#{helper_module_name}") rescue nil
+    HERE
+    super
+  end    
   
+  # This will initialize the controller, it is designed to be overridden in subclasses (like MerbController)
   # ==== Parameters
-  # *args:: The args are ignored.
+  # *args:: The args are ignored in this class, but we need this so that subclassed initializes can have parameters
+  #
+  # @overridable
   def initialize(*args)
     @_benchmarks = {}
     @_caught_content = {}
   end
   
-  # This will dispatch the request, calling internal before/after dispatch_callbacks
+  # This will dispatch the request, calling internal before/after dispatch callbacks.  
+  # If the return value of _call_filters is not :filter_chain_completed the action is not called, and the return from the filters is used instead. 
   # 
   # ==== Parameters
   # action~to_s::
   #   The action to dispatch to. This will be #send'ed in _call_action.
   #   Defaults to :to_s.
   #
+  # ==== Returns
+  # ~to_s::
+  #   Returns the string that was returned from the action. 
+  #
   # ==== Raises
-  # MerbControllerError:: Invalid body content caught.
+  # ArgumentError:: Invalid result caught from before filters.
+  #
+  # @api plugin
   def _dispatch(action)
     self._before_dispatch_callbacks.each { |cb| cb.call(self) }
     self.action_name = action
@@ -252,7 +284,8 @@ def _dispatch(action)
     @body = case caught
     when :filter_chain_completed  then _call_action(action_name)
     when String                   then caught
-    when nil                      then _filters_halted
+    # return *something* if you throw halt with nothing
+    when nil                      then "htmlbodyh1Filter Chain Halted!/h1/body/html"
     when Symbol                   then __send__(caught)
     when Proc                     then self.instance_eval(&caught)
     else
@@ -267,14 +300,19 @@ def _dispatch(action)
     @body
   end
   
-  # This method exists to provide an overridable hook for ActionArgs
+  # This method exists to provide an overridable hook for ActionArgs.  It uses #send to call the action method.
   #
   # ==== Parameters
   # action~to_s:: the action method to dispatch to
+  #
+  # @api plugin
+  # @overridable
   def _call_action(action)
     send(action)
   end
   
+  # Calls a filter chain. 
+  #
   # ==== Parameters
   # filter_setArray[Filter]::
   #   A set of filters in the form [[:filter, rule], [:filter, rule]]
@@ -290,6 +328,8 @@ def _call_action(action)
   # Procs::
   #   Execute the +Proc+, in the context of the controller (self will be the
   #   controller)
+  #
+  # @api private
   def _call_filters(filter_set)
     (filter_set || []).each do |filter, rule|
       if _call_filter_for_action?(rule, action_name) && _filter_condition_met?(rule)
@@ -308,6 +348,8 @@ def _call_filters(filter_set)
     return :filter_chain_completed
   end
 
+  # Determine whether the filter should be called for the current action using :only and :exclude.
+  #
   # ==== Parameters
   # ruleHash:: Rules for the filter (see below).
   # action_name~to_s:: The name of the action to be called.
@@ -322,6 +364,8 @@ def _call_filters(filter_set)
   #
   # ==== Returns
   # Boolean:: True if the action should be called.
+  #
+  # @api private
   def _call_filter_for_action?(rule, action_name)
     # Both:
     # * no :only or the current action is in the :only list
@@ -330,6 +374,8 @@ def _call_filter_for_action?(rule, action_name)
     (!rule.key?(:exclude) || !rule[:exclude].include?(action_name))
   end
 
+  # Determines whether the filter should be run based on the conditions passed (:if and :unless)
+  #
   # ==== Parameters
   # ruleHash:: Rules for the filter (see below).
   #
@@ -340,6 +386,8 @@ def _call_filter_for_action?(rule, action_name)
   #
   # ==== Returns
   # Boolean:: True if the conditions are met.
+  #
+  # @api private
   def _filter_condition_met?(rule)
     # Both:
     # * no :if or the if condition evaluates to true
@@ -348,6 +396,8 @@ def _filter_condition_met?(rule)
     (!rule.key?(:unless) || ! _evaluate_condition(rule[:unless]))
   end
 
+  # Evaluates a filter condition (:if or :unless)
+  #
   # ==== Parameters
   # conditionSymbol, Proc:: The condition to evaluate.
   #
@@ -360,6 +410,8 @@ def _filter_condition_met?(rule)
   # ==== Alternatives
   # If condition is a symbol, it will be send'ed. If it is a Proc it will be
   # called directly with self as an argument.
+  #
+  # @api private
   def _evaluate_condition(condition)
     case condition
     when Symbol : self.send(condition)
@@ -370,6 +422,7 @@ def _evaluate_condition(condition)
     end
   end
 
+  # Adds a filter to the after filter chain
   # ==== Parameters
   # filterSymbol, Proc:: The filter to add. Defaults to nil.
   # optsHash::
@@ -377,11 +430,15 @@ def _evaluate_condition(condition)
   # &block:: A block to use as a filter if filter is nil.
   #
   # ==== Notes
-  # If the filter already exists, its options will be replaced with opts.
+  # If the filter already exists, its options will be replaced with opts.;
+  #
+  # @api public
   def self.after(filter = nil, opts = {}, &block)
     add_filter(self._after_filters, filter || block, opts)
   end
 
+  # Adds a filter to the before filter chain.  
+  #
   # ==== Parameters
   # filterSymbol, Proc:: The filter to add. Defaults to nil.
   # optsHash::
@@ -390,44 +447,90 @@ def self.after(filter = nil, opts = {}, &block)
   #
   # ==== Notes
   # If the filter already exists, its options will be replaced with opts.
+  #
+  # @api public
   def self.before(filter = nil, opts = {}, &block)
     add_filter(self._before_filters, filter || block, opts)
   end
      
-  # Skip an after filter that has been previously defined (perhaps in a
-  # superclass)
+  # Removes a filter from the after filter chain.  This removes the 
+  # filter from the filter chain for the whole controller and does not 
+  # take any options. 
   #
   # ==== Parameters
-  # filterSymbol:: A filter name to skip.
+  # filterSymbol, String:: A filter name to skip.
+  #
+  # @api public
   def self.skip_after(filter)
     skip_filter(self._after_filters, filter)
   end
   
-  # Skip a before filter that has been previously defined (perhaps in a
-  # superclass).
+  # Removes a filter from the before filter chain.  This removes the 
+  # filter from the filter chain for the whole controller and does not 
+  # take any options.
   #
   # ==== Parameters
-  # filterSymbol:: A filter name to skip.
+  # filterSymbol, String:: A filter name to skip.
+  #
+  # @api public
   def self.skip_before(filter)
     skip_filter(self._before_filters , filter)
   end  
-  
-  #---
-  # Defaults that can be overridden by plugins, other mixins, or subclasses
-  def _filters_halted()   "htmlbodyh1Filter Chain Halted!/h1/body/html"  end
-  
-  # ==== Parameters
-  # name~to_sym, Hash:: The name of the URL to generate.
-  # rparamsHash:: Parameters for the route generation.
+
+  # There are three possible ways to use this method.  First, if you have a named route, 
+  # you can specify the route as the first parameter as a symbol and any paramters in a 
+  # hash.  Second, you can generate the default route by just passing the params hash, 
+  # just passing the params hash.  Finally, you can use the anonymous parameters.  This 
+  # allows you to specify the parameters to a named route in the order they appear in the 
+  # router.  
+  #
+  # ==== Parameters(Named Route)
+  # nameSymbol:: 
+  #   The name of the route. 
+  # argsHash:: 
+  #   Parameters for the route generation.
+  #
+  # ==== Parameters(Default Route)
+  # argsHash:: 
+  #   Parameters for the route generation.  This route will use the default route. 
+  #
+  # ==== Parameters(Anonymous Parameters)
+  # nameSymbol::
+  #   The name of the route.  
+  # argsArray:: 
+  #   An array of anonymous parameters to generate the route
+  #   with. These parameters are assigned to the route parameters
+  #   in the order that they are passed.
   #
   # ==== Returns
   # String:: The generated URL.
   #
-  # ==== Alternatives
-  # If a hash is used as the first argument, a default route will be
-  # generated based on it and rparams.
-  # ====
-  # TODO: Update this documentation
+  # ==== Examples
+  # Named Route
+  #
+  # Merb::Router.prepare do
+  #   match("/articles/:title").to(:controller = :articles, :action = :show).name("articles")
+  # end
+  #
+  # url(:articles, :title = "new_article")
+  #
+  # Default Route
+  #
+  # Merb::Router.prepare do
+  #   default_routes
+  # end
+  #
+  # url(:controller = "articles", :action = "new")
+  #
+  # Anonymous Paramters
+  #
+  # Merb::Router.prepare do
+  #   match("/articles/:year/:month/:title").to(:controller = :articles, :action = :show).name("articles")
+  # end
+  #
+  # url(:articles, 2008, 10, "test_article")
+  #
+  # @api public
   def url(name, *args)
     args  {}
     Merb::Router.url(name, *args)
@@ -435,22 +538,12 @@ def url(name, *args)
   
   alias_method :relative_url, :url
 
-  # ==== Parameters
-  # name~to_sym, Hash:: The name of the URL to generate.
-  # rparamsHash:: Parameters for the route generation.
-  #
-  # ==== Returns
-  # String:: The generated url with protocol + hostname + URL.
-  #
-  # ==== Options
-  #
-  # :protocol and :host options are special: use them to explicitly
-  # specify protocol and host of resulting url. If you omit them,
-  # protocol and host of request are used.
+  # Returns the absolute url including the passed protocol and host.  
+  # 
+  # This uses the same arguments as the url method, with added requirements 
+  # of protocol and host options. 
   #
-  # ==== Alternatives
-  # If a hash is used as the first argument, a default route will be
-  # generated based on it and rparams.
+  # @api public
   def absolute_url(name, *args)
     # FIXME: arrgh, why request.protocol returns http://?
     # :// is not part of protocol name
@@ -494,8 +587,9 @@ def absolute_url(name, *args)
   # resource(:users, :new)      # = /users/new
   # resource(:@user, :edit)     # = /users/10/edit
   #
+  # @api public
   def resource(*args)
-    args  params
+    args  {}
     Merb::Router.resource(*args)
   end
 
@@ -507,6 +601,8 @@ def resource(*args)
   #
   # ==== Returns
   # String:: The output of a template block or the return value of a non-template block converted to a string.
+  #
+  # @api public
   def capture(*args, &block)
     ret = nil
 
@@ -523,13 +619,16 @@ def capture(*args, &block)
   # ==== Parameters
   # strString:: The string to concatenate to the buffer.
   # bindingBinding:: The binding to use for the buffer.
+  #
+  # @api public
   def concat(str, binding)
     send("concat_#{@_engine}", str, binding)
   end
 
   private
+  # adds a filter to the specified filter chain
   # ==== Parameters
-  # filtersArray[Filter]:: The filter list that this should be added to.
+  # filtersArray[Filter]:: The filter chain that this should be added to.
   # filterFilter:: A filter that should be added.
   # optsHash::
   #   Filter options (see class documentation under ttFilter Options/tt).
@@ -538,6 +637,8 @@ def concat(str, binding)
   # ArgumentError::
   #   Both :only and :exclude, or :if and :unless given, if filter is not a
   #   Symbol, String or Proc, or if an unknown option is passed.
+  #
+  # @api private
   def self.add_filter(filters, filter, opts={})
     raise(ArgumentError,
       "You can specify either :only or :exclude but 
@@ -576,11 +677,13 @@ def self.add_filter(filters, filter, opts={})
   # inheritence hierarchies.
   #
   # ==== Parameters
-  # filtersArray[Filter]:: The filter list that this should be removed from.
+  # filtersArray[Filter]:: The filter chain that this should be removed from.
   # filterFilter:: A filter that should be removed.
   #
   # ==== Raises
   # ArgumentError:: filter not Symbol or String.
+  #
+  # @api private
   def self.skip_filter(filters, filter)
     raise(ArgumentError, 'You can only skip filters that have a String or Symbol name.') unless
       [Symbol, String].include? filter.class
@@ -600,6 +703,8 @@ def self.skip_filter(filters, filter)
   #
   # ==== Examples
   #   normalize_filters!(:only = :new) #= {:only = [:new]}
+  #
+  # @api public
   def self.normalize_filters!(opts={})
     opts[:only]     = Array(opts[:only]).map {|x| x.to_s} if opts[:only]
     opts[:exclude]  = Array(opts[:exclude]).map {|x| x.to_s} if opts[:exclude]</diff>
				</file>
				<file>
					<file_name>lib/merb-core/controller/exceptions.rb</file_name>
					<diff>@@ -1,12 +1,35 @@
 class Exception
+  # Returns the action_name that will be invoked on your Exceptions controller when this
+  # exception is raised. Override this method to force a different action to be invoked.
+  #
+  # ==== Returns
+  # String:: The name of the action in the Exceptions controller which will get invoked
+  #   when this exception is raised during a request.
+  # 
+  # @api public
+  # @overridable
   def action_name() self.class.action_name end
   
+  
+  # ==== Returns
+  # Boolean:: Whether or not this exception is the same as another.
+  #
+  # @api public
   def same?(other)
     self.class == other.class &&
     self.message == other.message &&
     self.backtrace == other.backtrace
   end
   
+  # Returns the action_name that will be invoked on your Exceptions controller when an instance
+  # is raised during a request.
+  #
+  # ==== Returns
+  # String:: The name of the action in the Exceptions controller which will get invoked
+  #   when an instance of this Exception sub/class is raised by an action.
+  # 
+  # @api public
+  # @overridable
   def self.action_name
     if self == Exception
       return nil unless Object.const_defined?(:Exceptions) && 
@@ -17,6 +40,14 @@ def self.action_name
       Exceptions.method_defined?(name) ? name : superclass.action_name
   end
   
+  # The status that will be sent in the response when an instance is
+  # raised during a request. Override this to send a different status.
+  #
+  # ==== Returns
+  # Integer:: The status code to send in the response. Defaults to 500.
+  #
+  # @api public
+  # @overridable
   def self.status
     500
   end
@@ -135,6 +166,8 @@ class  self
         #
         # ==== Returns
         # Fixnum:: The status code of this exception.
+        #
+        # @api public
         def status
           const_get(:STATUS) rescue 0
         end
@@ -147,6 +180,11 @@ def status
         #
         # ==== Parameters
         # num~to_i:: The status code
+        #
+        # ==== Returns
+        # (Integer, nil):: The status set on this exception, or nil if a status was already set.
+        #
+        # @api private
         def status=(num)
           unless self.status?
             register_status_code(self, num)
@@ -157,7 +195,9 @@ def status=(num)
         # See if a status-code has been defined (on self explicitly).
         #
         # ==== Returns
-        # Boolean:: Whether the a status code has been set
+        # Boolean:: Whether a status code has been set
+        #
+        # @api private
         def status?
           self.const_defined?(:STATUS)
         end
@@ -172,6 +212,8 @@ def status?
         # 
         # subclassMerb::ControllerExceptions::Base::
         #   The Exception class that is inheriting from Merb::ControllerExceptions::Base
+        #
+        # @api public
         def inherited(subclass)
           # don't set the constant yet - any class methods will be called after self.inherited
           # unless self.status = ... is set explicitly, the status code will be inherited
@@ -184,6 +226,8 @@ def inherited(subclass)
         #
         # ==== Parameters
         # num~to_i:: The status code
+        #
+        # @api privaate
         def register_status_code(klass, code)
           name = self.to_s.split('::').last.snake_case
           STATUS_CODES[name.to_sym] = code.to_i</diff>
				</file>
				<file>
					<file_name>lib/merb-core/controller/merb_controller.rb</file_name>
					<diff>@@ -15,104 +15,106 @@ def self.subclasses_list() _subclasses end
   include Merb::AuthenticationMixin
   include Merb::ConditionalGetMixin
 
-  class  self
-
-    # ==== Parameters
-    # klassMerb::Controller::
-    #   The Merb::Controller inheriting from the base class.
-    def inherited(klass)
-      _subclasses  klass.to_s
-      super
-      klass._template_root = Merb.dir_for(:view) unless self._template_root
-    end
+  # ==== Parameters
+  # klassMerb::Controller::
+  #   The Merb::Controller inheriting from the base class.
+  #
+  # @api private
+  def self.inherited(klass)
+    _subclasses  klass.to_s
+    super
+    klass._template_root = Merb.dir_for(:view) unless self._template_root
+  end
 
-    # Hide each of the given methods from being callable as actions.
-    #
-    # ==== Parameters
-    # *names~to-s:: Actions that should be added to the list.
-    #
-    # ==== Returns
-    # Array[String]::
-    #   An array of actions that should not be possible to dispatch to.
-    #
-    #---
-    # @public
-    def hide_action(*names)
-      self._hidden_actions = self._hidden_actions | names.map { |n| n.to_s }
-    end
+  # Hide each of the given methods from being callable as actions.
+  #
+  # ==== Parameters
+  # *names~to-s:: Actions that should be added to the list.
+  #
+  # ==== Returns
+  # Array[String]::
+  #   An array of actions that should not be possible to dispatch to.
+  #
+  # @api public
+  def self.hide_action(*names)
+    self._hidden_actions = self._hidden_actions | names.map { |n| n.to_s }
+  end
 
-    # Makes each of the given methods being callable as actions. You can use
-    # this to make methods included from modules callable as actions.
-    #
-    # ==== Parameters
-    # *names~to-s:: Actions that should be added to the list.
-    #
-    # ==== Returns
-    # Array[String]::
-    #   An array of actions that should be dispatched to even if they would not
-    #   otherwise be.
-    #
-    # ==== Example
-    #   module Foo
-    #     def self.included(base)
-    #       base.show_action(:foo)
-    #     end
-    #
-    #     def foo
-    #       # some actiony stuff
-    #     end
-    #
-    #     def foo_helper
-    #       # this should not be an action
-    #     end
-    #   end
-    #
-    #---
-    # @public
-    def show_action(*names)
-      self._shown_actions = self._shown_actions | names.map {|n| n.to_s}
-    end
+  # Makes each of the given methods being callable as actions. You can use
+  # this to make methods included from modules callable as actions.
+  #
+  # ==== Parameters
+  # *names~to-s:: Actions that should be added to the list.
+  #
+  # ==== Returns
+  # Array[String]::
+  #   An array of actions that should be dispatched to even if they would not
+  #   otherwise be.
+  #
+  # ==== Example
+  #   module Foo
+  #     def self.included(base)
+  #       base.show_action(:foo)
+  #     end
+  #
+  #     def foo
+  #       # some actiony stuff
+  #     end
+  #
+  #     def foo_helper
+  #       # this should not be an action
+  #     end
+  #   end
+  #
+  # @api public
+  def self.show_action(*names)
+    self._shown_actions = self._shown_actions | names.map {|n| n.to_s}
+  end
 
-    # The list of actions that are callable, after taking defaults,
-    # _hidden_actions and _shown_actions into consideration. It is calculated
-    # once, the first time an action is dispatched for this controller.
-    #
-    # ==== Returns
-    # SimpleSet[String]:: A set of actions that should be callable.
-    def callable_actions
-      @callable_actions ||= Extlib::SimpleSet.new(_callable_methods)
-    end
+  # The list of actions that are callable, after taking defaults,
+  # _hidden_actions and _shown_actions into consideration. It is calculated
+  # once, the first time an action is dispatched for this controller.
+  #
+  # ==== Returns
+  # SimpleSet[String]:: A set of actions that should be callable.
+  #
+  # @api public
+  def self.callable_actions
+    @callable_actions ||= Extlib::SimpleSet.new(_callable_methods)
+  end
 
-    # This is a stub method so plugins can implement param filtering if they want.
-    #
-    # ==== Parameters
-    # paramsHash{Symbol = String}:: A list of params
-    #
-    # ==== Returns
-    # Hash{Symbol = String}:: A new list of params, filtered as desired
-    #---
-    # @semipublic
-    def _filter_params(params)
-      params
-    end
+  # This is a stub method so plugins can implement param filtering if they want.
+  #
+  # ==== Parameters
+  # paramsHash{Symbol = String}:: A list of params
+  #
+  # ==== Returns
+  # Hash{Symbol = String}:: A new list of params, filtered as desired
+  # 
+  # @api plugin
+  # @overridable
+  def self._filter_params(params)
+    params
+  end
 
-    private
+  private
 
-    # All methods that are callable as actions.
-    #
-    # ==== Returns
-    # Array:: A list of method names that are also actions
-    def _callable_methods
-      callables = []
-      klass = self
-      begin
-        callables  (klass.public_instance_methods(false) + klass._shown_actions) - klass._hidden_actions
-        klass = klass.superclass
-      end until klass == Merb::AbstractController || klass == Object
-      callables.flatten.reject{|action| action =~ /^_.*/}
-    end
+  # All methods that are callable as actions.
+  #
+  # ==== Returns
+  # Array:: A list of method names that are also actions
+  #
+  # @api private
+  def self._callable_methods
+    callables = []
+    klass = self
+    begin
+      callables  (klass.public_instance_methods(false) + klass._shown_actions) - klass._hidden_actions
+      klass = klass.superclass
+    end until klass == Merb::AbstractController || klass == Object
+    callables.flatten.reject{|action| action =~ /^_.*/}
+  end
 
-  end # class  self
 
   # The location to look for a template for a particular controller, context,
   # and mime-type. This is overridden from AbstractController, which defines a
@@ -124,14 +126,14 @@ def _callable_methods
   #    The mime-type of the template that will be rendered. Defaults to nil.
   # controller~to_s::
   #   The name of the controller that will be rendered. Defaults to
-  #   controller_name.
+  #   controller_name.  This will be "layout" for rendering a layout.  
   #
   # ==== Notes
   # By default, this renders ":controller/:action.:type". To change this,
   # override it in your application class or in individual controllers.
   #
-  #---
-  # @public
+  # @api public
+  # @overridable
   def _template_location(context, type, controller)
     _conditionally_append_extension(controller ? "#{controller}/#{context}" : "#{context}", type)
   end
@@ -148,7 +150,7 @@ def _template_location(context, type, controller)
   # type~to_s::
   #    The mime-type of the template that will be rendered. Defaults to nil.
   #
-  # @public
+  # @api public
   def _absolute_template_location(template, type)
     _conditionally_append_extension(template, type)
   end
@@ -164,8 +166,9 @@ def _absolute_template_location(template, type)
   # headersHash{header = value}::
   #   A hash of headers to start the controller with. These headers can be
   #   overridden later by the #headers method.
-  #---
-  # @semipublic
+  # 
+  # @api plugin
+  # @overridable
   def initialize(request, status=200, headers={'Content-Type' = 'text/html; charset=utf-8'})
     super()
     @request, @_status, @headers = request, status, headers
@@ -181,8 +184,8 @@ def initialize(request, status=200, headers={'Content-Type' = 'text/html; chars
   #
   # ==== Raises
   # ActionNotFound:: The requested action was not found in class.
-  #---
-  # @semipublic
+  #
+  # @api plugin
   def _dispatch(action=:index)
     Merb.logger.info("Params: #{self.class._filter_params(request.params).inspect}")
     start = Time.now
@@ -197,6 +200,10 @@ def _dispatch(action=:index)
 
   attr_reader :request, :headers
 
+  # ==== Returns
+  # Fixnum:: The response status code
+  #
+  # @api public
   def status
     @_status
   end
@@ -205,6 +212,8 @@ def status
   #
   # ==== Parameters
   # sFixnum, Symbol:: A status-code or named http-status
+  #
+  # @api public
   def status=(s)
     if s.is_a?(Symbol) && STATUS_CODES.key?(s)
       @_status = STATUS_CODES[s]
@@ -217,27 +226,112 @@ def status=(s)
 
   # ==== Returns
   # Hash:: The parameters from the request object
+  # 
+  # @api public
   def params()  request.params  end
     
-  # ==== Parameters
-  # name~to_sym, Hash:: The name of the URL to generate.
-  # rparamsHash:: Parameters for the route generation.
+  # There are three possible ways to use this method.  First, if you have a named route, 
+  # you can specify the route as the first parameter as a symbol and any paramters in a 
+  # hash.  Second, you can generate the default route by just passing the params hash, 
+  # just passing the params hash.  Finally, you can use the anonymous parameters.  This 
+  # allows you to specify the parameters to a named route in the order they appear in the 
+  # router.  
+  #
+  # ==== Parameters(Named Route)
+  # nameSymbol:: 
+  #   The name of the route. 
+  # argsHash:: 
+  #   Parameters for the route generation.
+  #
+  # ==== Parameters(Default Route)
+  # argsHash:: 
+  #   Parameters for the route generation.  This route will use the default route. 
+  #
+  # ==== Parameters(Anonymous Parameters)
+  # nameSymbol::
+  #   The name of the route.  
+  # argsArray:: 
+  #   An array of anonymous parameters to generate the route
+  #   with. These parameters are assigned to the route parameters
+  #   in the order that they are passed.
   #
   # ==== Returns
   # String:: The generated URL.
   #
-  # ==== Alternatives
-  # If a hash is used as the first argument, a default route will be
-  # generated based on it and rparams.
-  # ====
-  # TODO: Update this documentation
+  # ==== Examples
+  # Named Route
+  #
+  # Merb::Router.prepare do
+  #   match("/articles/:title").to(:controller = :articles, :action = :show).name("articles")
+  # end
+  #
+  # url(:articles, :title = "new_article")
+  #
+  # Default Route
+  #
+  # Merb::Router.prepare do
+  #   default_routes
+  # end
+  #
+  # url(:controller = "articles", :action = "new")
+  #
+  # Anonymous Paramters
+  #
+  # Merb::Router.prepare do
+  #   match("/articles/:year/:month/:title").to(:controller = :articles, :action = :show).name("articles")
+  # end
+  #
+  # url(:articles, 2008, 10, "test_article")
+  #
+  # @api public
   def url(name, *args)
     args  params
     Merb::Router.url(name, *args)
   end
+  
+  # Generates a URL for a single or nested resource.
+  #
+  # ==== Parameters
+  # resourcesSymbol,Object:: The resources for which the URL
+  #   should be generated. These resources should be specified
+  #   in the router.rb file using #resources and #resource.
+  #
+  # optionsHash:: Any extra parameters that are needed to
+  #   generate the URL.
+  #
+  # ==== Returns
+  # String:: The generated URL.
+  #
+  # ==== Examples
+  #
+  # Merb::Router.prepare do
+  #   resources :users do
+  #     resources :comments
+  #   end
+  # end
+  #
+  # resource(:users)            # = /users
+  # resource(@user)             # = /users/10
+  # resource(@user, :comments)  # = /users/10/comments
+  # resource(@user, @comment)   # = /users/10/comments/15
+  # resource(:users, :new)      # = /users/new
+  # resource(:@user, :edit)     # = /users/10/edit
+  #
+  # @api public
+  def resource(*args)
+    args  params
+    Merb::Router.resource(*args)
+  end
+  
 
   alias_method :relative_url, :url
   
+  # Returns the absolute url including the passed protocol and host.  
+  # 
+  # This uses the same arguments as the url method, with added requirements 
+  # of protocol and host options. 
+  #
+  # @api public
   def absolute_url(*args)
     options  = extract_options_from_args!(args) || {}
     options[:protocol] ||= request.protocol
@@ -251,6 +345,8 @@ def absolute_url(*args)
   # ==== Returns
   # Array[Integer, Hash, String]::
   #   The controller's status code, headers, and body
+  #
+  # @api private
   def rack_response
     [status, headers, Merb::Rack::StreamWrapper.new(body)]
   end
@@ -258,6 +354,8 @@ def rack_response
   # Sets a controller to be "abstract" 
   # This controller will not be able to be routed to
   # and is used for super classing only
+  #
+  # @api public
   def self.abstract!
     @_abstract = true
   end
@@ -267,6 +365,8 @@ def self.abstract!
   # === Returns
   # Boolean
   #  true if the controller has been set as abstract
+  #
+  # @api public
   def self.abstract?
     !!@_abstract 
   end
@@ -277,6 +377,15 @@ def self.abstract?
   private
 
   # If not already added, add the proper mime extension to the template path.
+  #
+  # ==== Parameters
+  #
+  # template~to_s ::
+  #   The template path to append the mime type to.
+  # type~to_s ::
+  #   The extension to append to the template path conditionally
+  #
+  # @api private
   def _conditionally_append_extension(template, type)
     type && !template.match(/\.#{type.to_s.escape_regexp}$/) ? "#{template}.#{type}" : template
   end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/controller/mime.rb</file_name>
					<diff>@@ -1,12 +1,32 @@
 module Merb
   class  self
 
+    
+    # Returns a hash of the available mime types. 
+    #
     # ==== Returns
-    # Hash:: The available mime types.
+    # Hash{Symbol = Hash{Symbol = Object}}:: The available mime types.
+    #
+    # ==== Notes
+    # Each entry corresponds to a call to add_mime_type, having the mime type key (:html, :xml, :json, etc.)
+    # as the key and a hash containing the following entries:
+    #   :accepts           # the mime types that will be recognized by this entry
+    #   :transform_method  # the method called on an object to convert it to content of this type (such as to_json)
+    #   :content_type      # the value set to the "Content-Type" HTTP header when this mime is sent in a response
+    #   :response_headers  # sent in a response using this content type
+    #   :default_quality   # the scale factor used in describing content type preference
+    #   :response_block    # the block to be called with the controller when a request responds to this mime type
+    #
+    # @api public
     def available_mime_types
       ResponderMixin::TYPES
     end
 
+    # ==== Returns
+    # Hash{String = Symbol}:: 
+    #   A hash mapping Content-Type values to the mime type key of the appropriate entry in #available_mime_types
+    #
+    # @api public
     def available_accepts
       ResponderMixin::MIMES
     end
@@ -42,6 +62,11 @@ def available_accepts
     #   correctly appended to the mimetype itself.
     # &block:: a block which recieves the current controller when the format
     #   is set (in the controller's #content_type method)
+    #
+    # ==== Returns
+    # nil
+    #
+    # @api public
     def add_mime_type(key, transform_method, mimes, new_response_headers = {}, default_quality = 1, &block) 
       enforce!(key = Symbol, mimes = Array)
       
@@ -69,6 +94,8 @@ def render_#{key}(thing = nil, opts = {})
           render thing, opts
         end
       EOS
+      
+      nil
     end
 
     # Removes a MIME-type from the mime-type list.
@@ -78,6 +105,8 @@ def render_#{key}(thing = nil, opts = {})
     #
     # ==== Notes
     # :all is the key for */*; It can't be removed.
+    #
+    # @api public
     def remove_mime_type(key)
       return false if key == :all
       ResponderMixin::TYPES.delete(key)
@@ -91,21 +120,12 @@ def remove_mime_type(key)
     #
     # ==== Raises
     # ArgumentError:: The requested mime type is not valid.
+    #
+    # @api public
     def mime_transform_method(key)
       raise ArgumentError, ":#{key} is not a valid MIME-type" unless ResponderMixin::TYPES.key?(key)
       ResponderMixin::TYPES[key][:transform_method]
     end
 
-    # The mime-type for a particular inbound Accepts header.
-    #
-    # ==== Parameters
-    # headerString:: The name of the header to find the mime-type for.
-    #
-    # ==== Returns
-    # Hash:: The mime type information.
-    def mime_by_request_header(header)
-      available_mime_types.find {|key,info| info[:accepts].include?(header)}.first
-    end
-    
   end
 end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/controller/mixins/authentication.rb</file_name>
					<diff>@@ -12,6 +12,9 @@ module Merb::AuthenticationMixin
   # realm~to_s:: The realm to authenticate against. Defaults to 'Application'.
   # &authenticator:: A block to check if the authentication is valid.
   #
+  # ==== Returns
+  # Merb::AuthenticationMixin::BasicAuthentication
+  #
   # ==== Examples
   #     class Application  Merb::Controller
   #     
@@ -47,7 +50,7 @@ module Merb::AuthenticationMixin
   #
   # If you need to request basic authentication inside an action you need to use the request! method.
   #
-  # ====Example
+  # ==== Example
   #
   #    class Sessions  Application
   #  
@@ -55,15 +58,24 @@ module Merb::AuthenticationMixin
   #        case content_type
   #        when :html
   #          render
+  #
   #        else
-  #          basic_authentication.request!
+  #         user = basic_authentication.authenticate do |username, password|
+  #           User.authenticate(username, password)
+  #         end
+  #
+  #         if user
+  #           display(user)
+  #         else
+  #           basic_authentication.request
+  #         end
   #        end
   #      end
   # 
   #    end 
   #
-  #---
-  # @public
+  #
+  # @api public
   def basic_authentication(realm = "Application", &authenticator)
     @_basic_authentication ||= BasicAuthentication.new(self, realm, &authenticator)
   end
@@ -72,6 +84,7 @@ class BasicAuthentication
     # So we can have access to the status codes
     include Merb::ControllerExceptions
 
+    # @api private
     def initialize(controller, realm = "Application", &authenticator)
       @controller = controller
       @realm = realm
@@ -79,6 +92,15 @@ def initialize(controller, realm = "Application", &authenticator)
       authenticate_or_request(&authenticator) if authenticator
     end
 
+    # Determines whether or not the user is authenticated using the criteria
+    # in the provided authenticator block.
+    #
+    # ==== Parameters
+    # &authenticator:: A block that decides whether the provided username and password
+    #   are valid.
+    #
+    # ==== Returns
+    # Object:: False if basic auth is not provided, otherwise the return value of the authenticator block.
     def authenticate(&authenticator)
       if @auth.provided? and @auth.basic?
         authenticator.call(*@auth.credentials)
@@ -87,33 +109,56 @@ def authenticate(&authenticator)
       end
     end
 
+    # Request basic authentication and halt the filter chain. This is for use in a before filter.
+    #
+    # ==== Throws
+    # :halt with an "HTTP Basic: Access denied." message with no layout, and sets the status to Unauthorized.
+    #
+    # @api public
     def request
       request!
       throw :halt, @controller.render("HTTP Basic: Access denied.\n", :status = Unauthorized.status, :layout = false)
     end
     
-    # This is a special case for use outside a before filter.  Use this if you need to 
-    # request basic authenticaiton as part of an action
+    # Sets headers to request basic auth.
+    #
+    # ==== Returns
+    # String:: Returns the empty string to provide a response body.
+    #
+    # @api public
     def request!
       @controller.status = Unauthorized.status
       @controller.headers['WWW-Authenticate'] = 'Basic realm="%s"' % @realm
+      ""
     end
     
-    # Checks to see if there has been any basic authentication credentials provided
+    # ==== Returns
+    # Boolean:: Whether there has been any basic authentication credentials provided
+    #
+    # @api public
     def provided?
       @auth.provided?
     end
     
+    # ==== Returns
+    # String:: The username provided in the request.
+    #
+    # @api public
     def username
       provided? ? @auth.credentials.first : nil
     end
     
+    # ==== Returns
+    # String:: The password provided in the request.
+    #
+    # @api public
     def password
       provided? ? @auth.credentials.last : nil
     end
     
     protected
     
+    # @api private
     def authenticate_or_request(&authenticator)
       authenticate(&authenticator) || request
     end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/controller/mixins/conditional_get.rb</file_name>
					<diff>@@ -29,6 +29,8 @@ module Merb::ConditionalGetMixin
   # tag~to_s::
   #   value of ETag header enclosed in double quotes
   #   as required by the RFC
+  #
+  # @api public
   def etag=(tag)
     headers[Merb::Const::ETAG] = %("#{tag}")
   end
@@ -36,6 +38,8 @@ def etag=(tag)
   # ==== Returns
   # String::
   #   Value of ETag response header or nil if it's not set.
+  #
+  # @api public
   def etag
     headers[Merb::Const::ETAG]
   end
@@ -44,6 +48,8 @@ def etag
   # Boolean::
   # true if ETag response header equals If-None-Match request header,
   # false otherwise
+  #
+  # @api public
   def etag_matches?(tag = self.etag)
     tag == self.request.if_none_match
   end
@@ -54,6 +60,8 @@ def etag_matches?(tag = self.etag)
   # tagTime::
   # resource modification timestamp converted into format
   # required by the RFC
+  #
+  # @api public
   def last_modified=(time)
     headers[Merb::Const::LAST_MODIFIED] = time.httpdate
   end
@@ -61,6 +69,8 @@ def last_modified=(time)
   # ==== Returns
   # String::
   #   Value of Last-Modified response header or nil if it's not set.
+  #
+  # @api public
   def last_modified
     Time.rfc2822(headers[Merb::Const::LAST_MODIFIED])
   end
@@ -69,6 +79,8 @@ def last_modified
   # Boolean::
   # true if Last-Modified response header is  than
   # If-Modified-Since request header value, false otherwise.
+  #
+  # @api public
   def not_modified?(time = self.last_modified)
     request.if_modified_since && time && time = request.if_modified_since
   end
@@ -77,6 +89,8 @@ def not_modified?(time = self.last_modified)
   # Boolean::
   # true if either ETag matches or entity is not modified,
   # so request is fresh; false otherwise
+  #
+  # @api public
   def request_fresh?
     etag_matches?(self.etag) || not_modified?(self.last_modified)
   end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/controller/mixins/controller.rb</file_name>
					<diff>@@ -4,26 +4,27 @@ module ControllerMixin
     
     # Enqueu a block to run in a background thread outside of the request
     # response dispatch
-    #
+    # 
     # ==== Parameters
-    # takes a block to run later
-    #
+    # &blk:: proc to run later
+    # 
     # ==== Example
     # run_later do
     #   SomeBackgroundTask.run
     # end
-    #
+    # 
+    # @api public
     def run_later(&blk)
       Merb::Dispatcher.work_queue  blk
     end
     
     # Renders the block given as a parameter using chunked encoding.
-    #
+    # 
     # ==== Parameters
-    # &blk:: 
+    # &blk::
     #   A block that, when called, will use send_chunks to send chunks of data
     #   down to the server. The chunking will terminate once the block returns.
-    #
+    # 
     # ==== Examples
     #   def stream
     #     prefix = 'p'
@@ -44,6 +45,8 @@ def run_later(&blk)
     #       end
     #     end
     #   end
+    # 
+    # @api public
     def render_chunked(&blk)
       must_support_streaming!
       headers['Transfer-Encoding'] = 'chunked'
@@ -55,12 +58,14 @@ def render_chunked(&blk)
         response.write("0\r\n\r\n")
       }
     end
-
+    
     # Writes a chunk from +render_chunked+ to the response that is sent back to
     # the client. This should only be called within a +render_chunked+ block.
     #
     # ==== Parameters
     # dataString:: a chunk of data to return.
+    # 
+    # @api public
     def send_chunk(data)
       only_runs_on_mongrel!
       @response.write('%x' % data.size + "\r\n")
@@ -71,53 +76,59 @@ def send_chunk(data)
     # &blk::
     #   A proc that should get called outside the mutex, and which will return
     #   the value to render.
-    #
+    # 
     # ==== Returns
     # Proc::
-    #   A block that Mongrel can call later, allowing Merb to release the
+    #   A block that the server can call later, allowing Merb to release the
     #   thread lock and render another request.
+    # 
+    # @api public
     def render_deferred(&blk)
-      Proc.new {|response|
+      Proc.new do |response|
         response.write(blk.call)
-      }
+      end
     end
     
     # Renders the passed in string, then calls the block outside the mutex and
     # after the string has been returned to the client.
-    #
+    # 
     # ==== Parameters
     # strString:: A +String+ to return to the client.
     # &blk:: A block that should get called once the string has been returned.
-    #
+    # 
     # ==== Returns
     # Proc::
     #   A block that Mongrel can call after returning the string to the user.
+    # 
+    # @api public
     def render_then_call(str, &blk)
-      Proc.new {|response|
+      Proc.new do |response|
         response.write(str)
-        blk.call        
-      }      
+        blk.call
+      end
     end
-
+    
     # ==== Parameters
     # urlString::
     #   URL to redirect to. It can be either a relative or fully-qualified URL.
     # optsHash:: An options hash (see below)
-    #
+    # 
     # ==== Options (opts)
     # :messageHash::
     #   Messages to pass in url query string as value for "_message"
     # :permanentBoolean::
     #   When true, return status 301 Moved Permanently
-    #
+    # 
     # ==== Returns
     # String:: Explanation of redirect.
-    #
+    # 
     # ==== Examples
     #   redirect("/posts/34")
     #   redirect("/posts/34", :message = { :notice = 'Post updated successfully!' })
     #   redirect("http://www.merbivore.com/")
     #   redirect("http://www.merbivore.com/", :permanent = true)
+    # 
+    # @api public
     def redirect(url, opts = {})
       default_redirect_options = { :message = nil, :permanent = false }
       opts = default_redirect_options.merge(opts)
@@ -131,17 +142,20 @@ def redirect(url, opts = {})
       "htmlbodyYou are being a href=\"#{url}\"redirected/a./body/html"
     end
     
+    # Retreives the redirect message either locally or from the request.
+    # 
+    # @api public
     def message
       @_message = defined?(@_message) ? @_message : request.message
     end
     
     # Sends a file over HTTP.  When given a path to a file, it will set the
     # right headers so that the static file is served directly.
-    #
+    # 
     # ==== Parameters
     # fileString:: Path to file to send to the client.
     # optsHash:: Options for sending the file (see below).
-    #
+    # 
     # ==== Options (opts)
     # :dispositionString::
     #   The disposition of the file send. Defaults to "attachment".
@@ -151,6 +165,8 @@ def message
     #
     # ==== Returns
     # IO:: An I/O stream for the file.
+    # 
+    # @api public
     def send_file(file, opts={})
       opts.update(Merb::Const::DEFAULT_SEND_FILE_OPTIONS.merge(opts))
       disposition = opts[:disposition].dup || 'attachment'
@@ -160,28 +176,30 @@ def send_file(file, opts={})
         'Content-Disposition'       = disposition,
         'Content-Transfer-Encoding' = 'binary'
       )
-      Proc.new {|response|
+      Proc.new do |response|
         file = File.open(file, 'rb')
         while chunk = file.read(16384)
           response.write chunk
-        end  
+        end
         file.close
-      }
+      end
     end
     
     # Send binary data over HTTP to the user as a file download. May set content type,
     # apparent file name, and specify whether to show data inline or download as an attachment.
-    #
+    # 
     # ==== Parameters
     # dataString:: Path to file to send to the client.
     # optsHash:: Options for sending the data (see below).
-    #
+    # 
     # ==== Options (opts)
     # :dispositionString::
     #   The disposition of the file send. Defaults to "attachment".
     # :filenameString::
     #   The name to use for the file. Defaults to the filename of file.
     # :typeString:: The content type.
+    # 
+    # @api public
     def send_data(data, opts={})
       opts.update(Merb::Const::DEFAULT_SEND_FILE_OPTIONS.merge(opts))
       disposition = opts[:disposition].dup || 'attachment'
@@ -195,13 +213,13 @@ def send_data(data, opts={})
     end
     
     # Streams a file over HTTP.
-    #
+    # 
     # ==== Parameters
     # optsHash:: Options for the file streaming (see below).
     # &stream::
     #   A block that, when called, will return an object that responds to
     #   +get_lines+ for streaming.
-    #
+    # 
     # ==== Options
     # :dispositionString::
     #   The disposition of the file send. Defaults to "attachment".
@@ -216,6 +234,8 @@ def send_data(data, opts={})
     #       response.write chunk
     #     end
     #   end
+    # 
+    # @api public
     def stream_file(opts={}, &stream)
       opts.update(Merb::Const::DEFAULT_SEND_FILE_OPTIONS.merge(opts))
       disposition = opts[:disposition].dup || 'attachment'
@@ -227,32 +247,37 @@ def stream_file(opts={}, &stream)
         # Rack specification requires header values to respond to :each
         'CONTENT-LENGTH'            = opts[:content_length].to_s
       )
-      Proc.new{|response|
+      Proc.new do |response|
         stream.call(response)
-      }
+      end
     end
-
+    
     # Uses the nginx specific +X-Accel-Redirect+ header to send a file directly
-    # from nginx. For more information, see the nginx wiki:
+    # from nginx.
+    # 
+    # ==== Notes
+    # Unless Content-Disposition is set before calling this method,
+    # it is set to attachment with streamed file name.
+    # 
+    # For more information, see the nginx wiki:
     # http://wiki.codemongers.com/NginxXSendfile
-    #
+    # 
     # and the following sample gist:
     # http://gist.github.com/11225
-    #
+    # 
     # there's also example application up on GitHub:
-    #
+    # 
     # http://github.com/michaelklishin/nginx-x-accel-redirect-example-application/tree/master
-    #
-    # Unless Content-Disposition is set before calling this method,
-    # it is set to attachment with streamed file name.
-    #
+    # 
     # ==== Parameters
     # pathString:: Path to file to send to the client.
     # content_typeString:: content type header value. By default is set to empty string to let
     #                        Nginx detect it.
-    #
+    # 
     # ==== Return
-    # One space string.
+    # String:: precisely a single space.
+    # 
+    # @api public
     def nginx_send_file(path, content_type = "")
       # Let Nginx detect content type unless it is explicitly set
       headers['Content-Type']        = content_type
@@ -262,17 +287,17 @@ def nginx_send_file(path, content_type = "")
       
       return ' '
     end  
-  
+    
     # Sets a cookie to be included in the response.
-    #
+    # 
     # If you need to set a cookie, then use the +cookies+ hash.
-    #
+    # 
     # ==== Parameters
     # name~to_s:: A name for the cookie.
     # value~to_s:: A value for the cookie.
     # expires~gmtime:~strftime, Hash:: An expiration time for the cookie, or a hash of cookie options.
-    # ---
-    # @public
+    # 
+    # @api public
     def set_cookie(name, value, expires)
       options = expires.is_a?(Hash) ? expires : {:expires = expires}
       cookies.set_cookie(name, value, options)
@@ -280,11 +305,13 @@ def set_cookie(name, value, expires)
     
     # Marks a cookie as deleted and gives it an expires stamp in the past. This
     # method is used primarily internally in Merb.
-    #
+    # 
     # Use the +cookies+ hash to manipulate cookies instead.
-    #
+    # 
     # ==== Parameters
     # name~to_s:: A name for the cookie to delete.
+    # 
+    # @api public
     def delete_cookie(name)
       set_cookie(name, nil, Merb::Const::COOKIE_EXPIRED_TIME)
     end
@@ -296,6 +323,8 @@ def delete_cookie(name)
     #
     # ==== Returns
     # String:: The escaped object.
+    # 
+    # @api public
     def escape_xml(obj)
       Erubis::XmlHelper.escape_xml(obj.to_s)
     end
@@ -303,14 +332,17 @@ def escape_xml(obj)
     alias escape_html escape_xml
     
     private
-      # Marks an output method that only runs on the mongrel webserver.
-      #
-      # ==== Raises
-      # NotImplemented:: The Rack adapter is not mongrel.
-      def only_runs_on_mongrel!
-        unless Merb::Config[:log_stream] == 'mongrel'
-          raise(Merb::ControllerExceptions::NotImplemented, "Current Rack adapter is not mongrel. cannot support this feature")
-        end
+    
+    # Marks an output method that only runs on the Mongrel webserver.
+    # 
+    # ==== Raises
+    # NotImplemented:: The Rack adapter is not mongrel.
+    # 
+    # @api private
+    def only_runs_on_mongrel!
+      unless Merb::Config[:log_stream] == 'mongrel'
+        raise(Merb::ControllerExceptions::NotImplemented, "Current Rack adapter is not mongrel. cannot support this feature")
       end
+    end
   end
 end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/controller/mixins/render.rb</file_name>
					<diff>@@ -4,6 +4,8 @@ module Merb::RenderMixin
 
   # ==== Parameters
   # baseModule:: Module that is including RenderMixin (probably a controller)
+  #
+  # @private
   def self.included(base)
     base.extend(ClassMethods)
     base.class_eval do
@@ -17,6 +19,8 @@ module ClassMethods
     #
     # ==== Returns
     # Hash:: An options hash
+    #
+    # @api public
     def default_render_options
       self._default_render_options ||= {}
     end
@@ -25,6 +29,8 @@ def default_render_options
     #
     # ==== Parameters
     # optsHash:: An options hash
+    #
+    # @api public
     def render_options(opts)
       self._default_render_options = opts
     end
@@ -40,11 +46,18 @@ def render_options(opts)
     #
     # ==== Returns
     # Hash:: The default render options.
+    #
+    # @api public
     def layout(layout)
       self.default_render_options.update(:layout = (layout || false))
     end
 
     # Enable the default layout logic - reset the layout option.
+    #
+    # ==== Returns
+    # ~to_s:: The layout that was previously set.
+    #
+    # @api public
     def default_layout
       self.default_render_options.delete(:layout)
     end
@@ -82,8 +95,8 @@ def default_layout
   # ==== Alternatives
   # If you pass a Hash as the first parameter, it will be moved to opts and
   # "thing" will be the current action
-  #---
-  # @public
+  #
+  # @api public
   def render(thing = nil, opts = {})
     # render :format = :xml means render nil, :format = :xml
     opts, thing = thing, nil if thing.is_a?(Hash)
@@ -188,6 +201,7 @@ def render(thing = nil, opts = {})
   # The transformed object will not be used in a layout unless a :layout is
   # explicitly passed in the opts.
   #
+  # @api public
   def display(object, thing = nil, opts = {})
     template_opt = thing.is_a?(Hash) ? thing.delete(:template) : opts.delete(:template)
 
@@ -268,6 +282,8 @@ def display(object, thing = nil, opts = {})
   #
   # In this case, "one" will be available in the partial through the local
   # variable named +number+.
+  #
+  # @api public
   def partial(template, opts={})
 
     # partial :foo becomes "#{controller_name}/_foo"
@@ -323,6 +339,8 @@ def partial(template, opts={})
   #
   # ==== Returns
   # Hash:: The options hash that was passed in.
+  #
+  # @api private
   def _handle_options!(opts)
     self.status = opts.delete(:status).to_i if opts[:status]
     headers["Location"] = opts.delete(:location) if opts[:location]
@@ -346,6 +364,8 @@ def _handle_options!(opts)
   #   If a layout was specified (either via layout in the class or by passing
   #   one in to this method), and not found. No error will be raised if no
   #   layout was specified, and the default layouts were not found.
+  #
+  # @api private
   def _get_layout(layout = nil)
     return false if layout == false
     
@@ -385,6 +405,8 @@ def _get_layout(layout = nil)
   # ==== Returns
   # Array[Symbol, String]::
   #   A pair consisting of the template method and location.
+  #
+  # @api private
   def _template_for(context, content_type, controller=nil, template=nil, locals=[])
     template_method, template_location = nil, nil
 
@@ -419,6 +441,8 @@ def _template_for(context, content_type, controller=nil, template=nil, locals=[]
   #
   # ==== Returns
   # String:: The method, if it exists. Otherwise return nil.
+  #
+  # @api private
   def _template_method_for(template_location, locals)
     meth = Merb::Template.template_for(template_location, [], locals)
     meth && self.respond_to?(meth) ? meth : nil
@@ -431,8 +455,8 @@ def _template_method_for(template_location, locals)
   #
   # ==== Parameters
   # objObject:: The key in the thrown_content hash. Defaults to :for_layout.
-  #---
-  # @public
+  #
+  # @api public
   def catch_content(obj = :for_layout)
     @_caught_content[obj] || ''
   end
@@ -441,8 +465,8 @@ def catch_content(obj = :for_layout)
   #
   # ==== Parameters
   # objObject:: The key in the thrown_content hash. Defaults to :for_layout.
-  #---
-  # @public
+  #
+  # @api public
   def thrown_content?(obj = :for_layout)
     @_caught_content.key?(obj)
   end
@@ -463,8 +487,8 @@ def thrown_content?(obj = :for_layout)
   # ==== Example
   #   throw_content(:foo, "Foo")
   #   catch_content(:foo) #= "Foo"
-  #---
-  # @public
+  #
+  # @api public
   def throw_content(obj, string = nil, &block)
     unless string || block_given?
       raise ArgumentError, "You must pass a block or a string into throw_content"
@@ -499,8 +523,8 @@ def append_content(obj, string = nil, &block)
   #
   # ==== Parameters
   # objObject:: The key in the thrown_content hash. Defaults to :for_layout.
-  #---
-  # @public
+  #
+  # @api public
   def clear_content(obj = :for_layout)
     @_caught_content.delete(obj) unless @_caught_content[obj].nil?
   end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/controller/template.rb</file_name>
					<diff>@@ -86,7 +86,8 @@ def needs_compilation?(path, locals)
       return true if Merb::Config[:reload_templates] || !METHOD_LIST[path]
       
       current_locals = SUPPORTED_LOCALS_LIST[path]
-      locals.any?{|local| !current_locals.include?(local)}
+      current_locals != locals &&
+        !(locals - current_locals).empty?
     end
     
     # Get all known template extensions</diff>
				</file>
				<file>
					<file_name>lib/merb-core/core_ext/hash.rb</file_name>
					<diff>@@ -1,4 +1,13 @@
 class Hash
+  # Returns the value of self for each argument and deletes those entries.
+  #
+  # ==== Parameters
+  # *args:: the keys whose values should be extracted and deleted.
+  #
+  # ==== Returns
+  # Array[Object]:: The values of the provided arguments in corresponding order.
+  #
+  # @api public
   def extract!(*args)
     args.map do |arg|
       self.delete(arg)</diff>
				</file>
				<file>
					<file_name>lib/merb-core/core_ext/kernel.rb</file_name>
					<diff>@@ -39,13 +39,17 @@ def track_dependency(name, *ver, &blk)
   # If that has already happened, the gem will be activated
   # immediately, but it will still be registered.
   # 
-  # @param nameString The name of the gem to load.
-  # @param *verGem::Requirement, Gem::Version, Array, #to_str
+  # ==== Parameters
+  # nameString The name of the gem to load.
+  # *verGem::Requirement, Gem::Version, Array, #to_str
   #   Version requirements to be passed to Gem::Dependency.new.
   #   If the last argument is a Hash, extract the :immediate option,
   #   forcing a dependency to load immediately.
   #
-  # @return Gem::Dependency The dependency information.
+  # ==== Returns
+  # Gem::Dependency:: The dependency information.
+  #
+  # @api public
   def dependency(name, *ver, &blk)
     immediate = ver.last.is_a?(Hash) && ver.pop[:immediate]
     if immediate || Merb::BootLoader.finished?(Merb::BootLoader::Dependencies)
@@ -71,6 +75,8 @@ def dependency(name, *ver, &blk)
   #   as a library.
   #
   # @return Gem::Dependency The dependency information.
+  #
+  # @api private
   def load_dependency(name, *ver, &blk)
     dep = name.is_a?(Gem::Dependency) ? name : track_dependency(name, *ver)
     gem(dep)
@@ -93,7 +99,14 @@ def load_dependency(name, *ver, &blk)
   # Loads both gem and library dependencies that are passed in as arguments.
   # Execution is deferred to the Merb::BootLoader::Dependencies.run during bootup.
   #
-  # @param *argsString, Hash, Array The dependencies to load.
+  # ==== Parameters
+  # *argsString, Hash, Array The dependencies to load.
+  #
+  # ==== Returns
+  # Array[(Gem::Dependency, Array[Gem::Dependency])]:: Gem::Dependencies for the
+  #   dependencies specified in args.
+  #
+  # @api public
   def dependencies(*args)
     args.map do |arg|
       case arg
@@ -118,6 +131,8 @@ def dependencies(*args)
   # @example dependencies "RedCloth"                 # Loads the the RedCloth gem
   # @example dependencies "RedCloth", "merb_helpers" # Loads RedCloth and merb_helpers
   # @example dependencies "RedCloth" = "3.0"        # Loads RedCloth 3.0
+  #
+  # @api private
   def load_dependencies(*args)
     args.map do |arg|
       case arg
@@ -132,7 +147,12 @@ def load_dependencies(*args)
   #
   # @param libraryto_s The library to attempt to include.
   # @param messageString The error to add to the log upon failure. Defaults to nil.
+  #
+  # @api private
+  # @deprecated
   def rescue_require(library, message = nil)
+    Merb.logger.warn("Deprecation warning: rescue_require is deprecated")
+    sleep 2.0
     require library
   rescue LoadError, RuntimeError
     Merb.logger.error!(message) if message
@@ -142,17 +162,22 @@ def rescue_require(library, message = nil)
   # Mapper) you wish to use. Currently Merb has plugins to support
   # ActiveRecord, DataMapper, and Sequel.
   #
-  # @param ormSymbol The ORM to use.
+  # ==== Parameters
+  # ormSymbol:: The ORM to use.
   #
-  # @example
+  # ==== Returns
+  # nil
+  #
+  # ==== Example
   #   use_orm :datamapper
   #
   #   # This will use the DataMapper generator for your ORM
   #   $ merb-gen model ActivityEvent
   #
-  # @note
+  # ==== Notes
   #   If for some reason this is called more than once, latter
   #   call takes over other.
+  #
   # @api public
   def use_orm(orm)
     begin
@@ -163,24 +188,31 @@ def use_orm(orm)
       Merb.logger.warn!("The #{orm_plugin} gem was not found.  You may need to install it.")
       raise e
     end
+    nil
   end
 
   # Used in Merb.root/config/init.rb to tell Merb which testing framework to
   # use. Currently Merb has plugins to support RSpec and Test::Unit.
   #
-  # @param test_frameworkSymbol
+  # ==== Parameters
+  # test_frameworkSymbol::
   #   The test framework to use. Currently only supports :rspec and :test_unit.
   #
-  # @example
+  # ==== Returns
+  # nil
+  #
+  # ==== Example
   #   use_test :rspec
   #
   #   # This will now use the RSpec generator for tests
   #   $ merb-gen model ActivityEvent
+  #
   # @api public
   def use_testing_framework(test_framework, *test_dependencies)
     Merb.test_framework = test_framework
     
     Kernel.dependencies test_dependencies if Merb.env == "test" || Merb.env.nil?
+    nil
   end
 
   def use_test(*args)
@@ -190,14 +222,19 @@ def use_test(*args)
   # Used in Merb.root/config/init.rb to tell Merb which template engine to
   # prefer.
   #
-  # @param template_engineSymbol
+  # ==== Parameters
+  # template_engineSymbol
   #   The template engine to use.
   #
-  # @example
+  # ==== Returns
+  # nil
+  #
+  # ==== Example
   #   use_template_engine :haml
   #
   #   # This will now use haml templates in generators where available.
   #   $ merb-gen resource_controller Project 
+  #
   # @api public
   def use_template_engine(template_engine)
     Merb.template_engine = template_engine
@@ -210,11 +247,14 @@ def use_template_engine(template_engine)
       end
       Kernel.dependency(template_engine_plugin)
     end
+    
+    nil
   rescue LoadError = e
     Merb.logger.warn!("The #{template_engine_plugin} gem was not found.  You may need to install it.")
     raise e
   end
 
+
   # @param iFixnum The caller number. Defaults to 1.
   #
   # @return Array[Array] The file, line and method of the caller.
@@ -222,6 +262,8 @@ def use_template_engine(template_engine)
   # @example
   #   __caller_info__(1)
   #     # = ['/usr/lib/ruby/1.8/irb/workspace.rb', '52', 'irb_binding']
+  #
+  # @api private
   def __caller_info__(i = 1)
     file, line, meth = caller[i].scan(/(.*?):(\d+):in `(.*?)'/).first
   end
@@ -245,6 +287,8 @@ def __caller_info__(i = 1)
   #       [ 123, "      DEBUGGER__.waiting.push Thread.current",      false ],
   #       [ 124, "      @suspend_next = false",                       false ]
   #     ]
+  #
+  # @api private
   def __caller_lines__(file, line, size = 4)
     line = line.to_i
     if file =~ /\(erubis\)/
@@ -262,26 +306,6 @@ def __caller_lines__(file, line, size = 4)
         yield index + line - size, str.chomp
       end
     end
-    # 
-    # lines = File.readlines(file)
-    # current = line.to_i - 1
-    # 
-    # first = current - size
-    # first = first  0 ? 0 : first
-    # 
-    # last = current + size
-    # last = last  lines.size ? lines.size : last
-    # 
-    # log = lines[first..last]
-    # 
-    # area = []
-    # 
-    # log.each_with_index do |line, index|
-    #   index = index + first + 1
-    #   area  [index, line.chomp, index == current + 1]
-    # end
-    # 
-    # area
   end
 
   # Takes a block, profiles the results of running the block
@@ -309,6 +333,8 @@ def __caller_lines__(file, line, size = 4)
   #   Assuming that the total time taken for #puts calls was less than 5% of the
   #   total time to run, #puts won't appear in the profile report.
   #   The code block will be run 30 times in the example above.
+  #
+  # @api private
   def __profile__(name, min=1, iter=100)
     require 'ruby-prof' unless defined?(RubyProf)
     return_result = ''
@@ -334,6 +360,8 @@ def __profile__(name, min=1, iter=100)
   #     opts = extract_options_from_args!(args) || {}
   #     # [...]
   #   end
+  #
+  # @api public
   def extract_options_from_args!(args)
     args.pop if Hash === args.last
   end
@@ -346,6 +374,8 @@ def extract_options_from_args!(args)
   #
   # @raise ArgumentError
   #   An object failed to quack like a condition.
+  #
+  # @api public
   def enforce!(opts = {})
     opts.each do |k,v|
       raise ArgumentError, "#{k.inspect} doesn't quack like #{v.inspect}" unless k.quacks_like?(v)</diff>
				</file>
				<file>
					<file_name>lib/merb-core/dispatch/dispatcher.rb</file_name>
					<diff>@@ -4,15 +4,19 @@ module Merb
   class Dispatcher
     class  self
       include Merb::ControllerExceptions
-    
+      
       attr_accessor :use_mutex
       
       @@work_queue = Queue.new
-    
+      
+      # ==== Returns
+      # Queue:: the current queue of dispatch jobs.
+      # 
+      # @api private
       def work_queue 
         @@work_queue
       end  
-    
+      
       Merb::Dispatcher.use_mutex = ::Merb::Config[:use_mutex]
       
       # Dispatch the rack environment. ControllerExceptions are rescued here
@@ -25,9 +29,11 @@ def work_queue
       # ==== Returns
       # Merb::Controller::
       #   The Merb::Controller that was dispatched to
+      # 
+      # @api private
       def handle(request)
         request.handle
-      end      
+      end
     end
   end
   
@@ -36,10 +42,16 @@ class Request
     
     @@mutex = Mutex.new
     
+    # Handles request routing and action dispatch.
+    # 
+    # ==== Returns
+    # Merb::Controller:: the controller that handled the action dispatch.
+    # 
+    # @api private
     def handle
       start = Time.now
       Merb.logger.info "Started request handling: #{start.to_s}"
-  
+      
       find_route!
       return rack_response if handled?
       
@@ -57,7 +69,7 @@ def handle
       if klass.abstract?
         raise NotFound, "The '#{klass}' controller has no public actions"
       end
-    
+      
       controller = dispatch_action(klass, params[:action])
       controller._benchmarks[:dispatch_time] = Time.now - start
       Merb.logger.info controller._benchmarks.inspect
@@ -73,13 +85,13 @@ def handle
     # ==== Parameters
     # klassMerb::Controller:: The controller class to dispatch to.
     # actionSymbol:: The action to dispatch.
-    # requestMerb::Request::
-    #   The Merb::Request object that was created in #handle
     # statusInteger:: The status code to respond with.
     #
     # ==== Returns
     # Merb::Controller::
     #   The Merb::Controller that was dispatched to.
+    # 
+    # @api private
     def dispatch_action(klass, action, status=200)
       # build controller
       controller = klass.new(self, status)
@@ -101,8 +113,6 @@ def dispatch_action(klass, action, status=200)
     # StandardError is caught in standard_error).
     #
     # ==== Parameters
-    # requestMerb::Request:: 
-    #   The request object associated with the failed request.
     # exceptionObject::
     #   The exception object that was created when trying to dispatch the
     #   original controller.
@@ -110,6 +120,8 @@ def dispatch_action(klass, action, status=200)
     # ==== Returns
     # Exceptions::
     #   The Merb::Controller that was dispatched to. 
+    # 
+    # @api private
     def dispatch_exception(exception)
       if(exception.is_a?(Merb::ControllerExceptions::Base) &&
          !exception.is_a?(Merb::ControllerExceptions::ServerError))
@@ -117,12 +129,12 @@ def dispatch_exception(exception)
       else
         Merb.logger.error(Merb.exception(exception))
       end
-
+      
       self.exceptions = [exception]
-
+      
       begin
         e = exceptions.first
-
+        
         if action_name = e.action_name
           dispatch_action(Exceptions, action_name, e.class.status)
         else
@@ -134,7 +146,7 @@ def dispatch_exception(exception)
         else
           Merb.logger.error("Dispatching #{e.class} raised another error.")
           Merb.logger.error(Merb.exception(dispatch_issue))
-
+          
           exceptions.unshift dispatch_issue
           retry
         end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/dispatch/request.rb</file_name>
					<diff>@@ -25,16 +25,26 @@ class Request
     self.http_method_overrides = []
     
     # Initialize the request object.
-    #
+    # 
     # ==== Parameters
     # http_request~params:~[], ~body:IO:: 
     #   An object like an HTTP Request.
+    # 
+    # @api private
     def initialize(rack_env)
       @env  = rack_env
       @body = rack_env['rack.input']
       @route_params = {}
     end
     
+    # Returns the controller object for initialization and dispatching the
+    # request.
+    # 
+    # ==== Returns
+    # Class:: The controller class matching the routed request,
+    #   e.g. Posts.
+    # 
+    # @api private
     def controller
       unless params[:controller]
         raise ControllerExceptions::NotFound, 
@@ -58,13 +68,15 @@ def controller
     METHODS = %w{get post put delete head options}
 
     # ==== Returns
-    # Symbol:: The name of the request method, e.g. :get.
+    # Symbol:: The name of the request method, e.g. :get.
     #
     # ==== Notes
     # If the method is post, then the blocks specified in
     # http_method_overrides will be checked for the masquerading method.
     # The block will get the controller yielded to it.  The first matching workaround wins.
     # To disable this behavior, set http_method_overrides = []
+    # 
+    # @api public
     def method
       @method ||= begin
         request_method = @env['REQUEST_METHOD'].downcase.to_sym
@@ -89,20 +101,24 @@ def method
     METHODS.each do |m|
       class_eval "def #{m}?() method == :#{m} end"
     end
-
+    
+    # ==== Notes
     # Find route using requested URI and merges route
     # parameters (:action, :controller and named segments)
     # into request params hash.
+    # 
+    # @api private
     def find_route!
       @route, @route_params = Merb::Router.route_for(self)
       params.merge! @route_params if @route_params.is_a?(Hash)
     end
     
+    # ==== Notes
     # Processes the return value of a deferred router block
     # and returns the current route params for the current
     # request evaluation
-    # ---
-    # @private
+    # 
+    # @api private
     def _process_block_return(retval)
       # If the return value is an array, then it is a redirect
       # so we must set the request as a redirect and extract
@@ -114,33 +130,54 @@ def _process_block_return(retval)
     
     # Sets the request as matched. This will abort evaluating any
     # further deferred procs.
-    # ---
-    # @private
+    # 
+    # @api private
     def matched!
       @matched = true
     end
     
     # Checks whether or not the request has been matched to a route.
-    # ---
-    # @private
+    # 
+    # @api private
     def matched?
       @matched
     end
     
+    # ==== Returns
+    # (Array, Hash):: the route params for the matched route.
+    # 
+    # ==== Notes
+    # If the response is an Array then it is considered a direct Rack response
+    # to be sent back as a response. Otherwise, the route_params is a Hash with
+    # routing data (controller, action, et al).
+    # 
+    # @api private
     def rack_response
       @route_params
     end
     
     # If @route_params is an Array, then it will be the rack response.
-    # In this case, the request has been handled.
+    # In this case, the request is considered handled.
+    # 
+    # ==== Returns
+    # Boolean:: true if @route_params is an Array, false otherwise.
+    # 
+    # @api private
     def handled?
       @route_params.is_a?(Array)
     end
     
+    # == Params
+    # 
+    # Handles processing params from raw data and merging them together to get
+    # the final request params.
+    
     private
     
     # ==== Returns
     # Hash:: Parameters passed from the URL like ?blah=hello.
+    # 
+    # @api private
     def query_params
       @query_params ||= self.class.query_parse(query_string || '')
     end
@@ -150,6 +187,8 @@ def query_params
     #
     # ==== Returns
     # Hash:: The parameters passed in the body.
+    # 
+    # @api private
     def body_params
       @body_params ||= begin
         if content_type && content_type.match(Merb::Const::FORM_URL_ENCODED_REGEXP) # or content_type.nil?
@@ -157,11 +196,13 @@ def body_params
         end
       end
     end
-
+    
     # ==== Returns
     # Mash::
     #   The parameters gathered from the query string and the request body,
     #   with parameters in the body taking precedence.
+    # 
+    # @api private
     def body_and_query_params
       # ^-- FIXME a better name for this method
       @body_and_query_params ||= begin
@@ -170,13 +211,15 @@ def body_and_query_params
         h.to_mash
       end
     end
-
+    
     # ==== Raises
     # ControllerExceptions::MultiPartParseError::
     #   Unable to parse the multipart form data.
     #
     # ==== Returns
     # Hash:: The parsed multipart parameters.
+    # 
+    # @api private
     def multipart_params
       @multipart_params ||= 
         begin
@@ -192,7 +235,7 @@ def multipart_params
           raise e
         end
     end
-
+    
     # ==== Returns
     # Hash:: Parameters from body if this is a JSON request.
     #
@@ -201,6 +244,8 @@ def multipart_params
     # parameters hash.  If it parses to anything else (such as an Array, or
     # if it inflates to an Object) it will be accessible via the inflated_object
     # parameter.
+    # 
+    # @api private
     def json_params
       @json_params ||= begin
         if Merb::Const::JSON_MIME_TYPE_REGEXP.match(content_type)
@@ -209,9 +254,11 @@ def json_params
         end
       end
     end
-
+    
     # ==== Returns
     # Hash:: Parameters from body if this is an XML request.
+    # 
+    # @api private
     def xml_params
       @xml_params ||= begin
         if Merb::Const::XML_MIME_TYPE_REGEXP.match(content_type)
@@ -228,6 +275,8 @@ def xml_params
     # ==== Notes
     # The order of precedence for the params is XML, JSON, multipart, body and
     # request string.
+    # 
+    # @api public
     def params
       @params ||= begin
         h = body_and_query_params.merge(route_params)      
@@ -238,6 +287,10 @@ def params
       end
     end
     
+    # ==== Returns
+    # String:: Returns the redirect message Base64 unencoded.
+    # 
+    # @api public
     def message
       return {} unless params[:_message]
       begin
@@ -246,14 +299,19 @@ def message
         {}
       end
     end
-
+    
+    # ==== Notes
     # Resets the params to a nil value.
+    # 
+    # @api private
     def reset_params!
       @params = nil
     end
     
     # ==== Returns
     # String:: The raw post.
+    # 
+    # @api private
     def raw_post
       @body.rewind if @body.respond_to?(:rewind)
       @raw_post ||= @body.read
@@ -261,6 +319,8 @@ def raw_post
     
     # ==== Returns
     # Boolean:: If the request is an XML HTTP request.
+    # 
+    # @api public
     def xml_http_request?
       not /XMLHttpRequest/i.match(@env['HTTP_X_REQUESTED_WITH']).nil?
     end
@@ -269,17 +329,19 @@ def xml_http_request?
     
     # ==== Returns
     # String:: The remote IP address.
+    # 
+    # @api public
     def remote_ip
       return @env['HTTP_CLIENT_IP'] if @env.include?('HTTP_CLIENT_IP')
-    
+      
       if @env.include?(Merb::Const::HTTP_X_FORWARDED_FOR) then
         remote_ips = @env[Merb::Const::HTTP_X_FORWARDED_FOR].split(',').reject do |ip|
           ip =~ /^unknown$|^(127|10|172\.16|192\.168)\./i
         end
-    
+        
         return remote_ips.first.strip unless remote_ips.empty?
       end
-    
+      
       return @env[Merb::Const::REMOTE_ADDR]
     end
     
@@ -287,126 +349,168 @@ def remote_ip
     # String::
     #   The protocol, i.e. either "https" or "http" depending on the
     #   HTTPS header.
+    # 
+    # @api public
     def protocol
       ssl? ? 'https' : 'http'
     end
     
     # ==== Returns
     # Boolean::: True if the request is an SSL request.
+    # 
+    # @api public
     def ssl?
       @env['HTTPS'] == 'on' || @env['HTTP_X_FORWARDED_PROTO'] == 'https'
     end
     
     # ==== Returns
     # String:: The HTTP referer.
+    # 
+    # @api public
     def referer
       @env['HTTP_REFERER']
     end
     
     # ==== Returns
     # String:: The full URI, including protocol and host
+    # 
+    # @api public
     def full_uri
       protocol + "://" + host + uri
     end
     
     # ==== Returns
     # String:: The request URI.
+    # 
+    # @api public
     def uri
       @env['REQUEST_PATH'] || @env['REQUEST_URI'] || path_info
     end
-
+    
     # ==== Returns
     # String:: The HTTP user agent.
+    # 
+    # @api public
     def user_agent
       @env['HTTP_USER_AGENT']
     end
-
+    
     # ==== Returns
     # String:: The server name.
+    # 
+    # @api public
     def server_name
       @env['SERVER_NAME']
     end
-
+    
     # ==== Returns
     # String:: The accepted encodings.
+    # 
+    # @api private
     def accept_encoding
       @env['HTTP_ACCEPT_ENCODING']
     end
-
+    
     # ==== Returns
     # String:: The script name.
+    # 
+    # @api public
     def script_name
       @env['SCRIPT_NAME']
     end
-
+    
     # ==== Returns
     # String:: HTTP cache control.
+    # 
+    # @api public
     def cache_control
       @env['HTTP_CACHE_CONTROL']
     end
-
+    
     # ==== Returns
     # String:: The accepted language.
+    # 
+    # @api public
     def accept_language
       @env['HTTP_ACCEPT_LANGUAGE']
     end
-
+    
     # ==== Returns
     # String:: The server software.
+    # 
+    # @api public
     def server_software
       @env['SERVER_SOFTWARE']
     end
-
+    
     # ==== Returns
     # String:: Value of HTTP_KEEP_ALIVE.
+    # 
+    # @api public
     def keep_alive
       @env['HTTP_KEEP_ALIVE']
     end
-
+    
     # ==== Returns
     # String:: The accepted character sets.
+    # 
+    # @api public
     def accept_charset
       @env['HTTP_ACCEPT_CHARSET']
     end
-
+    
     # ==== Returns
     # String:: The HTTP version
+    # 
+    # @api private
     def version
       @env['HTTP_VERSION']
     end
-
+    
     # ==== Returns
     # String:: The gateway.
+    # 
+    # @api public
     def gateway
       @env['GATEWAY_INTERFACE']
     end
-
+    
     # ==== Returns
     # String:: The accepted response types. Defaults to "*/*".
+    # 
+    # @api private
     def accept
       @env['HTTP_ACCEPT'].blank? ? "*/*" : @env['HTTP_ACCEPT']
     end
-
+    
     # ==== Returns
     # String:: The HTTP connection.
+    # 
+    # @api private
     def connection
       @env['HTTP_CONNECTION']
     end
-
+    
     # ==== Returns
     # String:: The query string.
+    # 
+    # @api private
     def query_string
       @env['QUERY_STRING']  
     end
-
+    
     # ==== Returns
     # String:: The request content type.
+    # 
+    # @api private
     def content_type
       @env['CONTENT_TYPE']
     end
-
+    
     # ==== Returns
     # Fixnum:: The request content length.
+    # 
+    # @api public
     def content_length
       @content_length ||= @env[Merb::Const::CONTENT_LENGTH].to_i
     end
@@ -415,6 +519,8 @@ def content_length
     # String::
     #   The URI without the query string. Strips trailing "/" and reduces
     #   duplicate "/" to a single "/".
+    # 
+    # @api public
     def path
       path = (uri.empty? ? '/' : uri.split('?').first).squeeze("/")
       path = path[0..-2] if (path[-1] == ?/) && path.size  1
@@ -423,18 +529,24 @@ def path
     
     # ==== Returns
     # String:: The path info.
+    # 
+    # @api public
     def path_info
       @path_info ||= self.class.unescape(@env['PATH_INFO'])
     end
     
     # ==== Returns
     # Fixnum:: The server port.
+    # 
+    # @api public
     def port
       @env['SERVER_PORT'].to_i
     end
     
     # ==== Returns
     # String:: The full hostname including the port.
+    # 
+    # @api public
     def host
       @env['HTTP_X_FORWARDED_HOST'] || @env['HTTP_HOST'] 
     end
@@ -446,6 +558,8 @@ def host
     #
     # ==== Returns
     # Array:: All the subdomain parts of the host.
+    # 
+    # @api public
     def subdomains(tld_length = 1)
       parts = host.split('.')
       parts[0..-(tld_length+2)]
@@ -458,18 +572,24 @@ def subdomains(tld_length = 1)
     #
     # ==== Returns
     # String:: The full domain name without the port number.
+    # 
+    # @api public
     def domain(tld_length = 1)
       host.split('.').last(1 + tld_length).join('.').sub(/:\d+$/,'')
     end
-
+    
     # ==== Returns
     # Value of If-None-Match request header.
+    # 
+    # @api private
     def if_none_match
       @env[Merb::Const::HTTP_IF_NONE_MATCH]
     end
-
+    
     # ==== Returns
     # Value of If-Modified-Since request header.
+    # 
+    # @api private
     def if_modified_since
       if time = @env[Merb::Const::HTTP_IF_MODIFIED_SINCE]
         Time.rfc2822(time)
@@ -497,6 +617,8 @@ class  self
       #     # = "search[page]=10&search[word]=ruby"
       #   params_to_query_string([ "ice-cream", "cake" ], "shopping_list")
       #     # = "shopping_list[]=ice-cream&shopping_list[]=cake"
+      # 
+      # @api private
       def params_to_query_string(value, prefix = nil)
         case value
         when Array
@@ -517,17 +639,21 @@ def params_to_query_string(value, prefix = nil)
       #
       # ==== returns
       # String:: The escaped string.
+      # 
+      # @api private
       def escape(s)
         s.to_s.gsub(/([^ a-zA-Z0-9_.-]+)/n) {
           '%'+$1.unpack('H2'*$1.size).join('%').upcase
         }.tr(' ', '+')
       end
-
+      
       # ==== Parameter
       # sString:: String to URL unescape.
       #
       # ==== returns
       # String:: The unescaped string.
+      # 
+      # @api private
       def unescape(s)
         s.tr('+', ' ').gsub(/((?:%[0-9a-fA-F]{2})+)/n){
           [$1.delete('%')].pack('H*')
@@ -545,6 +671,8 @@ def unescape(s)
       # ==== Examples
       #   query_parse("bar=nik&post[body]=heya")
       #     # = { :bar = "nik", :post = { :body = "heya" } }
+      # 
+      # @api private
       def query_parse(query_string, delimiter = '&;', preserve_order = false)
         query = preserve_order ? Dictionary.new : {}
         for pair in (query_string || '').split(/[#{delimiter}] */n)
@@ -558,13 +686,13 @@ def query_parse(query_string, delimiter = '&;', preserve_order = false)
         end
         preserve_order ? query : query.to_mash
       end
-    
+      
       NAME_REGEX = /Content-Disposition:.* name="?([^\";]*)"?/ni.freeze
       CONTENT_TYPE_REGEX = /Content-Type: (.*)\r\n/ni.freeze
       FILENAME_REGEX = /Content-Disposition:.* filename="?([^\";]*)"?/ni.freeze
       CRLF = "\r\n".freeze
       EOL = CRLF
-
+      
       # ==== Parameters
       # requestIO:: The raw request.
       # boundaryString:: The boundary string.
@@ -575,6 +703,8 @@ def query_parse(query_string, delimiter = '&;', preserve_order = false)
       #
       # ==== Returns
       # Hash:: The parsed request.
+      # 
+      # @api private
       def parse_multipart(request, boundary, content_length)
         boundary = "--#{boundary}"
         paramhsh = {}
@@ -605,19 +735,19 @@ def parse_multipart(request, boundary, content_length)
               filename = head[FILENAME_REGEX, 1]
               content_type = head[CONTENT_TYPE_REGEX, 1]
               name = head[NAME_REGEX, 1]
-            
+              
               if filename && !filename.empty?
                 body = Tempfile.new(:Merb)
                 body.binmode if defined? body.binmode
               end
               next
             end
-          
+            
             # Save the read body part.
             if head && (boundary_size+4  buf.size)
               body  buf.slice!(0, buf.size - (boundary_size+4))
             end
-          
+            
             read_size = bufsize  content_length ? bufsize : content_length
             if( read_size  0 )
               c = input.read(read_size)
@@ -626,15 +756,15 @@ def parse_multipart(request, boundary, content_length)
               content_length -= c.size
             end
           end
-        
+          
           # Save the rest.
           if i = buf.index(rx)
             body  buf.slice!(0, i)
             buf.slice!(0, boundary_size+2)
-          
+            
             content_length = -1  if $1 == "--"
           end
-        
+          
           if filename && !filename.empty?   
             body.rewind
             data = { 
@@ -651,7 +781,7 @@ def parse_multipart(request, boundary, content_length)
         }
         paramhsh
       end
-
+      
       # Converts a query string snippet to a hash and adds it to existing
       # parameters.
       #
@@ -662,6 +792,8 @@ def parse_multipart(request, boundary, content_length)
       #
       # ==== Returns
       # Hash:: Normalized parameters
+      # 
+      # @api private
       def normalize_params(parms, name, val=nil)
         name =~ %r([\[\]]*([^\[\]]+)\]*)
         key = $1 || ''
@@ -687,4 +819,4 @@ def normalize_params(parms, name, val=nil)
       end
     end
   end
-end    
+end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/dispatch/router.rb</file_name>
					<diff>@@ -6,19 +6,19 @@
 module Merb
   # Router stores route definitions and finds the first
   # route that matches the incoming request URL.
-  #
+  # 
   # Then information from route is used by dispatcher to
   # call action on the controller.
-  #
+  # 
   # ==== Routes compilation.
-  #
+  # 
   # The most interesting method of Router (and heart of
   # route matching machinery) is match method generated
   # on the fly from routes definitions. It is called routes
   # compilation. Generated match method body contains
   # one if/elsif statement that picks the first matching route
   # definition and sets values to named parameters of the route.
-  #
+  # 
   # Compilation is synchronized by mutex.
   class Router
     @routes          = []
@@ -26,14 +26,14 @@ class Router
     @resource_routes = {}
     @compiler_mutex  = Mutex.new
     @root_behavior   = Behavior.new.defaults(:action = "index")
-
+    
     # Raised when route lookup fails.
     class RouteNotFound  StandardError; end;
     # Raised when parameters given to generation
     # method do not match route parameters.
     class GenerationError  StandardError; end;
     class NotCompiledError  StandardError; end;
-
+    
     class  self
       # @private
       attr_accessor :routes, :named_routes, :resource_routes, :root_behavior
@@ -41,19 +41,20 @@ class  self
       # Creates a route building context and evaluates the block in it. A
       # copy of +root_behavior+ (and instance of Behavior) is copied as
       # the context.
-      #
+      # 
       # ==== Parameters
       # firstArray::
       #   An array containing routes that should be prepended to the routes
       #   defined in the block.
-      #
       # lastArray::
       #   An array containing routes that should be appended to the routes
       #   defined in the block.
-      #
+      # 
       # ==== Returns
       # Merb::Router::
       #   Returns self to allow chaining of methods.
+      # 
+      # @api public
       def prepare(first = [], last = [], &block)
         @routes = []
         root_behavior._with_proxy(&block)
@@ -63,17 +64,23 @@ def prepare(first = [], last = [], &block)
       end
       
       # Appends route in the block to routing table.
+      # 
+      # @api public
       def append(&block)
         prepare(routes, [], &block)
       end
-
+      
       # Prepends routes in the block to routing table.
+      # 
+      # @api public
       def prepend(&block)
         prepare([], routes, &block)
       end
       
       # Clears the routing table. Route generation and request matching
       # won't work anymore until a new routing table is built.
+      # 
+      # @api private
       def reset!
         class  self
           alias_method :match, :match_before_compilation
@@ -84,18 +91,16 @@ class  self
       # Finds route matching URI of the request and returns a tuple of
       # [route index, route params]. This method is called by the
       # dispatcher and isn't as useful in applications.
-      #
+      # 
       # ==== Parameters
       # requestMerb::Request:: request to match.
-      #
+      # 
       # ==== Returns
-      # Array(Integer, Hash)::
-      #   Two-tuple: route index and route parameters. Route
-      #   parameters are :controller, :action and all the named
-      #   segments of the route.
-      #
-      # ---
-      # @private
+      # Array[Integer, Hash]::
+      #   Two-tuple: route index and route parameters. Route parameters
+      #   are :controller, :action and all the named segments of the route.
+      # 
+      # @api private
       def route_for(request) #:nodoc:
         index, params = match(request)
         route = routes[index] if index
@@ -105,43 +110,85 @@ def route_for(request) #:nodoc:
         end
         [route, params]
       end
-
-      # Just a placeholder for the compiled match method
+      
+      # A placeholder for the compiled match method.
+      # 
+      # ==== Notes
+      # This method is aliased as +match+ but this method gets overridden with
+      # the actual +match+ method (generated from the routes definitions) after
+      # being compiled. This method is only ever called before routes are
+      # compiled.
+      # 
+      # ==== Raises
+      # NotCompiledError:: routes have not been compiled yet.
+      # 
+      # @api private
       def match_before_compilation(request) #:nodoc:
         raise NotCompiledError, "The routes have not been compiled yet"
       end
-
+      
       alias_method :match, :match_before_compilation
       
-      # Generates a URL from the params
+      # There are three possible ways to use this method.  First, if you have a named route, 
+      # you can specify the route as the first parameter as a symbol and any paramters in a 
+      # hash.  Second, you can generate the default route by just passing the params hash, 
+      # just passing the params hash.  Finally, you can use the anonymous parameters.  This 
+      # allows you to specify the parameters to a named route in the order they appear in the 
+      # router.  
       #
-      # ==== Parameters
-      # nameSymbol::
-      #   The name of the route to generate
+      # ==== Parameters(Named Route)
+      # nameSymbol:: 
+      #   The name of the route. 
+      # argsHash:: 
+      #   Parameters for the route generation.
       #
-      # anonymous_paramsObject::
+      # ==== Parameters(Default Route)
+      # argsHash:: 
+      #   Parameters for the route generation.  This route will use the default route. 
+      #
+      # ==== Parameters(Anonymous Parameters)
+      # nameSymbol::
+      #   The name of the route.  
+      # argsArray:: 
       #   An array of anonymous parameters to generate the route
       #   with. These parameters are assigned to the route parameters
       #   in the order that they are passed.
       #
-      # paramsHash::
-      #   Named parameters to generate the route with.
-      #
-      # defaultsHash::
-      #   A hash of default parameters to generate the route with.
-      #   This is usually the request parameters. If there are any
-      #   required params that are missing to generate the route,
-      #   they are pulled from this hash.
       # ==== Returns
-      # String:: The generated URL
-      # ---
-      # @private
+      # String:: The generated URL.
+      #
+      # ==== Examples
+      # Named Route
+      #
+      # Merb::Router.prepare do
+      #   match("/articles/:title").to(:controller = :articles, :action = :show).name("articles")
+      # end
+      #
+      # url(:articles, :title = "new_article")
+      #
+      # Default Route
+      #
+      # Merb::Router.prepare do
+      #   default_routes
+      # end
+      #
+      # url(:controller = "articles", :action = "new")
+      #
+      # Anonymous Paramters
+      #
+      # Merb::Router.prepare do
+      #   match("/articles/:year/:month/:title").to(:controller = :articles, :action = :show).name("articles")
+      # end
+      #
+      # url(:articles, 2008, 10, "test_article")
+      #
+      # @api private
       def url(name, *args)
         unless name.is_a?(Symbol)
           args.unshift(name)
           name = :default
         end
-
+        
         unless route = Merb::Router.named_routes[name]
           raise Merb::Router::GenerationError, "Named route not found: #{name}"
         end
@@ -152,25 +199,25 @@ def url(name, *args)
       end
       
       # Generates a URL from the resource(s)
-      #
+      # 
       # ==== Parameters
       # resourcesSymbol,Object::
       #   The identifiers for the resource route to generate. These
       #   can either be symbols or objects. Symbols denote resource
       #   collection routes and objects denote the members.
-      #
+      # 
       # paramsHash::
       #   Any extra parameters needed to generate the route.
       # ==== Returns
       # String:: The generated URL
-      # ---
-      # @private
+      # 
+      # @api private
       def resource(*args)
         defaults = args.pop
         options  = extract_options_from_args!(args) || {}
         key      = []
         params   = []
-
+        
         args.each do |arg|
           if arg.is_a?(Symbol) || arg.is_a?(String)
             key  arg.to_s
@@ -179,19 +226,21 @@ def resource(*args)
             params  arg
           end
         end
-
+        
         params  options
-
+        
         unless route = Merb::Router.resource_routes[key]
           raise Merb::Router::GenerationError, "Resource route not found: #{args.inspect}"
         end
-
+        
         route.generate(params, defaults)
       end
-
-    private
-    
-      # Defines method with a switch statement that does routes recognition.
+      
+      private
+      
+      # Compiles the routes and creates the +match+ method.
+      # 
+      # @api private
       def compile
         if routes.any?
           eval(compiled_statement, binding, "Generated Code for Router", 1)
@@ -199,18 +248,21 @@ def compile
           reset!
         end
       end
-
-      # Generates method that does route recognition with a switch statement.
+      
+      # Generates the method for evaluation defining a +match+ method to match
+      # a request with the defined routes.
+      # 
+      # @api private
       def compiled_statement
         @compiler_mutex.synchronize do
           condition_keys, if_statements = Set.new, ""
-
+          
           routes.each_with_index do |route, i|
             route.freeze
             route.conditions.keys.each { |key| condition_keys  key }
             if_statements  route.compiled_statement(i == 0)
           end
-
+          
           statement =  "def match(request)\n"
           statement  condition_keys.inject("") do |cached, key|
             cached  "  cached_#{key} = request.#{key}.to_s\n"
@@ -222,7 +274,7 @@ def compiled_statement
           statement  "end"
         end
       end
-
+      
     end # class  self
   end
 end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/dispatch/router/behavior.rb</file_name>
					<diff>@@ -3,31 +3,51 @@ module Merb
   class Router
     
     class Behavior
-
-      class Error  StandardError; end;
+      
+      class Error  StandardError; end
       
       # Proxy catches any methods and proxies them to the current behavior.
       # This allows building routes without constantly having to catching the
       # yielded behavior object
-      # ---
-      # @private
-      class Proxy #:nodoc:
+      # 
+      # @api private
+      class Proxy
+        
         # Undefine as many methods as possible so that everything can be proxied
         # along to the behavior
         instance_methods.each { |m| undef_method m unless %w[ __id__ __send__ class kind_of? respond_to? assert_kind_of should should_not instance_variable_set instance_variable_get instance_eval].include?(m) }
         
+        # @api private
         def initialize
           @behaviors = []
         end
         
+        # Puts a behavior on the bottom of the stack.
+        # 
+        # ==== Notes
+        # The behaviors keep track of nested scopes.
+        # 
+        # @api private
         def push(behavior)
           @behaviors.push(behavior)
         end
         
+        # Removes the top-most behavior.
+        # 
+        # ==== Notes
+        # This occurs at the end of a nested scope (namespace, etc).
+        # 
+        # @api private
         def pop
           @behaviors.pop
         end
         
+        # Tests whether the top-most behavior responds to the arguments.
+        # 
+        # ==== Notes
+        # Behaviors contain the actual functionality of the proxy.
+        # 
+        # @api private
         def respond_to?(*args)
           super || @behaviors.last.respond_to?(*args)
         end
@@ -35,7 +55,7 @@ def respond_to?(*args)
         # Rake does some stuff with methods in the global namespace, so if I don't
         # explicitly define the Behavior methods to proxy here (specifically namespace)
         # Rake's methods take precedence.
-        # ---
+        # 
         # Removing the following:
         # name full_name fixatable redirect
         %w(
@@ -49,25 +69,86 @@ def #{method}(*args, &block)
           }
         end
         
-        # --- These methods are to be used in defer_to blocks
+        # == These methods are to be used in defer_to blocks
         
-        # Generates a URL from the passed arguments. This method is for use
-        # inside of defer_to 
+        # There are three possible ways to use this method.  First, if you have a named route, 
+        # you can specify the route as the first parameter as a symbol and any paramters in a 
+        # hash.  Second, you can generate the default route by just passing the params hash, 
+        # just passing the params hash.  Finally, you can use the anonymous parameters.  This 
+        # allows you to specify the parameters to a named route in the order they appear in the 
+        # router.  
+        #
+        # ==== Parameters(Named Route)
+        # nameSymbol:: 
+        #   The name of the route. 
+        # argsHash:: 
+        #   Parameters for the route generation.
+        #
+        # ==== Parameters(Default Route)
+        # argsHash:: 
+        #   Parameters for the route generation.  This route will use the default route. 
+        #
+        # ==== Parameters(Anonymous Parameters)
+        # nameSymbol::
+        #   The name of the route.  
+        # argsArray:: 
+        #   An array of anonymous parameters to generate the route
+        #   with. These parameters are assigned to the route parameters
+        #   in the order that they are passed.
+        #
+        # ==== Returns
+        # String:: The generated URL.
+        #
+        # ==== Examples
+        # Named Route
+        #
+        # Merb::Router.prepare do
+        #   match("/articles/:title").to(:controller = :articles, :action = :show).name("articles")
+        # end
+        #
+        # url(:articles, :title = "new_article")
+        #
+        # Default Route
+        #
+        # Merb::Router.prepare do
+        #   default_routes
+        # end
+        #
+        # url(:controller = "articles", :action = "new")
+        #
+        # Anonymous Paramters
+        #
+        # Merb::Router.prepare do
+        #   match("/articles/:year/:month/:title").to(:controller = :articles, :action = :show).name("articles")
+        # end
+        #
+        # url(:articles, 2008, 10, "test_article")
+        #
+        # @api public
         def url(name, *args)
           args  {}
           Merb::Router.url(name, *args)
         end
         
+        # Generates a Rack redirection response.
+        # 
+        # ==== Notes
+        # Refer to Merb::Rack::Helpers.redirect for documentation.
+        # 
+        # @api public
         def redirect(url, opts = {})
           Merb::Rack::Helpers.redirect(url, opts)
         end
         
-        def route(params)
-          params
-        end
+        private
         
-      private
-      
+        # Proxies the method calls to the behavior.
+        # 
+        # ==== Notes
+        # Please refer to:
+        # http://ruby-doc.org/core/classes/Kernel.html#M005951
+        # 
+        # @api private
         def method_missing(method, *args, &block)
           behavior = @behaviors.last
           
@@ -78,14 +159,14 @@ def method_missing(method, *args, &block)
           end
         end
       end
-
+      
       # Behavior objects are used for the Route building DSL. Each object keeps
       # track of the current definitions for the level at which it is defined.
       # Each time a method is called on a Behavior object that accepts a block,
       # a new instance of the Behavior class is created.
-      #
+      # 
       # ==== Parameters
-      #
+      # 
       # proxyProxy::
       #   This is the object initialized by Merb::Router.prepare that tracks the
       #   current Behavior object stack so that Behavior methods can be called
@@ -100,11 +181,11 @@ def method_missing(method, *args, &block)
       #   The initial route options. See #options.
       # blocksArray::
       #   The stack of deferred routing blocks for the route
-      #
+      # 
       # ==== Returns
       # Behavior:: The initialized Behavior object
-      #---
-      # @private
+      # 
+      # @api private
       def initialize(proxy = nil, conditions = {}, params = {}, defaults = {}, identifiers = {}, options = {}, blocks = []) #:nodoc:
         @proxy       = proxy
         @conditions  = conditions
@@ -113,130 +194,129 @@ def initialize(proxy = nil, conditions = {}, params = {}, defaults = {}, identif
         @identifiers = identifiers
         @options     = options
         @blocks      = blocks
-
+        
         stringify_condition_values
       end
-
+      
       # Defines the +conditions+ that are required to match a Request. Each
       # +condition+ is applied to a method of the Request object. Conditions
       # can also be applied to segments of the +path+.
-      #
+      # 
       # If #match is passed a block, it will create a new route scope with
       # the conditions passed to it and yield to the block such that all
       # routes that are defined in the block have the conditions applied
       # to them.
-      #
+      # 
       # ==== Parameters
-      #
+      # 
       # pathString, Regexp::
       #   The pattern against which Merb::Request path is matched.
-      #
+      # 
       #   When +path+ is a String, any substring that is wrapped in parenthesis
       #   is considered optional and any segment that begins with a colon, ex.:
       #   ":login", defines both a capture and a named param. Extra conditions
       #   can then be applied each named param individually.
-      #
+      # 
       #   When +path+ is a Regexp, the pattern is left untouched and the
       #   Merb::Request path is matched against it as is.
       #
       #   +path+ is optional.
-      #
+      # 
       # conditionsHash::
       #   Additional conditions that the request must meet in order to match.
       #   The keys must be the names of previously defined path segments or
       #   be methods that the Merb::Request instance will respond to.  The
       #   value is the string or regexp that matched the returned value.
       #   Conditions are inherited by child routes.
-      #
+      # 
       # &block::
       #   All routes defined in the block will be scoped to the conditions
       #   defined by the #match method.
-      #
+      # 
       # ==== Block parameters
       # rBehavior:: +optional+ - The match behavior object.
-      #
+      # 
       # ==== Returns
       # Behavior::
       #   A new instance of Behavior with the specified path and conditions.
-      #
+      # 
       # +Tip+: When nesting always make sure the most inner sub-match registers
-      # a Route and doesn't just returns new Behaviors.
-      #
+      # a Route and doesn't just return new Behaviors.
+      # 
       # ==== Examples
-      #
+      # 
       #   # registers /foo/bar to controller = "foo", :action = "bar"
       #   # and /foo/baz to controller = "foo", :action = "baz"
       #   match("/foo") do
       #     match("/bar").to(:controller = "foo", :action = "bar")
       #     match("/baz").to(:controller = "foo", :action = "caz")
       #   end
-      #
+      # 
       #   # Checks the format of the segments against the specified Regexp
       #   match("/:string/:number", :string = /[a-z]+/, :number = /\d+/).
       #     to(:controller = "string_or_numbers")
-      #
+      # 
       #   # Equivalent to the default_route
       #   match("/:controller(/:action(:id))(.:format)").register
-      #
+      # 
       #   #match only if the browser string contains MSIE or Gecko
       #   match("/foo", :user_agent = /(MSIE|Gecko)/ )
       #        .to(:controller = 'foo', :action = 'popular')
-      #
+      # 
       #   # Route GET and POST requests to different actions (see also #resources)
       #   r.match('/foo', :method = :get).to(:action = 'show')
       #   r.match('/foo', :method = :post).to(:action = 'create')
-      #
+      # 
       #   # match also takes regular expressions
-      #
+      # 
       #   r.match(%r[/account/([a-z]{4,6})]).to(:controller = "account",
       #      :action = "show", :id = "[1]")
-      #
+      # 
       #   r.match(%r{/?(en|es|fr|be|nl)?}).to(:language = "[1]") do
       #     match("/guides/:action/:id").to(:controller = "tour_guides")
       #   end
-      #---
-      # @public
+      # 
+      # @api public
       def match(path = {}, conditions = {}, &block)
         path, conditions = path[:path], path if path.is_a?(Hash)
-
-        raise Error, "The route has already been committed. Further conditions cannot be specified" if @route
         
+        raise Error, "The route has already been committed. Further conditions cannot be specified" if @route
         
         conditions.delete_if { |k, v| v.nil? }
         conditions[:path] = merge_paths(path)
-
+        
         behavior = Behavior.new(@proxy, @conditions.merge(conditions), @params, @defaults, @identifiers, @options, @blocks)
         with_behavior_context(behavior, &block)
       end
       
       # Creates a Route from one or more Behavior objects, unless a +block+ is
       # passed in.
-      #
+      # 
       # ==== Parameters
       # paramsHash:: The parameters the route maps to.
-      #
+      # 
       # &block::
       #   All routes defined in the block will be scoped to the params
       #   defined by the #to method.
-      #
+      # 
       # ==== Block parameters
       # rBehavior:: +optional+ - The to behavior object.
-      #
+      # 
       # ==== Returns
       # Route:: It registers a new route and returns it.
-      #
+      # 
       # ==== Examples
       #   match('/:controller/:id).to(:action = 'show')
-      #
+      # 
       #   to(:controller = 'simple') do
       #     match('/test').to(:action = 'index')
       #     match('/other').to(:action = 'other')
       #   end
-      #---
-      # @public
+      # 
+      # @api public
       def to(params = {}, &block)
         raise Error, "The route has already been committed. Further params cannot be specified" if @route
-
+        
         behavior = Behavior.new(@proxy, @conditions, @params.merge(params), @defaults, @identifiers, @options, @blocks)
         
         if block_given?
@@ -247,7 +327,8 @@ def to(params = {}, &block)
       end
       
       # Equivalent of #to. Allows for some nicer syntax when scoping blocks
-      # --- Ex:
+      # 
+      # ==== Examples
       # Merb::Router.prepare do
       #   with(:controller = "users") do
       #     match("/signup").to(:action = "signup")
@@ -255,32 +336,32 @@ def to(params = {}, &block)
       #     match("/logout").to(:action = "logout")
       #   end
       # end
-      alias_method :with, :to
+      alias :with :to
       
       # Equivalent of #to. Allows for nicer syntax when registering routes with no params
-      # --- Ex:
+      # 
+      # ==== Examples
       # Merb::Router.prepare do
       #   match("/:controller(/:action(/:id))(.:format)").register
       # end
-      #
-      alias_method :register, :to
+      alias :register :to
       
       # Sets default values for route parameters. If no value for the key
       # can be extracted from the request, then the value provided here
       # will be used.
-      #
+      # 
       # ==== Parameters
       # defaultsHash::
       #   The default values for named segments.
-      #
+      # 
       # &block::
       #   All routes defined in the block will be scoped to the defaults defined
       #   by the #default method.
-      #
+      # 
       # ==== Block parameters
       # rBehavior:: +optional+ - The defaults behavior object.
-      # ---
-      # @public
+      # 
+      # @api public
       def default(defaults = {}, &block)
         behavior = Behavior.new(@proxy, @conditions, @params, @defaults.merge(defaults), @identifiers, @options, @blocks)
         with_behavior_context(behavior, &block)
@@ -289,34 +370,34 @@ def default(defaults = {}, &block)
       alias_method :defaults, :default
       
       # Allows the fine tuning of certain router options.
-      #
+      # 
       # ==== Parameters
       # optionsHash::
       #   The options to set for all routes defined in the scope. The currently
       #   supported options are:
       #   * :controller_prefix - The module that the controller is included in.
       #   * :name_prefix       - The prefix added to all routes named with #name
-      #
+      # 
       # &block::
       #   All routes defined in the block will be scoped to the options defined
       #   by the #options method.
-      #
+      # 
       # ==== Block parameters
       # rBehavior:: The options behavior object. This is optional
-      #
+      # 
       # ==== Examples
       #   # If :group is not matched in the path, it will be "registered" instead
       #   # of nil.
       #   match("/users(/:group)").default(:group = "registered")
-      # ---
-      # @public
+      # 
+      # @api public
       def options(opts = {}, &block)
         options = @options.dup
-
+        
         opts.each_pair do |key, value|
           options[key] = (options[key] || []) + [value.freeze] if value
         end
-
+        
         behavior = Behavior.new(@proxy, @conditions, @params, @defaults, @identifiers, options, @blocks)
         with_behavior_context(behavior, &block)
       end
@@ -325,44 +406,47 @@ def options(opts = {}, &block)
       
       # Creates a namespace for a route. This way you can have logical
       # separation to your routes.
-      #
+      # 
       # ==== Parameters
       # name_or_pathString, Symbol::
       #   The name or path of the namespace.
-      #
+      # 
       # optionsHash::
-      #   Optional hash, set :path if you want to override what appears on the url
-      #
+      #   Optional hash (see below)
+      # 
       # &block::
       #   All routes defined in the block will be scoped to the namespace defined
       #   by the #namespace method.
-      #
+      # 
+      # ==== Options (opts)
+      # :pathString:: match against this url
+      # 
       # ==== Block parameters
       # rBehavior:: The namespace behavior object. This is optional
-      #
+      # 
       # ==== Examples
       #   namespace :admin do
       #     resources :accounts
       #     resource :email
       #   end
-      #
+      # 
       #   # /super_admin/accounts
       #   namespace(:admin, :path="super_admin") do
       #     resources :accounts
       #   end
-      # ---
-      # @public
+      # 
+      # @api public
       def namespace(name_or_path, opts = {}, &block)
         name = name_or_path.to_s # We don't want this modified ever
         path = opts.has_key?(:path) ? opts[:path] : name
-
+        
         raise Error, "The route has already been committed. Further options cannot be specified" if @route
-
+        
         # option keys could be nil
         opts[:controller_prefix] = name unless opts.has_key?(:controller_prefix)
         opts[:name_prefix]       = name unless opts.has_key?(:name_prefix)
         opts[:resource_prefix]   = opts[:name_prefix] unless opts.has_key?(:resource_prefix)
-
+        
         behavior = self
         behavior = behavior.match("/#{path}") unless path.nil? || path.empty?
         behavior.options(opts, &block)
@@ -372,22 +456,22 @@ def namespace(name_or_path, opts = {}, &block)
       # insertion into a route. This is useful when using models and want a
       # specific method to be called on it (For example, for ActiveRecord::Base
       # it would be #to_param).
-      #
+      # 
       # The default method called on objects is #to_s.
-      #
+      # 
       # ==== Paramters
       # identifiersHash::
       #   The keys are Classes and the values are the method that instances of the specified
       #   class should have called on.
-      #
+      # 
       # &block::
       #   All routes defined in the block will be call the specified methods during
       #   generation.
-      #
+      # 
       # ==== Block parameters
       # rBehavior:: The identify behavior object. This is optional
-      # ---
-      # @public
+      # 
+      # @api public
       def identify(identifiers = {}, &block)
         identifiers = if Hash === identifiers
           @identifiers.merge(identifiers)
@@ -402,23 +486,23 @@ def identify(identifiers = {}, &block)
       # Creates the most common routes /:controller/:action/:id.format when
       # called with no arguments. You can pass a hash or a block to add parameters
       # or override the default behavior.
-      #
+      # 
       # ==== Parameters
       # paramsHash::
       #   This optional hash can be used to augment the default settings
-      #
+      # 
       # &block::
       #   When passing a block a new behavior is yielded and more refinement is
       #   possible.
-      #
+      # 
       # ==== Returns
       # Route:: the default route
-      #
+      # 
       # ==== Examples
-      #
+      # 
       #   # Passing an extra parameter "mode" to all matches
       #   r.default_routes :mode = "default"
-      #
+      # 
       #   # specifying exceptions within a block
       #   r.default_routes do |nr|
       #     nr.defer_to do |request, params|
@@ -426,31 +510,31 @@ def identify(identifiers = {}, &block)
       #         :action = "new") if request.env["REQUEST_URI"] =~ /\/private\//
       #     end
       #   end
-      #---
-      # @public
+      # 
+      # @api public
       def default_routes(params = {}, &block)
         match("/:controller(/:action(/:id))(.:format)").to(params, &block).name(:default)
       end
       
       # Takes a block and stores it for deferred conditional routes. The block
       # takes the +request+ object and the +params+ hash as parameters.
-      #
+      # 
       # ==== Parameters
       # paramsHash:: Parameters and conditions associated with this behavior.
       # &conditional_block::
       #   A block with the conditions to be met for the behavior to take
       #   effect.
-      #
+      # 
       # ==== Returns
       # Route :: The default route.
-      #
+      # 
       # ==== Examples
       #   defer_to do |request, params|
       #     params.merge :controller = 'here',
       #       :action = 'there' if request.xhr?
       #   end
-      #---
-      # @public
+      # 
+      # @api public
       def defer_to(params = {}, &block)
         defer(block).to(params)
       end
@@ -458,27 +542,39 @@ def defer_to(params = {}, &block)
       # Takes a Proc as a parameter and applies it as a deferred proc for all the
       # routes defined in the block. This is mostly interesting for plugin
       # developers.
+      # 
+      # ==== Examples
+      #   defered_block = proc do |r, p|
+      #     p.merge :controller = 'api/comments' if request.xhr?
+      #   end
+      #   defer(defered_block) do
+      #     resources :comments
+      #   end
+      # 
+      # @api public
       def defer(deferred_block, &block)
         blocks = @blocks + [CachedProc.new(deferred_block)]
         behavior = Behavior.new(@proxy, @conditions, @params, @defaults, @identifiers, @options, blocks)
         with_behavior_context(behavior, &block)
       end
       
-      # Names this route in Router. Name must be a Symbol.
-      #
+      # Registers the route as a named route with the name given.
+      # 
       # ==== Parameters
-      # symbolSymbol:: The name of the route.
-      #
+      # symbolSymbol:: the name of the route.
+      # 
       # ==== Raises
       # ArgumentError:: symbol is not a Symbol.
+      # 
+      # @api public
       def name(prefix, name = nil)
         unless name
           name, prefix = prefix, nil
         end
-
+        
         full_name([prefix, @options[:name_prefix], name].flatten.compact.join('_'))
       end
-
+      
       # Names this route in Router. Name must be a Symbol. The current
       # name_prefix is ignored.
       #
@@ -487,6 +583,8 @@ def name(prefix, name = nil)
       #
       # ==== Raises
       # ArgumentError:: symbol is not a Symbol.
+      # 
+      # @api private
       def full_name(name)
         if @route
           @route.name = name
@@ -496,27 +594,34 @@ def full_name(name)
         end
       end
       
+      # Specifies that a route can be fixatable.
+      # 
       # ==== Parameters
       # enabledBoolean:: True enables fixation on the route.
+      # 
+      # @api public
       def fixatable(enable = true)
         @route.fixation = enable
         self
       end
-
-      # Sets the current route as a redirect.
-      #
+      
+      # Redirects the current route.
+      # 
       # ==== Parameters
-      # pathString::
-      #   The path to redirect to
-      #
+      # pathString:: The path to redirect to.
+      # 
       # optionsHash::
-      #   Options for the redirect
-      #   The supported options are:
-      #   * :permanent: Whether or not the redirect should be permanent.
-      #                 The default value is false.
+      #   Options (see below)
+      # 
+      # ==== Options (opts)
+      # :permanentBoolean::
+      #   Whether or not the redirect should be permanent.
+      #   The default value is false.
+      # 
+      # @api public
       def redirect(url, opts = {})
         raise Error, "The route has already been committed." if @route
-
+        
         status = opts[:permanent] ? 301 : 302
         @route = Route.new(@conditions, {:url = url.freeze, :status = status.freeze}, @blocks, :redirects = true)
         @route.register
@@ -529,6 +634,8 @@ def redirect(url, opts = {})
       # it doesn't affect how/which routes are added.
       #
       # &block:: A context in which routes are generated.
+      # 
+      # @api public
       def capture(&block)
         captured_routes = {}
         name_prefix     = [@options[:name_prefix]].flatten.compact.map { |p| "#{p}_"}
@@ -545,27 +652,42 @@ def capture(&block)
         captured_routes
       end
       
-      # So that Router can have a default route
-      # ---
-      # @private
-      def _with_proxy(&block) #:nodoc:
+      # Proxy routes with the default behaviors.
+      # 
+      # ==== Parameters
+      # &block:: defines routes within the provided context.
+      # 
+      # @api private
+      def _with_proxy(&block)
         proxy = Proxy.new
         proxy.push Behavior.new(proxy, @conditions, @params, @defaults, @identifiers, @options, @blocks)
         proxy.instance_eval(&block)
         proxy
       end
       
-    protected
-    
+      protected
+      
+      # Returns the current route.
+      # 
+      # ==== Returns
+      # Route:: the route.
+      # 
+      # @api private
       def _route
         @route
       end
       
-      def to_route # :nodoc:
+      # Turns a route definition into a Route object.
+      # 
+      # ==== Returns
+      # Route:: the route generated.
+      # 
+      # @api private
+      def to_route
         raise Error, "The route has already been committed." if @route
-
+        
         controller = @params[:controller]
-
+        
         if prefixes = @options[:controller_prefix]
           controller ||= ":controller"
           
@@ -594,12 +716,22 @@ def to_route # :nodoc:
       
       # Allows to insert the route at a certain spot in the list of routes
       # instead of appending to the list.
-      def before(route, &block) #:nodoc:
+      # 
+      # ==== Params
+      # routeRoute:: the route to insert before.
+      # &block:: the route definition to insert.
+      # 
+      # @api plugin
+      def before(route, &block)
         options(:before = route, &block)
       end
-
-    private
-    
+      
+      private
+      
+      # Takes @conditions and turns values into strings (except for Regexp and
+      # Array values).
+      # 
+      # @api private
       def stringify_condition_values # :nodoc:
         @conditions.each do |key, value|
           unless value.nil? || Regexp === value || Array === value
@@ -607,7 +739,18 @@ def stringify_condition_values # :nodoc:
           end
         end
       end
-    
+      
+      # Creates a new context with a given behavior for the route definition in
+      # the block.
+      # 
+      # ==== Params
+      # behaviorBehavior:: the behavior to proxy the calls in the block.
+      # &block:: the routing definitions to be nested within the behavior.
+      # 
+      # ==== Returns
+      # Behavior:: the behavior wrapping.
+      # 
+      # @api private
       def with_behavior_context(behavior, &block) # :nodoc:
         if block_given?
           @proxy.push(behavior)
@@ -616,11 +759,25 @@ def with_behavior_context(behavior, &block) # :nodoc:
         end
         behavior
       end
-
+      
+      # Merges the path elements together into an array to be joined for
+      # generating named routes.
+      # 
+      # ==== Parameters
+      # pathString:: the path to merge at the end.
+      # 
+      # ==== Returns
+      # Array:: array of path elements.
+      # 
+      # ==== Notes
+      # An array of ['a', 'b'] (the 'a' namespace with the 'b' action) will
+      # produce a name of :a_b.
+      # 
+      # @api private
       def merge_paths(path) # :nodoc:
         [@conditions[:path], path.freeze].flatten.compact
       end
-
+      
     end
   end
 end
\ No newline at end of file</diff>
				</file>
				<file>
					<file_name>lib/merb-core/dispatch/session.rb</file_name>
					<diff>@@ -6,6 +6,8 @@ class Config
     # Returns stores list constructed from
     # configured session stores (:session_stores config option)
     # or default one (:session_store config option).
+    # 
+    # @api private
     def self.session_stores
       @session_stores ||= begin
         config_stores = Array(
@@ -15,7 +17,7 @@ def self.session_stores
       end
     end
   end # Config
-
+  
   # The Merb::Session module gets mixed into Merb::SessionContainer to allow
   # app-level functionality (usually found in app/models/merb/session.rb) for
   # session.
@@ -23,35 +25,37 @@ def self.session_stores
   # You can use this module to implement additional methods to simplify
   # building wizard-like application components,
   # authentication frameworks, etc.
+  # 
+  # Session configuration options:
+  #
+  # :session_id_key           The key by which a session value/id is
+  #                           retrieved; defaults to _session_id
+  #
+  # :session_expiry           When to expire the session cookie;
+  #                           defaults to 2 weeks
+  #
+  # :session_secret_key       A secret string which is used to sign/validate
+  #                           session data; min. 16 chars
+  #
+  # :default_cookie_domain    The default domain to write cookies for.
   module Session
   end
-
+  
   # This is mixed into Merb::Controller on framework boot.
   module SessionMixin
     # Raised when no suitable session store has been setup.
     class NoSessionContainer  StandardError; end
-
+    
     # Raised when storing more data than the available space reserved.
     class SessionOverflow  StandardError; end
-
-    # Session configuration options:
-    #
-    # :session_id_key           The key by which a session value/id is
-    #                           retrieved; defaults to _session_id
-    #
-    # :session_expiry           When to expire the session cookie;
-    #                           defaults to 2 weeks
-    #
-    # :session_secret_key       A secret string which is used to sign/validate
-    #                           session data; min. 16 chars
-    #
-    # :default_cookie_domain    The default domain to write cookies for.
+    
+    # @api private
     def self.included(base)
       # Register a callback to finalize sessions - needs to run before the cookie
       # callback extracts Set-Cookie headers from request.cookies.
       base._after_dispatch_callbacks.unshift lambda { |c| c.request.finalize_session }
     end
-
+    
     # ==== Parameters
     # session_storeString:: The type of session store to access.
     #
@@ -60,9 +64,9 @@ def self.included(base)
     def session(session_store = nil)
       request.session(session_store)
     end
-
+    
     # Module methods
-
+    
     # ==== Returns
     # String:: A random 32 character string for use as a unique session ID.
     def rand_uuid
@@ -77,59 +81,76 @@ def rand_uuid
       ]
       "%04x%04x%04x%04x%04x%06x%06x" % values
     end
-
+    
     # Marks this session as needing a new cookie.
+    # 
+    # @api private
     def needs_new_cookie!
       @_new_cookie = true
     end
-
+    
+    # Does session need new cookie?
+    # 
+    # ==== Returns
+    # Boolean:: true if a new cookie is needed, false otherwise.
+    # 
+    # @api private
     def needs_new_cookie?
       @_new_cookie
     end
-
+    
     module_function :rand_uuid, :needs_new_cookie!, :needs_new_cookie?
-
+    
     module RequestMixin
-
+      
+      # Adds class methods to Merb::Request object.
+      # Sets up repository of session store types.
+      # Sets the session ID key and expiry values.
       def self.included(base)
         base.extend ClassMethods
-
+        
         # Keep track of all known session store types.
         base.cattr_accessor :registered_session_types
         base.registered_session_types = Dictionary.new
         base.class_inheritable_accessor :_session_id_key, :_session_secret_key,
                                         :_session_expiry
-
+        
         base._session_id_key        = Merb::Config[:session_id_key] || '_session_id'
         base._session_expiry        = Merb::Config[:session_expiry] || 0
         base._session_secret_key    = Merb::Config[:session_secret_key]
       end
-
+      
       module ClassMethods
-
+        
         # ==== Parameters
         # name~to_sym:: Name of the session type to register.
         # class_nameString:: The corresponding class name.
         #
         # === Notres
         # This is automatically called when Merb::SessionContainer is subclassed.
+        # 
+        # @api private
         def register_session_type(name, class_name)
           self.registered_session_types[name.to_sym] = class_name
         end
-
+        
       end
-
+      
       # The default session store type.
+      # 
+      # @api private
       def default_session_store
         Merb::Config[:session_store] && Merb::Config[:session_store].to_sym
       end
-
+      
       # ==== Returns
       # Hash:: All active session stores by type.
+      # 
+      # @api private
       def session_stores
         @session_stores ||= {}
       end
-
+      
       # Returns session container. Merb is able to handle multiple session
       # stores, hence a parameter to pick it.
       #
@@ -140,6 +161,12 @@ def session_stores
       # === Notes
       # If no suitable session store type is given, it defaults to
       # cookie-based sessions.
+      # 
+      # ==== Returns
+      # SessionContainer::
+      #   an instance of a session store extending Merb::SessionContainer.
+      # 
+      # @api public
       def session(session_store = nil)
         session_store ||= default_session_store
         if class_name = self.class.registered_session_types[session_store]
@@ -154,12 +181,14 @@ def session(session_store = nil)
           raise NoSessionContainer, msg            
         end
       end
-
+      
       # ==== Parameters
       # new_sessionMerb::SessionContainer:: A session store instance.
       #
       # === Notes
       # The session is assigned internally by its session_store_type key.
+      # 
+      # @api private
       def session=(new_session)
         if self.session?(new_session.class.session_store_type)
           original_session_id = self.session(new_session.class.session_store_type).session_id
@@ -169,21 +198,30 @@ def session=(new_session)
         end
         session_stores[new_session.class.session_store_type] = new_session
       end
-
+      
       # Whether a session has been setup
+      # 
+      # ==== Returns
+      # Boolean:: true if the session is part of the session stores configured.
+      # 
+      # @api private
       def session?(session_store = nil)
         (session_store ? [session_store] : session_stores).any? do |type, store|
           store.is_a?(Merb::SessionContainer)
         end
       end
-
+      
       # Teardown and/or persist the current sessions.
+      # 
+      # @api private
       def finalize_session
         session_stores.each { |name, store| store.finalize(self) }
       end
       alias :finalize_sessions :finalize_session
-
+      
       # Assign default cookie values
+      # 
+      # @api private
       def default_cookies
         defaults = {}
         if route && route.allow_fixation? && params.key?(_session_id_key)
@@ -198,6 +236,8 @@ def default_cookies
       # ==== Parameters
       # valueString:: The value of the session cookie; either the session id or the actual encoded data.
       # optionsHash:: Cookie options like domain, path and expired.
+      # 
+      # @api private
       def set_session_cookie_value(value, options = {})
         defaults = {}
         defaults[:expires] = Time.now + _session_expiry if _session_expiry  0
@@ -207,12 +247,16 @@ def set_session_cookie_value(value, options = {})
 
       # ==== Returns
       # String:: The value of the session cookie; either the session id or the actual encoded data.
+      # 
+      # @api private
       def session_cookie_value
         cookies[_session_id_key]
       end
       alias :session_id :session_cookie_value
       
       # Destroy the session cookie.
+      # 
+      # @api private
       def destroy_session_cookie
         cookies.delete(_session_id_key)
       end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/dispatch/session/container.rb</file_name>
					<diff>@@ -1,41 +1,49 @@
 module Merb
   class SessionContainer  Mash
-  
+    
     class_inheritable_accessor :session_store_type
     cattr_accessor :subclasses 
     self.subclasses = []
-  
+    
     attr_reader :session_id
     attr_accessor :needs_new_cookie
-  
+    
     class  self
-  
+      
       # Register the subclass as an available session store type.
       def inherited(klass)
         self.subclasses  klass.to_s
         super
       end
-
+      
       # Generates a new session ID and creates a new session.
       #
       # ==== Returns
       # SessionContainer:: The new session.
+      # 
+      # @api private
       def generate
       end
-    
+      
       # ==== Parameters
       # requestMerb::Request:: The Merb::Request that came in from Rack.
       #
+      # ==== Notes
+      # If no sessions were found, a new SessionContainer will be generated.
+      # 
       # ==== Returns
-      # SessionContainer:: a SessionContainer. If no sessions were found, 
-      # a new SessionContainer will be generated.
+      # SessionContainer:: a SessionContainer.
+      # 
+      # @api private
       def setup(request)
-      end    
-    
+      end
+      
     end
-  
+    
     # ==== Parameters
     # session_idString:: A unique identifier for this session.
+    # 
+    # @api private
     def initialize(session_id)
       @_destroy = false
       self.session_id = session_id
@@ -45,11 +53,13 @@ def initialize(session_id)
     #
     # Recreates the cookie with the default expiration time. Useful during log
     # in for pushing back the expiration date.
+    # 
+    # @api private
     def session_id=(sid)
       self.needs_new_cookie = (@session_id && @session_id != sid)
       @session_id = sid
     end
-  
+    
     # Teardown and/or persist the current session.
     #
     # If @_destroy is true, clear out the session completely, including
@@ -57,18 +67,24 @@ def session_id=(sid)
     #
     # ==== Parameters
     # requestMerb::Request:: The Merb::Request that came in from Rack.
+    # 
+    # @api private
     def finalize(request)
     end
-  
+    
     # Destroy the current session - clears data and removes session cookie.
+    # 
+    # @api private
     def clear!
       @_destroy = true
       self.clear
     end
-  
+    
     # Regenerate the session_id.
+    # 
+    # @api private
     def regenerate
     end
-
+    
   end
 end
\ No newline at end of file</diff>
				</file>
				<file>
					<file_name>lib/merb-core/dispatch/session/cookie.rb</file_name>
					<diff>@@ -1,7 +1,7 @@
 require 'base64'        # to convert Marshal.dump to ASCII
 require 'openssl'       # to generate the HMAC message digest
 module Merb
-
+  
   # If you have more than 4K of session data or don't want your data to be
   # visible to the user, pick another session store.
   #
@@ -19,31 +19,33 @@ class CookieSession  SessionContainer
     # TODO (maybe):
     # include request ip address
     # AES encrypt marshaled data
-
+    
     # Raised when storing more than 4K of session data.
     class CookieOverflow  StandardError; end
-
+    
     # Raised when the cookie fails its integrity check.
     class TamperedWithCookie  StandardError; end
-
+    
     # Cookies can typically store 4096 bytes.
     MAX = 4096
     DIGEST = OpenSSL::Digest::Digest.new('SHA1') # or MD5, RIPEMD160, SHA256?
-
+    
     attr_accessor :_original_session_data
-
+    
     # The session store type
     self.session_store_type = :cookie
-
+    
     class  self
       # Generates a new session ID and creates a new session.
       #
       # ==== Returns
       # SessionContainer:: The new session.
+      # 
+      # @api private
       def generate
         self.new(Merb::SessionMixin.rand_uuid, "", Merb::Request._session_secret_key)
       end
-
+      
       # Set up a new session on request: make it available on request instance.
       #
       # ==== Parameters
@@ -52,22 +54,26 @@ def generate
       # ==== Returns
       # SessionContainer:: a SessionContainer. If no sessions were found,
       # a new SessionContainer will be generated.
+      # 
+      # @api private
       def setup(request)
         session = self.new(Merb::SessionMixin.rand_uuid,
           request.session_cookie_value, request._session_secret_key)
         session._original_session_data = session.to_cookie
         request.session = session
       end
-
+      
     end
-
+    
     # ==== Parameters
     # session_idString:: A unique identifier for this session.
     # cookieString:: The raw cookie data.
     # secretString:: A session secret.
     #
     # ==== Raises
-    # ArgumentError:: Nil or blank secret.
+    # ArgumentError:: blank or insufficiently long secret.
+    # 
+    # @api private
     def initialize(session_id, cookie, secret)
       super session_id
       if secret.blank? || secret.length  16
@@ -78,7 +84,7 @@ def initialize(session_id, cookie, secret)
       @secret = secret
       self.update(unmarshal(cookie))
     end
-
+    
     # Teardown and/or persist the current session.
     #
     # If @_destroy is true, clear out the session completely, including
@@ -86,6 +92,8 @@ def initialize(session_id, cookie, secret)
     #
     # ==== Parameters
     # requestMerb::Request:: request object created from Rack environment.
+    # 
+    # @api private
     def finalize(request)
       if @_destroy
         request.destroy_session_cookie
@@ -95,10 +103,12 @@ def finalize(request)
     end
     
     # Regenerate the session_id.
+    # 
+    # @api private
     def regenerate
       self.session_id = Merb::SessionMixin.rand_uuid
     end
-
+    
     # Create the raw cookie string; includes an HMAC keyed message digest.
     #
     # ==== Returns
@@ -111,6 +121,8 @@ def regenerate
     # Session data is converted to a Hash first, since a container might
     # choose to marshal it, which would make it persist
     # attributes like 'needs_new_cookie', which it shouldn't.
+    # 
+    # @api private
     def to_cookie
       unless self.empty?
         data = self.serialize
@@ -123,24 +135,31 @@ def to_cookie
         value
       end
     end
-
+    
     private
-
+    
     # Generate the HMAC keyed message digest. Uses SHA1.
+    # 
+    # ==== Returns
+    # String:: an HMAC digest of the cookie data.
+    # 
+    # @api private
     def generate_digest(data)
       OpenSSL::HMAC.hexdigest(DIGEST, @secret, data)
     end
-
+    
     # Unmarshal cookie data to a hash and verify its integrity.
-    #
+    # 
     # ==== Parameters
     # cookie~to_s:: The cookie to unmarshal.
-    #
+    # 
     # ==== Raises
     # TamperedWithCookie:: The digests don't match.
-    #
+    # 
     # ==== Returns
     # Hash:: The stored session data.
+    # 
+    # @api private
     def unmarshal(cookie)
       if cookie.blank?
         {}
@@ -156,16 +175,26 @@ def unmarshal(cookie)
         unserialize(data)
       end
     end
-
+    
     protected
-
+    
     # Serialize current session data as a Hash.
     # Uses Base64 encoding for integrity.
+    # 
+    # ==== Returns
+    # String:: Base64 encoded dump of the session hash.
+    # 
+    # @api private
     def serialize
       Base64.encode64(Marshal.dump(self.to_hash)).chop
     end
-
+    
     # Unserialize the raw cookie data to a Hash
+    # 
+    # ==== Returns
+    # Hash:: the session hash Base64 decoded from the data dump.
+    # 
+    # @api private
     def unserialize(data)
       Marshal.load(Base64.decode64(data)) rescue {}
     end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/dispatch/session/memcached.rb</file_name>
					<diff>@@ -28,33 +28,37 @@ class MemcacheSession  SessionStoreContainer
   end
   
   module MemcacheStore
-
+    
     # Make the Memcached gem conform to the SessionStoreContainer interface
-
+    
     # ==== Parameters
     # session_idString:: ID of the session to retrieve.
     #
     # ==== Returns
     # ContainerSession:: The session corresponding to the ID.
+    # 
+    # @api private
     def retrieve_session(session_id)
       get("session:#{session_id}")
     end
-
+    
     # ==== Parameters
     # session_idString:: ID of the session to set.
     # dataContainerSession:: The session to set.
+    # 
+    # @api private
     def store_session(session_id, data)
       set("session:#{session_id}", data)
     end
-
+    
     # ==== Parameters
     # session_idString:: ID of the session to delete.
     def delete_session(session_id)
       delete("session:#{session_id}")
     end
-
+    
   end
-
+  
 end
 
 # For the memcached gem.</diff>
				</file>
				<file>
					<file_name>lib/merb-core/dispatch/session/memory.rb</file_name>
					<diff>@@ -34,9 +34,11 @@ def self.store
   
   # Used for handling multiple sessions stored in memory.
   class MemorySessionStore
-
+    
     # ==== Parameters
     # ttlFixnum:: Session validity time in seconds. Defaults to 1 hour.
+    # 
+    # @api private
     def initialize(ttl=nil)
       @sessions = Hash.new
       @timestamps = Hash.new
@@ -50,41 +52,51 @@ def initialize(ttl=nil)
     #
     # ==== Returns
     # ContainerSession:: The session corresponding to the ID.
+    # 
+    # @api private
     def retrieve_session(session_id)
       @mutex.synchronize {
         @timestamps[session_id] = Time.now
         @sessions[session_id]
       }
     end
-
+    
     # ==== Parameters
     # session_idString:: ID of the session to set.
     # dataContainerSession:: The session to set.
+    # 
+    # @api private
     def store_session(session_id, data)
       @mutex.synchronize {
         @timestamps[session_id] = Time.now
         @sessions[session_id] = data
       }
     end
-
+    
     # ==== Parameters
     # session_idString:: ID of the session to delete.
+    # 
+    # @api private
     def delete_session(session_id)
       @mutex.synchronize {
         @timestamps.delete(session_id)
         @sessions.delete(session_id)
       }
     end
-
+    
     # Deletes any sessions that have reached their maximum validity.
+    # 
+    # @api private
     def reap_expired_sessions
       @timestamps.each do |session_id,stamp|
         delete_session(session_id) if (stamp + @session_ttl)  Time.now 
       end
       GC.start
     end
-
+    
     # Starts the timer that will eventually reap outdated sessions.
+    # 
+    # @api private
     def start_timer
       Thread.new do
         loop {</diff>
				</file>
				<file>
					<file_name>lib/merb-core/dispatch/session/store_container.rb</file_name>
					<diff>@@ -45,25 +45,31 @@ class SessionStoreContainer  SessionContainer
     self.session_store_type = :store
     
     class  self
-
+      
       # Generates a new session ID and creates a new session.
-      #
+      # 
       # ==== Returns
       # SessionStoreContainer:: The new session.
+      # 
+      # @api private
       def generate
         session = new(Merb::SessionMixin.rand_uuid)
         session.needs_new_cookie = true
         session
       end
-
-      # Setup a new session.
-      #
+      
+      # Setup a new session or retreive an existing session.
+      # 
       # ==== Parameters
       # requestMerb::Request:: The Merb::Request that came in from Rack.
-      #
+      # 
+      # ==== Notes
+      # If no sessions were found, a new SessionContainer will be generated.
+      # 
       # ==== Returns
-      # SessionContainer:: a SessionContainer. If no sessions were found, 
-      # a new SessionContainer will be generated.
+      # SessionContainer:: a SessionContainer.
+      # 
+      # @api private
       def setup(request)
         session = retrieve(request.session_id)
         request.session = session
@@ -84,6 +90,8 @@ def setup(request)
       # ==== Notes
       # If there are persisted exceptions callbacks to execute, they all get executed
       # when Memcache library raises an exception.
+      # 
+      # @api private
       def retrieve(session_id)
         unless session_id.blank?
           begin
@@ -121,6 +129,8 @@ def retrieve(session_id)
     # The data (self) is converted to a Hash first, since a container might 
     # choose to do a full Marshal on the data, which would make it persist 
     # attributes like 'needs_new_cookie', which it shouldn't.
+    # 
+    # @api private
     def finalize(request)
       if @_destroy
         store.delete_session(self.session_id)
@@ -138,8 +148,10 @@ def finalize(request)
         end
       end
     end
-
+    
     # Regenerate the session ID.
+    # 
+    # @api private
     def regenerate
       store.delete_session(self.session_id)
       self.session_id = Merb::SessionMixin.rand_uuid</diff>
				</file>
				<file>
					<file_name>lib/merb-core/dispatch/worker.rb</file_name>
					<diff>@@ -3,14 +3,24 @@ class Worker
     
     attr_accessor :thread
     
+    # ==== Returns
+    # Merb::Worker:: instance of a worker.
+    # 
+    # @api private
     def self.start
       new
     end
     
+    # Creates a new worker thread that loops over the work queue.
+    # 
+    # @api private
     def initialize
       @thread = Thread.new { loop { process_queue } }
     end
     
+    # Processes tasks in the Merb::Dispatcher.work_queue.
+    # 
+    # @api private
     def process_queue
       begin
         while blk = Merb::Dispatcher.work_queue.pop
@@ -25,8 +35,8 @@ def process_queue
       rescue Exception = e
         Merb.logger.warn! %Q!Worker Thread Crashed with Exception:\n#{Merb.exception(e)}\nRestarting Worker Thread!
         retry
-      end    
+      end
     end
     
   end
-end    
\ No newline at end of file
+end
\ No newline at end of file</diff>
				</file>
				<file>
					<file_name>lib/merb-core/gem_ext/erubis.rb</file_name>
					<diff>@@ -1,5 +1,9 @@
 require 'erubis'
 module Erubis
+  # This adds support for embedding the return value of a block call:
+  #   %= foo do %...% end =%
+  #
+  # @api private
   module Basic::Converter
     def convert_input(src, input)
       pat = @pattern</diff>
				</file>
				<file>
					<file_name>lib/merb-core/logger.rb</file_name>
					<diff>@@ -1,16 +1,5 @@
 # Merb::Logger = Extlib::Logger
 
-class Merb::Logger  Extlib::Logger
-  def verbose!(message, level = :warn)
-    send("#{level}!", message) if Merb::Config[:verbose]
-  end
-
-  def verbose(message, level = :warn)
-    send(level, message) if Merb::Config[:verbose]
-  end
-end
-
-# require "time" # httpdate
 # ==== Public Merb Logger API
 #
 # To replace an existing logger with a new one:
@@ -45,168 +34,37 @@ def verbose(message, level = :warn)
 #   Merb::Logger.new(log{String, IO},level{Symbol, String})
 module Merb
 
-  class Logger
-
-    attr_accessor :level
-    attr_accessor :delimiter
-    attr_accessor :auto_flush
-    attr_reader   :buffer
-    attr_reader   :log
-    attr_reader   :init_args
-
-    # ==== Notes
-    # Ruby (standard) logger levels:
-    # :fatal:: An unhandleable error that results in a program crash
-    # :error:: A handleable error condition
-    # :warn:: A warning
-    # :info:: generic (useful) information about system operation
-    # :debug:: low-level information for developers
-    Levels = Mash.new({
-      :fatal = 7,
-      :error = 6,
-      :warn  = 4,
-      :info  = 3,
-      :debug = 0
-    }) unless const_defined?(:Levels)
-
-    @@mutex = {}
+  class Logger  Extlib::Logger
 
-    private
-
-    # Readies a log for writing.
+    # Appends a message to the log if the specified log level is at least as high as
+    # the log level of the logger if Merb::Config[:verbose]. Then flushes the log 
+    # buffer to disk.
     #
     # ==== Parameters
-    # logIO, String:: Either an IO object or a name of a logfile.
-    def initialize_log(log)
-      close if @log # be sure that we don't leave open files laying around.
-
-      if log.respond_to?(:write)
-        @log = log
-      elsif File.exist?(log)
-        @log = open(log, (File::WRONLY | File::APPEND))
-        @log.sync = true
-      else
-        FileUtils.mkdir_p(File.dirname(log)) unless File.directory?(File.dirname(log))
-        @log = open(log, (File::WRONLY | File::APPEND | File::CREAT))
-        @log.sync = true
-        @log.write("#{Time.now.httpdate} #{delimiter} info #{delimiter} Logfile created\n")
-      end
-    end
-
-    public
-
-    # To initialize the logger you create a new object, proxies to set_log.
+    # messageString:: The message to be logged.
+    # levelSymbol:: The level at which to log. Default is :warn.
     #
-    # ==== Parameters
-    # *args:: Arguments to create the log from. See set_logs for specifics.
-    def initialize(*args)
-      set_log(*args)
-    end
-
-    # Replaces an existing logger with a new one.
+    # ==== Returns
+    # self:: The logger object for chaining.
     #
-    # ==== Parameters
-    # logIO, String:: Either an IO object or a name of a logfile.
-    # log_level~to_sym::
-    #   The log level from, e.g. :fatal or :info. Defaults to :error in the
-    #   production environment and :debug otherwise.
-    # delimiterString::
-    #   Delimiter to use between message sections. Defaults to " ~ ".
-    # auto_flushBoolean::
-    #   Whether the log should automatically flush after new messages are
-    #   added. Defaults to false.
-    def set_log(stream = Merb::Config[:log_stream],
-      log_level = Merb::Config[:log_level],
-      delimiter = Merb::Config[:log_delimiter],
-      auto_flush = Merb::Config[:log_auto_flush])
-
-      @buffer                   = []
-      @delimiter                = delimiter
-      @auto_flush               = auto_flush
-
-      if Levels[log_level]
-        @level                  = Levels[log_level]
-      else
-        @level                  = log_level
-      end
-
-      @log                      = stream
-      @mutex = (@@mutex[@log] ||= Mutex.new)
-    end
-
-    # Flush the entire buffer to the log object.
-    def flush
-      return unless @buffer.size  0
-      @mutex.synchronize do
-        @log.write(@buffer.slice!(0..-1).to_s)
-      end
-    end
-
-    # Close and remove the current log object.
-    def close
-      flush
-      @log.close if @log.respond_to?(:close) && !@log.tty?
-      @log = nil
+    # @api plugin
+    def verbose!(message, level = :warn)
+      send("#{level}!", message) if Merb::Config[:verbose]
     end
 
-    # Appends a message to the log. The methods yield to an optional block and
-    # the output of this block will be appended to the message.
+    # Appends a message to the log if the specified log level is at least as high as
+    # the log level of the logger if Merb::Config[:verbose].
     #
     # ==== Parameters
-    # stringString:: The message to be logged. Defaults to nil.
+    # messageString:: The message to be logged.
+    # levelSymbol:: The level at which to log. Default is :warn.
     #
     # ==== Returns
-    # String:: The resulting message added to the log file.
-    def (string = nil)
-      message = ""
-      message  delimiter
-      message  string if string
-      message  "\n" unless message[-1] == ?\n
-      @buffer  message
-      flush if @auto_flush
-
-      message
-    end
-    alias :push :
-
-    # Generate the logging methods for Merb.logger for each log level.
-    Levels.each_pair do |name, number|
-      class_eval -LEVELMETHODS, __FILE__, __LINE__
-
-      # Appends a message to the log if the log level is at least as high as
-      # the log level of the logger.
-      #
-      # ==== Parameters
-      # stringString:: The message to be logged. Defaults to nil.
-      #
-      # ==== Returns
-      # self:: The logger object for chaining.
-      def #{name}(message = nil)
-        self  message if #{number} = level
-        self
-      end
-
-      # Appends a message to the log if the log level is at least as high as
-      # the log level of the logger. The bang! version of the method also auto
-      # flushes the log buffer to disk.
-      #
-      # ==== Parameters
-      # stringString:: The message to be logged. Defaults to nil.
-      #
-      # ==== Returns
-      # self:: The logger object for chaining.
-      def #{name}!(message = nil)
-        self  message if #{number} = level
-        flush if #{number} = level
-        self
-      end
-
-      # ==== Returns
-      # Boolean:: True if this level will be logged by this logger.
-      def #{name}?
-        #{number} = level
-      end
-      LEVELMETHODS
+    # self:: The logger object for chaining.
+    #
+    # @api plugin
+    def verbose(message, level = :warn)
+      send(level, message) if Merb::Config[:verbose]
     end
 
   end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/plugins.rb</file_name>
					<diff>@@ -2,10 +2,15 @@ module Merb
 
   module Plugins
 
+    # Returns the configuration settings hash for plugins. This is prepopulated from
+    # Merb.root / "config/plugins.yml" if it is present.
+    #
     # ==== Returns
     # Hash::
     #   The configuration loaded from Merb.root / "config/plugins.yml" or, if
     #   the load fails, an empty hash whose default value is another Hash.
+    #
+    # @api plugin
     def self.config
       @config ||= begin
         # this is so you can do Merb.plugins.config[:helpers][:awesome] = "bar"
@@ -25,12 +30,16 @@ def self.config
 
     # ==== Returns
     # Array(String):: All Rakefile load paths Merb uses for plugins.
+    #
+    # @api plugin
     def self.rakefiles
       Merb.rakefiles
     end
     
     # ==== Returns
     # Array(String):: All Generator load paths Merb uses for plugins.
+    #
+    # @api plugin
     def self.generators
       Merb.generators
     end
@@ -49,6 +58,8 @@ def self.generators
     # if defined(Merb::Plugins)
     #   Merb::Plugins.add_rakefiles "merb_sequel" / "merbtasks"
     # end
+    #
+    # @api plugin
     def self.add_rakefiles(*rakefiles)
       Merb.add_rakefiles(*rakefiles)
     end
@@ -60,6 +71,8 @@ def self.add_rakefiles(*rakefiles)
     #
     # This is the recommended way to register your plugin's generators
     # in Merb.
+    #
+    # @api plugin
     def self.add_generators(*generators)
       Merb.add_generators(*generators)
     end</diff>
				</file>
				<file>
					<file_name>lib/merb-core/rack/adapter.rb</file_name>
					<diff>@@ -5,6 +5,7 @@ module Rack
     class Adapter
 
       class  self
+        # Get a rack adapter by id. 
         # ==== Parameters
         # idString:: The identifier of the Rack adapter class to retrieve.
         #</diff>
				</file>
				<file>
					<file_name>lib/merb-core/rack/adapter/abstract.rb</file_name>
					<diff>@@ -2,7 +2,51 @@ module Merb
   module Rack
     class AbstractAdapter
 
+      # This method is designed to be overridden in a rack adapter.  It 
+      # will be called to start a server created with the new_server method.
+      # This is called from the AbstractAdapter start method.
+      #
+      # @api plugin
+      # @overridable
+      def self.start_server
+        raise NotImplemented
+      end
+      
+      # This method is designed to be overridden in a rack adapter.  It will
+      # be called to create a new instance of the server for the adapter to 
+      # start.  The adapter should attempt to bind to a port at this point. 
+      # This is called from the AbstractAdapter start method.
+      #
+      # ==== Parameters
+      # portInteger:: The port the server should listen on
+      #
+      # @api plugin
+      # @overridable
+      def self.new_server(port)
+        raise NotImplemented
+      end
+      
+      # This method is designed to be overridden in a rack adapter.  It will
+      # be called to stop the adapter server.  
+      #
+      # ==== Parameters
+      # statusInteger:: The exit status the adapter should exit with. 
+      #
+      # ==== Returns
+      # Boolean:: True if the server was properly stopped.  
+      #
+      # @api plugin
+      # @overridable
+      def self.stop(status)
+        raise NotImplemented
+      end
+
       # Spawn a new worker process at a port.
+      #
+      # ==== Parameters
+      # portInteger:: The port to start the worker process on. 
+      #
+      # @api private
       def self.spawn_worker(port)
         worker_pid = Kernel.fork
         start_at_port(port, @opts) unless worker_pid
@@ -15,6 +59,17 @@ def self.spawn_worker(port)
       end
 
       # The main start method for bootloaders that support forking.
+      # This method launches the adapters which inherit using the 
+      # new_server and start_server methods.  This method should not
+      # be overridden in adapters which want to fork.  
+      #
+      # ==== Parameters
+      # optsHash:: A hash of options
+      #   socket: the socket to bind to
+      #   port: the port to bind to
+      #   cluster: the number 
+      #
+      # @api private
       def self.start(opts={})
         @opts = opts
         $WORKERS ||= []
@@ -88,6 +143,14 @@ def self.start(opts={})
 
       end
 
+      # Fork a server on the specified port and start the app.
+      #
+      # ==== Parameters
+      # portInteger:: The port to start the server on
+      # optsHash:: The hash of options, defaults to the @opts 
+      #   instance variable.  
+      #
+      # @api private
       def self.start_at_port(port, opts = @opts)
         at_exit do
           Merb::Server.remove_pid(port)
@@ -167,11 +230,24 @@ def self.start_at_port(port, opts = @opts)
         start_server
       end
 
-      # This can be overridden in adapters, but shouldn't need to be.
+      # Exit the process with the specified status.  
+      #
+      # ==== Parameters
+      # statusInteger:: The exit code of the process.
+      # 
+      # @api private
       def self.exit_process(status = 0)
         exit(status)
       end
 
+      # Set the process title.
+      #
+      # ==== Parameters
+      # whoamiSymbol:: Either :spawner for the master process or :worker for any of the worker
+      #   processes. 
+      # portInteger:: The base port that the app is running on. 
+      #
+      # @api private
       def self.process_title(whoami, port)
         name = Merb::Config[:name]
         app  = "merb#{" : #{name}" if (name && name != "merb")}"</diff>
				</file>
				<file>
					<file_name>lib/merb-core/rack/adapter/irb.rb</file_name>
					<diff>@@ -1,15 +1,60 @@
 module Merb
   module Rack
     class Console
-      # ==== Parameters
-      # name~to_sym, Hash:: The name of the route to generate.
-      # paramsHash:: The params to use in the route generation.
+      # There are three possible ways to use this method.  First, if you have a named route, 
+      # you can specify the route as the first parameter as a symbol and any paramters in a 
+      # hash.  Second, you can generate the default route by just passing the params hash, 
+      # just passing the params hash.  Finally, you can use the anonymous parameters.  This 
+      # allows you to specify the parameters to a named route in the order they appear in the 
+      # router.  
+      #
+      # ==== Parameters(Named Route)
+      # nameSymbol:: 
+      #   The name of the route. 
+      # argsHash:: 
+      #   Parameters for the route generation.
+      #
+      # ==== Parameters(Default Route)
+      # argsHash:: 
+      #   Parameters for the route generation.  This route will use the default route. 
+      #
+      # ==== Parameters(Anonymous Parameters)
+      # nameSymbol::
+      #   The name of the route.  
+      # argsArray:: 
+      #   An array of anonymous parameters to generate the route
+      #   with. These parameters are assigned to the route parameters
+      #   in the order that they are passed.
       #
       # ==== Returns
       # String:: The generated URL.
       #
-      # ==== Alternatives
-      # If name is a hash, it will be merged with params.
+      # ==== Examples
+      # Named Route
+      #
+      # Merb::Router.prepare do
+      #   match("/articles/:title").to(:controller = :articles, :action = :show).name("articles")
+      # end
+      #
+      # url(:articles, :title = "new_article")
+      #
+      # Default Route
+      #
+      # Merb::Router.prepare do
+      #   default_routes
+      # end
+      #
+      # url(:controller = "articles", :action = "new")
+      #
+      # Anonymous Paramters
+      #
+      # Merb::Router.prepare do
+      #   match("/articles/:year/:month/:title").to(:controller = :articles, :action = :show).name("articles")
+      # end
+      #
+      # url(:articles, 2008, 10, "test_article")
+      #
+      # @api public
       def url(name, *args)
         args  {}
         Merb::Router.url(name, *args)</diff>
				</file>
				<file>
					<file_name>lib/merb-core/rack/application.rb</file_name>
					<diff>@@ -2,6 +2,16 @@ module Merb
   module Rack
     class Application
       
+      # The main rack application call method.  This is the entry point from rack (and the webserver) 
+      # to your application.  
+      #
+      # ==== Parameters
+      # envHash:: A rack request of parameters.  
+      #
+      # ==== Returns
+      # Array:: A rack response of [statusInteger, headersHash, bodyString, Stream]
+      #
+      # @api private
       def call(env) 
         begin
           rack_response = ::Merb::Dispatcher.handle(Merb::Request.new(env))
@@ -18,6 +28,18 @@ def call(env)
         rack_response
       end
 
+      # Determines whether this request is a "deferred_action", usually a long request. 
+      # Rack uses this method to detemine whether to use an evented request or a deferred 
+      # request in evented rack handlers.  
+      #
+      # ==== Parameters
+      # envHash:: The rack request
+      #
+      # ==== Returns
+      # Boolean::
+      #   True if the request should be deferred.  
+      #
+      # @api private
       def deferred?(env)
         path = env[Merb::Const::PATH_INFO] ? env[Merb::Const::PATH_INFO].chomp('/') : ""
         if path =~ Merb.deferred_actions</diff>
				</file>
				<file>
					<file_name>lib/merb-core/rack/helpers.rb</file_name>
					<diff>@@ -2,6 +2,20 @@ module Merb
   module Rack
     module Helpers
       
+      # A helper to build a rack response which implements a redirect.  The status will be set to 
+      # the passed in status if passed.  If you pass in permanent it will be a 301, permanent redirect,
+      # otherwise it defaults to a temporary 302 redirect.  
+      #
+      # ==== Parameters
+      # url~to_s:: The url to redirect to.
+      # optionsHash:: A hash of options for the redirect
+      #   status: The status code to use for the redirect
+      #   permanent:  True if this is a permanent redirect (301)
+      #
+      # ==== Returns
+      # Array:: A rack response to redirect to the specified url.  
+      #
+      # @api plugin
       def self.redirect(url, options = {})
         # Build the rack array
         status   = options.delete(:status)</diff>
				</file>
				<file>
					<file_name>lib/merb-core/server.rb</file_name>
					<diff>@@ -18,6 +18,8 @@ class  self
       # ==== Alternatives
       # If cluster is left out, then one process will be started. This process
       # will be daemonized if Merb::Config[:daemonize] is true.
+      #
+      # @api private
       def start(port, cluster=nil)
 
         @port = port
@@ -47,6 +49,8 @@ def start(port, cluster=nil)
       # ==== Returns
       # Boolean::
       #   True if Merb is running on the specified port.
+      #
+      # @api private
       def alive?(port)
         puts "About to check if port #{port} is alive..." if Merb::Config[:verbose]
         pidfile = pid_file(port)
@@ -68,6 +72,8 @@ def alive?(port)
       # ==== Alternatives
       # If you pass "all" as the port, the signal will be sent to all Merb
       # processes.
+      #
+      # @api private
       def kill(port, sig="INT")
         Merb::BootLoader::BuildFramework.run
         if sig == 9 && port == "main"
@@ -90,6 +96,8 @@ def kill(port, sig="INT")
         end
       end
 
+      # Kills the process pointed at by the provided pid file.
+      # @api private
       def kill_pid(sig, file)
         begin
           pid = File.read(file).chomp.to_i
@@ -118,6 +126,8 @@ def kill_pid(sig, file)
 
       # ==== Parameters
       # port~to_s:: The port of the Merb process to daemonize.
+      #
+      # @api private
       def daemonize(port)
         puts "About to fork..." if Merb::Config[:verbose]
         fork do
@@ -142,6 +152,9 @@ def daemonize(port)
         Merb.fatal! "Daemonized mode is not supported on your platform", e
       end
 
+      # Starts up Merb by running the bootloader and starting the adapter.
+      #
+      # @api private
       def bootup
         Merb.trap('TERM') {
           Merb::BootLoader::LoadClasses.reap_workers if Merb::Config[:fork_for_class_load]
@@ -154,6 +167,9 @@ def bootup
         Merb.adapter.start(Merb::Config.to_hash)
       end
 
+      # Change process user/group to those specified in Merb::Config.
+      #
+      # @api private
       def change_privilege
         if Merb::Config[:user] && Merb::Config[:group]
           Merb.logger.verbose! "About to change privilege to group " \
@@ -179,6 +195,8 @@ def change_privilege
       # ==== Alternatives
       # If Merb::Config[:pid_file] has been specified, that will be used
       # instead of the port based PID file.
+      #
+      # @api private
       def remove_pid_file(port)
         pidfile = pid_file(port)
         if File.exist?(pidfile)
@@ -198,14 +216,32 @@ def remove_pid_file(port)
       # ==== Alternatives
       # If Merb::Config[:pid_file] has been specified, that will be used
       # instead of the port based PID file.
+      #
+      # @api private
       def store_pid(port)
         store_details(port)
       end
 
+      # Delete the pidfile for the specified port.
+      #
+      # @api private
       def remove_pid(port)
         FileUtils.rm(pid_file(port)) if File.file?(pid_file(port))
       end
 
+      # Stores a PID file on the filesystem.
+      # This uses :pid_file options from configuration when provided
+      # or merb.port.pid in log directory by default.
+      #
+      # ==== Parameters
+      # port~to_s::
+      #   The port of the Merb process to whom the the PID file belongs to.
+      #
+      # ==== Alternatives
+      # If Merb::Config[:pid_file] has been specified, that will be used
+      # instead of the port based PID file.
+      #
+      # @api private
       def store_details(port = nil)
         file = pid_file(port)
         begin
@@ -233,6 +269,8 @@ def store_details(port = nil)
       # String::
       #   Location of pid file for specified port. If clustered and pid_file option
       #   is specified, it adds the port value to the path.
+      #
+      # @api private
       def pid_file(port)
         pidfile = Merb::Config[:pid_file] || (Merb.log_path / "merb.%s.pid")
         pidfile % port
@@ -243,6 +281,8 @@ def pid_file(port)
       # ==== Returns
       # Array::
       #   List of pid file paths. If not clustered, array contains a single path.
+      #
+      # @api private
       def pid_files
         if Merb::Config[:pid_file]
           if Merb::Config[:cluster]
@@ -263,6 +303,8 @@ def pid_files
       #
       # ==== Alternatives
       # If group is left out, the user will be used as the group.
+      #
+      # @api private
       def _change_privilege(user, group=user)
 
         Merb.logger.warn! "Changing privileges to #{user}:#{group}"
@@ -297,6 +339,7 @@ def _change_privilege(user, group=user)
         false
       end
 
+      # @api private
       def add_irb_trap
         Merb.trap('INT') do
           if @interrupted</diff>
				</file>
				<file>
					<file_name>lib/merb-core/test/helpers/request_helper.rb</file_name>
					<diff>@@ -36,7 +36,7 @@ def request(uri, env = {})
         end
 
         if env[:params]
-          uri  "&#{Merb::Request.params_to_query_string(env.delete(:body_params))}"
+          uri  "?#{Merb::Request.params_to_query_string(env.delete(:params))}"
         end
 
         if @__cookie__</diff>
				</file>
				<file>
					<file_name>lib/merb-core/test/helpers/route_helper.rb</file_name>
					<diff>@@ -3,14 +3,60 @@ module Test
     module RouteHelper
       include RequestHelper
       
-      # Mimics the url method available to controllers.
+      # There are three possible ways to use this method.  First, if you have a named route, 
+      # you can specify the route as the first parameter as a symbol and any paramters in a 
+      # hash.  Second, you can generate the default route by just passing the params hash, 
+      # just passing the params hash.  Finally, you can use the anonymous parameters.  This 
+      # allows you to specify the parameters to a named route in the order they appear in the 
+      # router.  
       #
-      # ==== Parameters
-      # name~to_sym:: The name of the URL to generate.
-      # paramsHash:: Parameters for the route generation.
+      # ==== Parameters(Named Route)
+      # nameSymbol:: 
+      #   The name of the route. 
+      # argsHash:: 
+      #   Parameters for the route generation.
+      #
+      # ==== Parameters(Default Route)
+      # argsHash:: 
+      #   Parameters for the route generation.  This route will use the default route. 
+      #
+      # ==== Parameters(Anonymous Parameters)
+      # nameSymbol::
+      #   The name of the route.  
+      # argsArray:: 
+      #   An array of anonymous parameters to generate the route
+      #   with. These parameters are assigned to the route parameters
+      #   in the order that they are passed.
       #
       # ==== Returns
       # String:: The generated URL.
+      #
+      # ==== Examples
+      # Named Route
+      #
+      # Merb::Router.prepare do
+      #   match("/articles/:title").to(:controller = :articles, :action = :show).name("articles")
+      # end
+      #
+      # url(:articles, :title = "new_article")
+      #
+      # Default Route
+      #
+      # Merb::Router.prepare do
+      #   default_routes
+      # end
+      #
+      # url(:controller = "articles", :action = "new")
+      #
+      # Anonymous Paramters
+      #
+      # Merb::Router.prepare do
+      #   match("/articles/:year/:month/:title").to(:controller = :articles, :action = :show).name("articles")
+      # end
+      #
+      # url(:articles, 2008, 10, "test_article")
+      #
+      # @api public
       def url(*args)
         args  (@request_params || {})
         Merb::Router.url(*args)</diff>
				</file>
				<file>
					<file_name>spec/private/core_ext/kernel_spec.rb</file_name>
					<diff>@@ -1,19 +1,5 @@
 require File.dirname(__FILE__) + '/../../spec_helper'
 
-describe "Kernel#require" do
-  before do
-    @logger = StringIO.new
-  end
-
-  it "should be able to require and throw a useful error message" do
-    Kernel.stub!(:require).with("redcloth").and_raise(LoadError)
-    Merb.logger.should_receive(:error!).with("foo")
-    Kernel.rescue_require("redcloth", "foo")
-  end
-end
-
-
-
 describe "Kernel#caller" do
   it "should be able to determine caller info" do
     __caller_info__.should be_kind_of(Array)
@@ -71,7 +57,7 @@
     end
   end
 
-  it "deferres load of dependencies given as Hash" do
+  it "defers load of dependencies given as Hash" do
     self.should_receive(:dependency).with("hpricot", "0.6").and_return(true)
     self.should_receive(:dependency).with("rake", "0.8.1").and_return(true)
 </diff>
				</file>
				<file>
					<file_name>spec/private/dispatch/bootloader_spec.rb</file_name>
					<diff>@@ -5,14 +5,16 @@
   it "should default to rack config (rack.rb)" do
     options = {:merb_root = File.dirname(__FILE__) / 'fixture'}
     Merb::Config.setup(options)
-    app = Merb::BootLoader::RackUpApplication.run
+    Merb::BootLoader::RackUpApplication.run
+    app = Merb::Config[:app]
     app.class.should == Merb::Rack::Static
   end
 
   it "should use rackup config that we specified" do
     options = {:rackup = File.dirname(__FILE__) / 'fixture' / 'config' / 'black_hole.rb'}
     Merb::Config.setup(options)
-    app = Merb::BootLoader::RackUpApplication.run
+    Merb::BootLoader::RackUpApplication.run
+    app = Merb::Config[:app]
     app.class.should == Rack::Adapter::BlackHole
 
     env = Rack::MockRequest.env_for("/black_hole")</diff>
				</file>
				<file>
					<file_name>spec/public/logger/logger_spec.rb</file_name>
					<diff>@@ -21,6 +21,14 @@
 
 describe Merb::Logger do
 
+  describe "Levels" do
+    it "should have the same entries as Extlib::Logger::Levels" do
+      Extlib::Logger::Levels.each do |level, value|
+        Merb::Logger::Levels[level].should == value
+      end
+    end
+  end
+
   describe "#new" do
     it "should call set_log with the arguments it was passed." do
       logger = Merb::Logger.allocate # create an object sans initialization
@@ -41,6 +49,12 @@
       Merb.logger.level.should == 4
     end
 
+    it "should set the log level to a specific numeric value when that value is set into Mer" do
+      Merb::Config[:log_level] = 5
+      Merb.reset_logger!
+      Merb.logger.level.should == 5
+    end
+
     it "should set the log level to :debug (0) when Merb.environment is development" do
       Merb.environment = "development"
       Merb::Config.delete(:log_level)
@@ -280,4 +294,81 @@ def set_level(level)
       Merb.logger.should log_with_method(:fatal)
     end
   end # #fatal
+  
+  describe "#verbose" do
+    before do
+      @stream = Merb::Config[:log_stream] = StringIO.new
+      Merb.reset_logger!
+    end
+    
+    describe "when Merb::Config[:verbose] is false" do
+      it "should not log any messages" do
+        Merb::Config[:verbose] = false
+        Merb::Config[:log_level] = :debug
+        Merb.logger.verbose("message", :fatal)
+        Merb.logger.flush
+        
+        Merb.logger.log.string.should_not include("message")
+      end
+    end
+    
+    describe "when Merb::Config[:verbose] is true" do
+      before do
+        Merb::Config[:verbose] = true
+        Merb::Config[:log_level] = :debug
+      end
+
+      it "adds to the buffer with error level" do
+        set_level(:error)
+        Merb.logger.verbose("message", :error)
+        Merb.logger.flush
+        Merb.logger.log.string.should include("message")
+      end
+
+      it "adds to the buffer with fatal level" do
+        set_level(:fatal)
+        Merb.logger.verbose("message", :error)
+        Merb.logger.flush
+        Merb.logger.log.string.should_not include("message")
+      end
+      
+    end
+  end
+  
+  describe "#verbose!" do
+    before do
+      @stream = Merb::Config[:log_stream] = StringIO.new
+      Merb.reset_logger!
+    end
+    
+    describe "when Merb::Config[:verbose] is false" do
+      it "should not log any messages" do
+        Merb::Config[:verbose] = false
+        Merb::Config[:log_level] = :debug
+        Merb.logger.verbose!("message", :fatal)
+        Merb.logger.log.string.should_not include("message")
+      end
+    end
+    
+    describe "when Merb::Config[:verbose] is true" do
+      before do
+        Merb::Config[:verbose] = true
+        Merb::Config[:log_level] = :debug
+      end
+
+      it "adds to the buffer with error level" do
+        set_level(:error)
+        Merb.logger.verbose!("message", :error)
+        Merb.logger.log.string.should include("message")
+      end
+
+      it "adds to the buffer with fatal level" do
+        set_level(:fatal)
+        Merb.logger.verbose!("message", :error)
+        Merb.logger.log.string.should_not include("message")
+      end
+      
+    end
+  end
+  
 end # Merb::Logger</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>1c01aa36a766874102d8deeb8b481046656b7753</sha>
			<message>Merge branch 'master' of git@github.com:wycats/merb-core</message>
			<author_name>Yehuda Katz</author_name>
			<author_date>2008-10-11T06:16:41Z</author_date>
			<author_email>wycats@gmail.com</author_email>
			<committer_name>Yehuda Katz</committer_name>
			<committer_date>2008-10-11T06:16:41Z</committer_date>
			<committer_email>wycats@gmail.com</committer_email>
			<files>
				<file>
					<file_name>lib/merb-core/test/helpers/request_helper.rb</file_name>
					<diff>@@ -36,7 +36,7 @@ def request(uri, env = {})
         end
 
         if env[:params]
-          uri  "&#{Merb::Request.params_to_query_string(env.delete(:body_params))}"
+          uri  "?#{Merb::Request.params_to_query_string(env.delete(:params))}"
         end
 
         if @__cookie__</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>284933f51f42df41d2ddf42092f925f247640751</sha>
			<message>Fixes given again</message>
			<author_name>Yehuda Katz</author_name>
			<author_date>2008-10-11T06:16:22Z</author_date>
			<author_email>wycats@gmail.com</author_email>
			<committer_name>Yehuda Katz</committer_name>
			<committer_date>2008-10-11T06:16:22Z</committer_date>
			<committer_email>wycats@gmail.com</committer_email>
			<files>
				<file>
					<file_name>lib/merb-core/test/test_ext/rspec.rb</file_name>
					<diff>@@ -7,7 +7,7 @@ def given(*args, &example_group_block)
     params[:shared] = true
     
     describe(*args) do
-      before(:each) do
+      prepend_before(:each) do
         self.instance_eval(&example_group_block)
       end
     end</diff>
				</file>
			</files>
		</commit>
	</commits>
	<actual_files>
		<actual_file>
			<filename>README</filename>
			<content>merb-core and merb-more have been merged into http://github.com/wycats/merb</content>
		</actual_file>
	</actual_files>
</repo>
<repo>
	<id>28</id>
	<name>god</name>
	<description>Ruby process monitor</description>n	<owner>mojombo</owner>
	<main_language>Ruby</main_language>
	<created_at>2008-01-13T05:16:23Z</created_at>
	<updated_at>2014-04-15T16:22:12Z</updated_at>
	<clone_url>https://github.com/mojombo/god.git</clone_url>
	<languages>
		<language>Ruby</language>
		<language>CSS</language>
		<language>C</language>
		<language>Shell</language>
		<language>JavaScript</language>
	</languages>
	<branches>
		<branch>debug</branch>
		<branch>debug2</branch>
		<branch>dist</branch>
		<branch>gh-pages</branch>
		<branch>keepalive</branch>
		<branch>master</branch>
		<branch>newcontacts</branch>
		<branch>next</branch>
		<branch>science</branch>
		<branch>science2</branch>
	</branches>
	<contributors>
		<contributor>mojombo</contributor>
		<contributor>eric</contributor>
		<contributor>kevinclark</contributor>
		<contributor>tmm1</contributor>
		<contributor>cyrilpic</contributor>
		<contributor>raggi</contributor>
		<contributor>woahdae</contributor>
		<contributor>monde</contributor>
		<contributor>defunkt</contributor>
		<contributor>jberkel</contributor>
		<contributor>pdlug</contributor>
		<contributor>ashmckenzie</contributor>
		<contributor>Bertg</contributor>
		<contributor>tigris</contributor>
		<contributor>flowfeeler</contributor>
		<contributor>shr3kst3r</contributor>
		<contributor>geoffgarside</contributor>
		<contributor>jnewland</contributor>
		<contributor>ice799</contributor>
		<contributor>zimbatm</contributor>
		<contributor>ps2</contributor>
		<contributor>scottjg</contributor>
		<contributor>willbryant</contributor>
		<contributor>b4hand</contributor>
		<contributor>turley</contributor>
		<contributor>chawco</contributor>
		<contributor>danshultz</contributor>
		<contributor>underley</contributor>
		<contributor>jamesds</contributor>
		<contributor>chewi</contributor>
	</contributors>
	<commits>
		<commit>
			<sha>5fad099e1513ac53d02a0b6d7b16aae638d8f20b</sha>
			<message>Merge pull request #168 from robmiller/fix/ssl-webhooks

Webhooks contact: allow SSL URIs</message>
			<author_name>Eric Lindvall</author_name>
			<author_date>2014-04-15T16:22:11Z</author_date>
			<author_email>eric@5stops.com</author_email>
			<committer_name>Eric Lindvall</committer_name>
			<committer_date>2014-04-15T16:22:11Z</committer_date>
			<committer_email>eric@5stops.com</committer_email>
			<files>
				<file>
					<file_name>lib/god/contacts/webhook.rb</file_name>
					<diff>@@ -41,6 +41,7 @@ def notify(message, time, priority, category, host)
 
         uri = URI.parse(arg(:url))
         http = Net::HTTP.new(uri.host, uri.port)
+        http.use_ssl = true if uri.scheme == "https"
 
         req = nil
         res = nil</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>3bc7849b5155815a1e91c9cfa8aa32e8128185a5</sha>
			<message>Webhooks contact: allow SSL URIs

Tell Net::HTTP to use SSL if the webhook URL we've been passed has
a scheme of `https`; otherwise, use HTTP.</message>
			<author_name>Rob Miller</author_name>
			<author_date>2014-04-15T11:01:06Z</author_date>
			<author_email>rob@bigfish.co.uk</author_email>
			<committer_name>Rob Miller</committer_name>
			<committer_date>2014-04-15T11:01:06Z</committer_date>
			<committer_email>rob@bigfish.co.uk</committer_email>
			<files>
				<file>
					<file_name>lib/god/contacts/webhook.rb</file_name>
					<diff>@@ -41,6 +41,7 @@ def notify(message, time, priority, category, host)
 
         uri = URI.parse(arg(:url))
         http = Net::HTTP.new(uri.host, uri.port)
+        http.use_ssl = true if uri.scheme == "https"
 
         req = nil
         res = nil</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>d469e3f11edafa5756a37c500e6b3079bfd4c971</sha>
			<message>Release 0.13.4</message>
			<author_name>Eric Lindvall</author_name>
			<author_date>2014-03-06T05:15:09Z</author_date>
			<author_email>eric@5stops.com</author_email>
			<committer_name>Eric Lindvall</committer_name>
			<committer_date>2014-03-06T05:15:09Z</committer_date>
			<committer_email>eric@5stops.com</committer_email>
			<files>
				<file>
					<file_name>History.txt</file_name>
					<diff>@@ -1,3 +1,11 @@
+== 0.13.4 / 2014-03-05
+  * Minor Enhancements
+    * Hipchat reporter (#162)
+    * Re-open log files on SIGUSR1 (#103)
+  * Bug fixes
+    * Send query params on webhook reporter (#160)
+    * Don't thow an exception when there are problems reading pid file (#164)
+
 == 0.13.3 / 2013-09-25
   * Minor Enhancements
     * Invoke commands for all watchers</diff>
				</file>
				<file>
					<file_name>god.gemspec</file_name>
					<diff>@@ -3,8 +3,8 @@ Gem::Specification.new do |s|
   s.required_rubygems_version = Gem::Requirement.new("= 0") if s.respond_to? :required_rubygems_version=
 
   s.name = 'god'
-  s.version = '0.13.3'
-  s.date = '2014-03-04'
+  s.version = '0.13.4'
+  s.date = '2014-03-05'
 
   s.summary = "Process monitoring framework."
   s.description = "An easy to configure, easy to extend monitoring framework written in Ruby."</diff>
				</file>
				<file>
					<file_name>lib/god.rb</file_name>
					<diff>@@ -158,7 +158,7 @@ def safe_attr_accessor(*args)
 
 module God
   # The String version number for this package.
-  VERSION = '0.13.3'
+  VERSION = '0.13.4'
 
   # The Integer number of lines of backlog to keep for the logger.
   LOG_BUFFER_SIZE_DEFAULT = 100</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>6445038f904e68c187aef384eb4649626cdb991c</sha>
			<message>Merge pull request #162 from pzimmerman-github/hipchat

Hipchat</message>
			<author_name>Eric Lindvall</author_name>
			<author_date>2014-03-06T05:01:25Z</author_date>
			<author_email>eric@5stops.com</author_email>
			<committer_name>Eric Lindvall</committer_name>
			<committer_date>2014-03-06T05:01:25Z</committer_date>
			<committer_email>eric@5stops.com</committer_email>
			<files>
				<file>
					<file_name>doc/god.asciidoc</file_name>
					<diff>@@ -999,6 +999,29 @@ ssl       - A Boolean determining whether or not to use SSL
             (default: false).
 ```
 
+Hipchat
+~~~~~~~~
+
+Send a notice to a Hipchat room (http://hipchat.com).
+
+```ruby
+God::Contacts::Hipchat.defaults do |d|
+  ...
+end
+
+God.contact(:hipchat) do |c|
+  ...
+end
+```
+
+```
+token     - The String token used for authentication.
+room      - The String room name to which the message should be sent.
+ssl       - A Boolean determining whether or not to use SSL
+            (default: false).
+from      - The String representing who the message should be sent as.
+```
+
 Email
 ~~~~~
 </diff>
				</file>
				<file>
					<file_name>god.gemspec</file_name>
					<diff>@@ -4,7 +4,7 @@ Gem::Specification.new do |s|
 
   s.name = 'god'
   s.version = '0.13.3'
-  s.date = '2013-09-25'
+  s.date = '2014-03-04'
 
   s.summary = "Process monitoring framework."
   s.description = "An easy to configure, easy to extend monitoring framework written in Ruby."
@@ -83,6 +83,7 @@ Gem::Specification.new do |s|
     lib/god/contacts/airbrake.rb
     lib/god/contacts/campfire.rb
     lib/god/contacts/email.rb
+    lib/god/contacts/hipchat.rb
     lib/god/contacts/jabber.rb
     lib/god/contacts/prowl.rb
     lib/god/contacts/scout.rb
@@ -154,6 +155,7 @@ Gem::Specification.new do |s|
     test/test_event_handler.rb
     test/test_god.rb
     test/test_handlers_kqueue_handler.rb
+    test/test_hipchat.rb
     test/test_jabber.rb
     test/test_logger.rb
     test/test_metric.rb</diff>
				</file>
				<file>
					<file_name>lib/god.rb</file_name>
					<diff>@@ -85,6 +85,7 @@ def load_contact(name)
 
 require 'god/contact'
 load_contact(:campfire)
+load_contact(:hipchat)
 load_contact(:email)
 load_contact(:jabber)
 load_contact(:prowl)</diff>
				</file>
				<file>
					<file_name>lib/god/contacts/hipchat.rb</file_name>
					<diff>@@ -0,0 +1,117 @@
+# Send a notice to a Hipchat room (http://hipchat.com).
+#
+#  token     - The String token used for authentication.
+#  room      - The String room name to which the message should be sent.
+#  ssl       - A Boolean determining whether or not to use SSL
+#              (default: false).
+#  from      - The String representing who the message should be sent as.
+
+require 'net/http'
+require 'net/https'
+
+CONTACT_DEPS[:hipchat] = ['json']
+CONTACT_DEPS[:hipchat].each do |d|
+  require d
+end
+
+module Marshmallow
+  class Connection
+    def initialize(options)
+      raise "Required option :token not set." unless options[:token]
+      @options = options
+    end
+
+    def base_url
+      scheme = @options[:ssl] ? 'https' : 'http'
+      "#{scheme}://api.hipchat.com/v1/rooms"
+    end
+
+    def find_room_id_by_name(room_name)
+      url = URI.parse("#{base_url}/list?format=json&auth_token=#{@options[:token]}")
+      http = Net::HTTP.new(url.host, url.port)
+      http.use_ssl = true if @options[:ssl]
+
+      req = Net::HTTP::Get.new(url.request_uri)
+      req.set_content_type('application/json')
+
+      res = http.request(req)
+      case res
+        when Net::HTTPSuccess
+          rooms = JSON.parse(res.body)
+          room = rooms['rooms'].select { |x| x['name'] == room_name }
+          rooms.empty? ? nil : room.first['room_id'].to_i
+        else
+          raise res.error!
+      end
+    end
+
+    def speak(room, message)
+      room_id = find_room_id_by_name(room)
+      puts "in spark: room_id = #{room_id}"
+      raise "No such room: #{room}." unless room_id
+
+      escaped_message = URI.escape(message)
+
+      url = URI.parse("#{base_url}/message?message_format=text&format=json&auth_token=#{@options[:token]}&from=#{@options[:from]}&room_id=#{room}&message=#{escaped_message}")
+      
+      http = Net::HTTP.new(url.host, url.port)
+      http.use_ssl = true if @options[:ssl]
+
+      req = Net::HTTP::Post.new(url.request_uri)
+      req.set_content_type('application/json')
+      res = http.request(req)
+      case res
+        when Net::HTTPSuccess
+          true
+        else
+          raise res.error!
+      end
+    end
+  end
+end
+
+module God
+  module Contacts
+
+    class Hipchat  Contact
+      class  self
+        attr_accessor :token, :room, :ssl, :from
+        attr_accessor :format
+      end
+
+      self.ssl = false
+
+      self.format = lambda do |message, time, priority, category, host|
+        "[#{time.strftime('%H:%M:%S')}] #{host} - #{message}"
+      end
+
+      attr_accessor :token, :room, :ssl, :from
+
+      def valid?
+        valid = true
+        valid &= complain("Attribute 'token' must be specified", self) unless arg(:token)
+        valid &= complain("Attribute 'room' must be specified", self) unless arg(:room)
+        valid &= complain("Attribute 'from' must be specified", self) unless arg(:from)
+        valid
+      end
+
+      def notify(message, time, priority, category, host)
+        body = Hipchat.format.call(message, time, priority, category, host)
+
+        conn = Marshmallow::Connection.new(
+          :token = arg(:token),
+          :ssl   = arg(:ssl),
+          :from  = arg(:from)
+        )
+
+        conn.speak(arg(:room), body)
+
+        self.info = "notified hipchat: #{arg(:room)}"
+      rescue Object = e
+        applog(nil, :info, "failed to notify hipchat: #{e.message}")
+        applog(nil, :debug, e.backtrace.join("\n"))
+      end
+    end
+
+  end
+end</diff>
				</file>
				<file>
					<file_name>test/configs/contact/contact.god</file_name>
					<diff>@@ -9,6 +9,16 @@
 #   c.name = 'tom4'
 # end
 
+# God::Contacts::Hipchat.defaults do |d|
+#   d.token = '9fb768e421975cc1c6ff3f4f8306f890cb46e24f'
+#   d.room = 'Notices'
+#   d.ssl = true
+# end
+#
+# God.contact(:hipchat) do |c|
+#   c.name = 'hip1'
+# end
+
 # God.contact(:email) do |c|
 #   c.name = 'tom'
 #   c.group = 'developers'</diff>
				</file>
				<file>
					<file_name>test/test_hipchat.rb</file_name>
					<diff>@@ -0,0 +1,23 @@
+require File.dirname(__FILE__) + '/helper'
+
+class TestHipchat  Test::Unit::TestCase
+  def setup
+    @hipchat = God::Contacts::Hipchat.new
+  end
+
+  def test_exists
+    God::Contacts::Hipchat
+  end
+
+  def test_notify
+    @hipchat.token = 'ee64d6e2337310af'
+    @hipchat.ssl = 'true'
+    @hipchat.room = 'testroom'
+    @hipchat.from = 'test'
+
+    time = Time.now
+    body = "[#{time.strftime('%H:%M:%S')}] host - msg"
+    Marshmallow::Connection.any_instance.expects(:speak).with('testroom', body)
+    @hipchat.notify('msg', time, 'prio', 'cat', 'host')
+  end
+end</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>c4cdc402f675f8108ce3451c2020d847f20eeb49</sha>
			<message>Pin dependencies to work in 1.8 and 1.9</message>
			<author_name>Eric Lindvall</author_name>
			<author_date>2014-03-06T04:49:06Z</author_date>
			<author_email>eric@5stops.com</author_email>
			<committer_name>Eric Lindvall</committer_name>
			<committer_date>2014-03-06T04:53:19Z</committer_date>
			<committer_email>eric@5stops.com</committer_email>
			<files>
				<file>
					<file_name>Gemfile</file_name>
					<diff>@@ -1,2 +1,5 @@
 source 'https://rubygems.org'
 gemspec
+
+gem 'redcarpet', ' 3.0.0'
+gem 'sanitize', '2.0.3'</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>3cfcbc96e73c388282b29d039a651edb04a70eaa</sha>
			<message>Merge pull request #164 from turley/patch-1

Fix fatal exception when pid is nil</message>
			<author_name>Eric Lindvall</author_name>
			<author_date>2014-03-06T04:39:04Z</author_date>
			<author_email>eric@5stops.com</author_email>
			<committer_name>Eric Lindvall</committer_name>
			<committer_date>2014-03-06T04:39:04Z</committer_date>
			<committer_email>eric@5stops.com</committer_email>
			<files>
				<file>
					<file_name>lib/god/process.rb</file_name>
					<diff>@@ -210,13 +210,19 @@ def call_action(action)
           applog(self, :info, "#{self.name} sent SIG#{@stop_signal}")
 
           # Poll to see if it's dead
+          pid_not_found = false
           @stop_timeout.times do
-            begin
-              ::Process.kill(0, pid)
-            rescue Errno::ESRCH
-              # It died. Good.
-              applog(self, :info, "#{self.name} process stopped")
-              return
+            if pid
+              begin
+                ::Process.kill(0, pid)
+              rescue Errno::ESRCH
+                # It died. Good.
+                applog(self, :info, "#{self.name} process stopped")
+                return
+              end
+            else
+              applog(self, :warn, "#{self.name} pid not found in #{self.pid_file}") unless pid_not_found
+              pid_not_found = true
             end
 
             sleep 1</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>4c1d9809788f1bfaa3f5dab970813ae4eadcc2c7</sha>
			<message>Fix fatal exception when pid is nil

pid may return a nil value (if never found in pid_file) causing Process.kill to throw an exception (TypeError: no implicit conversion from nil to integer). We should check to make sure the pid isn't nil before attempting to kill it. Warn (once) about the missing pid. Don't interrupt polling in case a valid pid_file shows up while polling.</message>
			<author_name>Ben Turley</author_name>
			<author_date>2014-03-06T01:09:39Z</author_date>
			<author_email>benturley@gmail.com</author_email>
			<committer_name>Ben Turley</committer_name>
			<committer_date>2014-03-06T01:09:39Z</committer_date>
			<committer_email>benturley@gmail.com</committer_email>
			<files>
				<file>
					<file_name>lib/god/process.rb</file_name>
					<diff>@@ -210,13 +210,19 @@ def call_action(action)
           applog(self, :info, "#{self.name} sent SIG#{@stop_signal}")
 
           # Poll to see if it's dead
+          pid_not_found = false
           @stop_timeout.times do
-            begin
-              ::Process.kill(0, pid)
-            rescue Errno::ESRCH
-              # It died. Good.
-              applog(self, :info, "#{self.name} process stopped")
-              return
+            if pid
+              begin
+                ::Process.kill(0, pid)
+              rescue Errno::ESRCH
+                # It died. Good.
+                applog(self, :info, "#{self.name} process stopped")
+                return
+              end
+            else
+              applog(self, :warn, "#{self.name} pid not found in #{self.pid_file}") unless pid_not_found
+              pid_not_found = true
             end
 
             sleep 1</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>6b1762c2e9151f6d49cc5d5415447dec7ad55d7a</sha>
			<message>switch test data to non-production values</message>
			<author_name>pzimmer</author_name>
			<author_date>2014-03-05T04:13:39Z</author_date>
			<author_email>phil.zimmerman@twcable.com</author_email>
			<committer_name>pzimmer</committer_name>
			<committer_date>2014-03-05T04:13:39Z</committer_date>
			<committer_email>phil.zimmerman@twcable.com</committer_email>
			<files>
				<file>
					<file_name>test/test_hipchat.rb</file_name>
					<diff>@@ -10,13 +10,14 @@ def test_exists
   end
 
   def test_notify
-    @hipchat.token = '808da95553dfe06f413b12ff1d5772'
+    @hipchat.token = 'ee64d6e2337310af'
     @hipchat.ssl = 'true'
-    @hipchat.room = 'philtest'
+    @hipchat.room = 'testroom'
+    @hipchat.from = 'test'
 
     time = Time.now
     body = "[#{time.strftime('%H:%M:%S')}] host - msg"
-    Marshmallow::Connection.any_instance.expects(:speak).with('philtest', body)
+    Marshmallow::Connection.any_instance.expects(:speak).with('testroom', body)
     @hipchat.notify('msg', time, 'prio', 'cat', 'host')
   end
 end</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>1900135b1058bf99a334e50d4c9b0956143ad85d</sha>
			<message>removed Iconv reference</message>
			<author_name>pzimmer</author_name>
			<author_date>2014-03-05T03:32:54Z</author_date>
			<author_email>phil.zimmerman@twcable.com</author_email>
			<committer_name>pzimmer</committer_name>
			<committer_date>2014-03-05T03:32:54Z</committer_date>
			<committer_email>phil.zimmerman@twcable.com</committer_email>
			<files>
				<file>
					<file_name>lib/god/contacts/hipchat.rb</file_name>
					<diff>@@ -50,8 +50,7 @@ def speak(room, message)
       puts "in spark: room_id = #{room_id}"
       raise "No such room: #{room}." unless room_id
 
-      enc_message = Iconv.conv('iso-8859-1', 'utf-8', message)
-      escaped_message = URI.escape(enc_message)
+      escaped_message = URI.escape(message)
 
       url = URI.parse("#{base_url}/message?message_format=text&format=json&auth_token=#{@options[:token]}&from=#{@options[:from]}&room_id=#{room}&message=#{escaped_message}")
       </diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>828e9a7a6aa36881b348d1423a3e86de974e1773</sha>
			<message>working version of hipchat Contact</message>
			<author_name>pzimmer</author_name>
			<author_date>2014-03-04T18:21:37Z</author_date>
			<author_email>phil.zimmerman@twcable.com</author_email>
			<committer_name>pzimmer</committer_name>
			<committer_date>2014-03-04T18:21:37Z</committer_date>
			<committer_email>phil.zimmerman@twcable.com</committer_email>
			<files>
				<file>
					<file_name>doc/god.asciidoc</file_name>
					<diff>@@ -999,6 +999,29 @@ ssl       - A Boolean determining whether or not to use SSL
             (default: false).
 ```
 
+Hipchat
+~~~~~~~~
+
+Send a notice to a Hipchat room (http://hipchat.com).
+
+```ruby
+God::Contacts::Hipchat.defaults do |d|
+  ...
+end
+
+God.contact(:hipchat) do |c|
+  ...
+end
+```
+
+```
+token     - The String token used for authentication.
+room      - The String room name to which the message should be sent.
+ssl       - A Boolean determining whether or not to use SSL
+            (default: false).
+from      - The String representing who the message should be sent as.
+```
+
 Email
 ~~~~~
 </diff>
				</file>
				<file>
					<file_name>god.gemspec</file_name>
					<diff>@@ -4,7 +4,7 @@ Gem::Specification.new do |s|
 
   s.name = 'god'
   s.version = '0.13.3'
-  s.date = '2014-03-03'
+  s.date = '2014-03-04'
 
   s.summary = "Process monitoring framework."
   s.description = "An easy to configure, easy to extend monitoring framework written in Ruby."</diff>
				</file>
				<file>
					<file_name>lib/god/contacts/hipchat.rb</file_name>
					<diff>@@ -4,6 +4,7 @@
 #  room      - The String room name to which the message should be sent.
 #  ssl       - A Boolean determining whether or not to use SSL
 #              (default: false).
+#  from      - The String representing who the message should be sent as.
 
 require 'net/http'
 require 'net/https'
@@ -25,21 +26,20 @@ def base_url
       "#{scheme}://api.hipchat.com/v1/rooms"
     end
 
-    def find_room_id_by_name(room)
-      url = URI.parse("#{base_url}/list")
-
+    def find_room_id_by_name(room_name)
+      url = URI.parse("#{base_url}/list?format=json&auth_token=#{@options[:token]}")
       http = Net::HTTP.new(url.host, url.port)
       http.use_ssl = true if @options[:ssl]
 
-      req = Net::HTTP::Get.new(url.path)
-      req.basic_auth(@options[:token], 'X')
+      req = Net::HTTP::Get.new(url.request_uri)
+      req.set_content_type('application/json')
 
       res = http.request(req)
       case res
         when Net::HTTPSuccess
           rooms = JSON.parse(res.body)
-          room = rooms['rooms'].select { |x| x['name'] == room }
-          rooms.empty? ? nil : room.first['id']
+          room = rooms['rooms'].select { |x| x['name'] == room_name }
+          rooms.empty? ? nil : room.first['room_id'].to_i
         else
           raise res.error!
       end
@@ -47,22 +47,19 @@ def find_room_id_by_name(room)
 
     def speak(room, message)
       room_id = find_room_id_by_name(room)
+      puts "in spark: room_id = #{room_id}"
       raise "No such room: #{room}." unless room_id
 
-      url = URI.parse("#{base_url}/message")
+      enc_message = Iconv.conv('iso-8859-1', 'utf-8', message)
+      escaped_message = URI.escape(enc_message)
 
+      url = URI.parse("#{base_url}/message?message_format=text&format=json&auth_token=#{@options[:token]}&from=#{@options[:from]}&room_id=#{room}&message=#{escaped_message}")
+      
       http = Net::HTTP.new(url.host, url.port)
       http.use_ssl = true if @options[:ssl]
 
-      req = Net::HTTP::Post.new(url.path)
-      req.basic_auth(@options[:token], 'X')
+      req = Net::HTTP::Post.new(url.request_uri)
       req.set_content_type('application/json')
-      req.body = { 'message' = message,
-                   'from'    = 'Hubot',
-                   'room_id' = room,
-                   'color'   = 'yellow'
-                 }.to_json
-
       res = http.request(req)
       case res
         when Net::HTTPSuccess
@@ -79,7 +76,7 @@ module Contacts
 
     class Hipchat  Contact
       class  self
-        attr_accessor :token, :room, :ssl
+        attr_accessor :token, :room, :ssl, :from
         attr_accessor :format
       end
 
@@ -89,12 +86,13 @@ class  self
         "[#{time.strftime('%H:%M:%S')}] #{host} - #{message}"
       end
 
-      attr_accessor :token, :room, :ssl
+      attr_accessor :token, :room, :ssl, :from
 
       def valid?
         valid = true
         valid &= complain("Attribute 'token' must be specified", self) unless arg(:token)
         valid &= complain("Attribute 'room' must be specified", self) unless arg(:room)
+        valid &= complain("Attribute 'from' must be specified", self) unless arg(:from)
         valid
       end
 
@@ -103,7 +101,8 @@ def notify(message, time, priority, category, host)
 
         conn = Marshmallow::Connection.new(
           :token = arg(:token),
-          :ssl = arg(:ssl)
+          :ssl   = arg(:ssl),
+          :from  = arg(:from)
         )
 
         conn.speak(arg(:room), body)</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>49cfa7f1dd37c7104ff51706a407b8a859676452</sha>
			<message>modified files to enable hipchat test</message>
			<author_name>pzimmer</author_name>
			<author_date>2014-03-03T19:41:05Z</author_date>
			<author_email>phil.zimmerman@twcable.com</author_email>
			<committer_name>pzimmer</committer_name>
			<committer_date>2014-03-03T19:41:05Z</committer_date>
			<committer_email>phil.zimmerman@twcable.com</committer_email>
			<files>
				<file>
					<file_name>god.gemspec</file_name>
					<diff>@@ -4,7 +4,7 @@ Gem::Specification.new do |s|
 
   s.name = 'god'
   s.version = '0.13.3'
-  s.date = '2013-09-25'
+  s.date = '2014-03-03'
 
   s.summary = "Process monitoring framework."
   s.description = "An easy to configure, easy to extend monitoring framework written in Ruby."
@@ -83,6 +83,7 @@ Gem::Specification.new do |s|
     lib/god/contacts/airbrake.rb
     lib/god/contacts/campfire.rb
     lib/god/contacts/email.rb
+    lib/god/contacts/hipchat.rb
     lib/god/contacts/jabber.rb
     lib/god/contacts/prowl.rb
     lib/god/contacts/scout.rb
@@ -154,6 +155,7 @@ Gem::Specification.new do |s|
     test/test_event_handler.rb
     test/test_god.rb
     test/test_handlers_kqueue_handler.rb
+    test/test_hipchat.rb
     test/test_jabber.rb
     test/test_logger.rb
     test/test_metric.rb</diff>
				</file>
				<file>
					<file_name>lib/god.rb</file_name>
					<diff>@@ -85,6 +85,7 @@ def load_contact(name)
 
 require 'god/contact'
 load_contact(:campfire)
+load_contact(:hipchat)
 load_contact(:email)
 load_contact(:jabber)
 load_contact(:prowl)</diff>
				</file>
				<file>
					<file_name>test/configs/contact/contact.god</file_name>
					<diff>@@ -9,6 +9,16 @@
 #   c.name = 'tom4'
 # end
 
+# God::Contacts::Hipchat.defaults do |d|
+#   d.token = '9fb768e421975cc1c6ff3f4f8306f890cb46e24f'
+#   d.room = 'Notices'
+#   d.ssl = true
+# end
+#
+# God.contact(:hipchat) do |c|
+#   c.name = 'hip1'
+# end
+
 # God.contact(:email) do |c|
 #   c.name = 'tom'
 #   c.group = 'developers'</diff>
				</file>
				<file>
					<file_name>test/test_hipchat.rb</file_name>
					<diff>@@ -11,12 +11,12 @@ def test_exists
 
   def test_notify
     @hipchat.token = '808da95553dfe06f413b12ff1d5772'
-    @hipchat.room = 'philtest'
     @hipchat.ssl = 'true'
+    @hipchat.room = 'philtest'
 
     time = Time.now
     body = "[#{time.strftime('%H:%M:%S')}] host - msg"
-    Marshmallow::Connection.any_instance.expects(:speak).with('danger', body)
+    Marshmallow::Connection.any_instance.expects(:speak).with('philtest', body)
     @hipchat.notify('msg', time, 'prio', 'cat', 'host')
   end
 end</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>94594d052bd837d0cc925c5ce5c36cc19eb3f280</sha>
			<message>adding hipchat test</message>
			<author_name>pzimmer</author_name>
			<author_date>2014-03-03T18:46:33Z</author_date>
			<author_email>phil.zimmerman@twcable.com</author_email>
			<committer_name>pzimmer</committer_name>
			<committer_date>2014-03-03T18:46:33Z</committer_date>
			<committer_email>phil.zimmerman@twcable.com</committer_email>
			<files>
				<file>
					<file_name>test/test_hipchat.rb</file_name>
					<diff>@@ -0,0 +1,22 @@
+require File.dirname(__FILE__) + '/helper'
+
+class TestHipchat  Test::Unit::TestCase
+  def setup
+    @hipchat = God::Contacts::Hipchat.new
+  end
+
+  def test_exists
+    God::Contacts::Hipchat
+  end
+
+  def test_notify
+    @hipchat.token = '808da95553dfe06f413b12ff1d5772'
+    @hipchat.room = 'philtest'
+    @hipchat.ssl = 'true'
+
+    time = Time.now
+    body = "[#{time.strftime('%H:%M:%S')}] host - msg"
+    Marshmallow::Connection.any_instance.expects(:speak).with('danger', body)
+    @hipchat.notify('msg', time, 'prio', 'cat', 'host')
+  end
+end</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>35f676ed61c8a92e2b4726fc0fe1860643006132</sha>
			<message>first attempt at hipchat Contact type</message>
			<author_name>pzimmer</author_name>
			<author_date>2014-03-03T18:26:15Z</author_date>
			<author_email>phil.zimmerman@twcable.com</author_email>
			<committer_name>pzimmer</committer_name>
			<committer_date>2014-03-03T18:26:15Z</committer_date>
			<committer_email>phil.zimmerman@twcable.com</committer_email>
			<files>
				<file>
					<file_name>lib/god/contacts/hipchat.rb</file_name>
					<diff>@@ -0,0 +1,119 @@
+# Send a notice to a Hipchat room (http://hipchat.com).
+#
+#  token     - The String token used for authentication.
+#  room      - The String room name to which the message should be sent.
+#  ssl       - A Boolean determining whether or not to use SSL
+#              (default: false).
+
+require 'net/http'
+require 'net/https'
+
+CONTACT_DEPS[:hipchat] = ['json']
+CONTACT_DEPS[:hipchat].each do |d|
+  require d
+end
+
+module Marshmallow
+  class Connection
+    def initialize(options)
+      raise "Required option :token not set." unless options[:token]
+      @options = options
+    end
+
+    def base_url
+      scheme = @options[:ssl] ? 'https' : 'http'
+      "#{scheme}://api.hipchat.com/v1/rooms"
+    end
+
+    def find_room_id_by_name(room)
+      url = URI.parse("#{base_url}/list")
+
+      http = Net::HTTP.new(url.host, url.port)
+      http.use_ssl = true if @options[:ssl]
+
+      req = Net::HTTP::Get.new(url.path)
+      req.basic_auth(@options[:token], 'X')
+
+      res = http.request(req)
+      case res
+        when Net::HTTPSuccess
+          rooms = JSON.parse(res.body)
+          room = rooms['rooms'].select { |x| x['name'] == room }
+          rooms.empty? ? nil : room.first['id']
+        else
+          raise res.error!
+      end
+    end
+
+    def speak(room, message)
+      room_id = find_room_id_by_name(room)
+      raise "No such room: #{room}." unless room_id
+
+      url = URI.parse("#{base_url}/message")
+
+      http = Net::HTTP.new(url.host, url.port)
+      http.use_ssl = true if @options[:ssl]
+
+      req = Net::HTTP::Post.new(url.path)
+      req.basic_auth(@options[:token], 'X')
+      req.set_content_type('application/json')
+      req.body = { 'message' = message,
+                   'from'    = 'Hubot',
+                   'room_id' = room,
+                   'color'   = 'yellow'
+                 }.to_json
+
+      res = http.request(req)
+      case res
+        when Net::HTTPSuccess
+          true
+        else
+          raise res.error!
+      end
+    end
+  end
+end
+
+module God
+  module Contacts
+
+    class Hipchat  Contact
+      class  self
+        attr_accessor :token, :room, :ssl
+        attr_accessor :format
+      end
+
+      self.ssl = false
+
+      self.format = lambda do |message, time, priority, category, host|
+        "[#{time.strftime('%H:%M:%S')}] #{host} - #{message}"
+      end
+
+      attr_accessor :token, :room, :ssl
+
+      def valid?
+        valid = true
+        valid &= complain("Attribute 'token' must be specified", self) unless arg(:token)
+        valid &= complain("Attribute 'room' must be specified", self) unless arg(:room)
+        valid
+      end
+
+      def notify(message, time, priority, category, host)
+        body = Hipchat.format.call(message, time, priority, category, host)
+
+        conn = Marshmallow::Connection.new(
+          :token = arg(:token),
+          :ssl = arg(:ssl)
+        )
+
+        conn.speak(arg(:room), body)
+
+        self.info = "notified hipchat: #{arg(:room)}"
+      rescue Object = e
+        applog(nil, :info, "failed to notify hipchat: #{e.message}")
+        applog(nil, :debug, e.backtrace.join("\n"))
+      end
+    end
+
+  end
+end</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>6844891d78f10a086e83e5ad7b9df3aa2cf709b2</sha>
			<message>Merge pull request #160 from ashmckenzie/master

Webhooks with URL's that contain query parameters</message>
			<author_name>Eric Lindvall</author_name>
			<author_date>2014-03-03T02:50:45Z</author_date>
			<author_email>eric@5stops.com</author_email>
			<committer_name>Eric Lindvall</committer_name>
			<committer_date>2014-03-03T02:50:45Z</committer_date>
			<committer_email>eric@5stops.com</committer_email>
			<files>
				<file>
					<file_name>lib/god/contacts/webhook.rb</file_name>
					<diff>@@ -47,10 +47,10 @@ def notify(message, time, priority, category, host)
 
         case arg(:format)
           when :form
-            req = Net::HTTP::Post.new(uri.path)
+            req = Net::HTTP::Post.new(uri.request_uri)
             req.set_form_data(data)
           when :json
-            req = Net::HTTP::Post.new(uri.path)
+            req = Net::HTTP::Post.new(uri.request_uri)
             req.body = data.to_json
         end
 
@@ -63,7 +63,7 @@ def notify(message, time, priority, category, host)
             self.info = "failed to send webhook to #{arg(:url)}: #{res.error!}"
         end
       rescue Object = e
-        applog(nil, :info, "failed to send email to #{arg(:url)}: #{e.message}")
+        applog(nil, :info, "failed to send webhook to #{arg(:url)}: #{e.message}")
         applog(nil, :debug, e.backtrace.join("\n"))
       end
 </diff>
				</file>
				<file>
					<file_name>test/test_webhook.rb</file_name>
					<diff>@@ -12,4 +12,11 @@ def test_notify
     @webhook.notify('msg', Time.now, 'prio', 'cat', 'host')
     assert_equal "sent webhook to http://example.com/switch", @webhook.info
   end
+
+  def test_notify_with_url_containing_query_parameters
+    @webhook.url = 'http://example.com/switch?api_key=123'
+    Net::HTTP::Post.expects(:new).with('/switch?api_key=123')
+
+    @webhook.notify('msg', Time.now, 'prio', 'cat', 'host')
+  end
 end</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>0ca8e350f4901ad1bcc2208a8bf4bb7d5254bbad</sha>
			<message>Updated Webook to allow url's with query parameters to work as expected</message>
			<author_name>Ash McKenzie</author_name>
			<author_date>2014-03-01T02:55:44Z</author_date>
			<author_email>ash@greenworm.com.au</author_email>
			<committer_name>Ash McKenzie</committer_name>
			<committer_date>2014-03-01T02:55:44Z</committer_date>
			<committer_email>ash@greenworm.com.au</committer_email>
			<files>
				<file>
					<file_name>lib/god/contacts/webhook.rb</file_name>
					<diff>@@ -47,10 +47,10 @@ def notify(message, time, priority, category, host)
 
         case arg(:format)
           when :form
-            req = Net::HTTP::Post.new(uri.path)
+            req = Net::HTTP::Post.new(uri.request_uri)
             req.set_form_data(data)
           when :json
-            req = Net::HTTP::Post.new(uri.path)
+            req = Net::HTTP::Post.new(uri.request_uri)
             req.body = data.to_json
         end
 </diff>
				</file>
				<file>
					<file_name>test/test_webhook.rb</file_name>
					<diff>@@ -12,4 +12,11 @@ def test_notify
     @webhook.notify('msg', Time.now, 'prio', 'cat', 'host')
     assert_equal "sent webhook to http://example.com/switch", @webhook.info
   end
+
+  def test_notify_with_url_containing_query_parameters
+    @webhook.url = 'http://example.com/switch?api_key=123'
+    Net::HTTP::Post.expects(:new).with('/switch?api_key=123')
+
+    @webhook.notify('msg', Time.now, 'prio', 'cat', 'host')
+  end
 end</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>073dee7a24afbef4ab6243a8c52f008e5961992c</sha>
			<message>Webook failure message referred incorrectly to email</message>
			<author_name>Ash McKenzie</author_name>
			<author_date>2014-03-01T02:44:39Z</author_date>
			<author_email>ash@greenworm.com.au</author_email>
			<committer_name>Ash McKenzie</committer_name>
			<committer_date>2014-03-01T02:44:39Z</committer_date>
			<committer_email>ash@greenworm.com.au</committer_email>
			<files>
				<file>
					<file_name>lib/god/contacts/webhook.rb</file_name>
					<diff>@@ -63,7 +63,7 @@ def notify(message, time, priority, category, host)
             self.info = "failed to send webhook to #{arg(:url)}: #{res.error!}"
         end
       rescue Object = e
-        applog(nil, :info, "failed to send email to #{arg(:url)}: #{e.message}")
+        applog(nil, :info, "failed to send webhook to #{arg(:url)}: #{e.message}")
         applog(nil, :debug, e.backtrace.join("\n"))
       end
 </diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>9de45fd6278d061528ad0d2ce908923c358d47c2</sha>
			<message>Merge pull request #103 from giraffi/log-reopen

When caught USR1,  reopen log file if defined.</message>
			<author_name>Eric Lindvall</author_name>
			<author_date>2013-12-16T18:11:32Z</author_date>
			<author_email>eric@5stops.com</author_email>
			<committer_name>Eric Lindvall</committer_name>
			<committer_date>2013-12-16T18:11:32Z</committer_date>
			<committer_email>eric@5stops.com</committer_email>
			<files>
				<file>
					<file_name>lib/god/cli/run.rb</file_name>
					<diff>@@ -83,6 +83,8 @@ def run_in_front
       def run_daemonized
         # trap and ignore SIGHUP
         Signal.trap('HUP') {}
+        # trap and log-reopen SIGUSR1
+        Signal.trap('USR1') { setup_logging }
 
         pid = fork do
           begin</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>b26115bcb41ad8e2f710ccd1a73b0542d43d2233</sha>
			<message>Release 0.13.3</message>
			<author_name>Eric Lindvall</author_name>
			<author_date>2013-09-25T19:43:00Z</author_date>
			<author_email>eric@5stops.com</author_email>
			<committer_name>Eric Lindvall</committer_name>
			<committer_date>2013-09-25T19:43:00Z</committer_date>
			<committer_email>eric@5stops.com</committer_email>
			<files>
				<file>
					<file_name>History.txt</file_name>
					<diff>@@ -1,3 +1,9 @@
+== 0.13.3 / 2013-09-25
+  * Minor Enhancements
+    * Invoke commands for all watchers
+    * Airbrake reporter
+    * Improvements to socket responding condition
+
 == 0.13.2 / 2013-02-26
   * Minor Enhancements
     * Added file_touched condition (#86)</diff>
				</file>
				<file>
					<file_name>god.gemspec</file_name>
					<diff>@@ -3,8 +3,8 @@ Gem::Specification.new do |s|
   s.required_rubygems_version = Gem::Requirement.new("= 0") if s.respond_to? :required_rubygems_version=
 
   s.name = 'god'
-  s.version = '0.13.2'
-  s.date = '2013-02-26'
+  s.version = '0.13.3'
+  s.date = '2013-09-25'
 
   s.summary = "Process monitoring framework."
   s.description = "An easy to configure, easy to extend monitoring framework written in Ruby."
@@ -80,6 +80,7 @@ Gem::Specification.new do |s|
     lib/god/conditions/tries.rb
     lib/god/configurable.rb
     lib/god/contact.rb
+    lib/god/contacts/airbrake.rb
     lib/god/contacts/campfire.rb
     lib/god/contacts/email.rb
     lib/god/contacts/jabber.rb</diff>
				</file>
				<file>
					<file_name>lib/god.rb</file_name>
					<diff>@@ -157,7 +157,7 @@ def safe_attr_accessor(*args)
 
 module God
   # The String version number for this package.
-  VERSION = '0.13.2'
+  VERSION = '0.13.3'
 
   # The Integer number of lines of backlog to keep for the logger.
   LOG_BUFFER_SIZE_DEFAULT = 100</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>f0866e9dfaeb93cdfa1bf8d1dc51d0d17f8e194e</sha>
			<message>Fix tests</message>
			<author_name>Eric Lindvall</author_name>
			<author_date>2013-07-05T01:22:43Z</author_date>
			<author_email>eric@5stops.com</author_email>
			<committer_name>Eric Lindvall</committer_name>
			<committer_date>2013-07-05T01:22:43Z</committer_date>
			<committer_email>eric@5stops.com</committer_email>
			<files>
				<file>
					<file_name>god.gemspec</file_name>
					<diff>@@ -36,7 +36,7 @@ Gem::Specification.new do |s|
   s.add_development_dependency('gollum', '~ 1.3.1')
   s.add_development_dependency('airbrake', '~ 3.1.7')
   s.add_development_dependency('nokogiri', '~ 1.5.0')
-
+  s.add_development_dependency('activesupport', [ '= 2.3.10', ' 4.0.0' ])
   # = MANIFEST =
   s.files = %w[
     Announce.txt</diff>
				</file>
				<file>
					<file_name>lib/god/event_handler.rb</file_name>
					<diff>@@ -56,7 +56,7 @@ def self.watching_pid?(pid)
     end
 
     def self.start
-      Thread.new do
+      @@thread = Thread.new do
         loop do
           begin
             @@handler.handle_events
@@ -72,6 +72,10 @@ def self.start
       @@loaded = self.operational?
     end
 
+    def self.stop
+      @@thread.kill if @@thread
+    end
+
     def self.operational?
       com = [false]
 </diff>
				</file>
				<file>
					<file_name>test/helper.rb</file_name>
					<diff>@@ -96,17 +96,25 @@ def silence_warnings
   $VERBOSE = old_verbose
 end
 
-LOG.instance_variable_set(:@io, StringIO.new('/dev/null'))
+LOG.instance_variable_set(:@io, StringIO.new())
 
-module Kernel
-  def abort(text)
-    raise SystemExit, text
-  end
-  def exit(code)
-    raise SystemExit, "Exit code: #{code}"
-  end
+def output_logs
+  io = LOG.instance_variable_get(:@io)
+  LOG.instance_variable_set(:@io, $stderr)
+  yield
+ensure
+  LOG.instance_variable_set(:@io, io)
 end
 
+# module Kernel
+#   def abort(text)
+#     raise SystemExit, text
+#   end
+#   def exit(code)
+#     raise SystemExit, "Exit code: #{code}"
+#   end
+# end
+
 module Test::Unit::Assertions
   def assert_abort
     assert_raise SystemExit do</diff>
				</file>
				<file>
					<file_name>test/test_condition.rb</file_name>
					<diff>@@ -23,6 +23,8 @@ def test_generate_should_abort_on_event_condition_without_loaded_event_system
       God::EventHandler.start
       Condition.generate(:process_exits, nil).class
     end
+  ensure
+    God::EventHandler.stop
   end
 
   def test_generate_should_return_a_good_error_message_for_invalid_types</diff>
				</file>
				<file>
					<file_name>test/test_process.rb</file_name>
					<diff>@@ -59,7 +59,9 @@ def test_valid_should_return_true_if_uid_does_not_exists
   def test_valid_should_return_true_if_gid_exists
     @p.start = 'qux'
     @p.log = '/tmp/foo.log'
-    @p.gid = 'mail'
+    @p.gid = Etc.getgrgid(::Process.gid).name
+
+    ::Process.stubs(:groups=)
 
     assert @p.valid?
   end
@@ -104,12 +106,16 @@ def test_valid_should_return_false_with_bogus_chroot
 
   def test_valid_should_return_true_with_chroot_and_valid_log
     @p.start = 'qux'
-    @p.chroot = '/tmp'
-    @p.log = '/tmp/foo.log'
+    @p.chroot = Dir.pwd
+    @p.log = "#{@p.chroot}/foo.log"
+
+    File.expects(:exist?).with(@p.chroot).returns(true)
+    File.expects(:exist?).with(@p.log).returns(true)
+    File.expects(:exist?).with("#{@p.chroot}/dev/null").returns(true)
+
+    File.stubs(:writable?).with('/foo.log').returns(true)
 
-    File.expects(:exist?).with('/tmp').returns(true)
-    File.expects(:exist?).with('/tmp/foo.log').returns(true)
-    File.expects(:exist?).with('/tmp/dev/null').returns(true)
+    ::Dir.stubs(:chroot)
 
     assert @p.valid?
   end</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>5968f503ca12e46104b4ee5021c182f5460476d8</sha>
			<message>Merge pull request #138 from adamkleingit/master

God stop/start/restart without argument, to monitor all processes</message>
			<author_name>Eric Lindvall</author_name>
			<author_date>2013-07-05T00:46:31Z</author_date>
			<author_email>eric@5stops.com</author_email>
			<committer_name>Eric Lindvall</committer_name>
			<committer_date>2013-07-05T00:46:31Z</committer_date>
			<committer_email>eric@5stops.com</committer_email>
			<files>
				<file>
					<file_name>doc/god.asciidoc</file_name>
					<diff>@@ -642,6 +642,19 @@ $ sudo god stop mongrels
 /////////////////////////////////////////////////////////////////////////////
 /////////////////////////////////////////////////////////////////////////////
 
+Invoke Commands for all watches
+-------------------------------
+
+If you need to invoke a command (e.g. Stop / Start / Restart) on all watches
+you can simply omit the second parameter. For example, to start all watches:
+
+```terminal
+$ sudo god start
+```
+
+/////////////////////////////////////////////////////////////////////////////
+/////////////////////////////////////////////////////////////////////////////
+
 Redirecting STDOUT and STDERR of your Process
 ---------------------------------------------
 </diff>
				</file>
				<file>
					<file_name>lib/god.rb</file_name>
					<diff>@@ -438,16 +438,23 @@ def self.uncontact(contact)
     end
   end
 
+  def self.watches_by_name(name)
+    case name 
+      when "", nil then self.watches.values.dup
+      else Array(self.watches[name] || self.groups[name]).dup
+    end
+  end
+
   # Control the lifecycle of the given task(s).
   #
-  # name    - The String name of a task/group.
+  # name    - The String name of a task/group. If empty, invokes command for all tasks.
   # command - The String command to run. Valid commands are:
   #           "start", "monitor", "restart", "stop", "unmonitor", "remove".
   #
   # Returns an Array of String task names affected by the command.
   def self.control(name, command)
     # Get the list of items.
-    items = Array(self.watches[name] || self.groups[name]).dup
+    items = self.watches_by_name(name)
 
     jobs = []
 
@@ -528,7 +535,7 @@ def self.status
   #
   # Returns an Array of String names of the tasks affected.
   def self.signal(name, signal)
-    items = Array(self.watches[name] || self.groups[name]).dup
+    items = watches_by_name(name)
     jobs = []
     items.each { |w| jobs  Thread.new { w.signal(signal) } }
     jobs.each { |j| j.join }</diff>
				</file>
				<file>
					<file_name>test/test_god.rb</file_name>
					<diff>@@ -331,12 +331,72 @@ def test_control_should_operate_on_each_watch_in_group
       w.group = 'bar'
     end
 
+    God.watch do |w|
+      w.name = 'bar1'
+      w.start = 'go'
+      w.group = 'foo'
+    end
+
     God.watches['foo1'].expects(:monitor)
     God.watches['foo2'].expects(:monitor)
+    God.watches['bar1'].expects(:monitor).never
 
     God.control('bar', 'start')
   end
 
+  def test_control_should_operate_on_all_watches_on_nil
+    God.watch do |w|
+      w.name = 'foo1'
+      w.start = 'go'
+      w.group = 'foo'
+    end
+
+    God.watch do |w|
+      w.name = 'foo2'
+      w.start = 'go'
+      w.group = 'foo'
+    end
+
+    God.watch do |w|
+      w.name = 'bar1'
+      w.start = 'go'
+      w.group = 'bar'
+    end
+
+    God.watches['foo1'].expects(:monitor)
+    God.watches['foo2'].expects(:monitor)
+    God.watches['bar1'].expects(:monitor)
+
+    God.control(nil, 'start')
+  end
+
+  def test_control_should_operate_on_all_watches_on_empty_string
+    God.watch do |w|
+      w.name = 'foo1'
+      w.start = 'go'
+      w.group = 'foo'
+    end
+
+    God.watch do |w|
+      w.name = 'foo2'
+      w.start = 'go'
+      w.group = 'foo'
+    end
+
+    God.watch do |w|
+      w.name = 'bar1'
+      w.start = 'go'
+      w.group = 'bar'
+    end
+
+    God.watches['foo1'].expects(:monitor)
+    God.watches['foo2'].expects(:monitor)
+    God.watches['bar1'].expects(:monitor)
+
+    God.control('', 'start')
+  end
+
+
   # stop_all
 
   # terminate</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>845d8ab62857713c04460e7bbdb31ce9956a8328</sha>
			<message>Try to make 1.9 tests exit properly</message>
			<author_name>Eric Lindvall</author_name>
			<author_date>2013-07-03T17:53:07Z</author_date>
			<author_email>eric@5stops.com</author_email>
			<committer_name>Eric Lindvall</committer_name>
			<committer_date>2013-07-03T17:53:07Z</committer_date>
			<committer_email>eric@5stops.com</committer_email>
			<files>
				<file>
					<file_name>test/helper.rb</file_name>
					<diff>@@ -143,3 +143,17 @@ def bypass
     Bypass.new(self)
   end
 end
+
+# Make sure we return valid exit codes
+if defined?(RUBY_ENGINE) && RUBY_ENGINE == "ruby" && RUBY_VERSION = "1.9"
+  module Kernel
+    alias :__at_exit :at_exit
+    def at_exit(&block)
+      __at_exit do
+        exit_status = $!.status if $!.is_a?(SystemExit)
+        block.call
+        exit exit_status if exit_status
+      end
+    end
+  end
+end</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>f4e7f9f4fa30299ee5e6ed92df6f3223748a43d0</sha>
			<message>Pick a group that hopefully exists on travis-ci</message>
			<author_name>Eric Lindvall</author_name>
			<author_date>2013-07-03T17:46:36Z</author_date>
			<author_email>eric@5stops.com</author_email>
			<committer_name>Eric Lindvall</committer_name>
			<committer_date>2013-07-03T17:46:54Z</committer_date>
			<committer_email>eric@5stops.com</committer_email>
			<files>
				<file>
					<file_name>test/test_process.rb</file_name>
					<diff>@@ -59,7 +59,7 @@ def test_valid_should_return_true_if_uid_does_not_exists
   def test_valid_should_return_true_if_gid_exists
     @p.start = 'qux'
     @p.log = '/tmp/foo.log'
-    @p.gid = 'wheel'
+    @p.gid = 'mail'
 
     assert @p.valid?
   end</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>1af40f201d1c7070a73554b4c225301035b50812</sha>
			<message>Added monitor (start/stop/etc.) all tasks by not specifying parameter, e.g. god stop. Added proper testcases, updated docs</message>
			<author_name>adam klein</author_name>
			<author_date>2013-06-15T09:17:54Z</author_date>
			<author_email>adamklein.mail@gmail.com</author_email>
			<committer_name>adam klein</committer_name>
			<committer_date>2013-06-20T06:35:43Z</committer_date>
			<committer_email>adamklein.mail@gmail.com</committer_email>
			<files>
				<file>
					<file_name>doc/god.asciidoc</file_name>
					<diff>@@ -642,6 +642,19 @@ $ sudo god stop mongrels
 /////////////////////////////////////////////////////////////////////////////
 /////////////////////////////////////////////////////////////////////////////
 
+Invoke Commands for all watches
+-------------------------------
+
+If you need to invoke a command (e.g. Stop / Start / Restart) on all watches
+you can simply omit the second parameter. For example, to start all watches:
+
+```terminal
+$ sudo god start
+```
+
+/////////////////////////////////////////////////////////////////////////////
+/////////////////////////////////////////////////////////////////////////////
+
 Redirecting STDOUT and STDERR of your Process
 ---------------------------------------------
 </diff>
				</file>
				<file>
					<file_name>lib/god.rb</file_name>
					<diff>@@ -438,16 +438,23 @@ def self.uncontact(contact)
     end
   end
 
+  def self.watches_by_name(name)
+    case name 
+      when "", nil then self.watches.values.dup
+      else Array(self.watches[name] || self.groups[name]).dup
+    end
+  end
+
   # Control the lifecycle of the given task(s).
   #
-  # name    - The String name of a task/group.
+  # name    - The String name of a task/group. If empty, invokes command for all tasks.
   # command - The String command to run. Valid commands are:
   #           "start", "monitor", "restart", "stop", "unmonitor", "remove".
   #
   # Returns an Array of String task names affected by the command.
   def self.control(name, command)
     # Get the list of items.
-    items = Array(self.watches[name] || self.groups[name]).dup
+    items = self.watches_by_name(name)
 
     jobs = []
 
@@ -528,7 +535,7 @@ def self.status
   #
   # Returns an Array of String names of the tasks affected.
   def self.signal(name, signal)
-    items = Array(self.watches[name] || self.groups[name]).dup
+    items = watches_by_name(name)
     jobs = []
     items.each { |w| jobs  Thread.new { w.signal(signal) } }
     jobs.each { |j| j.join }</diff>
				</file>
				<file>
					<file_name>test/test_god.rb</file_name>
					<diff>@@ -331,12 +331,72 @@ def test_control_should_operate_on_each_watch_in_group
       w.group = 'bar'
     end
 
+    God.watch do |w|
+      w.name = 'bar1'
+      w.start = 'go'
+      w.group = 'foo'
+    end
+
     God.watches['foo1'].expects(:monitor)
     God.watches['foo2'].expects(:monitor)
+    God.watches['bar1'].expects(:monitor).never
 
     God.control('bar', 'start')
   end
 
+  def test_control_should_operate_on_all_watches_on_nil
+    God.watch do |w|
+      w.name = 'foo1'
+      w.start = 'go'
+      w.group = 'foo'
+    end
+
+    God.watch do |w|
+      w.name = 'foo2'
+      w.start = 'go'
+      w.group = 'foo'
+    end
+
+    God.watch do |w|
+      w.name = 'bar1'
+      w.start = 'go'
+      w.group = 'bar'
+    end
+
+    God.watches['foo1'].expects(:monitor)
+    God.watches['foo2'].expects(:monitor)
+    God.watches['bar1'].expects(:monitor)
+
+    God.control(nil, 'start')
+  end
+
+  def test_control_should_operate_on_all_watches_on_empty_string
+    God.watch do |w|
+      w.name = 'foo1'
+      w.start = 'go'
+      w.group = 'foo'
+    end
+
+    God.watch do |w|
+      w.name = 'foo2'
+      w.start = 'go'
+      w.group = 'foo'
+    end
+
+    God.watch do |w|
+      w.name = 'bar1'
+      w.start = 'go'
+      w.group = 'bar'
+    end
+
+    God.watches['foo1'].expects(:monitor)
+    God.watches['foo2'].expects(:monitor)
+    God.watches['bar1'].expects(:monitor)
+
+    God.control('', 'start')
+  end
+
+
   # stop_all
 
   # terminate</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>a9ce556a2eb026e8362f62a4e71b423f65a9c0f9</sha>
			<message>Comment out tests that don't seem to make sense</message>
			<author_name>Eric Lindvall</author_name>
			<author_date>2013-06-18T22:47:01Z</author_date>
			<author_email>eric@5stops.com</author_email>
			<committer_name>Eric Lindvall</committer_name>
			<committer_date>2013-06-18T22:47:01Z</committer_date>
			<committer_email>eric@5stops.com</committer_email>
			<files>
				<file>
					<file_name>test/helper.rb</file_name>
					<diff>@@ -100,10 +100,10 @@ def silence_warnings
 
 module Kernel
   def abort(text)
-    raise SystemExit
+    raise SystemExit, text
   end
   def exit(code)
-    raise SystemExit
+    raise SystemExit, "Exit code: #{code}"
   end
 end
 </diff>
				</file>
				<file>
					<file_name>test/test_event_handler.rb</file_name>
					<diff>@@ -72,9 +72,11 @@ def teardown
   end
 end
 
-class TestEventHandlerOperational  Test::Unit::TestCase
-  def test_operational
-    God::EventHandler.start
-    assert God::EventHandler.loaded?
-  end
-end
+# This doesn't currently work:
+#
+# class TestEventHandlerOperational  Test::Unit::TestCase
+#   def test_operational
+#     God::EventHandler.start
+#     assert God::EventHandler.loaded?
+#   end
+# end</diff>
				</file>
				<file>
					<file_name>test/test_metric.rb</file_name>
					<diff>@@ -41,14 +41,16 @@ def test_poll_condition_should_abort_if_no_interval_and_no_watch_interval
     end
   end
 
-  def test_condition_should_allow_generation_of_subclasses_of_poll_or_event
-    metric = Metric.new(stub(:name = 'foo', :interval = 10), nil)
-
-    assert_nothing_raised do
-      metric.condition(:fake_poll_condition)
-      metric.condition(:fake_event_condition)
-    end
-  end
+  # This doesn't currently work:
+  #
+  # def test_condition_should_allow_generation_of_subclasses_of_poll_or_event
+  #   metric = Metric.new(stub(:name = 'foo', :interval = 10), nil)
+  #
+  #   assert_nothing_raised do
+  #     metric.condition(:fake_poll_condition)
+  #     metric.condition(:fake_event_condition)
+  #   end
+  # end
 
   def test_condition_should_abort_if_not_subclass_of_poll_or_event
     metric = Metric.new(stub(:name = 'foo', :interval = 10), nil)</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>d9f38e73384b2bc2a724131742a8dcd104ec9786</sha>
			<message>A little more dependency cleanup</message>
			<author_name>Eric Lindvall</author_name>
			<author_date>2013-06-15T05:05:20Z</author_date>
			<author_email>eric@5stops.com</author_email>
			<committer_name>Eric Lindvall</committer_name>
			<committer_date>2013-06-15T05:05:20Z</committer_date>
			<committer_email>eric@5stops.com</committer_email>
			<files>
				<file>
					<file_name>god.gemspec</file_name>
					<diff>@@ -24,7 +24,7 @@ Gem::Specification.new do |s|
   s.extra_rdoc_files = %w[README.md]
 
   s.add_development_dependency('json', '~ 1.6')
-  s.add_development_dependency('rake', '~ 0.9')
+  s.add_development_dependency('rake')
   s.add_development_dependency('rdoc', '~ 3.10')
   s.add_development_dependency('twitter', '~ 4.0')
   s.add_development_dependency('prowly', '~ 0.3')</diff>
				</file>
				<file>
					<file_name>test/helper.rb</file_name>
					<diff>@@ -25,7 +25,7 @@
 end
 
 begin
-  require 'mocha'
+  require 'mocha/setup'
 rescue LoadError
   unless gems ||= false
     require 'rubygems'</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>10be3f7671b56af03e7c569b067ecb128622a40b</sha>
			<message>Pin nokogiri to a version that works with ruby 1.8</message>
			<author_name>Eric Lindvall</author_name>
			<author_date>2013-06-15T04:57:18Z</author_date>
			<author_email>eric@5stops.com</author_email>
			<committer_name>Eric Lindvall</committer_name>
			<committer_date>2013-06-15T04:57:18Z</committer_date>
			<committer_email>eric@5stops.com</committer_email>
			<files>
				<file>
					<file_name>god.gemspec</file_name>
					<diff>@@ -35,6 +35,7 @@ Gem::Specification.new do |s|
   s.add_development_dependency('mocha', '~ 0.10')
   s.add_development_dependency('gollum', '~ 1.3.1')
   s.add_development_dependency('airbrake', '~ 3.1.7')
+  s.add_development_dependency('nokogiri', '~ 1.5.0')
 
   # = MANIFEST =
   s.files = %w[</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>50e5ebef13af18f3e90ee9b7bb127408d7fb2387</sha>
			<message>Update twitter gem</message>
			<author_name>Eric Lindvall</author_name>
			<author_date>2013-06-15T04:53:57Z</author_date>
			<author_email>eric@5stops.com</author_email>
			<committer_name>Eric Lindvall</committer_name>
			<committer_date>2013-06-15T04:53:57Z</committer_date>
			<committer_email>eric@5stops.com</committer_email>
			<files>
				<file>
					<file_name>Gemfile</file_name>
					<diff>@@ -1,2 +1,2 @@
-source :rubygems
+source 'https://rubygems.org'
 gemspec</diff>
				</file>
				<file>
					<file_name>god.gemspec</file_name>
					<diff>@@ -26,7 +26,7 @@ Gem::Specification.new do |s|
   s.add_development_dependency('json', '~ 1.6')
   s.add_development_dependency('rake', '~ 0.9')
   s.add_development_dependency('rdoc', '~ 3.10')
-  s.add_development_dependency('twitter', '~ 2.0')
+  s.add_development_dependency('twitter', '~ 4.0')
   s.add_development_dependency('prowly', '~ 0.3')
   s.add_development_dependency('xmpp4r', '~ 0.5')
   s.add_development_dependency('dike', '~ 0.0.3')</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>93088307135cb54a2fbfc725d709454277b72047</sha>
			<message>Remove dependency on snapshot gem</message>
			<author_name>Eric Lindvall</author_name>
			<author_date>2013-06-15T04:51:56Z</author_date>
			<author_email>eric@5stops.com</author_email>
			<committer_name>Eric Lindvall</committer_name>
			<committer_date>2013-06-15T04:51:56Z</committer_date>
			<committer_email>eric@5stops.com</committer_email>
			<files>
				<file>
					<file_name>god.gemspec</file_name>
					<diff>@@ -30,7 +30,6 @@ Gem::Specification.new do |s|
   s.add_development_dependency('prowly', '~ 0.3')
   s.add_development_dependency('xmpp4r', '~ 0.5')
   s.add_development_dependency('dike', '~ 0.0.3')
-  s.add_development_dependency('snapshot', '~ 1.0')
   s.add_development_dependency('rcov', '~ 0.9')
   s.add_development_dependency('daemons', '~ 1.1')
   s.add_development_dependency('mocha', '~ 0.10')</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>67319e695f5f22053279e230e1fcbb79c0aaa4c2</sha>
			<message>Add a travis config</message>
			<author_name>Eric Lindvall</author_name>
			<author_date>2013-06-15T04:47:39Z</author_date>
			<author_email>eric@5stops.com</author_email>
			<committer_name>Eric Lindvall</committer_name>
			<committer_date>2013-06-15T04:47:39Z</committer_date>
			<committer_email>eric@5stops.com</committer_email>
			<files>
				<file>
					<file_name>.travis.yml</file_name>
					<diff>@@ -0,0 +1,6 @@
+language: ruby
+rvm:
+  - 1.8.7
+  - 1.9.2
+  - 1.9.3
+  - ree</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>72f66e67958d3914f5962b0d9482da62f7667fde</sha>
			<message>Merge pull request #137 from danshultz/patch-1

process running condition informs running</message>
			<author_name>Eric Lindvall</author_name>
			<author_date>2013-06-12T19:55:30Z</author_date>
			<author_email>eric@5stops.com</author_email>
			<committer_name>Eric Lindvall</committer_name>
			<committer_date>2013-06-12T19:55:30Z</committer_date>
			<committer_email>eric@5stops.com</committer_email>
			<files>
				<file>
					<file_name>lib/god/conditions/process_running.rb</file_name>
					<diff>@@ -46,6 +46,7 @@ def test
         active = pid && System::Process.new(pid).exists?
 
         if (self.running && active)
+          self.info.concat(["process is running"])
           true
         elsif (!self.running && !active)
           self.info.concat(["process is not running"])</diff>
				</file>
			</files>
		</commit>
	</commits>
	<actual_files>
		<actual_file>
			<filename>.gitignore</filename>
			<content>rdoc
coverage
pkg
*.log
logs
*.rbc
*~
.*.sw?
.DS_Store
Gemfile.lock
bbin/
.bundle
site/index.html
gh-pages
</content>
		</actual_file>
		<actual_file>
			<filename>.travis.yml</filename>
			<content>language: ruby
rvm:
  - 1.8.7
  - 1.9.2
  - 1.9.3
  - ree
</content>
		</actual_file>
		<actual_file>
			<filename>Announce.txt</filename>
			<content>Subject: [ANN] god 0.6.0 released (and mailing list)

!!!NEW MAILING LIST!!! We now have a mailing list at http://groups.google.com/group/god-rb

This release is primarily focused on increased stability, robustness, and code cleanliness.

The last release (0.5.0) switched from TCP sockets to Unix Domain Sockets for the CLI tools. There were some issues regarding file descriptors that would cause god to hang when restarting (the unix socket was being held open by spawned processes). These problems are all fixed in 0.6.0. You may need to kill any processes that were started under god 0.5.0 when you upgrade to 0.6.0 (you will only need to do this once during the upgrade process).

More attention is now paid to Syslogging behavior.

God will delete its own PID file when terminated via a user request.

A new command line option now allows you to check whether your installation properly handles events (sometimes the C extension will compile ok, but still not support events. Gentoo, I'm looking at you). Run `god check` to see an attempt to use the event system. It will tell you if your installation does not support events.

A watch can now be removed entirely at runtime using `god remove watch name`.

A new condition DiskUsage allows you to check the available disk space on a given volume.

Updated documentation is now available on the website:

  http://god.rubyforge.org/


WHAT IS GOD?

God is an easy to configure, easy to extend monitoring framework written in Ruby.

Keeping your server processes and tasks running should be a simple part of your deployment process. God aims to be the simplest, most powerful monitoring application available.


DISCLAIMER

God is still beta so I do not yet recommend you use it for mission critical tasks. We are using it at Powerset, Inc. to monitor our public facing applications, but then, we're daring fellows.


INSTALL

sudo gem install god


FEATURES

* Config file is written in Ruby
* Easily write your own custom conditions in Ruby
* Supports both poll and event based conditions
* Different poll conditions can have different intervals
* Easily control non-daemonized processes


EXAMPLE

The easiest way to understand how god will make your life better is by looking at a sample config file. The following configuration file is what I use at gravatar.com to keep the mongrels running:

# run with:  god -c /path/to/gravatar.god
#
# This is the actual config file used to keep the mongrels of
# gravatar.com running.

RAILS_ROOT = "/Users/tom/dev/gravatar2"

%w{8200 8201 8202}.each do |port|
  God.watch do |w|
    w.name = "gravatar2-mongrel-#{port}"
    w.interval = 30.seconds # default
    w.start = "mongrel_rails start -c #{RAILS_ROOT} -p #{port} \
      -P #{RAILS_ROOT}/log/mongrel.#{port}.pid  -d"
    w.stop = "mongrel_rails stop -P #{RAILS_ROOT}/log/mongrel.#{port}.pid"
    w.restart = "mongrel_rails restart -P #{RAILS_ROOT}/log/mongrel.#{port}.pid"
    w.start_grace = 10.seconds
    w.restart_grace = 10.seconds
    w.pid_file = File.join(RAILS_ROOT, "log/mongrel.#{port}.pid")

    w.behavior(:clean_pid_file)

    w.start_if do |start|
      start.condition(:process_running) do |c|
        c.interval = 5.seconds
        c.running = false
      end
    end

    w.restart_if do |restart|
      restart.condition(:memory_usage) do |c|
        c.above = 150.megabytes
        c.times = [3, 5] # 3 out of 5 intervals
      end

      restart.condition(:cpu_usage) do |c|
        c.above = 50.percent
        c.times = 5
      end
    end

    # lifecycle
    w.lifecycle do |on|
      on.condition(:flapping) do |c|
        c.to_state = [:start, :restart]
        c.times = 5
        c.within = 5.minute
        c.transition = :unmonitored
        c.retry_in = 10.minutes
        c.retry_times = 5
        c.retry_within = 2.hours
      end
    end
  end
end


DOCS

Detailed documentation is available at http://god.rubyforge.org/


CHANGES

== 0.6.0 / 2007-12-4

* Minor Enhancement
  * Move Syslog calls into God::Logger and clean up all calling code
  * Remove god's pid file on user requested termination
  * Better handling and cleanup of DRb server's unix domain socket
  * Allow shorthand for requesting a god log
  * Add `god check` to make it easier to diagnose event problems
  * Refactor god binary into class/method structure
  * Implement `god remove` to remove a Task altogether
* New Conditions
  * DiskUsage  PollCondition - trigger if disk usage is above limit on mount [Rudy Desjardins]



AUTHORS

Tom Preston-Werner
Kevin Clark
</content>
		</actual_file>
		<actual_file>
			<filename>Gemfile</filename>
			<content>source 'https://rubygems.org'
gemspec

gem 'redcarpet', ' 3.0.0'
gem 'sanitize', '2.0.3'
</content>
		</actual_file>
		<actual_file>
			<filename>god.gemspec</filename>
			<content>Gem::Specification.new do |s|
  s.specification_version = 2 if s.respond_to? :specification_version=
  s.required_rubygems_version = Gem::Requirement.new("= 0") if s.respond_to? :required_rubygems_version=

  s.name = 'god'
  s.version = '0.13.4'
  s.date = '2014-03-05'

  s.summary = "Process monitoring framework."
  s.description = "An easy to configure, easy to extend monitoring framework written in Ruby."

  s.authors = ["Tom Preston-Werner", "Kevin Clark", "Eric Lindvall"]
  s.email = 'god-rb@googlegroups.com'
  s.homepage = 'http://god.rubyforge.org/'

  s.rubyforge_project = 'god'
  s.rubygems_version = '1.3.5'
  s.require_paths = %w[lib ext]

  s.executables = ["god"]
  s.extensions = %w[ext/god/extconf.rb]

  s.rdoc_options = ["--charset=UTF-8"]
  s.extra_rdoc_files = %w[README.md]

  s.add_development_dependency('json', '~ 1.6')
  s.add_development_dependency('rake')
  s.add_development_dependency('rdoc', '~ 3.10')
  s.add_development_dependency('twitter', '~ 4.0')
  s.add_development_dependency('prowly', '~ 0.3')
  s.add_development_dependency('xmpp4r', '~ 0.5')
  s.add_development_dependency('dike', '~ 0.0.3')
  s.add_development_dependency('rcov', '~ 0.9')
  s.add_development_dependency('daemons', '~ 1.1')
  s.add_development_dependency('mocha', '~ 0.10')
  s.add_development_dependency('gollum', '~ 1.3.1')
  s.add_development_dependency('airbrake', '~ 3.1.7')
  s.add_development_dependency('nokogiri', '~ 1.5.0')
  s.add_development_dependency('activesupport', [ '= 2.3.10', ' 4.0.0' ])
  # = MANIFEST =
  s.files = %w[
    Announce.txt
    Gemfile
    History.txt
    LICENSE
    README.md
    Rakefile
    bin/god
    doc/god.asciidoc
    doc/intro.asciidoc
    ext/god/.gitignore
    ext/god/extconf.rb
    ext/god/kqueue_handler.c
    ext/god/netlink_handler.c
    god.gemspec
    lib/god.rb
    lib/god/behavior.rb
    lib/god/behaviors/clean_pid_file.rb
    lib/god/behaviors/clean_unix_socket.rb
    lib/god/behaviors/notify_when_flapping.rb
    lib/god/cli/command.rb
    lib/god/cli/run.rb
    lib/god/cli/version.rb
    lib/god/compat19.rb
    lib/god/condition.rb
    lib/god/conditions/always.rb
    lib/god/conditions/complex.rb
    lib/god/conditions/cpu_usage.rb
    lib/god/conditions/degrading_lambda.rb
    lib/god/conditions/disk_usage.rb
    lib/god/conditions/file_mtime.rb
    lib/god/conditions/file_touched.rb
    lib/god/conditions/flapping.rb
    lib/god/conditions/http_response_code.rb
    lib/god/conditions/lambda.rb
    lib/god/conditions/memory_usage.rb
    lib/god/conditions/process_exits.rb
    lib/god/conditions/process_running.rb
    lib/god/conditions/socket_responding.rb
    lib/god/conditions/tries.rb
    lib/god/configurable.rb
    lib/god/contact.rb
    lib/god/contacts/airbrake.rb
    lib/god/contacts/campfire.rb
    lib/god/contacts/email.rb
    lib/god/contacts/hipchat.rb
    lib/god/contacts/jabber.rb
    lib/god/contacts/prowl.rb
    lib/god/contacts/scout.rb
    lib/god/contacts/twitter.rb
    lib/god/contacts/webhook.rb
    lib/god/driver.rb
    lib/god/errors.rb
    lib/god/event_handler.rb
    lib/god/event_handlers/dummy_handler.rb
    lib/god/event_handlers/kqueue_handler.rb
    lib/god/event_handlers/netlink_handler.rb
    lib/god/logger.rb
    lib/god/metric.rb
    lib/god/process.rb
    lib/god/registry.rb
    lib/god/simple_logger.rb
    lib/god/socket.rb
    lib/god/sugar.rb
    lib/god/sys_logger.rb
    lib/god/system/portable_poller.rb
    lib/god/system/process.rb
    lib/god/system/slash_proc_poller.rb
    lib/god/task.rb
    lib/god/timeline.rb
    lib/god/trigger.rb
    lib/god/watch.rb
    test/configs/child_events/child_events.god
    test/configs/child_events/simple_server.rb
    test/configs/child_polls/child_polls.god
    test/configs/child_polls/simple_server.rb
    test/configs/complex/complex.god
    test/configs/complex/simple_server.rb
    test/configs/contact/contact.god
    test/configs/contact/simple_server.rb
    test/configs/daemon_events/daemon_events.god
    test/configs/daemon_events/simple_server.rb
    test/configs/daemon_events/simple_server_stop.rb
    test/configs/daemon_polls/daemon_polls.god
    test/configs/daemon_polls/simple_server.rb
    test/configs/degrading_lambda/degrading_lambda.god
    test/configs/degrading_lambda/tcp_server.rb
    test/configs/keepalive/keepalive.god
    test/configs/keepalive/keepalive.rb
    test/configs/lifecycle/lifecycle.god
    test/configs/matias/matias.god
    test/configs/real.rb
    test/configs/running_load/running_load.god
    test/configs/stop_options/simple_server.rb
    test/configs/stop_options/stop_options.god
    test/configs/stress/simple_server.rb
    test/configs/stress/stress.god
    test/configs/task/logs/.placeholder
    test/configs/task/task.god
    test/configs/test.rb
    test/helper.rb
    test/suite.rb
    test/test_airbrake.rb
    test/test_behavior.rb
    test/test_campfire.rb
    test/test_condition.rb
    test/test_conditions_disk_usage.rb
    test/test_conditions_http_response_code.rb
    test/test_conditions_process_running.rb
    test/test_conditions_socket_responding.rb
    test/test_conditions_tries.rb
    test/test_contact.rb
    test/test_driver.rb
    test/test_email.rb
    test/test_event_handler.rb
    test/test_god.rb
    test/test_handlers_kqueue_handler.rb
    test/test_hipchat.rb
    test/test_jabber.rb
    test/test_logger.rb
    test/test_metric.rb
    test/test_process.rb
    test/test_prowl.rb
    test/test_registry.rb
    test/test_socket.rb
    test/test_sugar.rb
    test/test_system_portable_poller.rb
    test/test_system_process.rb
    test/test_task.rb
    test/test_timeline.rb
    test/test_trigger.rb
    test/test_watch.rb
    test/test_webhook.rb
  ]
  # = MANIFEST =

  s.test_files = s.files.select { |path| path =~ /^test\/test_.*\.rb/ }
end
</content>
		</actual_file>
		<actual_file>
			<filename>History.txt</filename>
			<content>== 0.13.4 / 2014-03-05
  * Minor Enhancements
    * Hipchat reporter (#162)
    * Re-open log files on SIGUSR1 (#103)
  * Bug fixes
    * Send query params on webhook reporter (#160)
    * Don't thow an exception when there are problems reading pid file (#164)

== 0.13.3 / 2013-09-25
  * Minor Enhancements
    * Invoke commands for all watchers
    * Airbrake reporter
    * Improvements to socket responding condition

== 0.13.2 / 2013-02-26
  * Minor Enhancements
    * Added file_touched condition (#86)
  * Bug fixes
    * Ensure Ruby 1.9 fixes only apply to 1.9.0 and 1.9.1 (#125)
    * Documentation fixes (#109, #84, #92)

== 0.13.1 / 2012-09-18
  * Minor Changes
    * Prevent auto-loading from bundler by requiring $load_god to require (#97)

== 0.13.0 / 2012-09-17
  * Minor Changes
    * Reduce verbosity of non-failing conditions (#111)

== 0.12.1 / 2012-01-21
  * Bug Fixes
    * Fix undefined variable problem in CLI (#82)

== 0.12.0 / 2012-01-13
  * Minor Enhancements
    * Add umask support
    * Add socket response condition (#25)
    * Don't require tests run as sudo under non-linux systems (#15)
    * Add Bundler support
    * Add keepalive simple conditional setups (#71)
    * Better load command to act upon removed watches (#70)
    * Add support for ssl in http_response_code condition (#36)
    * New documentation at http://godrb.com
  * Bug Fixes
    * Use IO.print instead of IO.puts for thread safety (#35)
    * Fix Slashproc poller for commands with spaces (#31)
    * Various segfault and kernel panic fixes
    * Fix SMTP Auth documentation (#29)
    * Fix a bunch of tests that were failing on Ruby 1.9

== 0.11.0 / 2010-07-01
  * Major Changes
    * Rewrite notification system to be more consistent and flexible.

== 0.10.1 / 2010-05-17
  * Bug Fixes
    * Fix date in gemspec

== 0.10.0 / 2010-05-17
  * Minor Enhancements
    * Add stop_timeout and stop_signal options to Watch
  * Bug Fixes
    * Stop command string was being ignored

== 0.9.0 / 2010-04-03
  * Minor Enhancements
    * Allow kqueue for OpenBSD and NetBSD
    * Add err_log and err_log_cmd
    * Add God.terminate_timeout option
    * Respect --log-level in Syslog
    * Add configuration parameters to set permissions on socket
    * Add Scout contact
    * Add Prowl contact
  * Bug Fixes
    * Fix interleaved log messages
  * Experimental
    * Ruby 1.9 support

== 0.8.0 / 2009-11-30
  * Minor Enhancements
    * Rubygems decontamination
    * Use Monitor instead of Mutex to provide ability to wait with a timeout
    * Only generate log messages when they're being used
    * Remove usage of Thread.critical in DriverEventQueue
    * Update to work with latest bleak-house
    * Cache some frequent lookups to reduce object creation
    * Changing the @io.print call in SimpleLogger to not concatenate
      the formatted results before printing
  * Bug fixes
    * Make sure we don't leak hash slots when processes die
    * Make sure the driver is shutdown on Task#unregister!
    * Fix memory leak when issuing "god load" successfully
    * Fix defunct process

== NOTE
  At this point I will stop giving credit in the history. Look at the author
  and committer in the commit for that info.

== 0.7.22 / 2009-10-29
  * Minor Enhancements
    * Save ARGV so we can get access to it later if we want [github.com/eric]

== 0.7.21 / 2009-10-29
  * Minor Enhancements
    * Cache some frequent lookups to reduce object creation [github.com/eric]
    * Try to make SimpleLogger less leaky [github.com/eric]

== 0.7.20 / 2009-09-24
  * Minor Enhancements
    * Rewrite `god status` command to be not as horrible. Add ability to get
      status for individual tasks.

== 0.7.19 / 2009-09-21
  * Minor Enhancements
    * Teach `god status` to take a task name as a param and return
      an exit code of 0 if all watches are up or a non-zero exit code
      (equal to the number of non-up watches) if they are not.

== 0.7.18 / 2009-09-09
  * Minor Enhancements
    * Better handling of unexpected exceptions in conditions
    * Added support for running processes in a directory other than '/' [github.com/samhendley]
  * Bug Fixes
    * Generate an actual unique identifier for email contact [github.com/underley]

== 0.7.17 / 2009-08-25
  * Bug Fixes
    * Fix the glob and directory config loading for -c option

== 0.7.16 / 2009-08-24
  * Minor Enhancements
    * Better logging for disk_usage condition [github.com/lettherebecode]
  * Bug Fixes
    * Only sleep if driver delay is  0 [github.com/ps2]
    * Rescue Timeout::Error exception due to smtp server timing out [github.com/ps2]
    * Disk usage condition should use `df -P` to prevent line splitting [github.com/mseppae]
    * Always require YAML so binary works on dumb systems

== 0.7.15 / 2009-08-19
  * Minor Enhancements
    * Support SSL Campfire connections [github.com/eric]
    * Allow wildcards in -c configuration file option

== 0.7.14 / 2009-08-10
  * Minor Enhancements
    * Only store log lines when a client wishes to see them
    * Add an lsb-compliant init script into god/init [Woody Peterson]
    * Never require stop command; use default killer if none is specified
  * Bug Fixes
    * Fix redefinition error for time.h and allow it to compile on Ubuntu Edgy [github.com/tbuser]
    * Fix a memory leak in jabber by adding a call to jabber_client.close [github.com/woahdae]
    * Make jabber code manage one connection to make it faster, use less memory,
      and not leak [github.com/woahdae]

== 0.7.13 / 2009-05-04
  * Bug Fixes
    * Auto daemonized processes are now stopped/unmonitored correctly [github.com/jcapote]

== 0.7.12 / 2008-12-10
  * Bug Fixes
    * Fix capistrano deployability [github.com/eric]
    * Fix event handling [brianw]

== 0.7.11 / 2008-11-14
  * Bug Fixes
    * Make notifications work inside lifecycle blocks

== 0.7.10 / 2008-11-13
  * Major Enhancements
    * Enable sending of arbitrary signals to a task or group via `god signal`
  * Bug Fixes
    * setup logging *after* loading a given config file when daemonized.
      enables logging to the 'God.log_file' specified in a config file. [github.com/jnewland]
  * New Conditions
    * FileMtime  PollCondition - trigger on file mtime durations [github.com/jwilkins]
  * New Contacts
    * Twitter - allow messages to twitter [github.com/jwilkins]
    * Campfire - send messages to 37signals' Campfire [github.com/hellvinz]
  * Minor Enhancements
    * Add watch log_cmd that can be reopened with STDOUT instead of a log file [github.com/jberkel]
    * Added webhook output support [Martyn Loughran]

== 0.7.9 / 2008-08-06
  * Major Enhancements
    * Use a psuedo-priority queue for more efficient driver loop [Darrell Kresge]
  * Bug Fixes
    * Fix file_writable? when using chroot [github.com/eric]

== 0.7.8 / 2008-07-09
  * Bug Fixes
    * Catch all Exceptions from HttpResponseCode condition [github.com/rliebling]
    * Don't error out if the process went away in SlashProcPoller [Kevin Clark]
    * Correction of Task#handle_poll to prevent crash under event registration failure conditions. [github.com/raggi]
    * Cleaned up logging of failed e-mail sends. [github.com/raggi]
    * Listen on 127.0.0.1 when using God as a client. [github.com/halorgium]
  * New Behaviors
    * clean_unix_socket [github.com/gma]
  * New Contacts
    * jabber [github.com/jwulff]
    * email via sendmail [github.com/monde]
  * Minor Enhancements
    * chroot support [github.com/eric]
    * Added God.log_file for the main god log, overridden by command line option. [github.com/raggi]
    * Print groups from `god status` command if present [github.com/pdlug]
    * Allow headers to be specified for http_response_code condition [github.com/pdlug]

== 0.7.7 / 2008-06-17
  * Bug Fixes
    * Fix detection of proc file system [raggi]

== 0.7.6 / 2008-05-13
  * Major Enhancements
    * Implement System::Process methods for Linux based on /proc [Kevin Clark]
  * Minor Enhancements
    * Allowing directories to be loaded at start [Bert Goethals]
  * Bug Fixes
    * Don't leak events on error in the kqueue handler [Kevin Clark]

== 0.7.5 / 2008-02-21
  * Bug Fixes
    * Remove Ruby's Logger and replace with custom SimpleLogger to stop threaded leak

== 0.7.4 / 2008-02-18
  * Bug Fixes
    * Introduce local scope to prevent faulty optimization that causes memory to leak

== 0.7.3 / 2008-02-14
  * Minor Enhancements
    * Add --bleakhouse to make running diagnostics easier
  * Bug Fixes
    * Use ::Process.kill(0, ...) instead of `kill -0` [queso]
    * Fix pid_file behavior in process-centric conditions so they work with tasks [matias]
    * Redirect output of daemonized god to log file or /dev/null earlier [_eric]

== 0.7.2 / 2008-02-04
  * Bug Fixes
    * Start event system for CLI commands
    * Up internal history to 100 lines per watch

== 0.7.1 / 2008-02-04
  * Minor Enhancements
    * Add --no-events option to completely disable events system

== 0.7.0 / 2008-02-01
  * Minor Enhancements
    * Better default pid_file_directory behavior
    * Add --attach pid to specify that god should quit if pid exits
  * Bug Fixes
    * Handle ECONNRESET in HttpResponseCode

== 0.6.12 / 2008-01-31
  * Minor Enhancements
    * Allow log file output for non-daemonized god
    * Switch to SIGTERM from SIGHUP for default lambda killer

== 0.6.11 / 2008-01-31
  * Major Enhancements
    * HUGE refactor of timer system to simplify scheduling
  * Minor Enhancements
    * Check for a truly working event system and disallow event conditions if none is present

== 0.6.10 / 2008-01-24
  * Bug Fixes
    * Fix ensure_stop nil pid no local variable bug

== 0.6.9 / 2008-01-23
  * Bug Fixes
    * Fix Timer condition dedup behavior

== 0.6.8 / 2008-01-23
  * Minor Enhancements
    * Warn if a command returns a non-zero exit code
    * Ensure that stop command actually stops process

== 0.6.7 / 2008-01-22
  * Minor Enhancements
    * Add --no-syslog option to disable Syslog
    * Allow contact redeclaration (dups are ignored)

== 0.6.6 / 2008-01-07
  * Bug Fixes
    * Redo Timer mutexing to reduce synchronization needs

== 0.6.5 / 2008-01-04
  * Bug Fixes
    * Fix Timer descheduling deadlock issue
    * Change HttpResponseCode to use GET instead of HEAD

== 0.6.4 / 2008-12-31
  * Bug Fixes
    * Refactor Hub to clarify mutexing
    * Eliminate potential iteration problem in Timer
    * Add caching PID accessor to process to solve event deregistration failure

== 0.6.3 / 2007-12-18
  * Minor Enhancements
    * Output ProcessExits registration/deregistration info

== 0.6.2 / 2007-12-17
  * Minor Enhancements
    * Output registered PID for ProcessExits
  * Bug Fixes
    * Fix `god remove group` not working for unmonitored watches

== 0.6.1 / 2007-12-14

* Minor Enhancement
  * Log when state change is complete

== 0.6.0 / 2007-12-4

* Minor Enhancement
  * Move Syslog calls into God::Logger and clean up all calling code
  * Remove god's pid file on user requested termination
  * Better handling and cleanup of DRb server's unix domain socket
  * Allow shorthand for requesting a god log
  * Add `god check` to make it easier to diagnose event problems
  * Refactor god binary into class/method structure
  * Implement `god remove` to remove a Task altogether
* New Conditions
  * DiskUsage  PollCondition - trigger if disk usage is above limit on mount [Rudy Desjardins]

== 0.5.2 / 2007-10-10

* Minor Enhancement
  * Allow extra args to pass through to config file

== 0.5.1 / 2007-10-08

* Bug Fixes
  * Rescue connection refused in http response code condition

== 0.5.0 / 2007-10-05

* Major Enhancements
  * Implement lifecycle scoped metric to allow for cross-state conditions
  * Add TriggerCondition for conditions that need info about state changes
  * Implement notification system
  * Add Tasks (a generalization of Watches) to do non-process related tasks
  * Add example init.d file in GOD_INSTALL_DIR/init/god [scott becker]
  * Add human readable info to conditions (and make low level log lines debug)
  * Switch DRb to use a unix domain socket for security reasons
* Minor Enchancements
  * Allow EventConditions to do transition overloading
  * Report errors during god startup instead of failing silently
  * Make transition block optional (default to Always condition returning true)
  * Better usage info for `god --help`
  * Explain what's going on when attempting to rebind to an in-use port
  * Add -b option to god binary to auto-bind to an unused port
  * Add `god quit` to stop god without stopping any tasks
  * Make self-daemonized Watch commands synchronous (as they should be)
  * Allow self-daemonized Watches to specify a log (could be useful)
  * Check for existence of config file if specified
  * Robustify `god load` and report errors back to the command issuer
  * Warn when `god load` tries to set global options
  * Add Configurable.clear method and make built-in conditions clear on entry
* New Conditions
  * Flapping  TriggerCondition - trigger on state change
  * HttpResponseCode  PollCondition - trigger on http response code or timeout (thx scott becker)
* New Contacts
  * Email  Contact - notify via email (smtp)
* Bug Fixes
  * Fix abort not aborting problem
  * Fix -p option not working for god binary
  * Fix God.init not accepting block (thx _eric)
  * Fix SIGHUP ignore (thx _eric)
  * Fix error reporting on `god --help` (don't error report a normal SystemExit)

== 0.4.3 / 2007-09-10
* Bug Fixes
  * fix Process#alive? to not raise on no such file (affects `god terminate`)

== 0.4.2 / 2007-09-10
* Bug Fixes
  * fix netlink buffer issue that prevented events on Linux from working consistently [dkresge]

== 0.4.1 / 2007-09-10
* Bug Fixes
  * require 'stringio' for ruby 1.8.5

== 0.4.0 / 2007-09-10

* Major Enhancements
  * Add the ability for conditions to override transition state (for exceptional cases)
  * Implement dynamic load of config files while god is running (god load filename)
  * Add ability to save auto-daemonized process output to a log file
  * Add robust default stop lambda command for auto-daemonized processes (inspired by _eric)
  * Add status command for god binary (shows status of each watch)
  * Create proper logger with timestamps
  * Add log command to god binary to get real time logs for a specific watch from a running god instance
  * Add terminate command for god binary (stop god and all watches)
* Minor Enhancements
  * Enforce validity of Watches
  * Enforce that God.init is not called after a Watch
  * Move pid_file_directory creation and validation to God.start
  * Remove check for at least one Watch during startup (now that dynamic loading exists)
* New Conditions
  * Tries  PollCondition - triggers after the specified number of tries
  * Add :notify_when_flapping behavior to check for oscillation [kevinclark]
  * Add :degrading_lambda condition. [kevinclark]
    It uses a decaying interval (1/2 rate) for 3 cycles before failing.
* Bug Fixes
  * Use exit!(0) instead of exit! in god binary to exit with code 0 (instead of default -1)
  * Command line group control fixed
  * Fix cross-thread return problem

== 0.3.0 / 2007-08-17

* Fix netlink header problem on Ubuntu Edgy [Dan Sully]
* Add uid/gid setting for processes [kevinclark]
* Add autostart flag for watches so they don't necessarily startup with god [kevinclark]
* Change command line call options for god binary to accommodate watch start/stop functionality
* Add individual start/stop/restart grace periods for finer grained control
* Change default DRb port to 17165 ('god'.to_i(32))
* Implement command line control to start/restart/stop/monitor/unmonitor watches/groups by name
* Watches can now belong to a group that can be controlled as a whole
* Allow god to be installed (sans events) on systems that don't support events
* Daemonize and handle PID files for non-daemonizing scripts [kevinclark]
* Fix simple mode lifecycle gap
* Remove necessity to specify pid_file for conditions
* Change config file to use God.init and God.watch directly instead of God.meddle block
* Move god binary command logic to main library
* Enhance god binary with better reporting
* Fix synchronization bug in Timer (reported by Srini Panguluri)
* Add Lambda condition for easy custom conditions [Mike Mintz]
* Add sugar for numerics (seconds, minutes, kilobytes, megabytes, percent, etc)
* Add optional PID and log file generation to god binary for daemon mode
* Add God.load to do glob enabled loading
* Add -V option to god binary for detailed version/build info

== 0.2.0 / 2007-07-18

* Rewrote innards to use a state and event based lifecycle
* Basic support for events via kqueue (bsd/darwin) and netlink/pec (linux) [kevinclark]
* Added advanced syntax (simple syntax calls advanced api underneath)
* Condition returns have changed meaning. With simple syntax, a true return activates block
* Updated http://god.rubyforge.org with updated simple config and new advanced config

== 0.1.0 / 2007-07-07

* 1 major enhancement
  * Birthday!

</content>
		</actual_file>
		<actual_file>
			<filename>LICENSE</filename>
			<content>(The MIT License)

Copyright (c) 2007 Tom Preston-Werner

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
'Software'), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</content>
		</actual_file>
		<actual_file>
			<filename>Rakefile</filename>
			<content>require 'rubygems'
require 'rake'
require 'rdoc/task'
require 'date'

#############################################################################
#
# Helper functions
#
#############################################################################

def name
  @name ||= Dir['*.gemspec'].first.split('.').first
end

def version
  line = File.read("lib/#{name}.rb")[/^\s*VERSION\s*=\s*.*/]
  line.match(/.*VERSION\s*=\s*['"](.*)['"]/)[1]
end

def date
  Date.today.to_s
end

def rubyforge_project
  name
end

def gemspec_file
  "#{name}.gemspec"
end

def gem_file
  "#{name}-#{version}.gem"
end

def replace_header(head, header_name)
  head.sub!(/(\.#{header_name}\s*= ').*'/) { "#{$1}#{send(header_name)}'"}
end

#############################################################################
#
# Standard tasks
#
#############################################################################

task :default = :test

require 'rake/testtask'
Rake::TestTask.new(:test) do |test|
  test.libs  'lib'  'test'
  test.pattern = 'test/**/test_*.rb'
  test.verbose = true
end

desc "Generate RCov test coverage and open in your browser"
task :coverage do
  require 'rcov'
  sh "rm -fr coverage"
  sh "rcov test/test_*.rb"
  sh "open coverage/index.html"
end

require 'rdoc/task'
Rake::RDocTask.new do |rdoc|
  rdoc.rdoc_dir = 'rdoc'
  rdoc.title = "#{name} #{version}"
  rdoc.rdoc_files.include('README*')
  rdoc.rdoc_files.include('lib/**/*.rb')
end

desc "Open an irb session preloaded with this library"
task :console do
  sh "irb -rubygems -r ./lib/#{name}.rb"
end

#############################################################################
#
# Custom tasks (add your own tasks here)
#
#############################################################################

desc "Generate and view the site locally"
task :site do
  # Generate the dynamic parts of the site.
  puts "Generating dynamic..."
  require 'gollum'
  wiki = Gollum::Wiki.new('.', :base_path = '/doc')
  html = wiki.page('god', 'HEAD').formatted_data.gsub("\342\200\231", "'")
  template = File.read('./site/index.template.html')
  index = template.sub("{{ content }}", html)
  File.open('./site/index.html', 'w') do |f|
    f.write(index)
  end

  puts "Done. Opening in browser..."
  sh "open site/index.html"
end

desc "Commit the local site to the gh-pages branch and deploy"
task :site_release do
  # Ensure the gh-pages dir exists so we can generate into it.
  puts "Checking for gh-pages dir..."
  unless File.exist?("./gh-pages")
    puts "No gh-pages directory found. Run the following commands first:"
    puts "  `git clone git@github.com:mojombo/god gh-pages"
    puts "  `cd gh-pages"
    puts "  `git checkout gh-pages`"
    exit(1)
  end

  # Copy the rest of the site over.
  puts "Copying static..."
  sh "cp -R site/* gh-pages/"

  # Commit the changes
  sha = `git log`.match(/[a-z0-9]{40}/)[0]
  sh "cd gh-pages && git add . && git commit -m 'Updating to #{sha}.' && git push"
  puts 'Done.'
end

#############################################################################
#
# Packaging tasks
#
#############################################################################

desc "Create tag v#{version} and build and push #{gem_file} to Rubygems"
task :release = :build do
  unless `git branch` =~ /^\* master$/
    puts "You must be on the master branch to release!"
    exit!
  end
  sh "git commit --allow-empty -a -m 'Release #{version}'"
  sh "git tag v#{version}"
  sh "git push origin master"
  sh "git push origin v#{version}"
  sh "gem push pkg/#{name}-#{version}.gem"
end

desc "Build #{gem_file} into the pkg directory"
task :build = :gemspec do
  sh "mkdir -p pkg"
  sh "gem build #{gemspec_file}"
  sh "mv #{gem_file} pkg"
end

desc "Generate #{gemspec_file}"
task :gemspec do
  # read spec file and split out manifest section
  spec = File.read(gemspec_file)
  head, manifest, tail = spec.split("  # = MANIFEST =\n")

  # replace name version and date
  replace_header(head, :name)
  replace_header(head, :version)
  replace_header(head, :date)
  #comment this out if your rubyforge_project has a different name
  replace_header(head, :rubyforge_project)

  # determine file list from git ls-files
  files = `git ls-files`.
    split("\n").
    sort.
    reject { |file| file =~ /^\./ }.
    reject { |file| file =~ /^(rdoc|pkg|examples|ideas|init|site)/ }.
    map { |file| "    #{file}" }.
    join("\n")

  # piece file back together and write
  manifest = "  s.files = %w[\n#{files}\n  ]\n"
  spec = [head, manifest, tail].join("  # = MANIFEST =\n")
  File.open(gemspec_file, 'w') { |io| io.write(spec) }
  puts "Updated #{gemspec_file}"
end
</content>
		</actual_file>
		<actual_file>
			<filename>README.md</filename>
			<content>God: The Ruby Framework for Process Management
==============================================

* Authors: Tom Preston-Werner, Kevin Clark, Eric Lindvall
* Website: http://godrb.com

Description
-----------

God is an easy to configure, easy to extend monitoring framework written in
Ruby.

Keeping your server processes and tasks running should be a simple part of
your deployment process. God aims to be the simplest, most powerful monitoring
application available.

Documentation
-------------

See in-repo documentation at `REPO_ROOT/doc`.
See online documentation at http://godrb.com.

Community
---------

Sign up for the god mailing list at http://groups.google.com/group/god-rb

License
-------

See LICENSE file.
</content>
		</actual_file>
		<actual_file>
			<filename>god</filename>
			<content>#!/usr/bin/env ruby

STDOUT.sync = true

$:.unshift File.join(File.dirname(__FILE__), *%w[.. lib])

require 'optparse'
require 'drb'
require 'yaml'

begin
  # Save ARGV in case someone wants to use it later
  ORIGINAL_ARGV = ARGV.dup

  options = {:daemonize = true, :port = 17165, :syslog = true, :events = true}

  opts = OptionParser.new do |opts|
    opts.banner = -EOF
  Usage:
    Starting:
      god [-c config file] [-p port | -b] [-P file] [-l file] [-D]

    Querying:
      god command argument [-p port]
      god command [-p port]
      god -v
      god -V (must be run as root to be accurate on Linux)

    Commands:
      start task or group name         start task or group
      restart task or group name       restart task or group
      stop task or group name          stop task or group
      monitor task or group name       monitor task or group
      unmonitor task or group name     unmonitor task or group
      remove task or group name        remove task or group from god
      load file [action]               load a config into a running god
      log task name                    show realtime log for given task
      status [task or group name]        show status
      signal task or group name sig  signal all matching tasks
      quit                               stop god
      terminate                          stop god and all tasks
      check                              run self diagnostic

    Options:
  EOF

    opts.on("-cCONFIG", "--config-file CONFIG", "Configuration file") do |x|
      options[:config] = x
    end

    opts.on("-pPORT", "--port PORT", "Communications port (default 17165)") do |x|
      options[:port] = x
    end

    opts.on("-b", "--auto-bind", "Auto-bind to an unused port number") do
      options[:port] = "0"
    end

    opts.on("-PFILE", "--pid FILE", "Where to write the PID file") do |x|
      options[:pid] = x
    end

    opts.on("-lFILE", "--log FILE", "Where to write the log file") do |x|
      options[:log] = x
    end

    opts.on("-D", "--no-daemonize", "Don't daemonize") do
      options[:daemonize] = false
    end

    opts.on("-v", "--version", "Print the version number and exit") do
      options[:version] = true
    end

    opts.on("-V", "Print extended version and build information") do
      options[:info] = true
    end

    opts.on("--log-level LEVEL", "Log level [debug|info|warn|error|fatal]") do |x|
      options[:log_level] = x.to_sym
    end

    opts.on("--no-syslog", "Disable output to syslog") do
      options[:syslog] = false
    end

    opts.on("--attach PID", "Quit god when the attached process dies") do |x|
      options[:attach] = x
    end

    opts.on("--no-events", "Disable the event system") do
      options[:events] = false
    end

    opts.on("--bleakhouse", "Enable bleakhouse profiling") do
      options[:bleakhouse] = true
    end
  end

  opts.parse!

  # validate
  if options[:log_level] && ![:debug, :info, :warn, :error, :fatal].include?(options[:log_level])
    abort("Invalid log level '#{options[:log_level]}'")
  end

  # Use this flag to actually load all of the god infrastructure
  $load_god = true

  # dispatch
  if !options[:config] && options[:version]
    require 'god'
    God::CLI::Version.version
  elsif !options[:config] && options[:info]
    require 'god'
    God::EventHandler.load
    God::CLI::Version.version_extended
  elsif !options[:config] && command = ARGV[0]
    require 'god'
    God::EventHandler.load
    God::CLI::Command.new(command, options, ARGV)
  else
    require 'god/cli/run'
    God::CLI::Run.new(options)
  end
rescue Exception = e
  if e.instance_of?(SystemExit)
    raise
  else
    puts 'Uncaught exception'
    puts e.message
    puts e.backtrace.join("\n")
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>god.asciidoc</filename>
			<content>Installation
------------

The best way to get god is via rubygems:

```terminal
$ [sudo] gem install god
```

Requirements
------------

God currently only works on *Linux (kernel 2.6.15+), BSD,* and *Darwin*
systems. No support for Windows is planned. Event based conditions on Linux
systems require the `cn` (connector) kernel module loaded or compiled into
the kernel and god must be run as root.

The following systems have been tested. Help us test it on others!

* Darwin 10.4.10
* RedHat Fedora 6-15
* Ubuntu Dapper (no events)
* Ubuntu Feisty
* CentOS 4.5 (no events), 5, 6


Quick Start
-----------

Note: this quick start guide requires god 0.12.0 or above. You can check your
version by running:

```terminal
$ god --version
```

The easiest way to understand how god will make your life better is by trying
out a simple example. To get you up and running quickly, I'll show you how to
keep a trivial server running.

Open up a new directory and write a simple server. Let's call it
`simple.rb`:

```ruby
loop do
  puts 'Hello'
  sleep 1
end
```

Now we'll write a god config file that tells god about our process. Place it
in the same directory and call it `simple.god`:

```ruby
God.watch do |w|
  w.name = "simple"
  w.start = "ruby /full/path/to/simple.rb"
  w.keepalive
end
```

This is the simplest possible god configuration. We start by declaring a
`God.watch` block.  A watch in god represents a process that we want to watch
and control. Each watch must have, at minimum, a unique name and a command that
tells god how to start the process. The `keepalive` declaration tells god to
keep this process alive. If the process is not running when god starts, it will
be started. If the process dies, it will be restarted.

In this example the `simple` process runs foreground, so god will take care of
daemonizing it and keeping track of the PID for us. When possible, it's best to
let god daemonize processes for us, that way we don't have to worry about
specifying and keeping track of PID files. Later on we'll see how to manage
processes that can't run foreground or that require PID files to be specified.

To run god, we give it the configuration file we wrote with `-c`. To see what's
going on, we can ask it to run foreground with `-D`:

```terminal
$ god -c path/to/simple.god -D
```

There are two ways that god can monitor your process. The first and better way
is with process events. Not every system supports it, but those that do will
automatically use it. With events, god will know immediately when a process
exits. For those systems without process event support, god will use a polling
mechanism. The output you see throughout this section will show both ways.

After starting god, you should see some output like the following:

```terminal
# Events

I [2011-12-10 15:24:34]  INFO: Loading simple.god
I [2011-12-10 15:24:34]  INFO: Syslog enabled.
I [2011-12-10 15:24:34]  INFO: Using pid file directory: /Users/tom/.god/pids
I [2011-12-10 15:24:34]  INFO: Started on drbunix:///tmp/god.17165.sock
I [2011-12-10 15:24:34]  INFO: simple move 'unmonitored' to 'init'
I [2011-12-10 15:24:34]  INFO: simple moved 'unmonitored' to 'init'
I [2011-12-10 15:24:34]  INFO: simple [trigger] process is not running (ProcessRunning)
I [2011-12-10 15:24:34]  INFO: simple move 'init' to 'start'
I [2011-12-10 15:24:34]  INFO: simple start: ruby /Users/tom/dev/mojombo/god/simple.rb
I [2011-12-10 15:24:34]  INFO: simple moved 'init' to 'start'
I [2011-12-10 15:24:34]  INFO: simple [trigger] process is running (ProcessRunning)
I [2011-12-10 15:24:34]  INFO: simple move 'start' to 'up'
I [2011-12-10 15:24:34]  INFO: simple registered 'proc_exit' event for pid 23298
I [2011-12-10 15:24:34]  INFO: simple moved 'start' to 'up'

# Polls

I [2011-12-07 09:40:18]  INFO: Loading simple.god
I [2011-12-07 09:40:18]  INFO: Syslog enabled.
I [2011-12-07 09:40:18]  INFO: Using pid file directory: /Users/tom/.god/pids
I [2011-12-07 09:40:18]  INFO: Started on drbunix:///tmp/god.17165.sock
I [2011-12-07 09:40:18]  INFO: simple move 'unmonitored' to 'up'
I [2011-12-07 09:40:18]  INFO: simple moved 'unmonitored' to 'up'
I [2011-12-07 09:40:18]  INFO: simple [trigger] process is not running (ProcessRunning)
I [2011-12-07 09:40:18]  INFO: simple move 'up' to 'start'
I [2011-12-07 09:40:18]  INFO: simple start: ruby /Users/tom/dev/mojombo/god/simple.rb
I [2011-12-07 09:40:19]  INFO: simple moved 'up' to 'up'
I [2011-12-07 09:40:19]  INFO: simple [ok] process is running (ProcessRunning)
I [2011-12-07 09:40:24]  INFO: simple [ok] process is running (ProcessRunning)
I [2011-12-07 09:40:29]  INFO: simple [ok] process is running (ProcessRunning)
```

Here you can see god starting up, noticing that the `simple` process isn't
running, starting it, and then checking every five seconds to make sure it's
up. If you'd like to see god work its magic, go ahead and kill the `simple`
process. You should then see something like this:

```terminal
# Events

I [2011-12-10 15:33:38]  INFO: simple [trigger] process 23416 exited (ProcessExits)
I [2011-12-10 15:33:38]  INFO: simple move 'up' to 'start'
I [2011-12-10 15:33:38]  INFO: simple deregistered 'proc_exit' event for pid 23416
I [2011-12-10 15:33:38]  INFO: simple start: ruby /Users/tom/dev/mojombo/god/simple.rb
I [2011-12-10 15:33:38]  INFO: simple moved 'up' to 'start'
I [2011-12-10 15:33:38]  INFO: simple [trigger] process is running (ProcessRunning)
I [2011-12-10 15:33:38]  INFO: simple move 'start' to 'up'
I [2011-12-10 15:33:38]  INFO: simple registered 'proc_exit' event for pid 23601
I [2011-12-10 15:33:38]  INFO: simple moved 'start' to 'up'

# Polls

I [2011-12-07 09:54:59]  INFO: simple [ok] process is running (ProcessRunning)
I [2011-12-07 09:55:04]  INFO: simple [ok] process is running (ProcessRunning)
I [2011-12-07 09:55:09]  INFO: simple [trigger] process is not running (ProcessRunning)
I [2011-12-07 09:55:09]  INFO: simple move 'up' to 'start'
I [2011-12-07 09:55:09]  INFO: simple start: ruby /Users/tom/dev/mojombo/god/simple.rb
I [2011-12-07 09:55:09]  INFO: simple moved 'up' to 'up'
I [2011-12-07 09:55:09]  INFO: simple [ok] process is running (ProcessRunning)
I [2011-12-07 09:55:14]  INFO: simple [ok] process is running (ProcessRunning)
```

While keeping a process up is useful, it would be even better if we could make
sure our process was behaving well and restart it when resource utilization
exceeds our specifications. With a few additions, we can easily have our
process restarted when memory usage or CPU goes above certain limits. Edit
your `sample.god` config file to look like this:

```ruby
God.watch do |w|
  w.name = "simple"
  w.start = "ruby /full/path/to/simple.rb"
  w.keepalive(:memory_max = 150.megabytes,
              :cpu_max = 50.percent)
end
```

Here I've specified a `:memory_max` option to the `keepalive` command. Now if
the process memory usage goes above 150 megabytes, god will restart it.
Similarly, by setting the `:cpu_max`, god will restart my process if its CPU
usage goes over 50%. By default these properties will be checked every 30
seconds and will be acted upon if there is an overage for three out of any
five checks. This prevents the process from getting restarted for temporary
resource spikes.

To test this out, modify your `simple.rb` server script to introduce a memory
leak:

```ruby
data = ''
loop do
  puts 'Hello'
  100000.times { data  'x' }
end
```

Ctrl-C out of the foregrounded god instance. Notice that your current `simple`
server will continue to run. Start god again with the same command as before.
Now instead of starting the `simple` process, it will notice that one is
already running and simply switch to the `up` state.

```terminal
# Events

I [2011-12-10 15:36:00]  INFO: Loading simple.god
I [2011-12-10 15:36:00]  INFO: Syslog enabled.
I [2011-12-10 15:36:00]  INFO: Using pid file directory: /Users/tom/.god/pids
I [2011-12-10 15:36:00]  INFO: Started on drbunix:///tmp/god.17165.sock
I [2011-12-10 15:36:00]  INFO: simple move 'unmonitored' to 'init'
I [2011-12-10 15:36:00]  INFO: simple moved 'unmonitored' to 'init'
I [2011-12-10 15:36:00]  INFO: simple [trigger] process is running (ProcessRunning)
I [2011-12-10 15:36:00]  INFO: simple move 'init' to 'up'
I [2011-12-10 15:36:00]  INFO: simple registered 'proc_exit' event for pid 23601
I [2011-12-10 15:36:00]  INFO: simple moved 'init' to 'up'

# Polls

I [2011-12-07 14:50:46]  INFO: Loading simple.god
I [2011-12-07 14:50:46]  INFO: Syslog enabled.
I [2011-12-07 14:50:46]  INFO: Using pid file directory: /Users/tom/.god/pids
I [2011-12-07 14:50:47]  INFO: Started on drbunix:///tmp/god.17165.sock
I [2011-12-07 14:50:47]  INFO: simple move 'unmonitored' to 'up'
I [2011-12-07 14:50:47]  INFO: simple moved 'unmonitored' to 'up'
I [2011-12-07 14:50:47]  INFO: simple [ok] process is running (ProcessRunning)
```

In order to get our new `simple` server running, we can issue a command to god
to have our process restarted:

```terminal
$ god restart simple
```

From the logs you can see god killing and restarting the process:

```terminal
# Events

I [2011-12-10 15:38:13]  INFO: simple move 'up' to 'restart'
I [2011-12-10 15:38:13]  INFO: simple deregistered 'proc_exit' event for pid 23601
I [2011-12-10 15:38:13]  INFO: simple stop: default lambda killer
I [2011-12-10 15:38:13]  INFO: simple sent SIGTERM
I [2011-12-10 15:38:14]  INFO: simple process stopped
I [2011-12-10 15:38:14]  INFO: simple start: ruby /Users/tom/dev/mojombo/god/simple.rb
I [2011-12-10 15:38:14]  INFO: simple moved 'up' to 'restart'
I [2011-12-10 15:38:14]  INFO: simple [trigger] process is running (ProcessRunning)
I [2011-12-10 15:38:14]  INFO: simple move 'restart' to 'up'
I [2011-12-10 15:38:14]  INFO: simple registered 'proc_exit' event for pid 23707
I [2011-12-10 15:38:14]  INFO: simple moved 'restart' to 'up'

# Polls

I [2011-12-07 14:51:13]  INFO: simple [ok] process is running (ProcessRunning)
I [2011-12-07 14:51:13]  INFO: simple move 'up' to 'restart'
I [2011-12-07 14:51:13]  INFO: simple stop: default lambda killer
I [2011-12-07 14:51:13]  INFO: simple sent SIGTERM
I [2011-12-07 14:51:14]  INFO: simple process stopped
I [2011-12-07 14:51:14]  INFO: simple start: ruby /Users/tom/dev/mojombo/god/simple.rb
I [2011-12-07 14:51:14]  INFO: simple moved 'up' to 'up'
I [2011-12-07 14:51:14]  INFO: simple [ok] process is running (ProcessRunning)
```

God will now start reporting on memory and CPU utilization of your process:

```terminal
# Events and Polls

I [2011-12-07 14:54:37]  INFO: simple [ok] process is running (ProcessRunning)
I [2011-12-07 14:54:37]  INFO: simple [ok] memory within bounds [2032kb] (MemoryUsage)
I [2011-12-07 14:54:37]  INFO: simple [ok] cpu within bounds [0.0%%] (CpuUsage)
I [2011-12-07 14:54:42]  INFO: simple [ok] process is running (ProcessRunning)
I [2011-12-07 14:54:42]  INFO: simple [ok] memory within bounds [2032kb, 13492kb] (MemoryUsage)
I [2011-12-07 14:54:42]  INFO: simple [ok] cpu within bounds [0.0%%, *99.7%%] (CpuUsage)
I [2011-12-07 14:54:47]  INFO: simple [ok] process is running (ProcessRunning)
I [2011-12-07 14:54:47]  INFO: simple [ok] memory within bounds [2032kb, 13492kb, 25568kb] (MemoryUsage)
I [2011-12-07 14:54:47]  INFO: simple [ok] cpu within bounds [0.0%%, *99.7%%, *100.0%%] (CpuUsage)
I [2011-12-07 14:54:52]  INFO: simple [ok] process is running (ProcessRunning)
I [2011-12-07 14:54:52]  INFO: simple [ok] memory within bounds [2032kb, 13492kb, 25568kb, 37556kb] (MemoryUsage)
I [2011-12-07 14:54:52]  INFO: simple [trigger] cpu out of bounds [0.0%%, *99.7%%, *100.0%%, *98.4%%] (CpuUsage)
I [2011-12-07 14:54:52]  INFO: simple move 'up' to 'restart'
```

On the last line of the above log you can see that CPU usage has gone above
50% for three cycles and god will issue a restart operation. God will continue
to monitor the `simple` process for as long as god is running and the process
is set to be monitored.

Now, before you kill the god process, let's kill the `simple` server by asking
god to stop it for us. In a new terminal, issue the command:

```terminal
$ god stop simple
```

You should see the following output:

```terminal
Sending 'stop' command

The following watches were affected:
  simple
```

And in the foregrounded god terminal window, you'll see the log of what
happened:

```terminal
# Events

I [2011-12-10 15:41:04]  INFO: simple stop: default lambda killer
I [2011-12-10 15:41:04]  INFO: simple sent SIGTERM
I [2011-12-10 15:41:05]  INFO: simple process stopped
I [2011-12-10 15:41:05]  INFO: simple move 'up' to 'unmonitored'
I [2011-12-10 15:41:05]  INFO: simple deregistered 'proc_exit' event for pid 23707
I [2011-12-10 15:41:05]  INFO: simple moved 'up' to 'unmonitored'

# Polls

I [2011-12-07 09:59:59]  INFO: simple [ok] process is running (ProcessRunning)
I [2011-12-07 10:00:04]  INFO: simple [ok] process is running (ProcessRunning)
I [2011-12-07 10:00:07]  INFO: simple stop: default lambda killer
I [2011-12-07 10:00:07]  INFO: simple sent SIGTERM
I [2011-12-07 10:00:08]  INFO: simple process stopped
I [2011-12-07 10:00:08]  INFO: simple move 'up' to 'unmonitored'
I [2011-12-07 10:00:08]  INFO: simple moved 'up' to 'unmonitored'
```

Now feel free to Ctrl-C out of god. Congratulations! You've just taken god for
a test ride and seen how easy it is to keep your processes running.

This is just the beginning of what god can do, and in reality, the `keepalive`
command is a convenience method written using more advanced transitional and
condition constructs that may be used directly. You can configure many
different kinds of conditions to have your process restarted when memory or
CPU are too high, when disk usage is above a threshold, when a process returns
an HTTP error code on a specific URL, and many more. In addition you can write
your own custom conditions and use them in your configuration files. Many
different lifecycle controls are available alongside a sophisticated and
extensible notifications system. Keep reading to find out what makes god
different from other monitoring systems and how it can help you solve many of
your process monitoring and control problems.


Config Files are Ruby Code!
---------------------------

Now that you've seen how to get started quickly, let's see how to use the more
powerful aspects of god. Once again, the best way to learn will be through an
example. The following configuration file is what I once used at gravatar.com
to keep the mongrels running:

```ruby
RAILS_ROOT = "/Users/tom/dev/gravatar2"

%w{8200 8201 8202}.each do |port|
  God.watch do |w|
    w.name = "gravatar2-mongrel-#{port}"

    w.start = "mongrel_rails start -c #{RAILS_ROOT} -p #{port} \
      -P #{RAILS_ROOT}/log/mongrel.#{port}.pid  -d"
    w.stop = "mongrel_rails stop -P #{RAILS_ROOT}/log/mongrel.#{port}.pid"
    w.restart = "mongrel_rails restart -P #{RAILS_ROOT}/log/mongrel.#{port}.pid"

    w.pid_file = File.join(RAILS_ROOT, "log/mongrel.#{port}.pid")

    w.behavior(:clean_pid_file)

    w.start_if do |start|
      start.condition(:process_running) do |c|
        c.interval = 5.seconds
        c.running = false
      end
    end

    w.restart_if do |restart|
      restart.condition(:memory_usage) do |c|
        c.above = 150.megabytes
        c.times = [3, 5] # 3 out of 5 intervals
      end

      restart.condition(:cpu_usage) do |c|
        c.above = 50.percent
        c.times = 5
      end
    end

    # lifecycle
    w.lifecycle do |on|
      on.condition(:flapping) do |c|
        c.to_state = [:start, :restart]
        c.times = 5
        c.within = 5.minute
        c.transition = :unmonitored
        c.retry_in = 10.minutes
        c.retry_times = 5
        c.retry_within = 2.hours
      end
    end
  end
end
```

That's a lot to take in at once, so I'll break it down by section and explain
what's going on in each.

```ruby
RAILS_ROOT = "/var/www/gravatar2/current"
```

Here I've set a constant that is used throughout the file. Keeping the
`RAILS_ROOT` value in a constant makes it easy to adapt this script to other
applications. Because the config file is Ruby code, I can set whatever
variables or constants I want that make the configuration more concise and
easier to work with.

```ruby
%w{8200 8201 8202}.each do |port|
  ...
end
```

Because the config file is written in actual Ruby code, we can construct loops
and do other intelligent things that are impossible in your every day, run of
the mill config file. I need to watch three mongrels, so I simply loop over
their port numbers, eliminating duplication and making my life a whole lot
easier.

```ruby
  God.watch do |w|
    w.name = "gravatar2-mongrel-#{port}"

    w.start = "mongrel_rails start -c #{RAILS_ROOT} -p #{port} \
      -P #{RAILS_ROOT}/log/mongrel.#{port}.pid  -d"
    w.stop = "mongrel_rails stop -P #{RAILS_ROOT}/log/mongrel.#{port}.pid"
    w.restart = "mongrel_rails restart -P #{RAILS_ROOT}/log/mongrel.#{port}.pid"

    w.pid_file = File.join(RAILS_ROOT, "log/mongrel.#{port}.pid")

    ...
  end
```

A `watch` represents a single process that has concrete start, stop, and/or
restart operations. You can define as many watches as you like. In the example
above, I've got some Rails instances running in Mongrels that I need to keep
alive. Every watch must have a unique `name` so that it can be identified
later on. The `start` and `stop` attributes specify the commands to start 
and stop the process. If no `restart` attribute is set, restart will be 
represented by a call to stop followed by a call to start. The
optional `grace` attribute sets the amount of time following a
start/stop/restart command to wait before resuming normal monitoring
operations. If the process you're watching runs as a daemon (as
mine does), you'll need to set the `pid_file` attribute.

```ruby
    w.behavior(:clean_pid_file)
```

Behaviors allow you to execute additional commands around start/stop/restart
commands. In our case, if the process dies it will leave a PID file behind.
The next time a start command is issued, it will fail, complaining about the
leftover PID file. We'd like the PID file cleaned up before a start command is
issued. The built-in behavior `clean_pid_file` will do just that.

```ruby
    w.start_if do |start|
      start.condition(:process_running) do |c|
        c.interval = 5.seconds
        c.running = false
      end
    end
```

Watches contain conditions grouped by the action to execute should they return
`true`. I start with a `start_if` block that contains a single condition.
Conditions are specified by calling `condition` with an identifier, in this
case `:process_running`. Each condition can specify a poll interval that will
override the default watch interval. In this case, I want to check that the
process is still running every 5 seconds instead of the 30 second interval
that other conditions will inherit. The ability to set condition specific poll
intervals makes it possible to run critical tests (such as :process_running)
more often than less critical tests (such as :memory_usage and :cpu_usage).

```ruby
    w.restart_if do |restart|
      restart.condition(:memory_usage) do |c|
        c.above = 150.megabytes
        c.times = [3, 5] # 3 out of 5 intervals
      end

      ...
    end
```

Similar to `start_if` there is a `restart_if` command that groups conditions
that should trigger a restart. The `memory_usage` condition will fail if the
specified process is using too much memory. The maximum allowable amount of
memory is specified with the `above` attribute (you can use the `kilobytes`,
`megabytes`, or `gigabytes` helpers). The number of times the test needs to
fail in order to trigger a restart is set with `times`. This can be either an
integer or an array. An integer means it must fail that many times in a row
while an array `[x, y]` means it must fail `x` times out of the last `y`
tests.

```ruby
    w.restart_if do |restart|
      ...

      restart.condition(:cpu_usage) do |c|
        c.above = 50.percent
        c.times = 5
      end
    end
```

To keep an eye on CPU usage, I've employed the `cpu_usage` condition. When CPU
usage for a Mongrel process is over 50% for 5 consecutive intervals, it will
be restarted.

```ruby
    w.lifecycle do |on|
      on.condition(:flapping) do |c|
        c.to_state = [:start, :restart]
        c.times = 5
        c.within = 5.minute
        c.transition = :unmonitored
        c.retry_in = 10.minutes
        c.retry_times = 5
        c.retry_within = 2.hours
      end
    end
```

Conditions inside a `lifecycle` section are active as long as the process is being monitored (they live across state changes).

The `:flapping` condition guards against the edge case wherein god rapidly
starts or restarts your application. Things like server configuration changes
or the unavailability of external services could make it impossible for my
process to start. In that case, god will try to start my process over and over
to no avail. The `:flapping` condition provides two levels of giving up on
flapping processes. If I were to translate the options of the code above, it
would be something like: If this watch is started or restarted five times
withing 5 minutes, then unmonitor it...then after ten minutes, monitor it
again to see if it was just a temporary problem; if the process is seen to be
flapping five times within two hours, then give up completely.

That's it!

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

Starting and Controlling God
----------------------------

To start the god monitoring process as a daemon simply run the `god`
executable passing in the path to the config file (you need to sudo if you're
using events on Linux or want to use the setuid/setgid functionality):

```terminal
$ sudo god -c /path/to/config.god
```

While you're writing your config file, it can be helpful to run god in the
foreground so you can see the log messages. You can do that with:

```terminal
$ sudo god -c /path/to/config.god -D
```

You can start/restart/stop/monitor/unmonitor your Watches with the same
utility like so:

```terminal
$ sudo god stop gravatar2-mongrel-8200
```

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

Watching Non-Daemon Processes
-----------------------------

Need to watch a script that doesn't have built in daemonization? No problem!
God will daemonize and keep track of your process for you. If you don't
specify a `pid_file` attribute for a watch, it will be auto-daemonized and a
PID file will be stored for it in `/var/run/god`. 


```ruby
God.pid_file_directory = '/home/tom/pids'

# Watcher that auto-daemonizes and creates the pid file
God.watch do |w|
  w.name = 'mongrel'
  w.pid_file = w.pid_file = File.join(RAILS_ROOT, "log/mongrel.pid")
  
  w.start = "mongrel_rails start -P #{RAILS_ROOT}/log/mongrel.pid  -d"
  
  # ...
end

# Watcher that does not auto-daemonize
God.watch do |w|
  w.name = 'worker'
  # w.pid_file = is not set
  
  w.start = "rake resque:worker"
  
  # ...
end
```


If you'd rather have the PID file stored in a different location, you can 
set it at the top of your config:

```ruby
God.pid_file_directory = '/home/tom/pids'
```

The directory you specify must be writable by god.


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

Grouping Watches
----------------

Watches can be assigned to groups. These groups can then be controlled
together from the command line.

```ruby
  God.watch do |w|
    ...

    w.group = 'mongrels'

    ...
  end
```

The above configuration now allows you to control the watch (and any others
that are in the group) with a single command:

```terminal
$ sudo god stop mongrels
```

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

Invoke Commands for all watches
-------------------------------

If you need to invoke a command (e.g. Stop / Start / Restart) on all watches
you can simply omit the second parameter. For example, to start all watches:

```terminal
$ sudo god start
```

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

Redirecting STDOUT and STDERR of your Process
---------------------------------------------

By default, the STDOUT stream for your process is redirected to `/dev/null`.
To get access to this output, you can redirect the stream either to a file or
to a command.

To redirect STDOUT to a file, set the `log` attribute to a file path. The file
will be written in append mode and created if it does not exist.

```ruby
  God.watch do |w|
    ...

    w.log = '/var/log/myprocess.log'

    ...
  end
```

To redirect STDOUT to a command that will be run for you, set the `log_cmd`
attribute to a command.

```ruby
  God.watch do |w|
    ...

    w.log_cmd = '/usr/bin/logger'

    ...
  end
```

By default, STDERR is redirected to STDOUT. You can redirect it to a file or a
command just like STDOUT by setting the `err_log` or `err_log_cmd` attributes
respectively.

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

Changing UID/GID for processes
------------------------------

It is possible to have god run your start/stop/restart commands as a specific
user/group. This can be done by setting the `uid` and/or `gid` attributes of a
watch.

```ruby
  God.watch do |w|
    ...

    w.uid = 'tom'
    w.gid = 'devs'

    ...
  end
```

This only works for commands specified as a string. Lambda commands are
unaffected.

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

Setting the Working Directory
-----------------------------

By default, God sets the working directory to `/` before running your process.
You can change this by setting the `dir` attribute on the watch.

```ruby
  God.watch do |w|
    ...

    w.dir = '/var/www/myapp'

    ...
  end
```

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

Setting environment variables
-----------------------------

You can set any number of environment variables you wish via the `env`
attribute of a watch.

```ruby
  God.watch do |w|
    ...

    w.env = { 'RAILS_ROOT' = "/var/www/myapp",
              'RAILS_ENV' = "production" }

    ...
  end
```

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

Using chroot to Change the File System Root
-------------------------------------------

If you want your process to run chrooted, simply use the `chroot` attribute on
the watch. The specified directory must exist and have a `/dev/null`.

```ruby
  God.watch do |w|
    ...

    w.chroot = '/var/myroot'

    ...
  end
```

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

Lambda commands
---------------

In addition to specifying start/stop/restart commands as strings (to be
executed via the shell), you can specify a lambda that will be called.

```ruby
  God.watch do |w|
    ...

    w.start = lambda { ENV['APACHE'] ? `apachectl -k graceful` : `lighttpd restart` }

    ...
  end
```

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

Customizing the Default Stop Lambda
-----------------------------------

If you do not provide a stop command, God will attempt to stop your process by
first sending a SIGTERM. It will then wait for ten seconds for the process to
exit. If after this time it still has not exited, it will be sent a SIGKILL.
You can customize the stop signal and/or the time to wait for the process to
exit by setting the `stop_signal` and `stop_timeout` attributes on the watch.

```ruby
  God.watch do |w|
    ...

    w.stop_signal = 'QUIT'
    w.stop_timeout = 20.seconds

    ...
  end
```


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

Loading Other Config Files
--------------------------

You should feel free to separate your god configs into separate files for
easier organization. You can load in other configs using Ruby's normal `load`
method, or use the convenience method `God.load` which allows for glob-style
paths:

```ruby
# load in all god configs
God.load "/usr/local/conf/*.god"
```

God won't start its monitoring operations until all configurations have been
loaded.

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

Dynamically Loading Config Files Into an Already Running God
------------------------------------------------------------

God allows you to load or reload configurations into an already running
instance. There are a few things to consider when doing this:

* Existng Watches with the same `name` as the incoming Watches will be
  overidden by the new config.
* All paths must be either absolute or relative to the path from which god was
  started.

To load a config into a running god, issue the following command:

```terminal
$ sudo god load path/to/config.god
```

Config files that are loaded dynamically can contain anything that a normal
config file contains, however, global options such as `God.pid_file_directory`
blocks will be ignored (and produce a warning in the logs).

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

Getting Logs for a Single Watch
-------------------------------

Sifting through the god logs for statements specific to a single Watch can be
frustrating when you have many of them. You can get the realtime logs for a
single Watch via the command line:

```terminal
$ sudo god log local-3000
```

This will display log output for the 'local-3000' Watch and update every
second with new log messages.

You can also supply a shorthand to the log command that will match one of your
watches. If it happens to match several, the shortest match will be used:

```terminal
$ sudo god log l3
```

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

Notifications
-------------

God has an extensible notification framework built in that makes it easy to
have notifications sent when conditions are triggered. Each notification type
has a set of configuration parameters that must be set. These parameters may
be set globally via Contact Defaults or individually via Contact Instances.

*Contact Defaults* - Some parameters are unlikely to change on a per-contact
basis. You should set those parameters via the defaults mechanism.

```ruby
God::Contacts::Email.defaults do |d|
  d.from_email = 'god@example.com'
  d.from_name = 'God'
  d.delivery_method = :sendmail
end
```

*Contact Instances* - Each contact must have a unique `name` set. You may
optionally assign each contact to a `group`.

```ruby
God.contact(:email) do |c|
  c.name = 'tom'
  c.group = 'developers'
  c.to_email = 'tom@example.com'
end

God.contact(:email) do |c|
  c.name = 'vanpelt'
  c.group = 'developers'
  c.to_email = 'vanpelt@example.com'
end

God.contact(:email) do |c|
  c.name = 'kevin'
  c.group = 'developers'
  c.to_email = 'kevin@example.com'
end
```

*Condition Attachment* - To have a specific contact notified when a condition
is triggered, simply set the condition's `notify` attribute to the name of the
individual contact.

```ruby
  w.transition(:up, :start) do |on|
    on.condition(:process_exits) do |c|
      c.notify = 'tom'
    end
  end
```

There are two ways to specify that a notification should be sent. The first,
easier way is shown above. Every condition can take an optional `notify`
attribute that specifies which contacts should be notified when the condition
is triggered. The value can be a contact name or contact group *or* an array
of contact names and/or contact groups.

```ruby
  w.transition(:up, :start) do |on|
    on.condition(:process_exits) do |c|
      c.notify = {:contacts = ['tom', 'developers'], :priority = 1, :category = 'product'}
    end
  end
```

The second way allows you to specify the `priority` and `category` in addition
to the contacts. The extra attributes can be arbitrary integers or strings and
will be passed as-is to the notification subsystem.

The above notification will arrive as an email similar to the following.

```
From: God &lt;god@example.com&gt;
To: tom &lt;tom@example.com&gt;
Subject: [god] mongrel-8600 [trigger] process exited (ProcessExits)

Message: mongrel-8600 [trigger] process exited (ProcessExits)
Host: candymountain.example.com
Priority: 1
Category: product
```

Available Notification Types
----------------------------

Campfire
~~~~~~~~

Send a notice to a Campfire room (http://campfirenow.com).

```ruby
God::Contacts::Campfire.defaults do |d|
  ...
end

God.contact(:campfire) do |c|
  ...
end
```

```
subdomain - The String subdomain of the Campfire account. If your URL is
            "foo.campfirenow.com" then your subdomain is "foo".
token     - The String token used for authentication.
room      - The String room name to which the message should be sent.
ssl       - A Boolean determining whether or not to use SSL
            (default: false).
```

Hipchat
~~~~~~~~

Send a notice to a Hipchat room (http://hipchat.com).

```ruby
God::Contacts::Hipchat.defaults do |d|
  ...
end

God.contact(:hipchat) do |c|
  ...
end
```

```
token     - The String token used for authentication.
room      - The String room name to which the message should be sent.
ssl       - A Boolean determining whether or not to use SSL
            (default: false).
from      - The String representing who the message should be sent as.
```

Email
~~~~~

Send a notice to an email address.

```ruby
God::Contacts::Email.defaults do |d|
  ...
end

God.contact(:email) do |c|
  ...
end
```

```
to_email        - The String email address to which the email will be sent.
to_name         - The String name corresponding to the recipient.
from_email      - The String email address from which the email will be sent.
from_name       - The String name corresponding to the sender.
delivery_method - The Symbol delivery method. [ :smtp | :sendmail ]
                  (default: :smtp).

=== SMTP Options (when delivery_method = :smtp) ===
server_host     - The String hostname of the SMTP server (default: localhost).
server_port     - The Integer port of the SMTP server (default: 25).
server_auth     - A Boolean or Symbol, false if no authentication else a symbol
                  for the type of authentication [false | :plain | :login | :cram_md5]
                  (default: false).

=== SMTP Auth Options (when server_auth = true) ===
server_domain   - The String domain.
server_user     - The String username.
server_password - The String password.

=== Sendmail Options (when delivery_method = :sendmail) ===
sendmail_path   - The String path to the sendmail executable
                  (default: "/usr/sbin/sendmail").
sendmail_args   - The String args to send to sendmail (default "-i -t").
```

Jabber
~~~~~~

Send a notice to a Jabber address (http://jabber.org/).

Google Mail addresses should work. If you need a non-Gmail address, you can
sign up for one at http://register.jabber.org/.

```ruby
God::Contacts::Jabber.defaults do |d|
  ...
end

God.contact(:jabber) do |c|
  ...
end
```

```
host     - The String hostname of the Jabber server.
port     - The Integer port of the Jabber server.
from_jid - The String Jabber ID of the sender.
password - The String password of the sender.
to_jid   - The String Jabber ID of the recipient.
subject  - The String subject of the message (default: "God Notification").
```

Prowl
~~~~~

Send a notice to Prowl (http://prowl.weks.net/).

```ruby
God::Contacts::Prowl.defaults do |d|
  ...
end

God.contact(:prowl) do |c|
  ...
end
```

```
apikey - The String API key.
```

Scout
~~~~~

Send a notice to Scout (http://scoutapp.com/).

```ruby
God::Contacts::Scout.defaults do |d|
  ...
end

God.contact(:scout) do |c|
  ...
end
```

```
client_key - The String client key.
plugin_id  - The String plugin id.

```

Twitter
~~~~~~~

Send a notice to a Twitter account (http://twitter.com/).

In order to use the Twitter notification, you will need to authorize God via
OAuth and then get the OAuth token and secret for your account. The easiest
way to do this is with a Ruby gem called `twurl`. Install it like so:

```terminal
[sudo] gem install twurl
```

Then, run the following:

```terminal
twurl auth --consumer-key gOhjax6s0L3mLeaTtBWPw \
           --consumer-secret yz4gpAVXJHKxvsGK85tEyzQJ7o2FEy27H1KEWL75jfA
```

This will return a URL. Copy it to your clipboard. Make sure you are logged
into Twitter with the account that will used for the notifications, and then
paste the URL into a new browser window. At the end of the authentication
process, you will be given a PIN. Copy this PIN and paste it back to the
command line prompt. Once this is complete, you need to find your access token
and secret:

```terminal
cat ~/.twurlrc
```

This will output the contents of the config file from which you can grab your
access token and secret:

```
---
profiles:
  mojombo:
    gOhjax6s0L3mLeaTtBWPw:
      [red]token: 17376380-KXA91nCrgaQ4HxUXMmZtM38gB56qS3hx1NYbjT6mQ
      consumer_key: gOhjax6s0L3mLeaTtBWPw
      username: mojombo
      consumer_secret: yz4gpAVXJHKxvsGK85tEyzQJ7o2FEy27H1KEWL75jfA
      [red]secret: EBWFQBCtuMwCDeU4OXlc3LwGyY8OdWAV0Jg5KVB0
configuration:
  default_profile:
  - mojombo
  - gOhjax6s0L3mLeaTtBWPw

```

The access token and secret (highlighted in red above) are what you need to
use as parameters to the Twitter notification.

```ruby
God::Contacts::Twitter.defaults do |d|
  ...
end

God.contact(:twitter) do |c|
  ...
end
```

```
consumer_token  - The String OAuth consumer token (defaults to God's
                  existing consumer token).
consumer_secret - The String OAuth consumer secret (defaults to God's
                  existing consumer secret).
access_token    - The String OAuth access token.
access_secret   - The String OAuth access secret.
```

Webhook
~~~~~~~

Send a notice to a webhook (http://www.webhooks.org/).

```ruby
God::Contacts::Webhook.defaults do |d|
  ...
end

God.contact(:webhook) do |c|
  ...
end
```

```
url    - The String webhook URL.
format - The Symbol format [ :form | :json ] (default: :form).

```

Airbrake
~~~~~~~

Send a notice to airbrake (http://airbrake.io/).

```ruby
God::Contacts::Airbrake.defaults do |d|
  ...
end

God.contact(:airbrake) do |c|
  ...
end
```

```
apikey - The String API key.
```

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

Advanced Configuration with Transitions and Events
--------------------------------------------------

So far you've been introduced to a simple poll-based config file and seen how
to run it. Poll-based monitoring works great for simple things, but falls
short for highly critical tasks. God has native support for kqueue/netlink
events on BSD/Darwin/Linux systems. For instance, instead of using the
`process_running` condition to poll for the status of your process, you can
use the `process_exits` condition that will be notified *immediately* upon the
exit of your process. This means less load on your system and shorter downtime
after a crash.

While the configuration syntax you saw in the previous example is very simple,
it lacks the power that we need to deal with event based monitoring. In fact,
the `start_if` and `restart_if` methods are really just calling out to a
lower-level API. If we use the low-level API directly, we can harness the full
power of god's event based lifecycle system. Let's look at another example
config file.

```ruby
RAILS_ROOT = "/Users/tom/dev/gravatar2"

God.watch do |w|
  w.name = "local-3000"

  w.start = "mongrel_rails start -c #{RAILS_ROOT} -P #{RAILS_ROOT}/log/mongrel.pid -p 3000 -d"
  w.stop = "mongrel_rails stop -P #{RAILS_ROOT}/log/mongrel.pid"
  w.restart = "mongrel_rails restart -P #{RAILS_ROOT}/log/mongrel.pid"

  w.pid_file = File.join(RAILS_ROOT, "log/mongrel.pid")

  # clean pid files before start if necessary
  w.behavior(:clean_pid_file)

  # determine the state on startup
  w.transition(:init, { true = :up, false = :start }) do |on|
    on.condition(:process_running) do |c|
      c.running = true
    end
  end

  # determine when process has finished starting
  w.transition([:start, :restart], :up) do |on|
    on.condition(:process_running) do |c|
      c.running = true
    end

    # failsafe
    on.condition(:tries) do |c|
      c.times = 5
      c.transition = :start
    end
  end

  # start if process is not running
  w.transition(:up, :start) do |on|
    on.condition(:process_exits)
  end

  # restart if memory or cpu is too high
  w.transition(:up, :restart) do |on|
    on.condition(:memory_usage) do |c|
      c.interval = 20
      c.above = 50.megabytes
      c.times = [3, 5]
    end

    on.condition(:cpu_usage) do |c|
      c.interval = 10
      c.above = 10.percent
      c.times = [3, 5]
    end
  end

  # lifecycle
  w.lifecycle do |on|
    on.condition(:flapping) do |c|
      c.to_state = [:start, :restart]
      c.times = 5
      c.within = 5.minute
      c.transition = :unmonitored
      c.retry_in = 10.minutes
      c.retry_times = 5
      c.retry_within = 2.hours
    end
  end
end

```

A bit longer, I know, but very straighforward once you understand how the
`transition` calls work. The `name`, `interval`, `start`, `stop`, and
`pid_file` attributes should be familiar. We also specify the `clean_pid_file`
behavior.

Before jumping into the code, it's important to understand the different
states that a Watch can have, and how that state changes over time. At any
given time, a Watch will be in one of the `init`, `up`, `start`, or `restart`
states. As different conditions are satisfied, the Watch will progress from
state to state, enabling and disabling conditions along the way.

When god first starts, each Watch is placed in the `init` state.

You'll use the `transition` method to tell god how to transition between
states. It takes two arguments. The first argument may be either a symbol or
an array of symbols representing the state or states during which the
specified conditions should be enabled. The second argument may be either a
symbol or a hash. If it is a symbol, then that is the state that will be
transitioned to if any of the conditions return `true`. If it is a hash, then
that hash must have both `true` and `false` keys, each of which point to a
symbol that represents the state to transition to given the corresponding
return from the single condition that must be specified.

```ruby
  # determine the state on startup
  w.transition(:init, { true = :up, false = :start }) do |on|
    on.condition(:process_running) do |c|
      c.running = true
    end
  end
```

The first transition block tells god what to do when the Watch is in the
`init` state (first argument). This is where I tell god how to determine if my
task is already running. Since I'm monitoring a process, I can use the
`process_running` condition to determine whether the process is running. If
the process is running, it will return true, otherwise it will return false.
Since I sent a hash as the second argument to `transition`, the return from
`process_running` will determine which of the two states will be transitioned
to. If the process is running, the return is true and god will put the Watch
into the `up` state. If the process is not running, the return is false and
god will put the Watch into the `start` state.

```ruby
  # determine when process has finished starting
  w.transition([:start, :restart], :up) do |on|
    on.condition(:process_running) do |c|
      c.running = true
    end

    ...
  end
```

If god has determined that my process isn't running, the Watch will be put
into the `start` state. Upon entering this state, the `start` command that I
specified on the Watch will be called. In addition, the above transition
specifies a condition that should be enabled when in either the `start` or
`restart` states. The condition is another `process_running`, however this
time I'm only interested in moving to another state once it returns `true`. A
`true` return from this condition means that the process is running and it's
ok to transition to the `up` state (second argument to `transition`).

```ruby
  # determine when process has finished starting
  w.transition([:start, :restart], :up) do |on|
    ...

    # failsafe
    on.condition(:tries) do |c|
      c.times = 5
      c.transition = :start
    end
  end
```

The other half of this transition uses the `tries` condition to ensure that
god doesn't get stuck in this state. It's possible that the process could go
down while the transition is being made, in which case god would end up
polling forever to see if the process is up. Here I've specified that if this
condition is called five times, god should override the normal transition
destination and move to the `start` state instead. If you specify a
`transition` attribute on any condition, that state will be transferred to
instead of the normal transfer destination.

```ruby
  # start if process is not running
  w.transition(:up, :start) do |on|
    on.condition(:process_exits)
  end
```

This is where the event based system comes into play. Once in the `up` state,
I want to be notified when my process exits. The `process_exits` condition
registers a callback that will trigger a transition change when it is fired
off. Event conditions (like this one) cannot be used in transitions that have
a hash for the second argument (as they do not return true or false).

```ruby
  # restart if memory or cpu is too high
  w.transition(:up, :restart) do |on|
    on.condition(:memory_usage) do |c|
      c.interval = 20
      c.above = 50.megabytes
      c.times = [3, 5]
    end

    on.condition(:cpu_usage) do |c|
      c.interval = 10
      c.above = 10.percent
      c.times = [3, 5]
    end
  end
```

Notice that I can have multiple transitions with the same start state. In this
case, I want to have the `memory_usage` and `cpu_usage` poll conditions going
at the same time that I listen for the process exit event. In the case of
runaway CPU or memory usage, however, I want to transition to the `restart`
state. When a Watch enters the `restart` state it will either call the
`restart` command that you specified, or if none has been set, call the `stop`
and then `start` commands.


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

Extend God with your own Conditions
-----------------------------------

God was designed from the start to allow you to easily write your own custom
conditions, making it simple to add tests that are application specific.


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

Contribute
----------

If you'd like to hack on god itself or contribute fixes or new functionality,
read this section.

The codebase can be found at https://github.com/mojombo/god. To get started,
fork god on GitHub into your own account and then pull that down to your local
machine. This way you can easily submit changes via Pull Requests later on.

```terminal
$ git clone git@github.com:yourusername/god
```

We recommend using link:https://github.com/sstephenson/rbenv[rbenv] and
link:https://github.com/sstephenson/ruby-build[ruby-build] to manage multiple
versions of Ruby and their separate gemsets. Any changes to god must work on
both Ruby 1.8.7-p352 and 1.9.3-p0.

God uses link:http://gembundler.com/[bundler] to deal with development
dependencies. Once you have the code locally, you can pull in all the
dependencies like so:

```terminal
$ cd god
$ bundle install
```

In order for process events to function during development you'll need to
compile the C extensions:

```terminal
$ cd ext/god
$ ruby extconf.rb
$ make
$ cd ../..
```

Now you're ready to run the tests and make sure everything is configured
properly.  On Linux you'll need to run the tests as root in order for the
events system to load. On MacOS there is no need to run the tests as root.

```terminal
$ [sudo] bundle exec rake
```

To run your development god to make sure config files and such still work
properly, just run:

```terminal
$ [sudo] bundle exec god -c myconfig.god -D
```

There are a bunch of example config files for various scenarios in
`test/configs` that you can try out. For big new features, it's great to add a
new test config showing off the usage of the feature.

If you intend to contribute your changes back to god core, make sure you create
a new branch and do your work there. Then, when your changes are ready to be
shared with the world, push them to your fork and issue a Pull Request against
mojombo/god. Make sure to describe your changes in detail and add relevant
tests.

Any feature additions or changes should be accompanied by corresponding updates
to the documentation. It can be found in the `docs` directory. The
documentation is done in link:http://github.com/github/gollum[Gollum] format
and then converted into the public site at http://godrb.com. To see the
generated site locally you'll first need to commit your changes to git and then
issue the following:

```terminal
$ bundle exec rake site
```

This will open the site in your browser so you can check for correctness.
</content>
		</actual_file>
		<actual_file>
			<filename>intro.asciidoc</filename>
			<content>God: The Ruby Framework for Process Management
==============================================
Tom Preston-Werner tom@mojombo.com

God is an easy to configure, easy to extend monitoring framework written in
Ruby.

Keeping your server processes and tasks running should be a simple part of
your deployment process. God aims to be the simplest, most powerful monitoring
application available.

Features
--------

* Config file is written in Ruby
* Easily write your own custom conditions in Ruby
* Supports both poll and event based conditions
* Different poll conditions can have different intervals
* Integrated notification system (write your own too!)
* Easily control non-daemonizing scripts
</content>
		</actual_file>
		<actual_file>
			<filename>events.god</filename>
			<content># This example shows how you might keep a local development Rails server up
# and running on your Mac.

# Run with:
# god -c /path/to/events.god

RAILS_ROOT = ENV['GOD_TEST_RAILS_ROOT']

%w{3002}.each do |port|
  God.watch do |w|
    w.name = "local-#{port}"
    w.interval = 5.seconds
    w.start = "mongrel_rails start -p #{port} -P #{RAILS_ROOT}/log/mongrel.#{port}.pid -c #{RAILS_ROOT} -d"
    w.stop = "mongrel_rails stop -P #{RAILS_ROOT}/log/mongrel.#{port}.pid -c #{RAILS_ROOT}"
    w.pid_file = File.join(RAILS_ROOT, "log/mongrel.#{port}.pid")
    w.log = File.join(RAILS_ROOT, "log/commands.#{port}.log")

    # clean pid files before start if necessary
    w.behavior(:clean_pid_file)

    # determine the state on startup
    w.transition(:init, { true = :up, false = :start }) do |on|
      on.condition(:process_running) do |c|
        c.running = true
      end
    end

    # determine when process has finished starting
    w.transition([:start, :restart], :up) do |on|
      on.condition(:process_running) do |c|
        c.running = true
      end

      # failsafe
      on.condition(:tries) do |c|
        c.times = 8
        c.within = 2.minutes
        c.transition = :start
      end
    end

    # start if process is not running
    w.transition(:up, :start) do |on|
      on.condition(:process_exits)
    end

    # restart if memory or cpu is too high
    w.transition(:up, :restart) do |on|
      on.condition(:memory_usage) do |c|
        c.interval = 20
        c.above = 50.megabytes
        c.times = [3, 5]
      end

      on.condition(:cpu_usage) do |c|
        c.interval = 10
        c.above = 10.percent
        c.times = 5
      end

      on.condition(:http_response_code) do |c|
        c.host = 'localhost'
        c.port = port
        c.path = '/'
        c.code_is = 500
        c.timeout = 10.seconds
        c.times = [3, 5]
      end
    end

    # lifecycle
    w.lifecycle do |on|
      on.condition(:flapping) do |c|
        c.to_state = [:start, :restart]
        c.times = 5
        c.within = 1.minute
        c.transition = :unmonitored
        c.retry_in = 10.minutes
        c.retry_times = 5
        c.retry_within = 2.hours
      end
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>gravatar.god</filename>
			<content># run with:  god -c /path/to/gravatar.god
#
# This is the actual config file used to keep the mongrels of
# gravatar.com running.

RAILS_ROOT = "/Users/tom/dev/gravatar2"

%w{8200 8201 8202}.each do |port|
  God.watch do |w|
    w.name = "gravatar2-mongrel-#{port}"
    w.interval = 30.seconds # default
    w.start = "mongrel_rails start -c #{RAILS_ROOT} -p #{port} \
      -P #{RAILS_ROOT}/log/mongrel.#{port}.pid  -d"
    w.stop = "mongrel_rails stop -P #{RAILS_ROOT}/log/mongrel.#{port}.pid"
    w.restart = "mongrel_rails restart -P #{RAILS_ROOT}/log/mongrel.#{port}.pid"
    w.start_grace = 10.seconds
    w.restart_grace = 10.seconds
    w.pid_file = File.join(RAILS_ROOT, "log/mongrel.#{port}.pid")

    w.behavior(:clean_pid_file)

    w.start_if do |start|
      start.condition(:process_running) do |c|
        c.interval = 5.seconds
        c.running = false
      end
    end

    w.restart_if do |restart|
      restart.condition(:memory_usage) do |c|
        c.above = 150.megabytes
        c.times = [3, 5] # 3 out of 5 intervals
      end

      restart.condition(:cpu_usage) do |c|
        c.above = 50.percent
        c.times = 5
      end
    end

    # lifecycle
    w.lifecycle do |on|
      on.condition(:flapping) do |c|
        c.to_state = [:start, :restart]
        c.times = 5
        c.within = 5.minute
        c.transition = :unmonitored
        c.retry_in = 10.minutes
        c.retry_times = 5
        c.retry_within = 2.hours
      end
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>single.god</filename>
			<content>RAILS_ROOT = "/Users/tom/dev/gravatar2"

God.watch do |w|
  w.name = "local-3000"
  w.interval = 5.seconds # default
  w.start = "mongrel_rails start -c #{RAILS_ROOT} -P #{RAILS_ROOT}/log/mongrel.pid -p 3000 -d"
  w.stop = "mongrel_rails stop -P #{RAILS_ROOT}/log/mongrel.pid"
  w.restart = "mongrel_rails restart -P #{RAILS_ROOT}/log/mongrel.pid"
  w.pid_file = File.join(RAILS_ROOT, "log/mongrel.pid")

  # clean pid files before start if necessary
  w.behavior(:clean_pid_file)

  # determine the state on startup
  w.transition(:init, { true = :up, false = :start }) do |on|
    on.condition(:process_running) do |c|
      c.running = true
    end
  end

  # determine when process has finished starting
  w.transition([:start, :restart], :up) do |on|
    on.condition(:process_running) do |c|
      c.running = true
    end

    # failsafe
    on.condition(:tries) do |c|
      c.times = 5
      c.transition = :start
    end
  end

  # start if process is not running
  w.transition(:up, :start) do |on|
    on.condition(:process_exits)
  end

  # restart if memory or cpu is too high
  w.transition(:up, :restart) do |on|
    on.condition(:memory_usage) do |c|
      c.interval = 20
      c.above = 50.megabytes
      c.times = [3, 5]
    end

    on.condition(:cpu_usage) do |c|
      c.interval = 10
      c.above = 10.percent
      c.times = [3, 5]
    end
  end

  # lifecycle
  w.lifecycle do |on|
    on.condition(:flapping) do |c|
      c.to_state = [:start, :restart]
      c.times = 5
      c.within = 5.minute
      c.transition = :unmonitored
      c.retry_in = 10.minutes
      c.retry_times = 5
      c.retry_within = 2.hours
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>.gitignore</filename>
			<content>Makefile
kqueue_handler_ext.bundle
kqueue_handler.o
netlink_handler_ext.bundle
netlink_handler.o
</content>
		</actual_file>
		<actual_file>
			<filename>extconf.rb</filename>
			<content>require 'mkmf'

fail = false

def create_dummy_makefile
  File.open("Makefile", 'w') do |f|
    f.puts "all:"
    f.puts "install:"
  end
end

case RUBY_PLATFORM
when /bsd/i, /darwin/i
  unless have_header('sys/event.h')
    puts
    puts "Missing 'sys/event.h' header"
    fail = true
  end

  if fail
    puts
    puts "Events handler could not be compiled (see above error). Your god installation will not support event conditions."
    create_dummy_makefile
  else
    create_makefile 'kqueue_handler_ext'
  end
when /linux/i
  unless have_header('linux/netlink.h')
    puts
    puts "Missing 'linux/netlink.h' header(s)"
    puts "You may need to install a header package for your system"
    fail = true
  end

  unless have_header('linux/connector.h') && have_header('linux/cn_proc.h')
    puts
    puts "Missing 'linux/connector.h', or 'linux/cn_proc.h' header(s)"
    puts "These are only available in Linux kernel 2.6.15 and later (run `uname -a` to find yours)"
    puts "You may need to install a header package for your system"
    fail = true
  end

  if fail
    puts
    puts "Events handler could not be compiled (see above error). Your god installation will not support event conditions."
    create_dummy_makefile
  else
    create_makefile 'netlink_handler_ext'
  end
else
  puts
  puts "Unsupported platform '#{RUBY_PLATFORM}'. Supported platforms are BSD, DARWIN, and LINUX."
  puts "Your god installation will not support event conditions."
  create_dummy_makefile
end
</content>
		</actual_file>
		<actual_file>
			<filename>kqueue_handler.c</filename>
			<content>#if defined(__FreeBSD__) || defined(__APPLE__) || defined(__OpenBSD__) || defined(__NetBSD__)

#include ruby.h
#include sys/event.h
#include sys/time.h
#include errno.h

static VALUE mGod;
static VALUE cKQueueHandler;
static VALUE cEventHandler;

static ID proc_exit;
static ID proc_fork;
static ID m_call;
static ID m_size;
static ID m_deregister;

static int kq;
int num_events;

#define NUM_EVENTS FIX2INT(rb_funcall(rb_cv_get(cEventHandler, "@@actions"), m_size, 0))

VALUE
kqh_event_mask(VALUE klass, VALUE sym)
{
  ID id = SYM2ID(sym);
  if (proc_exit == id) {
    return UINT2NUM(NOTE_EXIT);
  } else if (proc_fork == id) {
    return UINT2NUM(NOTE_FORK);
  } else {
    rb_raise(rb_eNotImpError, "Event `%s` not implemented", rb_id2name(id));
  }

  return Qnil;
}


VALUE
kqh_monitor_process(VALUE klass, VALUE pid, VALUE mask)
{
  struct kevent new_event;
  ID event;

  (void)event;      //! Silence warning about unused var, should be removed?

  u_int fflags = NUM2UINT(mask);

  EV_SET(&new_event, FIX2UINT(pid), EVFILT_PROC,
         EV_ADD | EV_ENABLE, fflags, 0, 0);

  if (-1 == kevent(kq, &new_event, 1, NULL, 0, NULL)) {
    rb_raise(rb_eStandardError, "%s", strerror(errno));
  }

  num_events = NUM_EVENTS;

  return Qnil;
}

VALUE
kqh_handle_events()
{
  int nevents, i, num_to_fetch;
  struct kevent *events;
  fd_set read_set;

  FD_ZERO(&read_set);
  FD_SET(kq, &read_set);

  // Don't actually run this method until we've got an event
  rb_thread_select(kq + 1, &read_set, NULL, NULL, NULL);

  // Grabbing num_events once for thread safety
  num_to_fetch = num_events;
  events = (struct kevent*)malloc(num_to_fetch * sizeof(struct kevent));

  if (NULL == events) {
    rb_raise(rb_eStandardError, "%s", strerror(errno));
  }

  nevents = kevent(kq, NULL, 0, events, num_to_fetch, NULL);

  if (-1 == nevents) {
    free(events);
    rb_raise(rb_eStandardError, "%s", strerror(errno));
  } else {
    for (i = 0; i  nevents; i++) {
      if (events[i].fflags & NOTE_EXIT) {
        rb_funcall(cEventHandler, m_call, 2, INT2NUM(events[i].ident), ID2SYM(proc_exit));
      } else if (events[i].fflags & NOTE_FORK) {
        rb_funcall(cEventHandler, m_call, 2, INT2NUM(events[i].ident), ID2SYM(proc_fork));
      }
    }
  }

  free(events);

  return INT2FIX(nevents);
}

void
Init_kqueue_handler_ext()
{
  kq = kqueue();

  if (kq == -1) {
    rb_raise(rb_eStandardError, "kqueue initilization failed");
  }

  proc_exit = rb_intern("proc_exit");
  proc_fork = rb_intern("proc_fork");
  m_call = rb_intern("call");
  m_size = rb_intern("size");
  m_deregister = rb_intern("deregister");

  mGod = rb_const_get(rb_cObject, rb_intern("God"));
  cEventHandler = rb_const_get(mGod, rb_intern("EventHandler"));
  cKQueueHandler = rb_define_class_under(mGod, "KQueueHandler", rb_cObject);
  rb_define_singleton_method(cKQueueHandler, "monitor_process", kqh_monitor_process, 2);
  rb_define_singleton_method(cKQueueHandler, "handle_events", kqh_handle_events, 0);
  rb_define_singleton_method(cKQueueHandler, "event_mask", kqh_event_mask, 1);
}

#endif
</content>
		</actual_file>
		<actual_file>
			<filename>netlink_handler.c</filename>
			<content>#ifdef __linux__ /* only build on linux */

#include ruby.h
#include sys/types.h
#include unistd.h
#include sys/socket.h
#include linux/netlink.h
#include linux/connector.h
#define _LINUX_TIME_H
#include linux/cn_proc.h
#include errno.h

static VALUE mGod;
static VALUE cNetlinkHandler;
static VALUE cEventHandler;

static ID proc_exit;
static ID proc_fork;
static ID m_call;
static ID m_watching_pid;

static int nl_sock;   /* socket for netlink connection  */


VALUE
nlh_handle_events()
{
  char buff[CONNECTOR_MAX_MSG_SIZE];
  struct nlmsghdr *hdr;
  struct proc_event *event;

  VALUE extra_data;

  fd_set fds;

  FD_ZERO(&fds);
  FD_SET(nl_sock, &fds);

  if (0  rb_thread_select(nl_sock + 1, &fds, NULL, NULL, NULL)) {
    rb_raise(rb_eStandardError, "%s", strerror(errno));
  }

  /* If there were no events detected, return */
  if (! FD_ISSET(nl_sock, &fds)) {
    return INT2FIX(0);
  }

  /* if there are events, make calls */
  if (-1 == recv(nl_sock, buff, sizeof(buff), 0)) {
    rb_raise(rb_eStandardError, "%s", strerror(errno));
  }

  hdr = (struct nlmsghdr *)buff;

  if (NLMSG_ERROR == hdr-nlmsg_type) {
    rb_raise(rb_eStandardError, "%s", strerror(errno));
  } else if (NLMSG_DONE == hdr-nlmsg_type) {

    event = (struct proc_event *)((struct cn_msg *)NLMSG_DATA(hdr))-data;

    switch(event-what) {
      case PROC_EVENT_EXIT:
        if (Qnil == rb_funcall(cEventHandler, m_watching_pid, 1, INT2FIX(event-event_data.exit.process_pid))) {
          return INT2FIX(0);
        }

        extra_data = rb_hash_new();
        rb_hash_aset(extra_data, ID2SYM(rb_intern("pid")), INT2FIX(event-event_data.exit.process_pid));
        rb_hash_aset(extra_data, ID2SYM(rb_intern("exit_code")), INT2FIX(event-event_data.exit.exit_code));
        rb_hash_aset(extra_data, ID2SYM(rb_intern("exit_signal")), INT2FIX(event-event_data.exit.exit_signal));
        rb_hash_aset(extra_data, ID2SYM(rb_intern("thread_group_id")), INT2FIX(event-event_data.exit.process_tgid));

        rb_funcall(cEventHandler, m_call, 3, INT2FIX(event-event_data.exit.process_pid), ID2SYM(proc_exit), extra_data);
        return INT2FIX(1);

      case PROC_EVENT_FORK:
        if (Qnil == rb_funcall(cEventHandler, m_watching_pid, 1, INT2FIX(event-event_data.fork.parent_pid))) {
          return INT2FIX(0);
        }

        extra_data = rb_hash_new();
        rb_hash_aset(extra_data, ID2SYM(rb_intern("parent_pid")), INT2FIX(event-event_data.fork.parent_pid));
        rb_hash_aset(extra_data, ID2SYM(rb_intern("parent_thread_group_id")), INT2FIX(event-event_data.fork.parent_tgid));
        rb_hash_aset(extra_data, ID2SYM(rb_intern("child_pid")), INT2FIX(event-event_data.fork.child_pid));
        rb_hash_aset(extra_data, ID2SYM(rb_intern("child_thread_group_id")), INT2FIX(event-event_data.fork.child_tgid));

        rb_funcall(cEventHandler, m_call, 3, INT2FIX(event-event_data.fork.parent_pid), ID2SYM(proc_fork), extra_data);
        return INT2FIX(1);

      default:
        break;
    }
  }

  return Qnil;
}


#define NL_MESSAGE_SIZE (sizeof(struct nlmsghdr) + sizeof(struct cn_msg) + \
                         sizeof(int))

void
connect_to_netlink()
{
  struct sockaddr_nl sa_nl; /* netlink interface info */
  char buff[NL_MESSAGE_SIZE];
  struct nlmsghdr *hdr; /* for telling netlink what we want */
  struct cn_msg *msg;   /* the actual connector message */

  /* connect to netlink socket */
  nl_sock = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_CONNECTOR);

  if (-1 == nl_sock) {
    rb_raise(rb_eStandardError, "%s", strerror(errno));
  }

  bzero(&sa_nl, sizeof(sa_nl));
  sa_nl.nl_family = AF_NETLINK;
  sa_nl.nl_groups = CN_IDX_PROC;
  sa_nl.nl_pid    = getpid();

  if (-1 == bind(nl_sock, (struct sockaddr *)&sa_nl, sizeof(sa_nl))) {
    rb_raise(rb_eStandardError, "%s", strerror(errno));
  }

  /* Fill header */
  hdr = (struct nlmsghdr *)buff;
  hdr-nlmsg_len = NL_MESSAGE_SIZE;
  hdr-nlmsg_type = NLMSG_DONE;
  hdr-nlmsg_flags = 0;
  hdr-nlmsg_seq = 0;
  hdr-nlmsg_pid = getpid();

  /* Fill message */
  msg = (struct cn_msg *)NLMSG_DATA(hdr);
  msg-id.idx = CN_IDX_PROC;  /* Connecting to process information */
  msg-id.val = CN_VAL_PROC;
  msg-seq = 0;
  msg-ack = 0;
  msg-flags = 0;
  msg-len = sizeof(int);
  *(int*)msg-data = PROC_CN_MCAST_LISTEN;

  if (-1 == send(nl_sock, hdr, hdr-nlmsg_len, 0)) {
    rb_raise(rb_eStandardError, "%s", strerror(errno));
  }
}

void
Init_netlink_handler_ext()
{
  proc_exit = rb_intern("proc_exit");
  proc_fork = rb_intern("proc_fork");
  m_call = rb_intern("call");
  m_watching_pid = rb_intern("watching_pid?");

  mGod = rb_const_get(rb_cObject, rb_intern("God"));
  cEventHandler = rb_const_get(mGod, rb_intern("EventHandler"));
  cNetlinkHandler = rb_define_class_under(mGod, "NetlinkHandler", rb_cObject);
  rb_define_singleton_method(cNetlinkHandler, "handle_events", nlh_handle_events, 0);

  connect_to_netlink();
}

#endif
</content>
		</actual_file>
		<actual_file>
			<filename>future.god</filename>
			<content># This example shows how you might keep a local development Rails server up
# and running on your Mac.

# Run with:
# god -c /path/to/events.god

RAILS_ROOT = "/Users/tom/dev/helloworld"

God::Contacts::Email.delivery_method = :smtp
God::Contacts::Email.server_settings = {}

God.contact(:email) do |c|
  c.name = 'tom'
  c.email = 'tom@powerset.com'
  c.group = 'developers'
  c.throttle = 30.minutes
end

God.watch do |w|
  w.name = "local-3000"
  w.interval = 5.seconds
  w.start = "mongrel_rails start -P ./log/mongrel.pid -c #{RAILS_ROOT} -d"
  w.stop = "mongrel_rails stop -P ./log/mongrel.pid -c #{RAILS_ROOT}"
  w.pid_file = File.join(RAILS_ROOT, "log/mongrel.pid")

  # clean pid files before start if necessary
  w.behavior(:clean_pid_file)

  # determine the state on startup
  w.transition(:init, { true = :up, false = :start }) do |on|
    on.condition(:process_running) do |c|
      c.running = true
    end
  end

  # determine when process has finished starting
  w.transition([:start, :restart], :up) do |on|
    on.condition(:process_running) do |c|
      c.running = true
    end
  end

  # start if process is not running
  w.transition(:up, :start) do |on|
    on.condition(:process_exits)
  end

  # restart if memory or cpu is too high
  w.transition(:up, :restart) do |on|
    on.condition(:memory_usage) do |c|
      c.interval = 20
      c.above = 50.megabytes
      c.times = [3, 5]
    end

    on.condition(:cpu_usage) do |c|
      c.interval = 10
      c.above = 10.percent
      c.times = [3, 5]
    end
  end

  # lifecycle
  w.lifecycle do |on|
    on.condition(:flapping) do |c|
      c.to_state = [:start, :restart]
      c.times = 5
      c.within = 30.seconds
      c.transition = nil
      c.retry = 60.seconds
      c.giveup_tries = 5
      c.notify = 'tom'
    end

    on.condition(:memory_usage) do |c|
      c.interval = 20
      c.above = 40.megabytes
      c.times = [3, 5]
      c.notify = 'tom'
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>execve.c</filename>
			<content>#include "ruby.h"

static VALUE mKernel;
void Init_execve();
VALUE method_execve(VALUE self, VALUE cmd, VALUE env);

void Init_execve() {
  mKernel = rb_const_get(rb_cObject, rb_intern("Kernel"));
  rb_define_method(mKernel, "execve", method_execve, 2);
}

VALUE method_execve(VALUE self, VALUE r_cmd, VALUE r_env) {
  char *shell = (char *)dln_find_exe("sh", 0);
  char *arg[] = { "sh", "-c", StringValuePtr(r_cmd), (char *)0 };

  struct RArray *env_array;
  env_array = RARRAY(r_env);
  char *env[env_array-len + 1];

  int i;
  for(i = 0; i  env_array-len; i++) {
    env[i] = StringValuePtr(env_array-ptr[i]);
  }

  env[env_array-len] = (char *)0;

  execve(shell, arg, env);
  return Qnil;
}
</content>
		</actual_file>
		<actual_file>
			<filename>extconf.rb</filename>
			<content># Loads mkmf which is used to make makefiles for Ruby extensions
require 'mkmf'

# Give it a name
extension_name = 'execve'

# The destination
dir_config(extension_name)

# Do the work
create_makefile(extension_name)
</content>
		</actual_file>
		<actual_file>
			<filename>go.rb</filename>
			<content>require 'execve'

my_env = ENV.to_hash.merge('HOME' = '/foo')
# my_env = ENV.to_hash

env = my_env.keys.inject([]) { |acc, k| acc  "#{k}=#{my_env[k]}"; acc }

execve(%Q{ruby -e "puts ENV['HOME']"}, env)
</content>
		</actual_file>
		<actual_file>
			<filename>god</filename>
			<content>#!/bin/bash
#
# god       Startup script for god (http://god.rubyforge.org)
#
# chkconfig: - 85 15
# description: God is an easy to configure, easy to extend monitoring \
#              framework written in Ruby.
#

CONF_DIR=/etc/god

RETVAL=0

# Go no further if config directory is missing.
[ -d "$CONF_DIR" ] || exit 0

case "$1" in
    start)
      # Create pid directory
      ruby /usr/bin/god -c $CONF_DIR/master.conf
      RETVAL=$?
  ;;
    stop)
      ruby /usr/bin/god terminate
      RETVAL=$?
  ;;
    restart)
      ruby /usr/bin/god terminate
      ruby /usr/bin/god -c $CONF_DIR/master.conf
      RETVAL=$?
  ;;
    status)
      ruby /usr/bin/god status
      RETVAL=$?
  ;;
    *)
      echo "Usage: god {start|stop|restart|status}"
      exit 1
  ;;
esac

exit $RETVAL
</content>
		</actual_file>
		<actual_file>
			<filename>lsb_compliant_god</filename>
			<content>#!/usr/bin/env ruby

# see http://refspecs.freestandards.org/LSB_3.1.0/LSB-Core-generic/LSB-Core-generic/iniscrptact.html

PATH="/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin"
DESC="god daemon"
NAME="god"
DAEMON="/usr/bin/#{NAME}"
CONFIGFILE="/etc/god/god.conf"
PIDFILE="/var/run/#{NAME}.pid"
SCRIPTNAME="/etc/init.d/#{NAME}"
START_FLAGS="--no-syslog -P #{PIDFILE}"

ENV["PATH"] = PATH

def read_pid
  begin
    @pid = File.read(PIDFILE).to_i
    @pid = nil if @pid == 0
  rescue
    @pid = nil
  end
end

def kill(code)
  Process.kill(code, @pid)
  true
rescue
  false
end

def running?
  @pid && kill(0)
end

def dead?
  @pid && !kill(0)
end

def start
  if running?
    puts "already running (#{@pid})"
    exit
  end

  if dead?
    clean_pid
  end

  puts "starting #{NAME}"
  system("#{DAEMON} -c #{CONFIGFILE} #{START_FLAGS}")
end

def stop
  if not running?
    puts "not running"
    exit
  end

	system("god quit")
end

def restart
	if running?
		stop
		read_pid
	end
	start
end

def force_reload
	if running?
	  restart
	end
end

def clean_pid
  File.delete(PIDFILE)
end

read_pid
case ARGV[0]
when 'start'
  start
when 'stop'
  stop
when 'restart'
  if not running?
    start
  else
    restart
  end
when 'force-reload'
  force_reload
when 'status'
  if running?
    puts "running (#{@pid})"
  elsif dead?
    puts "dead (#{@pid})"
    exit!(1)
  else
    puts "not running"
    exit!(3)
  end
else
  puts "Usage: #{SCRIPTNAME} start|stop|restart|force-reload|status"
end

exit
</content>
		</actual_file>
		<actual_file>
			<filename>god.rb</filename>
			<content># Bail out before loading anything unless this flag is set.
#
# We are doing this to guard against bundler autoloading because there is
# no value in loading god in most processes.
if $load_god

# core
require 'stringio'
require 'fileutils'

begin
  require 'fastthread'
rescue LoadError
ensure
  require 'thread'
end

# stdlib

# internal requires
require 'god/errors'
require 'god/simple_logger'
require 'god/logger'
require 'god/sugar'

require 'god/system/process'
require 'god/system/portable_poller'
require 'god/system/slash_proc_poller'

require 'god/timeline'
require 'god/configurable'

require 'god/task'

require 'god/behavior'
require 'god/behaviors/clean_pid_file'
require 'god/behaviors/clean_unix_socket'
require 'god/behaviors/notify_when_flapping'

require 'god/condition'
require 'god/conditions/process_running'
require 'god/conditions/process_exits'
require 'god/conditions/tries'
require 'god/conditions/memory_usage'
require 'god/conditions/cpu_usage'
require 'god/conditions/always'
require 'god/conditions/lambda'
require 'god/conditions/degrading_lambda'
require 'god/conditions/flapping'
require 'god/conditions/http_response_code'
require 'god/conditions/disk_usage'
require 'god/conditions/complex'
require 'god/conditions/file_mtime'
require 'god/conditions/file_touched'
require 'god/conditions/socket_responding'

require 'god/socket'
require 'god/driver'

require 'god/metric'
require 'god/watch'

require 'god/trigger'
require 'god/event_handler'
require 'god/registry'
require 'god/process'

require 'god/cli/version'
require 'god/cli/command'

# ruby 1.8 specific configuration
if RUBY_VERSION  '1.9'
  $KCODE = 'u'
end

CONTACT_DEPS = { }
CONTACT_LOAD_SUCCESS = { }

def load_contact(name)
  require "god/contacts/#{name}"
  CONTACT_LOAD_SUCCESS[name] = true
rescue LoadError
  CONTACT_LOAD_SUCCESS[name] = false
end

require 'god/contact'
load_contact(:campfire)
load_contact(:hipchat)
load_contact(:email)
load_contact(:jabber)
load_contact(:prowl)
load_contact(:scout)
load_contact(:twitter)
load_contact(:webhook)
load_contact(:airbrake)

$:.unshift File.join(File.dirname(__FILE__), *%w[.. ext god])

# App wide logging system
LOG = God::Logger.new

def applog(watch, level, text)
  LOG.log(watch, level, text)
end

# The $run global determines whether god should be started when the
# program would normally end. This should be set to true if when god
# should be started (e.g. `god -c config file`) and false otherwise
# (e.g. `god status`)
$run ||= nil

GOD_ROOT = File.expand_path(File.join(File.dirname(__FILE__), '..'))

# Return the binding of god's root level
def root_binding
  binding
end

module Kernel
  alias_method :abort_orig, :abort

  def abort(text = nil)
    $run = false
    applog(nil, :error, text) if text
    exit(1)
  end

  alias_method :exit_orig, :exit

  def exit(code = 0)
    $run = false
    exit_orig(code)
  end
end

class Module
  def safe_attr_accessor(*args)
    args.each do |arg|
      define_method((arg.to_s + "=").intern) do |other|
        if !self.running && self.inited
          abort "God.#{arg} must be set before any Tasks are defined"
        end

        if self.running && self.inited
          applog(nil, :warn, "God.#{arg} can't be set while god is running")
          return
        end

        instance_variable_set(('@' + arg.to_s).intern, other)
      end

      define_method(arg) do
        instance_variable_get(('@' + arg.to_s).intern)
      end
    end
  end
end

module God
  # The String version number for this package.
  VERSION = '0.13.4'

  # The Integer number of lines of backlog to keep for the logger.
  LOG_BUFFER_SIZE_DEFAULT = 100

  # An Array of directory paths to be used as the default PID file directory.
  # This list will be searched in order and the first one that has write
  # permissions will be used.
  PID_FILE_DIRECTORY_DEFAULTS = ['/var/run/god', '~/.god/pids']

  # The default Integer port number for the DRb communcations channel.
  DRB_PORT_DEFAULT = 17165

  # The default Array of String IPs that will allow DRb communication access.
  DRB_ALLOW_DEFAULT = ['127.0.0.1']

  # The default Symbol log level.
  LOG_LEVEL_DEFAULT = :info

  # The default Integer number of seconds to wait for god to terminate when
  # issued the quit command.
  TERMINATE_TIMEOUT_DEFAULT = 10

  # The default Integer number of seconds to wait for a process to terminate.
  STOP_TIMEOUT_DEFAULT = 10

  # The default String signal to send for the stop command.
  STOP_SIGNAL_DEFAULT = 'TERM'

  class  self
    # user configurable
    safe_attr_accessor :pid,
                       :host,
                       :port,
                       :allow,
                       :log_buffer_size,
                       :pid_file_directory,
                       :log_file,
                       :log_level,
                       :use_events,
                       :terminate_timeout,
                       :socket_user,
                       :socket_group,
                       :socket_perms

    # internal
    attr_accessor :inited,
                  :running,
                  :pending_watches,
                  :pending_watch_states,
                  :server,
                  :watches,
                  :groups,
                  :contacts,
                  :contact_groups,
                  :main
  end

  # Initialize class instance variables.
  self.pid = nil
  self.host = nil
  self.port = nil
  self.allow = nil
  self.log_buffer_size = nil
  self.pid_file_directory = nil
  self.log_level = nil
  self.terminate_timeout = nil
  self.socket_user = nil
  self.socket_group = nil
  self.socket_perms = 0755

  # Initialize internal data.
  #
  # Returns nothing.
  def self.internal_init
    # Only do this once.
    return if self.inited

    # Variable init.
    self.watches = {}
    self.groups = {}
    self.pending_watches = []
    self.pending_watch_states = {}
    self.contacts = {}
    self.contact_groups = {}

    # Set defaults.
    self.log_buffer_size ||= LOG_BUFFER_SIZE_DEFAULT
    self.port ||= DRB_PORT_DEFAULT
    self.allow ||= DRB_ALLOW_DEFAULT
    self.log_level ||= LOG_LEVEL_DEFAULT
    self.terminate_timeout ||= TERMINATE_TIMEOUT_DEFAULT

    # Additional setup.
    self.setup

    # Log level.
    log_level_map = {:debug = Logger::DEBUG,
                     :info = Logger::INFO,
                     :warn = Logger::WARN,
                     :error = Logger::ERROR,
                     :fatal = Logger::FATAL}
    LOG.level = log_level_map[self.log_level]

    # Init has been executed.
    self.inited = true

    # Not yet running.
    self.running = false
  end

  # Instantiate a new, empty Watch object and pass it to the mandatory block.
  # The attributes of the watch will be set by the configuration file. Aborts
  # on duplicate watch name, invalid watch, or conflicting group name.
  #
  # Returns nothing.
  def self.watch(&block)
    self.task(Watch, &block)
  end

  # Instantiate a new, empty Task object and yield it to the mandatory block.
  # The attributes of the task will be set by the configuration file. Aborts
  # on duplicate task name, invalid task, or conflicting group name.
  #
  # Returns nothing.
  def self.task(klass = Task)
    # Ensure internal init has run.
    self.internal_init

    t = klass.new
    yield(t)

    # Do the post-configuration.
    t.prepare

    # If running, completely remove the watch (if necessary) to prepare for
    # the reload
    existing_watch = self.watches[t.name]
    if self.running && existing_watch
      self.pending_watch_states[existing_watch.name] = existing_watch.state
      self.unwatch(existing_watch)
    end

    # Ensure the new watch has a unique name.
    if self.watches[t.name] || self.groups[t.name]
      abort "Task name '#{t.name}' already used for a Task or Group"
    end

    # Ensure watch is internally valid.
    t.valid? || abort("Task '#{t.name}' is not valid (see above)")

    # Add to list of watches.
    self.watches[t.name] = t

    # Add to pending watches.
    self.pending_watches  t

    # Add to group if specified.
    if t.group
      # Ensure group name hasn't been used for a watch already.
      if self.watches[t.group]
        abort "Group name '#{t.group}' already used for a Task"
      end

      self.groups[t.group] ||= []
      self.groups[t.group]  t
    end

    # Register watch.
    t.register!

    # Log.
    if self.running && existing_watch
      applog(t, :info, "#{t.name} Reloaded config")
    elsif self.running
      applog(t, :info, "#{t.name} Loaded config")
    end
  end

  # Unmonitor and remove the given watch from god.
  #
  # watch - The Watch to remove.
  #
  # Returns nothing.
  def self.unwatch(watch)
    # Unmonitor.
    watch.unmonitor unless watch.state == :unmonitored

    # Unregister.
    watch.unregister!

    # Remove from watches.
    self.watches.delete(watch.name)

    # Remove from groups.
    if watch.group
      self.groups[watch.group].delete(watch)
    end

    applog(watch, :info, "#{watch.name} unwatched")
  end

  # Instantiate a new Contact of the given kind and send it to the block.
  # Then prepare, validate, and record the Contact. Aborts on invalid kind,
  # duplicate contact name, invalid contact, or conflicting group name.
  #
  # kind - The Symbol contact class specifier.
  #
  # Returns nothing.
  def self.contact(kind)
    # Ensure internal init has run.
    self.internal_init

    # Verify contact has been loaded.
    if CONTACT_LOAD_SUCCESS[kind] == false
      applog(nil, :error, "A required dependency for the #{kind} contact is unavailable.")
      applog(nil, :error, "Run the following commands to install the dependencies:")
      CONTACT_DEPS[kind].each do |d|
        applog(nil, :error, "  [sudo] gem install #{d}")
      end
      abort
    end

    # Create the contact.
    begin
      c = Contact.generate(kind)
    rescue NoSuchContactError = e
      abort e.message
    end

    # Send to block so config can set attributes.
    yield(c) if block_given?

    # Call prepare on the contact.
    c.prepare

    # Remove existing contacts of same name.
    existing_contact = self.contacts[c.name]
    if self.running && existing_contact
      self.uncontact(existing_contact)
    end

    # Warn and noop if the contact has been defined before.
    if self.contacts[c.name] || self.contact_groups[c.name]
      applog(nil, :warn, "Contact name '#{c.name}' already used for a Contact or Contact Group")
      return
    end

    # Abort if the Contact is invalid, the Contact will have printed out its
    # own error messages by now.
    unless Contact.valid?(c) && c.valid?
      abort "Exiting on invalid contact"
    end

    # Add to list of contacts.
    self.contacts[c.name] = c

    # Add to contact group if specified.
    if c.group
      # Ensure group name hasn't been used for a contact already.
      if self.contacts[c.group]
        abort "Contact Group name '#{c.group}' already used for a Contact"
      end

      self.contact_groups[c.group] ||= []
      self.contact_groups[c.group]  c
    end
  end

  # Remove the given contact from god.
  #
  # contact - The Contact to remove.
  #
  # Returns nothing.
  def self.uncontact(contact)
    self.contacts.delete(contact.name)
    if contact.group
      self.contact_groups[contact.group].delete(contact)
    end
  end

  def self.watches_by_name(name)
    case name 
      when "", nil then self.watches.values.dup
      else Array(self.watches[name] || self.groups[name]).dup
    end
  end

  # Control the lifecycle of the given task(s).
  #
  # name    - The String name of a task/group. If empty, invokes command for all tasks.
  # command - The String command to run. Valid commands are:
  #           "start", "monitor", "restart", "stop", "unmonitor", "remove".
  #
  # Returns an Array of String task names affected by the command.
  def self.control(name, command)
    # Get the list of items.
    items = self.watches_by_name(name)

    jobs = []

    # Do the command.
    case command
      when "start", "monitor"
        items.each { |w| jobs  Thread.new { w.monitor if w.state != :up } }
      when "restart"
        items.each { |w| jobs  Thread.new { w.move(:restart) } }
      when "stop"
        items.each { |w| jobs  Thread.new { w.action(:stop); w.unmonitor if w.state != :unmonitored } }
      when "unmonitor"
        items.each { |w| jobs  Thread.new { w.unmonitor if w.state != :unmonitored } }
      when "remove"
        items.each { |w| self.unwatch(w) }
      else
        raise InvalidCommandError.new
    end

    jobs.each { |j| j.join }

    items.map { |x| x.name }
  end

  # Unmonitor and stop all tasks.
  #
  # Returns true on success, false if all tasks could not be stopped within 10
  # seconds
  def self.stop_all
    self.watches.sort.each do |name, w|
      Thread.new do
        w.unmonitor if w.state != :unmonitored
        w.action(:stop) if w.alive?
      end
    end

    terminate_timeout.times do
      return true unless self.watches.map { |name, w| w.alive? }.any?
      sleep 1
    end

    return false
  end

  # Force the termination of god.
  # * Clean up pid file if one exists
  # * Stop DRb service
  # * Hard exit using exit!
  #
  # Never returns because the process will no longer exist!
  def self.terminate
    FileUtils.rm_f(self.pid) if self.pid
    self.server.stop if self.server
    exit!(0)
  end

  # Gather the status of each task.
  #
  # Examples
  #
  #   God.status
  #   # = { 'mongrel' = :up, 'nginx' = :up }
  #
  # Returns a Hash where the key is the String task name and the value is the
  #   Symbol status.
  def self.status
    info = {}
    self.watches.map do |name, w|
      info[name] = {:state = w.state, :group = w.group}
    end
    info
  end

  # Send a signal to each task.
  #
  # name   - The String name of the task or group.
  # signal - The String or integer signal to send. e.g. 'HUP', 9.
  #
  # Returns an Array of String names of the tasks affected.
  def self.signal(name, signal)
    items = watches_by_name(name)
    jobs = []
    items.each { |w| jobs  Thread.new { w.signal(signal) } }
    jobs.each { |j| j.join }
    items.map { |x| x.name }
  end

  # Log lines for the given task since the specified time.
  #
  # watch_name - The String name of the task (may be abbreviated).
  # since      - The Time since which to report log lines.
  #
  # Raises God::NoSuchWatchError if no tasks matched.
  # Returns the String of newline separated log lines.
  def self.running_log(watch_name, since)
    matches = pattern_match(watch_name, self.watches.keys)

    unless matches.first
      raise NoSuchWatchError.new
    end

    LOG.watch_log_since(matches.first, since)
  end

  # Load a config file into a running god instance. Rescues any exceptions
  # that the config may raise and reports these back to the caller.
  #
  # code     - The String config file contents.
  # filename - The filename of the config file.
  # action   - The optional String command specifying how to deal with
  #            existing watches. Valid options are: 'stop', 'remove' or
  #            'leave' (default).
  #
  # Returns a three-tuple Array [loaded_names, errors, unloaded_names] where:
  #         loaded_names   - The Array of String task names that were loaded.
  #         errors         - The String of error messages produced during the
  #                          load phase. Will be a blank String if no errors
  #                          were encountered.
  #         unloaded_names - The Array of String task names that were unloaded
  #                          from the system (if 'remove' or 'stop' was
  #                          specified as the action).
  def self.running_load(code, filename, action = nil)
    errors = ""
    loaded_watches = []
    unloaded_watches = []
    jobs = []

    begin
      LOG.start_capture

      Gem.clear_paths
      eval(code, root_binding, filename)
      self.pending_watches.each do |w|
        if previous_state = self.pending_watch_states[w.name]
          w.monitor unless previous_state == :unmonitored
        else
          w.monitor if w.autostart?
        end
      end
      loaded_watches = self.pending_watches.map { |w| w.name }
      self.pending_watches.clear
      self.pending_watch_states.clear

      self.watches.each do |name, watch|
        next if loaded_watches.include?(name)

        case action
        when 'stop'
          jobs  Thread.new(watch) { |w| w.action(:stop); self.unwatch(w) }
          unloaded_watches  name
        when 'remove'
          jobs  Thread.new(watch) { |w| self.unwatch(w) }
          unloaded_watches  name
        when 'leave', '', nil
          # Do nothing
        else
          raise InvalidCommandError, "Unknown action: #{action}"
        end
      end

      # Make sure we quit capturing when we're done.
      LOG.finish_capture
    rescue Exception = e
      # Don't ever let running_load take down god.
      errors  LOG.finish_capture

      unless e.instance_of?(SystemExit)
        errors  e.message  "\n"
        errors  e.backtrace.join("\n")
      end
    end

    jobs.each { |t| t.join }

    [loaded_watches, errors, unloaded_watches]
  end

  # Load the given file(s) according to the given glob.
  #
  # glob - The glob-enabled String path to load.
  #
  # Returns nothing.
  def self.load(glob)
    Dir[glob].each do |f|
      Kernel.load f
    end
  end

  # Setup pid file directory and log system.
  #
  # Returns nothing.
  def self.setup
    if self.pid_file_directory
      # Pid file dir was specified, ensure it is created and writable.
      unless File.exist?(self.pid_file_directory)
        begin
          FileUtils.mkdir_p(self.pid_file_directory)
        rescue Errno::EACCES = e
          abort "Failed to create pid file directory: #{e.message}"
        end
      end

      unless File.writable?(self.pid_file_directory)
        abort "The pid file directory (#{self.pid_file_directory}) is not writable by #{Etc.getlogin}"
      end
    else
      # No pid file dir specified, try defaults.
      PID_FILE_DIRECTORY_DEFAULTS.each do |idir|
        dir = File.expand_path(idir)
        begin
          FileUtils.mkdir_p(dir)
          if File.writable?(dir)
            self.pid_file_directory = dir
            break
          end
        rescue Errno::EACCES = e
        end
      end

      unless self.pid_file_directory
        dirs = PID_FILE_DIRECTORY_DEFAULTS.map { |x| File.expand_path(x) }
        abort "No pid file directory exists, could be created, or is writable at any of #{dirs.join(', ')}"
      end
    end

    if God::Logger.syslog
      LOG.info("Syslog enabled.")
    else
      LOG.info("Syslog disabled.")
    end

    applog(nil, :info, "Using pid file directory: #{self.pid_file_directory}")
  end

  # Initialize and startup the machinery that makes god work.
  #
  # Returns nothing.
  def self.start
    self.internal_init

    # Instantiate server.
    self.server = Socket.new(self.port, self.socket_user, self.socket_group, self.socket_perms)

    # Start monitoring any watches set to autostart.
    self.watches.values.each { |w| w.monitor if w.autostart? }

    # Clear pending watches.
    self.pending_watches.clear

    # Mark as running.
    self.running = true

    # Don't exit.
    self.main =
    Thread.new do
      loop do
        sleep 60
      end
    end
  end

  # Prevent god from exiting.
  #
  # Returns nothing.
  def self.join
    self.main.join if self.main
  end

  # Returns the version String.
  def self.version
    God::VERSION
  end

  # To be called on program exit to start god.
  #
  # Returns nothing.
  def self.at_exit
    self.start
    self.join
  end

  # private

  # Match a shortened pattern against a list of String candidates.
  # The pattern is expanded into a regular expression by
  # inserting .* between each character.
  #
  # pattern - The String containing the abbreviation.
  # list    - The Array of Strings to match against.
  #
  # Examples
  #
  #   list = %w{ foo bar bars }
  #   pattern = 'br'
  #   God.pattern_match(list, pattern)
  #   # = ['bar', 'bars']
  #
  # Returns the Array of matching name Strings.
  def self.pattern_match(pattern, list)
    regex = pattern.split('').join('.*')

    list.select do |item|
      item =~ Regexp.new(regex)
    end.sort_by { |x| x.size }
  end
end

# Runs immediately before the program exits. If $run is true,
# start god, if $run is false, exit normally.
#
# Returns nothing.
at_exit do
  God.at_exit if $run
end

end
</content>
		</actual_file>
		<actual_file>
			<filename>behavior.rb</filename>
			<content>module God

  class Behavior
    include Configurable

    attr_accessor :watch

    # Generate a Behavior of the given kind. The proper class is found by camel casing the
    # kind (which is given as an underscored symbol).
    #   +kind+ is the underscored symbol representing the class (e.g. foo_bar for God::Behaviors::FooBar)
    def self.generate(kind, watch)
      sym = kind.to_s.capitalize.gsub(/_(.)/){$1.upcase}.intern
      b = God::Behaviors.const_get(sym).new
      b.watch = watch
      b
    rescue NameError
      raise NoSuchBehaviorError.new("No Behavior found with the class name God::Behaviors::#{sym}")
    end

    def valid?
      true
    end

    #######

    def before_start
    end

    def after_start
    end

    def before_restart
    end

    def after_restart
    end

    def before_stop
    end

    def after_stop
    end

    # Construct the friendly name of this Behavior, looks like:
    #
    # Behavior FooBar on Watch 'baz'
    def friendly_name
      "Behavior " + super + " on Watch '#{self.watch.name}'"
    end
  end

end
</content>
		</actual_file>
		<actual_file>
			<filename>compat19.rb</filename>
			<content>require 'monitor'

# Taken from http://redmine.ruby-lang.org/repositories/entry/ruby-19/lib/monitor.rb

module MonitorMixin
  class ConditionVariable
    def wait(timeout = nil)
      @monitor.__send__(:mon_check_owner)
      count = @monitor.__send__(:mon_exit_for_cond)
      begin
        @cond.wait(@monitor.instance_variable_get("@mon_mutex"), timeout)
        return true
      ensure
        @monitor.__send__(:mon_enter_for_cond, count)
      end
    end
  end
end

# Taken from http://redmine.ruby-lang.org/repositories/entry/ruby-19/lib/thread.rb

class ConditionVariable
  def wait(mutex, timeout=nil)
    begin
      # TODO: mutex should not be used
      @waiters_mutex.synchronize do
        @waiters.push(Thread.current)
      end
      mutex.sleep timeout
    end
    self
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>condition.rb</filename>
			<content>module God

  class Condition  Behavior
    attr_accessor :transition, :notify, :info, :phase

    # Generate a Condition of the given kind. The proper class if found by camel casing the
    # kind (which is given as an underscored symbol).
    #   +kind+ is the underscored symbol representing the class (e.g. :foo_bar for God::Conditions::FooBar)
    def self.generate(kind, watch)
      sym = kind.to_s.capitalize.gsub(/_(.)/){$1.upcase}.intern
      c = God::Conditions.const_get(sym).new

      unless c.kind_of?(PollCondition) || c.kind_of?(EventCondition) || c.kind_of?(TriggerCondition)
        abort "Condition '#{c.class.name}' must subclass God::PollCondition, God::EventCondition, or God::TriggerCondition"
      end

      if !EventHandler.loaded? && c.kind_of?(EventCondition)
        abort "Condition '#{c.class.name}' requires an event system but none has been loaded"
      end

      c.watch = watch
      c
    rescue NameError
      raise NoSuchConditionError.new("No Condition found with the class name God::Conditions::#{sym}")
    end

    def self.valid?(condition)
      valid = true
      if condition.notify
        begin
          Contact.normalize(condition.notify)
        rescue ArgumentError = e
          valid &= Configurable.complain("Attribute 'notify' " + e.message, condition)
        end
      end
      valid
    end

    # Construct the friendly name of this Condition, looks like:
    #
    # Condition FooBar on Watch 'baz'
    def friendly_name
      "Condition #{self.class.name.split('::').last} on Watch '#{self.watch.name}'"
    end
  end

  class PollCondition  Condition
    # all poll conditions can specify a poll interval
    attr_accessor :interval

    # Override this method in your Conditions (optional)
    def before
    end

    # Override this method in your Conditions (mandatory)
    #
    # Return true if the test passes (everything is ok)
    # Return false otherwise
    def test
      raise AbstractMethodNotOverriddenError.new("PollCondition#test must be overridden in subclasses")
    end

    # Override this method in your Conditions (optional)
    def after
    end
  end

  class EventCondition  Condition
    def register
      raise AbstractMethodNotOverriddenError.new("EventCondition#register must be overridden in subclasses")
    end

    def deregister
      raise AbstractMethodNotOverriddenError.new("EventCondition#deregister must be overridden in subclasses")
    end
  end

  class TriggerCondition  Condition
    def process(event, payload)
      raise AbstractMethodNotOverriddenError.new("TriggerCondition#process must be overridden in subclasses")
    end

    def trigger
      self.watch.trigger(self)
    end

    def register
      Trigger.register(self)
    end

    def deregister
      Trigger.deregister(self)
    end
  end

end
</content>
		</actual_file>
		<actual_file>
			<filename>configurable.rb</filename>
			<content>module God

  module Configurable
    # Override this method in your Configurable (optional)
    #
    # Called once after the Configurable has been sent to the block and attributes have been
    # set. Do any post-processing on attributes here
    def prepare

    end

    def reset

    end

    # Override this method in your Configurable (optional)
    #
    # Called once during evaluation of the config file. Return true if valid, false otherwise
    #
    # A convenience method 'complain' is available that will print out a message and return false,
    # making it easy to report multiple validation errors:
    #
    #   def valid?
    #     valid = true
    #     valid &= complain("You must specify the 'pid_file' attribute for :memory_usage") if self.pid_file.nil?
    #     valid &= complain("You must specify the 'above' attribute for :memory_usage") if self.above.nil?
    #     valid
    #   end
    def valid?
      true
    end

    def base_name
      x = 1 # fix for MRI's local scope optimization bug DO NOT REMOVE!
      @base_name ||= self.class.name.split('::').last
    end

    def friendly_name
      base_name
    end

    def self.complain(text, c = nil)
      watch = c.watch rescue nil
      msg = ""
      msg += "#{watch.name}: " if watch
      msg += text
      msg += " for #{c.friendly_name}" if c
      applog(watch, :error, msg)
      false
    end

    def complain(text, c = nil)
      Configurable.complain(text, c)
    end
  end

end
</content>
		</actual_file>
		<actual_file>
			<filename>contact.rb</filename>
			<content>module God

  class Contact
    include Configurable

    attr_accessor :name, :group, :info

    def self.generate(kind)
      sym = kind.to_s.capitalize.gsub(/_(.)/){$1.upcase}.intern
      c = God::Contacts.const_get(sym).new

      unless c.kind_of?(Contact)
        abort "Contact '#{c.class.name}' must subclass God::Contact"
      end

      c
    rescue NameError
      raise NoSuchContactError.new("No Contact found with the class name God::Contacts::#{sym}")
    end

    def self.valid?(contact)
      valid = true
      valid &= Configurable.complain("Attribute 'name' must be specified", contact) if contact.name.nil?
      valid
    end

    def self.defaults
      yield self
    end

    def arg(name)
      self.instance_variable_get("@#{name}") || self.class.instance_variable_get("@#{name}")
    end

    # Normalize the given notify specification into canonical form.
    #   +spec+ is the notify spec as a String, Array of Strings, or Hash
    #
    # Canonical form looks like:
    # {:contacts = ['fred', 'john'], :priority = '1', :category = 'awesome'}
    # Where :contacts will be present and point to an Array of Strings. Both
    # :priority and :category may not be present but if they are, they will each
    # contain a single String.
    #
    # Returns normalized notify spec
    # Raises ArgumentError on invalid spec (message contains details)
    def self.normalize(spec)
      case spec
        when String
          {:contacts = Array(spec)}
        when Array
          unless spec.select { |x| !x.instance_of?(String) }.empty?
            raise ArgumentError.new("contains non-String elements")
          end
          {:contacts = spec}
        when Hash
          copy = spec.dup

          # check :contacts
          if contacts = copy.delete(:contacts)
            case contacts
              when String
                # valid
              when Array
                unless contacts.select { |x| !x.instance_of?(String) }.empty?
                  raise ArgumentError.new("has a :contacts key containing non-String elements")
                end
                # valid
              else
                raise ArgumentError.new("must have a :contacts key pointing to a String or Array of Strings")
            end
          else
            raise ArgumentError.new("must have a :contacts key")
          end

          # remove priority and category
          copy.delete(:priority)
          copy.delete(:category)

          # check for invalid keys
          unless copy.empty?
            raise ArgumentError.new("contains extra elements: #{copy.inspect}")
          end

          # normalize
          spec[:contacts] &&= Array(spec[:contacts])
          spec[:priority] &&= spec[:priority].to_s
          spec[:category] &&= spec[:category].to_s

          spec
        else
          raise ArgumentError.new("must be a String (contact name), Array (of contact names), or Hash (contact specification)")
      end
    end

    # Abstract
    # Send the message to the external source
    #   +message+ is the message body returned from the condition
    #   +time+ is the Time at which the notification was made
    #   +priority+ is the arbitrary priority String
    #   +category+ is the arbitrary category String
    #   +host+ is the hostname of the server
    def notify(message, time, priority, category, host)
      raise AbstractMethodNotOverriddenError.new("Contact#notify must be overridden in subclasses")
    end

    # Construct the friendly name of this Contact, looks like:
    #
    # Contact FooBar
    def friendly_name
      super + " Contact '#{self.name}'"
    end
  end

end
</content>
		</actual_file>
		<actual_file>
			<filename>driver.rb</filename>
			<content>require 'monitor'

# Ruby 1.9.1 specific fixes.
if RUBY_VERSION.between?('1.9', '1.9.1')
  require 'god/compat19'
end

module God
  # The TimedEvent class represents an event in the future. This class is used
  # by the drivers to schedule upcoming conditional tests and other scheduled
  # events.
  class TimedEvent
    include Comparable

    # The Time at which this event is due.
    attr_accessor :at

    # Instantiate a new TimedEvent that will be triggered after the specified
    # delay.
    #
    # delay - The optional Numeric number of seconds from now at which to
    #         trigger (default: 0).
    def initialize(delay = 0)
      self.at = Time.now + delay
    end

    # Is the current event due (current time = event time)?
    #
    # Returns true if the event is due, false if not.
    def due?
      Time.now = self.at
    end

    # Compare this event to another.
    #
    # other - The other TimedEvent.
    #
    # Returns -1 if this event is before the other, 0 if the two events are
    #   due at the same time, 1 if the other event is later.
    def =(other)
      self.at = other.at
    end
  end

  # A DriverEvent is a TimedEvent with an associated Task and Condition. This
  # is the primary mechanism for poll conditions to be scheduled.
  class DriverEvent  TimedEvent
    # Initialize a new DriverEvent.
    #
    # delay     - The Numeric delay for this event.
    # task      - The Task associated with this event.
    # condition - The Condition associated with this event.
    def initialize(delay, task, condition)
      super(delay)
      @task = task
      @condition = condition
    end

    # Handle this event by invoking the underlying condition on the associated
    # task.
    #
    # Returns nothing.
    def handle_event
      @task.handle_poll(@condition)
    end
  end

  # A DriverOperation is a TimedEvent that is due as soon as possible. It is
  # used to execute an arbitrary method on the associated Task.
  class DriverOperation  TimedEvent
    # Initialize a new DriverOperation.
    #
    # task - The Task upon which to operate.
    # name - The Symbol name of the method to call.
    # args - The Array of arguments to send to the method.
    def initialize(task, name, args)
      super(0)
      @task = task
      @name = name
      @args = args
    end

    # Handle the operation that was issued asynchronously.
    #
    # Returns nothing.
    def handle_event
      @task.send(@name, *@args)
    end
  end

  # The DriverEventQueue is a simple queue that holds TimedEvent instances in
  # order to maintain the schedule of upcoming events.
  class DriverEventQueue
    # Initialize a DriverEventQueue.
    def initialize
      @shutdown = false
      @events = []
      @monitor = Monitor.new
      @resource = @monitor.new_cond
    end

    # Wake any sleeping threads after setting the sentinel.
    #
    # Returns nothing.
    def shutdown
      @shutdown = true
      @monitor.synchronize do
        @resource.broadcast
      end
    end

    # Wait until the queue has something due, pop it off the queue, and return
    # it.
    #
    # Returns the popped event.
    def pop
      @monitor.synchronize do
        if @events.empty?
          raise ThreadError, "queue empty" if @shutdown
          @resource.wait
        else
          delay = @events.first.at - Time.now
          @resource.wait(delay) if delay  0
        end

        @events.shift
      end
    end

    # Add an event to the queue, wake any waiters if what we added needs to
    # happen sooner than the next pending event.
    #
    # Returns nothing.
    def push(event)
      @monitor.synchronize do
        @events  event
        @events.sort!

        # If we've sorted the events and found the one we're adding is at
        # the front, it will likely need to run before the next due date.
        @resource.signal if @events.first == event
      end
    end

    # Returns true if the queue is empty, false if not.
    def empty?
      @events.empty?
    end

    # Clear the queue.
    #
    # Returns nothing.
    def clear
      @events.clear
    end

    # Returns the Integer length of the queue.
    def length
      @events.length
    end

    alias size length
  end

  # The Driver class is responsible for scheduling all of the events for a
  # given Task.
  class Driver
    # The Thread running the driver loop.
    attr_reader :thread

    # Instantiate a new Driver and start the scheduler loop to handle events.
    #
    # task - The Task this Driver belongs to.
    def initialize(task)
      @task = task
      @events = God::DriverEventQueue.new

      @thread = Thread.new do
        loop do
          begin
            @events.pop.handle_event
          rescue ThreadError = e
            # queue is empty
            break
          rescue Object = e
            message = format("Unhandled exception in driver loop - (%s): %s\n%s",
                             e.class, e.message, e.backtrace.join("\n"))
            applog(nil, :fatal, message)
          end
        end
      end
    end

    # Check if we're in the driver context.
    #
    # Returns true if in driver thread, false if not.
    def in_driver_context?
      Thread.current == @thread
    end

    # Clear all events for this Driver.
    #
    # Returns nothing.
    def clear_events
      @events.clear
    end

    # Shutdown the DriverEventQueue threads.
    #
    # Returns nothing.
    def shutdown
      @events.shutdown
    end

    # Queue an asynchronous message.
    #
    # name - The Symbol name of the operation.
    # args - An optional Array of arguments.
    #
    # Returns nothing.
    def message(name, args = [])
      @events.push(DriverOperation.new(@task, name, args))
    end

    # Create and schedule a new DriverEvent.
    #
    # condition - The Condition.
    # delay     - The Numeric number of seconds to delay (default: interval
    #             defined in condition).
    #
    # Returns nothing.
    def schedule(condition, delay = condition.interval)
      applog(nil, :debug, "driver schedule #{condition} in #{delay} seconds")

      @events.push(DriverEvent.new(delay, @task, condition))
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>errors.rb</filename>
			<content>module God

  class AbstractMethodNotOverriddenError  StandardError
  end

  class NoSuchWatchError  StandardError
  end

  class NoSuchConditionError  StandardError
  end

  class NoSuchBehaviorError  StandardError
  end

  class NoSuchContactError  StandardError
  end

  class InvalidCommandError  StandardError
  end

  class EventRegistrationFailedError  StandardError
  end

end
</content>
		</actual_file>
		<actual_file>
			<filename>event_handler.rb</filename>
			<content>module God
  class EventHandler
    @@actions = {}
    @@handler = nil
    @@loaded = false

    def self.loaded?
      @@loaded
    end

    def self.event_system
      @@handler::EVENT_SYSTEM
    end

    def self.load
      begin
        case RUBY_PLATFORM
        when /darwin/i, /bsd/i
          require 'god/event_handlers/kqueue_handler'
          @@handler = KQueueHandler
        when /linux/i
          require 'god/event_handlers/netlink_handler'
          @@handler = NetlinkHandler
        else
          raise NotImplementedError, "Platform not supported for EventHandler"
        end
        @@loaded = true
      rescue Exception
        require 'god/event_handlers/dummy_handler'
        @@handler = DummyHandler
        @@loaded = false
      end
    end

    def self.register(pid, event, &block)
      @@actions[pid] ||= {}
      @@actions[pid][event] = block
      @@handler.register_process(pid, @@actions[pid].keys)
    end

    def self.deregister(pid, event)
      if watching_pid? pid
        running = ::Process.kill(0, pid.to_i) rescue false
        @@actions[pid].delete(event)
        @@handler.register_process(pid, @@actions[pid].keys) if running
        @@actions.delete(pid) if @@actions[pid].empty?
      end
    end

    def self.call(pid, event, extra_data = {})
      @@actions[pid][event].call(extra_data) if watching_pid?(pid) && @@actions[pid][event]
    end

    def self.watching_pid?(pid)
      @@actions[pid]
    end

    def self.start
      @@thread = Thread.new do
        loop do
          begin
            @@handler.handle_events
          rescue Exception = e
            message = format("Unhandled exception (%s): %s\n%s",
                             e.class, e.message, e.backtrace.join("\n"))
            applog(nil, :fatal, message)
          end
        end
      end

      # do a real test to make sure events are working properly
      @@loaded = self.operational?
    end

    def self.stop
      @@thread.kill if @@thread
    end

    def self.operational?
      com = [false]

      Thread.new do
        begin
          event_system = God::EventHandler.event_system

          pid = fork do
            loop { sleep(1) }
          end

          self.register(pid, :proc_exit) do
            com[0] = true
          end

          ::Process.kill('KILL', pid)
          ::Process.waitpid(pid)

          sleep(0.1)

          self.deregister(pid, :proc_exit) rescue nil
        rescue = e
          puts e.message
          puts e.backtrace.join("\n")
        end
      end.join

      sleep(0.1)

      com.first
    end

  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>logger.rb</filename>
			<content>module God

  class Logger  SimpleLogger

    attr_accessor :logs

    class  self
      attr_accessor :syslog
    end

    self.syslog = defined?(Syslog)

    # Instantiate a new Logger object
    def initialize(io = $stdout)
      super(io)
      self.logs = {}
      @mutex = Mutex.new
      @capture = nil
      @spool = Time.now - 10
      @templogio = StringIO.new
      @templog = SimpleLogger.new(@templogio)
      @templog.level = Logger::INFO
    end


    def level=(lev)
      SysLogger.level = SimpleLogger::CONSTANT_TO_SYMBOL[lev] if Logger.syslog
      super(lev)
    end

    # Log a message
    #   +watch+ is the String name of the Watch (may be nil if not Watch is applicable)
    #   +level+ is the log level [:debug|:info|:warn|:error|:fatal]
    #   +text+ is the String message
    #
    # Returns nothing
    def log(watch, level, text)
      # initialize watch log if necessary
      self.logs[watch.name] ||= Timeline.new(God::LOG_BUFFER_SIZE_DEFAULT) if watch

      # push onto capture and timeline for the given watch
      if @capture || (watch && (Time.now - @spool  2))
        @mutex.synchronize do
          @templogio.truncate(0)
          @templogio.rewind
          @templog.send(level, text)

          message = @templogio.string.dup

          if @capture
            @capture.puts(message)
          else
            self.logs[watch.name]  [Time.now, message]
          end
        end
      end

      # send to regular logger
      self.send(level, text)

      # send to syslog
      SysLogger.log(level, text) if Logger.syslog
    end

    # Get all log output for a given Watch since a certain Time.
    #   +watch_name+ is the String name of the Watch
    #   +since+ is the Time since which to fetch log lines
    #
    # Returns String
    def watch_log_since(watch_name, since)
      # initialize watch log if necessary
      self.logs[watch_name] ||= Timeline.new(God::LOG_BUFFER_SIZE_DEFAULT)

      # get and join lines since given time
      @mutex.synchronize do
        @spool = Time.now
        self.logs[watch_name].select do |x|
          x.first  since
        end.map do |x|
          x[1]
        end.join
      end
    end

    # private

    # Enable capturing of log
    #
    # Returns nothing
    def start_capture
      @mutex.synchronize do
        @capture = StringIO.new
      end
    end

    # Disable capturing of log and return what was captured since
    # capturing was enabled with Logger#start_capture
    #
    # Returns String
    def finish_capture
      @mutex.synchronize do
        cap = @capture.string if @capture
        @capture = nil
        cap
      end
    end
  end

end
</content>
		</actual_file>
		<actual_file>
			<filename>metric.rb</filename>
			<content>module God
  # Metrics are responsible for holding watch conditions. An instance of
  # Metric is yielded to blocks in the start_if, restart_if, stop_if, and
  # transition methods.
  class Metric
    # The Watch.
    attr_accessor :watch

    # The destination Hash in canonical hash form. Example:
    # { true = :up, false = :restart}
    attr_accessor :destination

    # The Array of Condition instances.
    attr_accessor :conditions

    # Initialize a new Metric.
    #
    # watch       - The Watch.
    # destination - The optional destination Hash in canonical hash form.
    def initialize(watch, destination = nil)
      self.watch = watch
      self.destination = destination
      self.conditions = []
    end

    # Public: Instantiate the given Condition and pass it into the optional
    # block. Attributes of the condition must be set in the config file.
    #
    # kind - The Symbol name of the condition.
    #
    # Returns nothing.
    def condition(kind)
      # Create the condition.
      begin
        c = Condition.generate(kind, self.watch)
      rescue NoSuchConditionError = e
        abort e.message
      end

      # Send to block so config can set attributes.
      yield(c) if block_given?

      # Prepare the condition.
      c.prepare

      # Test generic and specific validity.
      unless Condition.valid?(c) && c.valid?
        abort "Exiting on invalid condition"
      end

      # Inherit interval from watch if no poll condition specific interval was
      # set.
      if c.kind_of?(PollCondition) && !c.interval
        if self.watch.interval
          c.interval = self.watch.interval
        else
          abort "No interval set for Condition '#{c.class.name}' in Watch " +
                "'#{self.watch.name}', and no default Watch interval from " +
                "which to inherit."
        end
      end

      # Add the condition to the list.
      self.conditions  c
    end

    # Enable all of this Metric's conditions. Poll conditions will be
    # scheduled and event/trigger conditions will be registered.
    #
    # Returns nothing.
    def enable
      self.conditions.each do |c|
        self.watch.attach(c)
      end
    end

    # Disable all of this Metric's conditions. Poll conditions will be
    # halted and event/trigger conditions will be deregistered.
    #
    # Returns nothing.
    def disable
      self.conditions.each do |c|
        self.watch.detach(c)
      end
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>process.rb</filename>
			<content>module God
  class Process
    WRITES_PID = [:start, :restart]

    attr_accessor :name, :uid, :gid, :log, :log_cmd, :err_log, :err_log_cmd,
                  :start, :stop, :restart, :unix_socket, :chroot, :env, :dir,
                  :stop_timeout, :stop_signal, :umask

    def initialize
      self.log = '/dev/null'

      @pid_file = nil
      @tracking_pid = true
      @user_log = false
      @pid = nil
      @unix_socket = nil
      @log_cmd = nil
      @stop_timeout = God::STOP_TIMEOUT_DEFAULT
      @stop_signal = God::STOP_SIGNAL_DEFAULT
    end

    def alive?
      if self.pid
        System::Process.new(self.pid).exists?
      else
        false
      end
    end

    def file_writable?(file)
      pid = fork do
        begin
          uid_num = Etc.getpwnam(self.uid).uid if self.uid
          gid_num = Etc.getgrnam(self.gid).gid if self.gid

          ::Dir.chroot(self.chroot) if self.chroot
          ::Process.groups = [gid_num] if self.gid
          ::Process::Sys.setgid(gid_num) if self.gid
          ::Process::Sys.setuid(uid_num) if self.uid
        rescue ArgumentError, Errno::EPERM, Errno::ENOENT
          exit(1)
        end

        File.writable?(file_in_chroot(file)) ? exit(0) : exit(1)
      end

      wpid, status = ::Process.waitpid2(pid)
      status.exitstatus == 0 ? true : false
    end

    def valid?
      # determine if we're tracking pid or not
      self.pid_file

      valid = true

      # a start command must be specified
      if self.start.nil?
        valid = false
        applog(self, :error, "No start command was specified")
      end

      # uid must exist if specified
      if self.uid
        begin
          Etc.getpwnam(self.uid)
        rescue ArgumentError
          valid = false
          applog(self, :error, "UID for '#{self.uid}' does not exist")
        end
      end

      # gid must exist if specified
      if self.gid
        begin
          Etc.getgrnam(self.gid)
        rescue ArgumentError
          valid = false
          applog(self, :error, "GID for '#{self.gid}' does not exist")
        end
      end

      # dir must exist and be a directory if specified
      if self.dir
        if !File.exist?(self.dir)
          valid = false
          applog(self, :error, "Specified directory '#{self.dir}' does not exist")
        elsif !File.directory?(self.dir)
          valid = false
          applog(self, :error, "Specified directory '#{self.dir}' is not a directory")
        end
      end

      # pid dir must exist if specified
      if !@tracking_pid && !File.exist?(File.dirname(self.pid_file))
        valid = false
        applog(self, :error, "PID file directory '#{File.dirname(self.pid_file)}' does not exist")
      end

      # pid dir must be writable if specified
      if !@tracking_pid && File.exist?(File.dirname(self.pid_file)) && !file_writable?(File.dirname(self.pid_file))
        valid = false
        applog(self, :error, "PID file directory '#{File.dirname(self.pid_file)}' is not writable by #{self.uid || Etc.getlogin}")
      end

      # log dir must exist
      if !File.exist?(File.dirname(self.log))
        valid = false
        applog(self, :error, "Log directory '#{File.dirname(self.log)}' does not exist")
      end

      # log file or dir must be writable
      if File.exist?(self.log)
        unless file_writable?(self.log)
          valid = false
          applog(self, :error, "Log file '#{self.log}' exists but is not writable by #{self.uid || Etc.getlogin}")
        end
      else
        unless file_writable?(File.dirname(self.log))
          valid = false
          applog(self, :error, "Log directory '#{File.dirname(self.log)}' is not writable by #{self.uid || Etc.getlogin}")
        end
      end

      # chroot directory must exist and have /dev/null in it
      if self.chroot
        if !File.directory?(self.chroot)
          valid = false
          applog(self, :error, "CHROOT directory '#{self.chroot}' does not exist")
        end

        if !File.exist?(File.join(self.chroot, '/dev/null'))
          valid = false
          applog(self, :error, "CHROOT directory '#{self.chroot}' does not contain '/dev/null'")
        end
      end

      valid
    end

    # DON'T USE THIS INTERNALLY. Use the instance variable. -- Kev
    # No really, trust me. Use the instance variable.
    def pid_file=(value)
      # if value is nil, do the right thing
      if value
        @tracking_pid = false
      else
        @tracking_pid = true
      end

      @pid_file = value
    end

    def pid_file
      @pid_file ||= default_pid_file
    end

    # Fetch the PID from pid_file. If the pid_file does not
    # exist, then use the PID from the last time it was read.
    # If it has never been read, then return nil.
    #
    # Returns Integer(pid) or nil
    def pid
      contents = File.read(self.pid_file).strip rescue ''
      real_pid = contents =~ /^\d+$/ ? contents.to_i : nil

      if real_pid
        @pid = real_pid
        real_pid
      else
        @pid
      end
    end

    # Send the given signal to this process.
    #
    # Returns nothing
    def signal(sig)
      sig = sig.to_i if sig.to_i != 0
      applog(self, :info, "#{self.name} sending signal '#{sig}' to pid #{self.pid}")
      ::Process.kill(sig, self.pid) rescue nil
    end

    def start!
      call_action(:start)
    end

    def stop!
      call_action(:stop)
    end

    def restart!
      call_action(:restart)
    end

    def default_pid_file
      File.join(God.pid_file_directory, "#{self.name}.pid")
    end

    def call_action(action)
      command = send(action)

      if action == :stop && command.nil?
        pid = self.pid
        name = self.name
        command = lambda do
          applog(self, :info, "#{self.name} stop: default lambda killer")

          ::Process.kill(@stop_signal, pid) rescue nil
          applog(self, :info, "#{self.name} sent SIG#{@stop_signal}")

          # Poll to see if it's dead
          pid_not_found = false
          @stop_timeout.times do
            if pid
              begin
                ::Process.kill(0, pid)
              rescue Errno::ESRCH
                # It died. Good.
                applog(self, :info, "#{self.name} process stopped")
                return
              end
            else
              applog(self, :warn, "#{self.name} pid not found in #{self.pid_file}") unless pid_not_found
              pid_not_found = true
            end

            sleep 1
          end

          ::Process.kill('KILL', pid) rescue nil
          applog(self, :warn, "#{self.name} still alive after #{@stop_timeout}s; sent SIGKILL")
        end
      end

      if command.kind_of?(String)
        pid = nil

        if [:start, :restart].include?(action) && @tracking_pid
          # double fork god-daemonized processes
          # we don't want to wait for them to finish
          r, w = IO.pipe
          begin
            opid = fork do
              STDOUT.reopen(w)
              r.close
              pid = self.spawn(command)
              puts pid.to_s # send pid back to forker
            end

            ::Process.waitpid(opid, 0)
            w.close
            pid = r.gets.chomp
          ensure
            # make sure the file descriptors get closed no matter what
            r.close rescue nil
            w.close rescue nil
          end
        else
          # single fork self-daemonizing processes
          # we want to wait for them to finish
          pid = self.spawn(command)
          status = ::Process.waitpid2(pid, 0)
          exit_code = status[1]  8

          if exit_code != 0
            applog(self, :warn, "#{self.name} #{action} command exited with non-zero code = #{exit_code}")
          end

          ensure_stop if action == :stop
        end

        if @tracking_pid or (@pid_file.nil? and WRITES_PID.include?(action))
          File.open(default_pid_file, 'w') do |f|
            f.write pid
          end

          @tracking_pid = true
          @pid_file = default_pid_file
        end
      elsif command.kind_of?(Proc)
        # lambda command
        command.call
      else
        raise NotImplementedError
      end
    end

    # Fork/exec the given command, returns immediately
    #   +command+ is the String containing the shell command
    #
    # Returns nothing
    def spawn(command)
      fork do
        File.umask self.umask if self.umask
        uid_num = Etc.getpwnam(self.uid).uid if self.uid
        gid_num = Etc.getgrnam(self.gid).gid if self.gid

        ::Dir.chroot(self.chroot) if self.chroot
        ::Process.setsid
        ::Process.groups = [gid_num] if self.gid
        ::Process::Sys.setgid(gid_num) if self.gid
        ::Process::Sys.setuid(uid_num) if self.uid
        self.dir ||= '/'
        Dir.chdir self.dir
        $0 = command
        STDIN.reopen "/dev/null"
        if self.log_cmd
          STDOUT.reopen IO.popen(self.log_cmd, "a")
        else
          STDOUT.reopen file_in_chroot(self.log), "a"
        end
        if err_log_cmd
          STDERR.reopen IO.popen(err_log_cmd, "a")
        elsif err_log && (log_cmd || err_log != log)
          STDERR.reopen file_in_chroot(err_log), "a"
        else
          STDERR.reopen STDOUT
        end

        # close any other file descriptors
        3.upto(256){|fd| IO::new(fd).close rescue nil}

        if self.env && self.env.is_a?(Hash)
          self.env.each do |(key, value)|
            ENV[key] = value.to_s
          end
        end

        exec command unless command.empty?
      end
    end

    # Ensure that a stop command actually stops the process. Force kill
    # if necessary.
    #
    # Returns nothing
    def ensure_stop
      applog(self, :warn, "#{self.name} ensuring stop...")

      unless self.pid
        applog(self, :warn, "#{self.name} stop called but pid is uknown")
        return
      end

      # Poll to see if it's dead
      @stop_timeout.times do
        begin
          ::Process.kill(0, self.pid)
        rescue Errno::ESRCH
          # It died. Good.
          return
        end

        sleep 1
      end

      # last resort
      ::Process.kill('KILL', self.pid) rescue nil
      applog(self, :warn, "#{self.name} still alive after #{@stop_timeout}s; sent SIGKILL")
    end

    private
    def file_in_chroot(file)
      return file unless self.chroot

      file.gsub(/^#{Regexp.escape(File.expand_path(self.chroot))}/, '')
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>registry.rb</filename>
			<content>module God
  def self.registry
    @registry ||= Registry.new
  end

  class Registry
    def initialize
      @storage = {}
    end

    def add(item)
      # raise TypeError unless item.is_a? God::Process
      @storage[item.name] = item
    end

    def remove(item)
      @storage.delete(item.name)
    end

    def size
      @storage.size
    end

    def [](name)
      @storage[name]
    end

    def reset
      @storage.clear
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>simple_logger.rb</filename>
			<content>module God

  class SimpleLogger
    DEBUG = 2
    INFO = 4
    WARN = 8
    ERROR = 16
    FATAL = 32

    SEV_LABEL = {DEBUG = 'DEBUG',
                 INFO = 'INFO',
                 WARN = 'WARN',
                 ERROR = 'ERROR',
                 FATAL = 'FATAL'}

    CONSTANT_TO_SYMBOL = { DEBUG = :debug,
                           INFO = :info,
                           WARN = :warn,
                           ERROR = :error,
                           FATAL = :fatal }

    attr_accessor :datetime_format, :level

    def initialize(io)
      @io = io
      @level = INFO
      @datetime_format = "%Y-%m-%d %H:%M:%S"
    end

    def output(level, msg)
      return if level  self.level

      time = Time.now.strftime(self.datetime_format)
      label = SEV_LABEL[level]
      @io.print("#{label[0..0]} [#{time}] #{label.rjust(5)}: #{msg}\n")
    end

    def fatal(msg)
      self.output(FATAL, msg)
    end

    def error(msg)
      self.output(ERROR, msg)
    end

    def warn(msg)
      self.output(WARN, msg)
    end

    def info(msg)
      self.output(INFO, msg)
    end

    def debug(msg)
      self.output(DEBUG, msg)
    end
  end

end
</content>
		</actual_file>
		<actual_file>
			<filename>socket.rb</filename>
			<content>require 'drb'

module God

  # The God::Server oversees the DRb server which dishes out info on this God daemon.
  class Socket
    attr_reader :port

    # The location of the socket for a given port
    #   +port+ is the port number
    #
    # Returns String (file location)
    def self.socket_file(port)
      "/tmp/god.#{port}.sock"
    end

    # The address of the socket for a given port
    #   +port+ is the port number
    #
    # Returns String (drb address)
    def self.socket(port)
      "drbunix://#{self.socket_file(port)}"
    end

    # The location of the socket for this Server
    #
    # Returns String (file location)
    def socket_file
      self.class.socket_file(@port)
    end

    # The address of the socket for this Server
    #
    # Returns String (drb address)
    def socket
      self.class.socket(@port)
    end

    # Create a new Server and star the DRb server
    #   +port+ is the port on which to start the DRb service (default nil)
    def initialize(port = nil, user = nil, group = nil, perm = nil)
      @port  = port
      @user  = user
      @group = group
      @perm  = perm
      start
    end

    # Returns true
    def ping
      true
    end

    # Forward API calls to God
    #
    # Returns whatever the forwarded call returns
    def method_missing(*args, &block)
      God.send(*args, &block)
    end

    # Stop the DRb server and delete the socket file
    #
    # Returns nothing
    def stop
      DRb.stop_service
      FileUtils.rm_f(self.socket_file)
    end

    private

    # Start the DRb server. Abort if there is already a running god instance
    # on the socket.
    #
    # Returns nothing
    def start
      begin
        @drb ||= DRb.start_service(self.socket, self)
        applog(nil, :info, "Started on #{DRb.uri}")
      rescue Errno::EADDRINUSE
        applog(nil, :info, "Socket already in use")
        DRb.start_service
        server = DRbObject.new(nil, self.socket)

        begin
          Timeout.timeout(5) do
            server.ping
          end
          abort "Socket #{self.socket} already in use by another instance of god"
        rescue StandardError, Timeout::Error
          applog(nil, :info, "Socket is stale, reopening")
          File.delete(self.socket_file) rescue nil
          @drb ||= DRb.start_service(self.socket, self)
          applog(nil, :info, "Started on #{DRb.uri}")
        end
      end

      if File.exists?(self.socket_file)
        uid = Etc.getpwnam(@user).uid if @user
        gid = Etc.getgrnam(@group).gid if @group

        File.chmod(Integer(@perm), socket_file) if @perm
        File.chown(uid, gid, socket_file) if uid or gid
      end
    end
  end

end
</content>
		</actual_file>
		<actual_file>
			<filename>sugar.rb</filename>
			<content>class Numeric
  # Public: Units of seconds.
  def seconds
    self
  end

  # Public: Units of seconds.
  alias :second :seconds

  # Public: Units of minutes (60 seconds).
  def minutes
    self * 60
  end

  # Public: Units of minutes (60 seconds).
  alias :minute :minutes

  # Public: Units of hours (3600 seconds).
  def hours
    self * 3600
  end

  # Public: Units of hours (3600 seconds).
  alias :hour :hours

  # Public: Units of days (86400 seconds).
  def days
    self * 86400
  end

  # Public: Units of days (86400 seconds).
  alias :day :days

  # Units of kilobytes.
  def kilobytes
    self
  end

  # Units of kilobytes.
  alias :kilobyte :kilobytes

  # Units of megabytes (1024 kilobytes).
  def megabytes
    self * 1024
  end

  # Units of megabytes (1024 kilobytes).
  alias :megabyte :megabytes

  # Units of gigabytes (1,048,576 kilobytes).
  def gigabytes
    self * (1024 ** 2)
  end

  # Units of gigabytes (1,048,576 kilobytes).
  alias :gigabyte :gigabytes

  # Units of percent. e.g. 50.percent.
  def percent
    self
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>sys_logger.rb</filename>
			<content>begin
  require 'syslog'

  # Ensure that Syslog is open
  begin
    Syslog.open('god')
  rescue RuntimeError
    Syslog.reopen('god')
  end

  Syslog.info("Syslog enabled.")

  module God

    class SysLogger
      SYMBOL_EQUIVALENTS = { :fatal = Syslog::LOG_CRIT,
                             :error = Syslog::LOG_ERR,
                             :warn = Syslog::LOG_WARNING,
                             :info = Syslog::LOG_INFO,
                             :debug = Syslog::LOG_DEBUG }

      # Set the log level
      #   +level+ is the Symbol level to set as maximum. One of:
      #           [:fatal | :error | :warn | :info | :debug ]
      #
      # Returns Nothing
      def self.level=(level)
        Syslog.mask = Syslog::LOG_UPTO(SYMBOL_EQUIVALENTS[level])
      end

      # Log a message to syslog.
      #   +level+ is the Symbol level of the message. One of:
      #           [:fatal | :error | :warn | :info | :debug ]
      #   +text+ is the String text of the message
      #
      # Returns Nothing
      def self.log(level, text)
        Syslog.log(SYMBOL_EQUIVALENTS[level], '%s', text)
      end
    end

  end
rescue Object = e
  puts "Syslog could not be enabled: #{e.message}"
end
</content>
		</actual_file>
		<actual_file>
			<filename>task.rb</filename>
			<content>module God

  class Task
    # Public: Gets/Sets the String name of the task.
    attr_accessor :name

    # Public: Gets/Sets the Numeric default interval to be used between poll
    # events.
    attr_accessor :interval

    # Public: Gets/Sets the String group name of the task.
    attr_accessor :group

    # Public: Gets/Sets the Array of Symbol valid states for the state machine.
    attr_accessor :valid_states

    # Public: Gets/Sets the Symbol initial state of the state machine.
    attr_accessor :initial_state

    # Gets/Sets the Driver for this task.
    attr_accessor :driver

    # Public: Sets whether the task should autostart when god starts. Defaults
    # to true (enabled).
    attr_writer :autostart

    # Returns true if autostart is enabled, false if not.
    def autostart?
      @autostart
    end

    # api
    attr_accessor :state, :behaviors, :metrics, :directory

    def initialize
      @autostart ||= true

      # initial state is unmonitored
      self.state = :unmonitored

      # the list of behaviors
      self.behaviors = []

      # the list of conditions for each action
      self.metrics = {nil = [], :unmonitored = [], :stop = []}

      # the condition - metric lookup
      self.directory = {}

      # driver
      self.driver = Driver.new(self)
    end

    # Initialize the metrics to an empty state.
    #
    # Returns nothing.
    def prepare
      self.valid_states.each do |state|
        self.metrics[state] ||= []
      end
    end

    # Verify that the minimum set of configuration requirements has been met.
    #
    # Returns true if valid, false if not.
    def valid?
      valid = true

      # A name must be specified.
      if self.name.nil?
        valid = false
        applog(self, :error, "No name String was specified.")
      end

      # Valid states must be specified.
      if self.valid_states.nil?
        valid = false
        applog(self, :error, "No valid_states Array or Symbols was specified.")
      end

      # An initial state must be specified.
      if self.initial_state.nil?
        valid = false
        applog(self, :error, "No initial_state Symbol was specified.")
      end

      valid
    end

    ###########################################################################
    #
    # Advanced mode
    #
    ###########################################################################

    # Convert the given input into canonical hash form which looks like:
    #
    # { true = :state } or { true = :state, false = :otherstate }
    #
    # to - The Symbol or Hash destination.
    #
    # Returns the canonical Hash.
    def canonical_hash_form(to)
      to.instance_of?(Symbol) ? {true = to} : to
    end

    # Public: Define a transition handler which consists of a set of conditions
    #
    # start_states - The Symbol or Array of Symbols start state(s).
    # end_states   - The Symbol or Hash end states.
    #
    # Yields the Metric for this transition.
    #
    # Returns nothing.
    def transition(start_states, end_states)
      # Convert end_states into canonical hash form.
      canonical_end_states = canonical_hash_form(end_states)

      Array(start_states).each do |start_state|
        # Validate start state.
        unless self.valid_states.include?(start_state)
          abort "Invalid state :#{start_state}. Must be one of the symbols #{self.valid_states.map{|x| ":#{x}"}.join(', ')}"
        end

        # Create a new metric to hold the task, end states, and conditions.
        m = Metric.new(self, canonical_end_states)

        if block_given?
          # Let the config file define some conditions on the metric.
          yield(m)
        else
          # Add an :always condition if no block was given.
          m.condition(:always) do |c|
            c.what = true
          end
        end

        # Populate the condition - metric directory.
        m.conditions.each do |c|
          self.directory[c] = m
        end

        # Record the metric.
        self.metrics[start_state] ||= []
        self.metrics[start_state]  m
      end
    end

    # Public: Define a lifecycle handler. Conditions that belong to a
    # lifecycle are active as long as the process is being monitored.
    #
    # Returns nothing.
    def lifecycle
      # Create a new metric to hold the task and conditions.
      m = Metric.new(self)

      # Let the config file define some conditions on the metric.
      yield(m)

      # Populate the condition - metric directory.
      m.conditions.each do |c|
        self.directory[c] = m
      end

      # Record the metric.
      self.metrics[nil]  m
    end

    ###########################################################################
    #
    # Lifecycle
    #
    ###########################################################################

    # Enable monitoring.
    #
    # Returns nothing.
    def monitor
      self.move(self.initial_state)
    end

    # Disable monitoring.
    #
    # Returns nothing.
    def unmonitor
      self.move(:unmonitored)
    end

    # Move to the given state.
    #
    # to_state - The Symbol representing the state to move to.
    #
    # Returns this Task.
    def move(to_state)
      if !self.driver.in_driver_context?
        # Called from outside Driver. Send an async message to Driver.
        self.driver.message(:move, [to_state])
      else
        # Called from within Driver. Record original info.
        orig_to_state = to_state
        from_state = self.state

        # Log.
        msg = "#{self.name} move '#{from_state}' to '#{to_state}'"
        applog(self, :info, msg)

        # Cleanup from current state.
        self.driver.clear_events
        self.metrics[from_state].each { |m| m.disable }
        if to_state == :unmonitored
          self.metrics[nil].each { |m| m.disable }
        end

        # Perform action.
        self.action(to_state)

        # Enable simple mode.
        if [:start, :restart].include?(to_state) && self.metrics[to_state].empty?
          to_state = :up
        end

        # Move to new state.
        self.metrics[to_state].each { |m| m.enable }

        # If no from state, enable lifecycle metric.
        if from_state == :unmonitored
          self.metrics[nil].each { |m| m.enable }
        end

        # Set state.
        self.state = to_state

        # Broadcast to interested TriggerConditions.
        Trigger.broadcast(self, :state_change, [from_state, orig_to_state])

        # Log.
        msg = "#{self.name} moved '#{from_state}' to '#{to_state}'"
        applog(self, :info, msg)
      end

      self
    end

    # Notify the Driver that an EventCondition has triggered.
    #
    # condition - The Condition.
    #
    # Returns nothing.
    def trigger(condition)
      self.driver.message(:handle_event, [condition])
    end

    def signal(sig)
      # noop
    end

    ###########################################################################
    #
    # Actions
    #
    ###########################################################################

    def method_missing(sym, *args)
      unless (sym.to_s =~ /=$/)
        super
      end

      base = sym.to_s.chop.intern

      unless self.valid_states.include?(base)
        super
      end

      self.class.send(:attr_accessor, base)
      self.send(sym, *args)
    end

    # Perform the given action.
    #
    # a - The Symbol action.
    # c - The Condition.
    #
    # Returns this Task.
    def action(a, c = nil)
      if !self.driver.in_driver_context?
        # Called from outside Driver. Send an async message to Driver.
        self.driver.message(:action, [a, c])
      else
        # Called from within Driver.
        if self.respond_to?(a)
          command = self.send(a)

          case command
            when String
              msg = "#{self.name} #{a}: #{command}"
              applog(self, :info, msg)

              system(command)
            when Proc
              msg = "#{self.name} #{a}: lambda"
              applog(self, :info, msg)

              command.call
            else
              raise NotImplementedError
          end
        end
      end
    end

    ###########################################################################
    #
    # Events
    #
    ###########################################################################

    def attach(condition)
      case condition
        when PollCondition
          self.driver.schedule(condition, 0)
        when EventCondition, TriggerCondition
          condition.register
      end
    end

    def detach(condition)
      case condition
        when PollCondition
          condition.reset
        when EventCondition, TriggerCondition
          condition.deregister
      end
    end

    ###########################################################################
    #
    # Registration
    #
    ###########################################################################

    def register!
      # override if necessary
    end

    def unregister!
      driver.shutdown
    end

    ###########################################################################
    #
    # Handlers
    #
    ###########################################################################

    # Evaluate and handle the given poll condition. Handles logging
    # notifications, and moving to the new state if necessary.
    #
    # condition - The Condition to handle.
    #
    # Returns nothing.
    def handle_poll(condition)
      # Lookup metric.
      metric = self.directory[condition]

      # Run the test.
      begin
        result = condition.test
      rescue Object = e
        cname = condition.class.to_s.split('::').last
        message = format("Unhandled exception in %s condition - (%s): %s\n%s",
                         cname, e.class, e.message, e.backtrace.join("\n"))
        applog(self, :error, message)
        result = false
      end

      # Log.
      messages = self.log_line(self, metric, condition, result)

      # Notify.
      if result && condition.notify
        self.notify(condition, messages.last)
      end

      # After-condition.
      condition.after

      # Get the destination.
      dest =
      if result && condition.transition
        # Condition override.
        condition.transition
      else
        # Regular.
        metric.destination && metric.destination[result]
      end

      # Transition or reschedule.
      if dest
        # Transition.
        begin
          self.move(dest)
        rescue EventRegistrationFailedError
          msg = self.name + ' Event registration failed, moving back to previous state'
          applog(self, :info, msg)

          dest = self.state
          retry
        end
      else
        # Reschedule.
        self.driver.schedule(condition)
      end
    end

    # Asynchronously evaluate and handle the given event condition. Handles
    # logging notifications, and moving to the new state if necessary.
    #
    # condition - The Condition to handle.
    #
    # Returns nothing.
    def handle_event(condition)
      # Lookup metric.
      metric = self.directory[condition]

      # Log.
      messages = self.log_line(self, metric, condition, true)

      # Notify.
      if condition.notify
        self.notify(condition, messages.last)
      end

      # Get the destination.
      dest =
      if condition.transition
        # Condition override.
        condition.transition
      else
        # Regular.
        metric.destination && metric.destination[true]
      end

      if dest
        self.move(dest)
      end
    end

    # Determine whether a trigger happened.
    #
    # metric - The Metric.
    # result - The Boolean result from the condition's test.
    #
    # Returns Boolean
    def trigger?(metric, result)
      metric.destination && metric.destination[result]
    end

    # Log info about the condition and return the list of messages logged.
    #
    # watch     - The Watch.
    # metric    - The Metric.
    # condition - The Condition.
    # result    - The Boolean result of the condition test evaluation.
    #
    # Returns the Array of String messages.
    def log_line(watch, metric, condition, result)
      status =
      if self.trigger?(metric, result)
        "[trigger]"
      else
        "[ok]"
      end

      messages = []

      # Log info if available.
      if condition.info
        Array(condition.info).each do |condition_info|
          messages  "#{watch.name} #{status} #{condition_info} (#{condition.base_name})"
          applog(watch, :info, messages.last)
        end
      else
        messages  "#{watch.name} #{status} (#{condition.base_name})"
        applog(watch, :info, messages.last)
      end

      # Log.
      debug_message = watch.name + ' ' + condition.base_name + " [#{result}] " + self.dest_desc(metric, condition)
      applog(watch, :debug, debug_message)

      messages
    end

    # Format the destination specification for use in debug logging.
    #
    # metric    - The Metric.
    # condition - The Condition.
    #
    # Returns the formatted String.
    def dest_desc(metric, condition)
      if condition.transition
        {true = condition.transition}.inspect
      else
        if metric.destination
          metric.destination.inspect
        else
          'none'
        end
      end
    end

    # Notify all recipients of the given condition with the specified message.
    #
    # condition - The Condition.
    # message   - The String message to send.
    #
    # Returns nothing.
    def notify(condition, message)
      spec = Contact.normalize(condition.notify)
      unmatched = []

      # Resolve contacts.
      resolved_contacts =
      spec[:contacts].inject([]) do |acc, contact_name_or_group|
        cons = Array(God.contacts[contact_name_or_group] || God.contact_groups[contact_name_or_group])
        unmatched  contact_name_or_group if cons.empty?
        acc += cons
        acc
      end

      # Warn about unmatched contacts.
      unless unmatched.empty?
        msg = "#{condition.watch.name} no matching contacts for '#{unmatched.join(", ")}'"
        applog(condition.watch, :warn, msg)
      end

      # Notify each contact.
      resolved_contacts.each do |c|
        host = `hostname`.chomp rescue 'none'
        begin
          c.notify(message, Time.now, spec[:priority], spec[:category], host)
          msg = "#{condition.watch.name} #{c.info ? c.info : "notification sent for contact: #{c.name}"} (#{c.base_name})"
          applog(condition.watch, :info, msg % [])
        rescue Exception = e
          applog(condition.watch, :error, "#{e.message} #{e.backtrace}")
          msg = "#{condition.watch.name} Failed to deliver notification for contact: #{c.name} (#{c.base_name})"
          applog(condition.watch, :error, msg % [])
        end
      end
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>timeline.rb</filename>
			<content>module God

  class Timeline  Array
    # Instantiate a new Timeline
    #   +max_size+ is the maximum size to which the timeline should grow
    #
    # Returns Timeline
    def initialize(max_size)
      super()
      @max_size = max_size
    end

    # Push a value onto the Timeline
    #   +val+ is the value to push
    #
    # Returns Timeline
    def push(val)
      self.concat([val])
      shift if size  @max_size
    end

    alias_method :, :push
  end

end
</content>
		</actual_file>
		<actual_file>
			<filename>trigger.rb</filename>
			<content>module God

  class Trigger

    class  self
      attr_accessor :triggers # {task.name = condition}
    end

    # init
    self.triggers = {}
    @mutex = Mutex.new

    def self.register(condition)
      @mutex.synchronize do
        self.triggers[condition.watch.name] ||= []
        self.triggers[condition.watch.name]  condition
      end
    end

    def self.deregister(condition)
      @mutex.synchronize do
        self.triggers[condition.watch.name].delete(condition)
        self.triggers.delete(condition.watch.name) if self.triggers[condition.watch.name].empty?
      end
    end

    def self.broadcast(task, message, payload)
      return unless self.triggers[task.name]

      @mutex.synchronize do
        self.triggers[task.name].each do |t|
          t.process(message, payload)
        end
      end
    end

    def self.reset
      self.triggers.clear
    end

  end

end
</content>
		</actual_file>
		<actual_file>
			<filename>watch.rb</filename>
			<content>require 'etc'
require 'forwardable'

module God
  # The Watch class is a specialized Task that handles standard process
  # workflows. It has four states: init, up, start, and restart.
  class Watch  Task
    # The Array of Symbol valid task states.
    VALID_STATES = [:init, :up, :start, :restart]

    # The Sybmol initial state.
    INITIAL_STATE = :init

    # Public: The grace period for this process (seconds).
    attr_accessor :grace

    # Public: The start grace period (seconds).
    attr_accessor :start_grace

    # Public: The stop grace period (seconds).
    attr_accessor :stop_grace

    # Public: The restart grace period (seconds).
    attr_accessor :restart_grace

    # Public: God::Process delegators. See lib/god/process.rb for docs.
    extend Forwardable
    def_delegators :@process, :name, :uid, :gid, :start, :stop, :restart, :dir,
                              :name=, :uid=, :gid=, :start=, :stop=, :restart=,
                              :dir=, :pid_file, :pid_file=, :log, :log=,
                              :log_cmd, :log_cmd=, :err_log, :err_log=,
                              :err_log_cmd, :err_log_cmd=, :alive?, :pid,
                              :unix_socket, :unix_socket=, :chroot, :chroot=,
                              :env, :env=, :signal, :stop_timeout=,
                              :stop_signal=, :umask, :umask=

    # Initialize a new Watch instance.
    def initialize
      super

      # This God::Process instance holds information specific to the process.
      @process = God::Process.new

      # Valid states.
      self.valid_states = VALID_STATES
      self.initial_state = INITIAL_STATE

      # No grace period by default.
      self.grace = self.start_grace = self.stop_grace = self.restart_grace = 0
    end

    # Is this Watch valid?
    #
    # Returns true if the Watch is valid, false if not.
    def valid?
      super && @process.valid?
    end

    ###########################################################################
    #
    # Behavior
    #
    ###########################################################################

    # Public: Add a behavior to this Watch. See lib/god/behavior.rb.
    #
    # kind - The Symbol name of the Behavior to add.
    #
    # Yields the newly instantiated Behavior.
    #
    # Returns nothing.
    def behavior(kind)
      # Create the behavior.
      begin
        b = Behavior.generate(kind, self)
      rescue NoSuchBehaviorError = e
        abort e.message
      end

      # Send to block so config can set attributes.
      yield(b) if block_given?

      # Abort if the Behavior is invalid, the Behavior will have printed
      # out its own error messages by now.
      abort unless b.valid?

      self.behaviors  b
    end

    ###########################################################################
    #
    # Quickstart mode
    #
    ###########################################################################

    # Default Integer interval at which keepalive will runn poll checks.
    DEFAULT_KEEPALIVE_INTERVAL = 5.seconds

    # Default Integer or Array of Integers specification of how many times the
    # memory condition must fail before triggering.
    DEFAULT_KEEPALIVE_MEMORY_TIMES = [3, 5]

    # Default Integer or Array of Integers specification of how many times the
    # CPU condition must fail before triggering.
    DEFAULT_KEEPALIVE_CPU_TIMES = [3, 5]

    # Public: A set of conditions for easily getting started with simple watch
    # scenarios. Keepalive is intended for use by beginners or on processes
    # that do not need very sophisticated monitoring.
    #
    # If events are enabled, it will use the :process_exit event to determine
    # if a process fails. Otherwise it will use the :process_running poll.
    #
    # options - The option Hash. Possible values are:
    #           :interval -     The Integer number of seconds on which to poll
    #                           for process status. Affects CPU, memory, and
    #                           :process_running conditions (if used).
    #                           Default: 5.seconds.
    #           :memory_max   - The Integer memory max. A bare integer means
    #                           kilobytes. You may use Numeric.kilobytes,
    #                           Numeric#megabytes, and Numeric#gigabytes to
    #                           makes things more clear.
    #           :memory_times - If :memory_max is set, :memory_times can be
    #                           set to either an Integer or a 2 element
    #                           Integer Array to specify the number of times
    #                           the memory condition must fail. Examples:
    #                           3 (three times), [3, 5] (three out of any five
    #                           checks). Default: [3, 5].
    #           :cpu_max      - The Integer CPU percentage max. Range is
    #                           0 to 100. You may use the Numberic#percent
    #                           sugar to clarify e.g. 50.percent.
    #           :cpu_times    - If :cpu_max is set, :cpu_times can be
    #                           set to either an Integer or a 2 element
    #                           Integer Array to specify the number of times
    #                           the memory condition must fail. Examples:
    #                           3 (three times), [3, 5] (three out of any five
    #                           checks). Default: [3, 5].
    def keepalive(options = {})
      if God::EventHandler.loaded?
        self.transition(:init, { true = :up, false = :start }) do |on|
          on.condition(:process_running) do |c|
            c.interval = options[:interval] || DEFAULT_KEEPALIVE_INTERVAL
            c.running = true
          end
        end

        self.transition([:start, :restart], :up) do |on|
          on.condition(:process_running) do |c|
            c.interval = options[:interval] || DEFAULT_KEEPALIVE_INTERVAL
            c.running = true
          end
        end

        self.transition(:up, :start) do |on|
          on.condition(:process_exits)
        end
      else
        self.start_if do |start|
          start.condition(:process_running) do |c|
            c.interval = options[:interval] || DEFAULT_KEEPALIVE_INTERVAL
            c.running = false
          end
        end
      end

      self.restart_if do |restart|
        if options[:memory_max]
          restart.condition(:memory_usage) do |c|
            c.interval = options[:interval] || DEFAULT_KEEPALIVE_INTERVAL
            c.above = options[:memory_max]
            c.times = options[:memory_times] || DEFAULT_KEEPALIVE_MEMORY_TIMES
          end
        end

        if options[:cpu_max]
          restart.condition(:cpu_usage) do |c|
            c.interval = options[:interval] || DEFAULT_KEEPALIVE_INTERVAL
            c.above = options[:cpu_max]
            c.times = options[:cpu_times] || DEFAULT_KEEPALIVE_CPU_TIMES
          end
        end
      end
    end

    ###########################################################################
    #
    # Simple mode
    #
    ###########################################################################

    # Public: Start the process if any of the given conditions are triggered.
    #
    # Yields the Metric upon which conditions can be added.
    #
    # Returns nothing.
    def start_if
      self.transition(:up, :start) do |on|
        yield(on)
      end
    end

    # Public: Restart the process if any of the given conditions are triggered.
    #
    # Yields the Metric upon which conditions can be added.
    #
    # Returns nothing.
    def restart_if
      self.transition(:up, :restart) do |on|
        yield(on)
      end
    end

    # Public: Stop the process if any of the given conditions are triggered.
    #
    # Yields the Metric upon which conditions can be added.
    #
    # Returns nothing.
    def stop_if
      self.transition(:up, :stop) do |on|
        yield(on)
      end
    end

    ###########################################################################
    #
    # Lifecycle
    #
    ###########################################################################

    # Enable monitoring. Start at the first available of the init or up states.
    #
    # Returns nothing.
    def monitor
      if !self.metrics[:init].empty?
        self.move(:init)
      else
        self.move(:up)
      end
    end

    ###########################################################################
    #
    # Actions
    #
    ###########################################################################

    # Perform an action.
    #
    # a - The Symbol action to perform. One of :start, :restart, :stop.
    # c - The Condition.
    #
    # Returns this Watch.
    def action(a, c = nil)
      if !self.driver.in_driver_context?
        # Called from outside Driver. Send an async message to Driver.
        self.driver.message(:action, [a, c])
      else
        # Called from within Driver.
        case a
        when :start
          call_action(c, :start)
          sleep(self.start_grace + self.grace)
        when :restart
          if self.restart
            call_action(c, :restart)
          else
            action(:stop, c)
            action(:start, c)
          end
          sleep(self.restart_grace + self.grace)
        when :stop
          call_action(c, :stop)
          sleep(self.stop_grace + self.grace)
        end
      end

      self
    end

    # Perform the specifics of the action.
    #
    # condition - The Condition.
    # action    - The Symbol action.
    #
    # Returns nothing.
    def call_action(condition, action)
      # Before.
      before_items = self.behaviors
      before_items += [condition] if condition
      before_items.each do |b|
        info = b.send("before_#{action}")
        if info
          msg = "#{self.name} before_#{action}: #{info} (#{b.base_name})"
          applog(self, :info, msg)
        end
      end

      # Log.
      if self.send(action)
        msg = "#{self.name} #{action}: #{self.send(action).to_s}"
        applog(self, :info, msg)
      end

      # Execute.
      @process.call_action(action)

      # After.
      after_items = self.behaviors
      after_items += [condition] if condition
      after_items.each do |b|
        info = b.send("after_#{action}")
        if info
          msg = "#{self.name} after_#{action}: #{info} (#{b.base_name})"
          applog(self, :info, msg)
        end
      end
    end

    ###########################################################################
    #
    # Registration
    #
    ###########################################################################

    # Register the Process in the global process registry.
    #
    # Returns nothing.
    def register!
      God.registry.add(@process)
    end

    # Unregister the Process in the global process registry.
    #
    # Returns nothing.
    def unregister!
      God.registry.remove(@process)
      super
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>clean_pid_file.rb</filename>
			<content>module God
  module Behaviors

    class CleanPidFile  Behavior
      def valid?
        valid = true
        valid &= complain("Attribute 'pid_file' must be specified", self) if self.watch.pid_file.nil?
        valid
      end

      def before_start
        File.delete(self.watch.pid_file)

        "deleted pid file"
      rescue
        "no pid file to delete"
      end
    end

  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>clean_unix_socket.rb</filename>
			<content>module God
  module Behaviors

    class CleanUnixSocket  Behavior
      def valid?
        valid = true
        valid &= complain("Attribute 'unix_socket' must be specified", self) if self.watch.unix_socket.nil?
        valid
      end

      def before_start
        File.delete(self.watch.unix_socket)

        "deleted unix socket"
      rescue
        "no unix socket to delete"
      end
    end

  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>notify_when_flapping.rb</filename>
			<content>module God
  module Behaviors

    class NotifyWhenFlapping  Behavior
      attr_accessor :failures # number of failures
      attr_accessor :seconds  # number of seconds
      attr_accessor :notifier # class to notify with

      def initialize
        super
        @startup_times = []
      end

      def valid?
        valid = true
        valid &= complain("Attribute 'failures' must be specified", self) unless self.failures
        valid &= complain("Attribute 'seconds' must be specified", self) unless self.seconds
        valid &= complain("Attribute 'notifier' must be specified", self) unless self.notifier

        # Must take one arg or variable args
        unless self.notifier.respond_to?(:notify) and [1,-1].include?(self.notifier.method(:notify).arity)
          valid &= complain("The 'notifier' must have a method 'notify' which takes 1 or variable args", self)
        end

        valid
      end

      def before_start
        now = Time.now.to_i
        @startup_times  now
        check_for_flapping(now)
      end

      def before_restart
        now = Time.now.to_i
        @startup_times  now
        check_for_flapping(now)
      end

      private

        def check_for_flapping(now)
          @startup_times.select! {|time| time = now - self.seconds }
          if @startup_times.length = self.failures
            self.notifier.notify("#{self.watch.name} has called start/restart #{@startup_times.length} times in #{self.seconds} seconds")
          end
        end
    end

  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>command.rb</filename>
			<content>module God
  module CLI

    class Command
      def initialize(command, options, args)
        @command = command
        @options = options
        @args = args

        dispatch
      end

      def setup
        # connect to drb unix socket
        DRb.start_service("druby://127.0.0.1:0")
        @server = DRbObject.new(nil, God::Socket.socket(@options[:port]))

        # ping server to ensure that it is responsive
        begin
          @server.ping
        rescue DRb::DRbConnError
          puts "The server is not available (or you do not have permissions to access it)"
          abort
        end
      end

      def dispatch
        if %w{load status signal log quit terminate}.include?(@command)
          setup
          send("#{@command}_command")
        elsif %w{start stop restart monitor unmonitor remove}.include?(@command)
          setup
          lifecycle_command
        elsif @command == 'check'
          check_command
        else
          puts "Command '#{@command}' is not valid. Run 'god --help' for usage"
          abort
        end
      end

      def load_command
        file = @args[1]
        action = @args[2] || 'leave'

        unless ['stop', 'remove', 'leave', ''].include?(action)
          puts "Command '#{@command}' action must be either 'stop', 'remove' or 'leave'"
          exit(1)
        end

        puts "Sending '#{@command}' command with action '#{action}'"
        puts

        unless File.exist?(file)
          abort "File not found: #{file}"
        end

        affected, errors, removed = *@server.running_load(File.read(file), File.expand_path(file), action)

        # output response
        unless affected.empty?
          puts 'The following tasks were affected:'
          affected.each do |w|
            puts '  ' + w
          end
        end

        unless removed.empty?
          puts 'The following tasks were removed:'
          removed.each do |w|
            puts '  ' + w
          end
        end

        unless errors.empty?
          puts errors
          exit(1)
        end
      end

      def status_command
        exitcode = 0
        statuses = @server.status
        groups = {}
        statuses.each do |name, status|
          g = status[:group] || ''
          groups[g] ||= {}
          groups[g][name] = status
        end

        if item = @args[1]
          if single = statuses[item]
            # specified task (0 - up, 1 - unmonitored, 2 - other)
            state = single[:state]
            puts "#{item}: #{state}"
            exitcode = state == :up ? 0 : (state == :unmonitored ? 1 : 2)
          elsif groups[item]
            # specified group (0 - up, N - other)
            puts "#{item}:"
            groups[item].keys.sort.each do |name|
              state = groups[item][name][:state]
              print "  "
              puts "#{name}: #{state}"
              exitcode += 1 unless state == :up
            end
          else
            puts "Task or Group '#{item}' not found."
            exit(1)
          end
        else
          # show all groups and watches
          groups.keys.sort.each do |group|
            puts "#{group}:" unless group.empty?
            groups[group].keys.sort.each do |name|
              state = groups[group][name][:state]
              print "  " unless group.empty?
              puts "#{name}: #{state}"
            end
          end
        end

        exit(exitcode)
      end

      def signal_command
        # get the name of the watch/group
        name = @args[1]
        signal = @args[2]

        puts "Sending signal '#{signal}' to '#{name}'"

        t = Thread.new { loop { sleep(1); STDOUT.print('.'); STDOUT.flush; sleep(1) } }

        watches = @server.signal(name, signal)

        # output response
        t.kill; STDOUT.puts
        unless watches.empty?
          puts 'The following watches were affected:'
          watches.each do |w|
            puts '  ' + w
          end
        else
          puts 'No matching task or group'
        end
      end

      def log_command
        begin
          Signal.trap('INT') { exit }
          name = @args[1]

          unless name
            puts "You must specify a Task or Group name"
            exit!
          end

          puts "Please wait..."
          t = Time.at(0)
          loop do
            print @server.running_log(name, t)
            t = Time.now
            sleep 0.25
          end
        rescue God::NoSuchWatchError
          puts "No such watch"
        rescue DRb::DRbConnError
          puts "The server went away"
        end
      end

      def quit_command
        begin
          @server.terminate
          abort 'Could not stop god'
        rescue DRb::DRbConnError
          puts 'Stopped god'
        end
      end

      def terminate_command
        t = Thread.new { loop { STDOUT.print('.'); STDOUT.flush; sleep(1) } }
        if @server.stop_all
          t.kill; STDOUT.puts
          puts 'Stopped all watches'
        else
          t.kill; STDOUT.puts
          puts "Could not stop all watches within #{@server.terminate_timeout} seconds"
        end

        begin
          @server.terminate
          abort 'Could not stop god'
        rescue DRb::DRbConnError
          puts 'Stopped god'
        end
      end

      def check_command
        Thread.new do
          begin
            event_system = God::EventHandler.event_system
            puts "using event system: #{event_system}"

            if God::EventHandler.loaded?
              puts "starting event handler"
              God::EventHandler.start
            else
              puts "[fail] event system did not load"
              exit(1)
            end

            puts 'forking off new process'

            pid = fork do
              loop { sleep(1) }
            end

            puts "forked process with pid = #{pid}"

            God::EventHandler.register(pid, :proc_exit) do
              puts "[ok] process exit event received"
              exit!(0)
            end

            sleep(1)

            puts "killing process"

            ::Process.kill('KILL', pid)
            ::Process.waitpid(pid)
          rescue = e
            puts e.message
            puts e.backtrace.join("\n")
          end
        end

        sleep(2)

        puts "[fail] never received process exit event"
        exit(1)
      end

      def lifecycle_command
        # get the name of the watch/group
        name = @args[1]

        puts "Sending '#{@command}' command"

        t = Thread.new { loop { sleep(1); STDOUT.print('.'); STDOUT.flush; sleep(1) } }

        # send @command
        watches = @server.control(name, @command)

        # output response
        t.kill; STDOUT.puts
        unless watches.empty?
          puts 'The following watches were affected:'
          watches.each do |w|
            puts '  ' + w
          end
        else
          puts 'No matching task or group'
        end
      end
    end # Command

  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>run.rb</filename>
			<content>module God
  module CLI

    class Run
      def initialize(options)
        @options = options

        dispatch
      end

      def dispatch
        # have at_exit start god
        $run = true

        if @options[:syslog]
          require 'god/sys_logger'
        end

        # run
        if @options[:daemonize]
          run_daemonized
        else
          run_in_front
        end
      end

      def attach
        process = System::Process.new(@options[:attach])
        Thread.new do
          loop do
            unless process.exists?
              applog(nil, :info, "Going down because attached process #{@options[:attach]} exited")
              exit!
            end
            sleep 5
          end
        end
      end

      def default_run
        # make sure we have STDIN/STDOUT redirected immediately
        setup_logging

        # start attached pid watcher if necessary
        if @options[:attach]
          self.attach
        end

        if @options[:port]
          God.port = @options[:port]
        end

        if @options[:events]
          God::EventHandler.load
        end

        # set log level, defaults to WARN
        if @options[:log_level]
          God.log_level = @options[:log_level]
        else
          God.log_level = @options[:daemonize] ? :warn : :info
        end

        if @options[:config]
          if !@options[:config].include?('*') && !File.exist?(@options[:config])
            abort "File not found: #{@options[:config]}"
          end

          # start the event handler
          God::EventHandler.start if God::EventHandler.loaded?

          load_config @options[:config]
        end
        setup_logging
      end

      def run_in_front
        require 'god'

        default_run
      end

      def run_daemonized
        # trap and ignore SIGHUP
        Signal.trap('HUP') {}
        # trap and log-reopen SIGUSR1
        Signal.trap('USR1') { setup_logging }

        pid = fork do
          begin
            require 'god'

            # set pid if requested
            if @options[:pid] # and as deamon
              God.pid = @options[:pid]
            end

            default_run

            unless God::EventHandler.loaded?
              puts
              puts "***********************************************************************"
              puts "*"
              puts "* Event conditions are not available for your installation of god."
              puts "* You may still use and write custom conditions using the poll system"
              puts "*"
              puts "***********************************************************************"
              puts
            end

          rescue = e
            puts e.message
            puts e.backtrace.join("\n")
            abort "There was a fatal system error while starting god (see above)"
          end
        end

        if @options[:pid]
          File.open(@options[:pid], 'w') { |f| f.write pid }
        end

        ::Process.detach pid

        exit
      end

      def setup_logging
        log_file = God.log_file
        log_file = File.expand_path(@options[:log]) if @options[:log]
        log_file = "/dev/null" if !log_file && @options[:daemonize]
        if log_file
          puts "Sending output to log file: #{log_file}" unless @options[:daemonize]

          # reset file descriptors
          STDIN.reopen "/dev/null"
          STDOUT.reopen(log_file, "a")
          STDERR.reopen STDOUT
          STDOUT.sync = true
        end
      end

      def load_config(config)
        files = File.directory?(config) ? Dir['**/*.god'] : Dir[config]
        abort "No files could be found" if files.empty?
        files.each do |god_file|
          unless load_god_file(god_file)
            abort "File '#{god_file}' could not be loaded"
          end
        end
      end

      def load_god_file(god_file)
        applog(nil, :info, "Loading #{god_file}")
        load File.expand_path(god_file)
        true
      rescue Exception = e
        if e.instance_of?(SystemExit)
          raise
        else
          puts "There was an error in #{god_file}"
          puts "\t" + e.message
          puts "\t" + e.backtrace.join("\n\t")
          false
        end
      end

    end # Run

  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>version.rb</filename>
			<content>module God
  module CLI

    class Version
      def self.version
        require 'god'

        # print version
        puts "Version #{God.version}"
        exit
      end

      def self.version_extended
        puts "Version: #{God.version}"
        puts "Polls: enabled"
        puts "Events: " + God::EventHandler.event_system

        exit
      end
    end

  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>always.rb</filename>
			<content>module God
  module Conditions
    # Always trigger or never trigger.
    #
    # Examples
    #
    #   # Always trigger.
    #   on.condition(:always) do |c|
    #     c.what = true
    #   end
    #
    #   # Never trigger.
    #   on.condition(:always) do |c|
    #     c.what = false
    #   end
    class Always  PollCondition
      # The Boolean determining whether this condition will always trigger
      # (true) or never trigger (false).
      attr_accessor :what

      def initialize
        self.info = "always"
      end

      def valid?
        valid = true
        valid &= complain("Attribute 'what' must be specified", self) if self.what.nil?
        valid
      end

      def test
        @what
      end
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>complex.rb</filename>
			<content>module God
  module Conditions

    class Complex  PollCondition
      AND = 0x1
      OR  = 0x2
      NOT = 0x4

      def initialize()
        super

        @oper_stack = []
        @op_stack = []

        @this = nil
      end

      def valid?
        @oper_stack.inject(true) { |acc, oper| acc & oper.valid? }
      end

      def prepare
        @oper_stack.each { |oper| oper.prepare }
      end

      def new_oper(kind, op)
        oper = Condition.generate(kind, self.watch)
        @oper_stack.push(oper)
        @op_stack.push(op)
        oper
      end

      def this(kind)
        @this = Condition.generate(kind, self.watch)
        yield @this if block_given?
      end

      def and(kind)
        oper = new_oper(kind, 0x1)
        yield oper if block_given?
      end

      def and_not(kind)
        oper = new_oper(kind, 0x5)
        yield oper if block_given?
      end

      def or(kind)
        oper = new_oper(kind, 0x2)
        yield oper if block_given?
      end

      def or_not(kind)
        oper = new_oper(kind, 0x6)
        yield oper if block_given?
      end

      def test
        if @this.nil?
          # Although this() makes sense semantically and therefore
          # encourages easy-to-read conditions, being able to omit it
          # allows for more DRY code in some cases, so we deal with a
          # nil @this here by initially setting res to true or false,
          # depending on whether the first operator used is AND or OR
          # respectively.
          if 0  @op_stack[0] & AND
            res = true
          else
            res = false
          end
        else
          res = @this.test
        end

        @op_stack.each do |op|
          cond = @oper_stack.shift
          eval "res " + ((0  op & AND) ? "&&" : "||") + "= " + ((0  op & NOT) ? "!" : "") + "cond.test"
          @oper_stack.push cond
        end

        res
      end
    end

  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>cpu_usage.rb</filename>
			<content>module God
  module Conditions

    # Condition Symbol :cpu_usage
    # Type: Poll
    #
    # Trigger when the percent of CPU use of a process is above a specified limit.
    # On multi-core systems, this number could conceivably be above 100.
    #
    # Paramaters
    #   Required
    #     +pid_file+ is the pid file of the process in question. Automatically
    #                populated for Watches.
    #     +above+ is the percent CPU above which to trigger the condition. You
    #             may use #percent to clarify this amount (see examples).
    #
    # Examples
    #
    # Trigger if the process is using more than 25 percent of the cpu (from a Watch):
    #
    #   on.condition(:cpu_usage) do |c|
    #     c.above = 25.percent
    #   end
    #
    # Non-Watch Tasks must specify a PID file:
    #
    #   on.condition(:cpu_usage) do |c|
    #     c.above = 25.percent
    #     c.pid_file = "/var/run/mongrel.3000.pid"
    #   end
    class CpuUsage  PollCondition
      attr_accessor :above, :times, :pid_file

      def initialize
        super
        self.above = nil
        self.times = [1, 1]
      end

      def prepare
        if self.times.kind_of?(Integer)
          self.times = [self.times, self.times]
        end

        @timeline = Timeline.new(self.times[1])
      end

      def reset
        @timeline.clear
      end

      def pid
        self.pid_file ? File.read(self.pid_file).strip.to_i : self.watch.pid
      end

      def valid?
        valid = true
        valid &= complain("Attribute 'pid_file' must be specified", self) if self.pid_file.nil? && self.watch.pid_file.nil?
        valid &= complain("Attribute 'above' must be specified", self) if self.above.nil?
        valid
      end

      def test
        process = System::Process.new(self.pid)
        @timeline.push(process.percent_cpu)
        self.info = []

        history = "[" + @timeline.map { |x| "#{x  self.above ? '*' : ''}#{x}%%" }.join(", ") + "]"

        if @timeline.select { |x| x  self.above }.size = self.times.first
          self.info = "cpu out of bounds #{history}"
          return true
        else
          return false
        end
      end
    end

  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>degrading_lambda.rb</filename>
			<content>module God
  module Conditions

    # This condition degrades its interval by a factor of two for 3 tries before failing
    class DegradingLambda  PollCondition
      attr_accessor :lambda

      def initialize
        super
        @tries = 0
      end

      def valid?
        valid = true
        valid &= complain("Attribute 'lambda' must be specified", self) if self.lambda.nil?
        valid
      end

      def test
        puts "Calling test. Interval at #{self.interval}"
        @original_interval ||= self.interval
        unless pass?
          if @tries == 2
            self.info = "lambda condition was satisfied"
            return true
          end
          self.interval = self.interval / 2.0
          @tries += 1
        else
          @tries = 0
          self.interval = @original_interval
        end

        self.info = "lambda condition was not satisfied"
        false
      end

      private

        def pass?
          begin
            Timeout::timeout(@interval) {
              self.lambda.call()
            }
          rescue Timeout::Error
            false
          end
        end
    end

  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>disk_usage.rb</filename>
			<content>module God
  module Conditions

    class DiskUsage  PollCondition
      attr_accessor :above, :mount_point

      def initialize
        super
        self.above = nil
        self.mount_point = nil
      end

      def valid?
        valid = true
        valid &= complain("Attribute 'mount_point' must be specified", self) if self.mount_point.nil?
        valid &= complain("Attribute 'above' must be specified", self) if self.above.nil?
        valid
      end

      def test
        self.info = []
        usage = `df -P | grep -i " #{self.mount_point}$" | awk '{print $5}' | sed 's/%//'`
        if usage.to_i  self.above
          self.info = "disk space out of bounds"
          return true
        else
          return false
        end
      end
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>file_mtime.rb</filename>
			<content>module God
  module Conditions

    class FileMtime  PollCondition
      attr_accessor :path, :max_age

      def initialize
        super
        self.path = nil
        self.max_age = nil
      end

      def valid?
        valid = true
        valid &= complain("Attribute 'path' must be specified", self) if self.path.nil?
        valid &= complain("Attribute 'max_age' must be specified", self) if self.max_age.nil?
        valid
      end

      def test
        (Time.now - File.mtime(self.path))  self.max_age
      end
    end

  end
end


</content>
		</actual_file>
		<actual_file>
			<filename>file_touched.rb</filename>
			<content>module God
  module Conditions
  
    # Condition Symbol :file_touched
    # Type: Poll
    #
    # Trigger when a specified file is touched.
    #
    # Paramaters
    #   Required
    #     +path+ is the path to the file to watch.
    #
    # Examples
    #
    # Trigger if 'tmp/restart.txt' file is touched (from a Watch):
    #
    #   on.condition(:file_touched) do |c|
    #     c.path = 'tmp/restart.txt'
    #   end
    #
    class FileTouched  PollCondition
      attr_accessor :path

      def initialize
        super
        self.path = nil
      end

      def valid?
        valid = true
        valid &= complain("Attribute 'path' must be specified", self) if self.path.nil?
        valid
      end

      def test
        if File.exists?(self.path)
          (Time.now - File.mtime(self.path)) = self.interval
        else
          false
        end
      end
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>flapping.rb</filename>
			<content>module God
  module Conditions

    # Condition Symbol :flapping
    # Type: Trigger
    #
    # Trigger when a Task transitions to or from a state or states a given number
    # of times within a given period.
    #
    # Paramaters
    #   Required
    #     +times+ is the number of times that the Task must transition before
    #             triggering.
    #     +within+ is the number of seconds within which the Task must transition
    #              the specified number of times before triggering. You may use
    #              the sugar methods #seconds, #minutes, #hours, #days to clarify
    #              your code (see examples).
    #     --one or both of--
    #     +from_state+ is the state (as a Symbol) from which the transition must occur.
    #     +to_state is the state (as a Symbol) to which the transition must occur.
    #
    #   Optional:
    #     +retry_in+ is the number of seconds after which to re-monitor the Task after
    #                it has been disabled by the condition.
    #     +retry_times+ is the number of times after which to permanently unmonitor
    #                   the Task.
    #     +retry_within+ is the number of seconds within which
    #
    # Examples
    #
    # Trigger if
    class Flapping  TriggerCondition
      attr_accessor :times,
                    :within,
                    :from_state,
                    :to_state,
                    :retry_in,
                    :retry_times,
                    :retry_within

      def initialize
        self.info = "process is flapping"
      end

      def prepare
        @timeline = Timeline.new(self.times)
        @retry_timeline = Timeline.new(self.retry_times)
      end

      def valid?
        valid = true
        valid &= complain("Attribute 'times' must be specified", self) if self.times.nil?
        valid &= complain("Attribute 'within' must be specified", self) if self.within.nil?
        valid &= complain("Attributes 'from_state', 'to_state', or both must be specified", self) if self.from_state.nil? && self.to_state.nil?
        valid
      end

      def process(event, payload)
        begin
          if event == :state_change
            event_from_state, event_to_state = *payload

            from_state_match = !self.from_state || self.from_state && Array(self.from_state).include?(event_from_state)
            to_state_match = !self.to_state || self.to_state && Array(self.to_state).include?(event_to_state)

            if from_state_match && to_state_match
              @timeline  Time.now

              concensus = (@timeline.size == self.times)
              duration = (@timeline.last - @timeline.first)  self.within

              if concensus && duration
                @timeline.clear
                trigger
                retry_mechanism
              end
            end
          end
        rescue = e
          puts e.message
          puts e.backtrace.join("\n")
        end
      end

      private

      def retry_mechanism
        if self.retry_in
          @retry_timeline  Time.now

          concensus = (@retry_timeline.size == self.retry_times)
          duration = (@retry_timeline.last - @retry_timeline.first)  self.retry_within

          if concensus && duration
            # give up
            Thread.new do
              sleep 1

              # log
              msg = "#{self.watch.name} giving up"
              applog(self.watch, :info, msg)
            end
          else
            # try again later
            Thread.new do
              sleep 1

              # log
              msg = "#{self.watch.name} auto-reenable monitoring in #{self.retry_in} seconds"
              applog(self.watch, :info, msg)

              sleep self.retry_in

              # log
              msg = "#{self.watch.name} auto-reenabling monitoring"
              applog(self.watch, :info, msg)

              if self.watch.state == :unmonitored
                self.watch.monitor
              end
            end
          end
        end
      end
    end

  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>http_response_code.rb</filename>
			<content>require 'net/http'
require 'net/https'

module God
  module Conditions

    # Condition Symbol :http_response_code
    # Type: Poll
    #
    # Trigger based on the response from an HTTP request.
    #
    # Paramaters
    #   Required
    #     +host+ is the hostname to connect [required]
    #     --one of code_is or code_is_not--
    #     +code_is+ trigger if the response code IS one of these
    #               e.g. 500 or '500' or [404, 500] or %w{404 500}
    #     +code_is_not+ trigger if the response code IS NOT one of these
    #                   e.g. 200 or '200' or [200, 302] or %w{200 302}
    #  Optional
    #     +port+ is the port to connect (default 80)
    #     +path+ is the path to connect (default '/')
    #     +headers+ is the hash of HTTP headers to send (default none)
    #     +times+ is the number of times after which to trigger (default 1)
    #             e.g. 3 (times in a row) or [3, 5] (three out of fives times)
    #     +timeout+ is the time to wait for a connection (default 60.seconds)
    #     +ssl+ should the connection use ssl (default false)
    #
    # Examples
    #
    # Trigger if the response code from www.example.com/foo/bar
    # is not a 200 (or if the connection is refused or times out:
    #
    #   on.condition(:http_response_code) do |c|
    #     c.host = 'www.example.com'
    #     c.path = '/foo/bar'
    #     c.code_is_not = 200
    #   end
    #
    # Trigger if the response code is a 404 or a 500 (will not
    # be triggered by a connection refusal or timeout):
    #
    #   on.condition(:http_response_code) do |c|
    #     c.host = 'www.example.com'
    #     c.path = '/foo/bar'
    #     c.code_is = [404, 500]
    #   end
    #
    # Trigger if the response code is not a 200 five times in a row:
    #
    #   on.condition(:http_response_code) do |c|
    #     c.host = 'www.example.com'
    #     c.path = '/foo/bar'
    #     c.code_is_not = 200
    #     c.times = 5
    #   end
    #
    # Trigger if the response code is not a 200 or does not respond
    # within 10 seconds:
    #
    #   on.condition(:http_response_code) do |c|
    #     c.host = 'www.example.com'
    #     c.path = '/foo/bar'
    #     c.code_is_not = 200
    #     c.timeout = 10
    #   end
    class HttpResponseCode  PollCondition
      attr_accessor :code_is,      # e.g. 500 or '500' or [404, 500] or %w{404 500}
                    :code_is_not,  # e.g. 200 or '200' or [200, 302] or %w{200 302}
                    :times,        # e.g. 3 or [3, 5]
                    :host,         # e.g. www.example.com
                    :port,         # e.g. 8080
                    :ssl,          # e.g. true or false
                    :ca_file,      # e.g /path/to/pem_file for ssl verification (checkout http://curl.haxx.se/ca/cacert.pem)
                    :timeout,      # e.g. 60.seconds
                    :path,         # e.g. '/'
                    :headers       # e.g. {'Host' = 'myvirtual.mydomain.com'}

      def initialize
        super
        self.port = 80
        self.path = '/'
        self.headers = {}
        self.times = [1, 1]
        self.timeout = 60.seconds
        self.ssl = false
        self.ca_file = nil
      end

      def prepare
        self.code_is = Array(self.code_is).map { |x| x.to_i } if self.code_is
        self.code_is_not = Array(self.code_is_not).map { |x| x.to_i } if self.code_is_not

        if self.times.kind_of?(Integer)
          self.times = [self.times, self.times]
        end

        @timeline = Timeline.new(self.times[1])
        @history = Timeline.new(self.times[1])
      end

      def reset
        @timeline.clear
        @history.clear
      end

      def valid?
        valid = true
        valid &= complain("Attribute 'host' must be specified", self) if self.host.nil?
        valid &= complain("One (and only one) of attributes 'code_is' and 'code_is_not' must be specified", self) if
          (self.code_is.nil? && self.code_is_not.nil?) || (self.code_is && self.code_is_not)
        valid
      end

      def test
        response = nil

        connection = Net::HTTP.new(self.host, self.port)
        connection.use_ssl = self.port == 443 ? true : self.ssl
        connection.verify_mode = OpenSSL::SSL::VERIFY_NONE if connection.use_ssl?

        if connection.use_ssl? && self.ca_file
          pem = File.read(self.ca_file)
          connection.ca_file = self.ca_file
          connection.verify_mode = OpenSSL::SSL::VERIFY_PEER
        end

        connection.start do |http|
          http.read_timeout = self.timeout
          response = http.get(self.path, self.headers)
        end

        actual_response_code = response.code.to_i
        if self.code_is && self.code_is.include?(actual_response_code)
          pass(actual_response_code)
        elsif self.code_is_not && !self.code_is_not.include?(actual_response_code)
          pass(actual_response_code)
        else
          fail(actual_response_code)
        end
      rescue Errno::ECONNREFUSED
        self.code_is ? fail('Refused') : pass('Refused')
      rescue Errno::ECONNRESET
        self.code_is ? fail('Reset') : pass('Reset')
      rescue EOFError
        self.code_is ? fail('EOF') : pass('EOF')
      rescue Timeout::Error
        self.code_is ? fail('Timeout') : pass('Timeout')
      rescue Errno::ETIMEDOUT
        self.code_is ? fail('Timedout') : pass('Timedout')
      rescue Exception = failure
        self.code_is ? fail(failure.class.name) : pass(failure.class.name)
      end

      private

      def pass(code)
        @timeline  true
        if @timeline.select { |x| x }.size = self.times.first
          self.info = "http response abnormal #{history(code, true)}"
          true
        else
          self.info = "http response nominal #{history(code, true)}"
          false
        end
      end

      def fail(code)
        @timeline  false
        self.info = "http response nominal #{history(code, false)}"
        false
      end

      def history(code, passed)
        entry = code.to_s.dup
        entry = '*' + entry if passed
        @history  entry
        '[' + @history.join(", ") + ']'
      end

    end

  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>lambda.rb</filename>
			<content>module God
  module Conditions

    class Lambda  PollCondition
      attr_accessor :lambda

      def valid?
        valid = true
        valid &= complain("Attribute 'lambda' must be specified", self) if self.lambda.nil?
        valid
      end

      def test
        if self.lambda.call()
          self.info = "lambda condition was satisfied"
          true
        else
          self.info = "lambda condition was not satisfied"
          false
        end
      end
    end

  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>memory_usage.rb</filename>
			<content>module God
  module Conditions

    # Condition Symbol :memory_usage
    # Type: Poll
    #
    # Trigger when the resident memory of a process is above a specified limit.
    #
    # Paramaters
    #   Required
    #     +pid_file+ is the pid file of the process in question. Automatically
    #                populated for Watches.
    #     +above+ is the amount of resident memory (in kilobytes) above which
    #             the condition should trigger. You can also use the sugar
    #             methods #kilobytes, #megabytes, and #gigabytes to clarify
    #             this amount (see examples).
    #
    # Examples
    #
    # Trigger if the process is using more than 100 megabytes of resident
    # memory (from a Watch):
    #
    #   on.condition(:memory_usage) do |c|
    #     c.above = 100.megabytes
    #   end
    #
    # Non-Watch Tasks must specify a PID file:
    #
    #   on.condition(:memory_usage) do |c|
    #     c.above = 100.megabytes
    #     c.pid_file = "/var/run/mongrel.3000.pid"
    #   end
    class MemoryUsage  PollCondition
      attr_accessor :above, :times, :pid_file

      def initialize
        super
        self.above = nil
        self.times = [1, 1]
      end

      def prepare
        if self.times.kind_of?(Integer)
          self.times = [self.times, self.times]
        end

        @timeline = Timeline.new(self.times[1])
      end

      def reset
        @timeline.clear
      end

      def pid
        self.pid_file ? File.read(self.pid_file).strip.to_i : self.watch.pid
      end

      def valid?
        valid = true
        valid &= complain("Attribute 'pid_file' must be specified", self) if self.pid_file.nil? && self.watch.pid_file.nil?
        valid &= complain("Attribute 'above' must be specified", self) if self.above.nil?
        valid
      end

      def test
        process = System::Process.new(self.pid)
        @timeline.push(process.memory)
        self.info = []

        history = "[" + @timeline.map { |x| "#{x  self.above ? '*' : ''}#{x}kb" }.join(", ") + "]"

        if @timeline.select { |x| x  self.above }.size = self.times.first
          self.info = "memory out of bounds #{history}"
          return true
        else
          return false
        end
      end
    end

  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>process_exits.rb</filename>
			<content>module God
  module Conditions
    # Trigger when a process exits.
    #
    #     +pid_file+ is the pid file of the process in question. Automatically
    #                populated for Watches.
    #
    # Examples
    #
    #   # Trigger if process exits (from a Watch).
    #   on.condition(:process_exits)
    #
    #   # Trigger if process exits (non-Watch).
    #   on.condition(:process_exits) do |c|
    #     c.pid_file = "/var/run/mongrel.3000.pid"
    #   end
    class ProcessExits  EventCondition
      # The String PID file location of the process in question. Automatically
      # populated for Watches.
      attr_accessor :pid_file

      def initialize
        self.info = "process exited"
      end

      def valid?
        true
      end

      def pid
        self.pid_file ? File.read(self.pid_file).strip.to_i : self.watch.pid
      end

      def register
        pid = self.pid

        begin
          EventHandler.register(pid, :proc_exit) do |extra|
            formatted_extra = extra.size  0 ? " #{extra.inspect}" : ""
            self.info = "process #{pid} exited#{formatted_extra}"
            self.watch.trigger(self)
          end

          msg = "#{self.watch.name} registered 'proc_exit' event for pid #{pid}"
          applog(self.watch, :info, msg)
        rescue StandardError
          raise EventRegistrationFailedError.new
        end
      end

      def deregister
        pid = self.pid
        if pid
          EventHandler.deregister(pid, :proc_exit)

          msg = "#{self.watch.name} deregistered 'proc_exit' event for pid #{pid}"
          applog(self.watch, :info, msg)
        else
          pid_file_location = self.pid_file || self.watch.pid_file
          applog(self.watch, :error, "#{self.watch.name} could not deregister: no cached PID or PID file #{pid_file_location} (#{self.base_name})")
        end
      end
    end

  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>process_running.rb</filename>
			<content>module God
  module Conditions
    # Trigger when a process is running or not running depending on attributes.
    #
    # Examples
    #
    #   # Trigger if process IS NOT running.
    #   on.condition(:process_running) do |c|
    #     c.running = false
    #   end
    #
    #   # Trigger if process IS running.
    #   on.condition(:process_running) do |c|
    #     c.running = true
    #   end
    #
    #   # Non-Watch Tasks must specify a PID file.
    #   on.condition(:process_running) do |c|
    #     c.running = false
    #     c.pid_file = "/var/run/mongrel.3000.pid"
    #   end
    class ProcessRunning  PollCondition
      # Public: The Boolean specifying whether you want to trigger if the
      # process is running (true) or if it is not running (false).
      attr_accessor :running

      # Public: The String PID file location of the process in question.
      # Automatically populated for Watches.
      attr_accessor :pid_file

      def pid
        self.pid_file ? File.read(self.pid_file).strip.to_i : self.watch.pid
      end

      def valid?
        valid = true
        valid &= complain("Attribute 'pid_file' must be specified", self) if self.pid_file.nil? && self.watch.pid_file.nil?
        valid &= complain("Attribute 'running' must be specified", self) if self.running.nil?
        valid
      end

      def test
        self.info = []

        pid = self.pid
        active = pid && System::Process.new(pid).exists?

        if (self.running && active)
          self.info.concat(["process is running"])
          true
        elsif (!self.running && !active)
          self.info.concat(["process is not running"])
          true
        else
          if self.running
            self.info.concat(["process is not running"])
          end
          false
        end
      end
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>socket_responding.rb</filename>
			<content>require 'socket'
include Socket::Constants

module God
  module Conditions
    # Condition Symbol :socket_running
    # Type: Poll
    #
    # Trigger when a TCP or UNIX socket is running or not
    #
    # Parameters
    # Required
    #   +family+ is the family of socket: either 'tcp' or 'unix'
    #   --one of port or path--
    #   +port+ is the port (required if +family+ is 'tcp')
    #   +path+ is the path (required if +family+ is 'unix')
    #
    # Optional
    #   +responding+ is the boolean specifying whether you want to trigger if the socket is responding (true)
    #                or if it is not responding (false) (default false)
    #
    # Examples
    #
    # Trigger if the TCP socket on port 80 is not responding or the connection is refused
    #
    # on.condition(:socket_responding) do |c|
    #   c.family = 'tcp'
    #   c.port = '80'
    # end
    #
    # Trigger if the socket is not responding or the connection is refused (use alternate compact +socket+ interface)
    #
    # on.condition(:socket_responding) do |c|
    #   c.socket = 'tcp:80'
    # end
    #
    # Trigger if the socket is responding
    #
    # on.condition(:socket_responding) do |c|
    #   c.socket = 'tcp:80'
    #   c.responding = true
    # end
    #
    # Trigger if the socket is not responding or the connection is refused 5 times in a row
    #
    # on.condition(:socket_responding) do |c|
    #   c.socket = 'tcp:80'
    #   c.times = 5
    # end
    #
    # Trigger if the Unix socket on path '/tmp/sock' is not responding or non-existent
    #
    # on.condition(:socket_responding) do |c|
    #   c.family = 'unix'
    #   c.port = '/tmp/sock'
    # end
    #
    class SocketResponding  PollCondition
      attr_accessor :family, :addr, :port, :path, :times, :responding

      def initialize
        super
        # default to tcp on the localhost
        self.family = 'tcp'
        self.addr = '127.0.0.1'
        # Set these to nil/0 values
        self.port = 0
        self.path = nil
        self.responding = false

        self.times = [1, 1]
      end

      def prepare
        if self.times.kind_of?(Integer)
          self.times = [self.times, self.times]
        end

        @timeline = Timeline.new(self.times[1])
        @history = Timeline.new(self.times[1])
      end

      def reset
        @timeline.clear
        @history.clear
      end

      def socket=(s)
        components = s.split(':')
        if components.size == 3
          @family,@addr,@port = components
          @port = @port.to_i
        elsif components[0] =~ /^tcp$/
          @family = components[0]
          @port = components[1].to_i
        elsif components[0] =~ /^unix$/
          @family = components[0]
          @path = components[1]
        end
      end

      def valid?
        valid = true
        if self.family == 'tcp' and @port == 0
          valid &= complain("Attribute 'port' must be specified for tcp sockets", self)
        end
        if self.family == 'unix' and self.path.nil?
          valid &= complain("Attribute 'path' must be specified for unix sockets", self)
        end
        valid = false unless %w{tcp unix}.member?(self.family)
        valid
      end

      def test
        self.info = []
        if self.family == 'tcp'
          begin
            s = TCPSocket.new(self.addr, self.port)
          rescue SystemCallError
          end
          status = self.responding == !s.nil?
        elsif self.family == 'unix'
          begin
            s = UNIXSocket.new(self.path)
          rescue SystemCallError
          end
          status = self.responding == !s.nil?
        else
          status = false
        end
        @timeline.push(status)
        history = "[" + @timeline.map {|t| t ? '*' : ''}.join(',') + "]"
        if @timeline.select { |x| x }.size = self.times.first
          self.info = "socket out of bounds #{history}"
          return true
        else
          return false
        end
      end
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>tries.rb</filename>
			<content>module God
  module Conditions

    class Tries  PollCondition
      attr_accessor :times, :within

      def prepare
        @timeline = Timeline.new(self.times)
      end

      def reset
        @timeline.clear
      end

      def valid?
        valid = true
        valid &= complain("Attribute 'times' must be specified", self) if self.times.nil?
        valid
      end

      def test
        @timeline  Time.now

        concensus = (@timeline.size == self.times)
        duration = self.within.nil? || (@timeline.last - @timeline.first)  self.within

        if within
          history = "[#{@timeline.size}/#{self.times} within #{(@timeline.last - @timeline.first).to_i}s]"
        else
          history = "[#{@timeline.size}/#{self.times}]"
        end

        if concensus && duration
          self.info = "tries exceeded #{history}"
          return true
        else
          self.info = "tries within bounds #{history}"
          return false
        end
      end
    end

  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>airbrake.rb</filename>
			<content># Send a notice to Airbrake (http://airbrake.io/).
#
# apikey - The String API key.

CONTACT_DEPS[:airbrake] = ['airbrake']
CONTACT_DEPS[:airbrake].each do |d|
  require d
end

module God
  module Contacts
    class Airbrake  Contact

      class  self
        attr_accessor :apikey
      end

      def valid?
        valid = true
        valid &= complain("Attribute 'apikey' must be specified", self) if self.apikey.nil?
        valid
      end

      attr_accessor :apikey

      def notify(message, time, priority, category, host)
        ::Airbrake.configure {}

        message = "God: #{message.to_s} at #{host}"
        message  " | #{[category, priority].join(" ")}" unless category.to_s.empty? or priority.to_s.empty?

        if ::Airbrake.notify nil, :error_message = message, :api_key = arg(:apikey)
          self.info = "sent airbrake notification to #{self.name}"
        else
          self.info = "failed to send airbrake notification to #{self.name}"
        end
      rescue Object = e
        applog(nil, :info, "failed to send airbrake notification: #{e.message}")
        applog(nil, :debug, e.backtrace.join("\n"))
      end

    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>campfire.rb</filename>
			<content># Send a notice to a Campfire room (http://campfirenow.com).
#
#  subdomain - The String subdomain of the Campfire account. If your URL is
#              "foo.campfirenow.com" then your subdomain is "foo".
#  token     - The String token used for authentication.
#  room      - The String room name to which the message should be sent.
#  ssl       - A Boolean determining whether or not to use SSL
#              (default: false).

require 'net/http'
require 'net/https'

CONTACT_DEPS[:campfire] = ['json']
CONTACT_DEPS[:campfire].each do |d|
  require d
end

module Marshmallow
  class Connection
    def initialize(options)
      raise "Required option :subdomain not set." unless options[:subdomain]
      raise "Required option :token not set." unless options[:token]
      @options = options
    end

    def base_url
      scheme = @options[:ssl] ? 'https' : 'http'
      subdomain = @options[:subdomain]
      "#{scheme}://#{subdomain}.campfirenow.com"
    end

    def find_room_id_by_name(room)
      url = URI.parse("#{base_url}/rooms.json")

      http = Net::HTTP.new(url.host, url.port)
      http.use_ssl = true if @options[:ssl]

      req = Net::HTTP::Get.new(url.path)
      req.basic_auth(@options[:token], 'X')

      res = http.request(req)
      case res
        when Net::HTTPSuccess
          rooms = JSON.parse(res.body)
          room = rooms['rooms'].select { |x| x['name'] == room }
          rooms.empty? ? nil : room.first['id']
        else
          raise res.error!
      end
    end

    def speak(room, message)
      room_id = find_room_id_by_name(room)
      raise "No such room: #{room}." unless room_id

      url = URI.parse("#{base_url}/room/#{room_id}/speak.json")

      http = Net::HTTP.new(url.host, url.port)
      http.use_ssl = true if @options[:ssl]

      req = Net::HTTP::Post.new(url.path)
      req.basic_auth(@options[:token], 'X')
      req.set_content_type('application/json')
      req.body = { 'message' = { 'body' = message } }.to_json

      res = http.request(req)
      case res
        when Net::HTTPSuccess
          true
        else
          raise res.error!
      end
    end
  end
end

module God
  module Contacts

    class Campfire  Contact
      class  self
        attr_accessor :subdomain, :token, :room, :ssl
        attr_accessor :format
      end

      self.ssl = false

      self.format = lambda do |message, time, priority, category, host|
        "[#{time.strftime('%H:%M:%S')}] #{host} - #{message}"
      end

      attr_accessor :subdomain, :token, :room, :ssl

      def valid?
        valid = true
        valid &= complain("Attribute 'subdomain' must be specified", self) unless arg(:subdomain)
        valid &= complain("Attribute 'token' must be specified", self) unless arg(:token)
        valid &= complain("Attribute 'room' must be specified", self) unless arg(:room)
        valid
      end

      def notify(message, time, priority, category, host)
        body = Campfire.format.call(message, time, priority, category, host)

        conn = Marshmallow::Connection.new(
          :subdomain = arg(:subdomain),
          :token = arg(:token),
          :ssl = arg(:ssl)
        )

        conn.speak(arg(:room), body)

        self.info = "notified campfire: #{arg(:subdomain)}"
      rescue Object = e
        applog(nil, :info, "failed to notify campfire: #{e.message}")
        applog(nil, :debug, e.backtrace.join("\n"))
      end
    end

  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>email.rb</filename>
			<content># Send a notice to an email address.
#
# to_email        - The String email address to which the email will be sent.
# to_name         - The String name corresponding to the recipient.
# from_email      - The String email address from which the email will be sent.
# from_name       - The String name corresponding to the sender.
# delivery_method - The Symbol delivery method. [ :smtp | :sendmail ]
#                   (default: :smtp).
#
# === SMTP Options (when delivery_method = :smtp) ===
# server_host     - The String hostname of the SMTP server (default: localhost).
# server_port     - The Integer port of the SMTP server (default: 25).
# server_auth     - The Symbol authentication method. Possible values:
#                   [ nil | :plain | :login | :cram_md5 ]
#                   The default is nil, which means no authentication. To
#                   enable authentication, pass the appropriate symbol and
#                   then pass the appropriate SMTP Auth Options (below).
#
# === SMTP Auth Options (when server_auth != nil) ===
# server_domain   - The String domain.
# server_user     - The String username.
# server_password - The String password.
#
# === Sendmail Options (when delivery_method = :sendmail) ===
# sendmail_path   - The String path to the sendmail executable
#                   (default: "/usr/sbin/sendmail").
# sendmail_args   - The String args to send to sendmail (default "-i -t").

require 'time'
require 'net/smtp'

module God
  module Contacts

    class Email  Contact
      class  self
        attr_accessor :to_email, :to_name, :from_email, :from_name,
                      :delivery_method, :server_host, :server_port,
                      :server_auth, :server_domain, :server_user,
                      :server_password, :sendmail_path, :sendmail_args
        attr_accessor :format
      end

      self.from_email = 'god@example.com'
      self.from_name = 'God Process Monitoring'
      self.delivery_method = :smtp
      self.server_auth = nil
      self.server_host = 'localhost'
      self.server_port = 25
      self.sendmail_path = '/usr/sbin/sendmail'
      self.sendmail_args = '-i -t'

      self.format = lambda do |name, from_email, from_name, to_email, to_name, message, time, priority, category, host|
        -EOF
From: #{from_name} #{from_email}
To: #{to_name || name} #{to_email}
Subject: [god] #{message}
Date: #{time.httpdate}
Message-Id: #{rand(1000000000).to_s(36)}.#{$$}.#{from_email}

Message: #{message}
Host: #{host}
Priority: #{priority}
Category: #{category}
        EOF
      end

      attr_accessor :to_email, :to_name, :from_email, :from_name,
                    :delivery_method, :server_host, :server_port,
                    :server_auth, :server_domain, :server_user,
                    :server_password, :sendmail_path, :sendmail_args

      def valid?
        valid = true
        valid &= complain("Attribute 'to_email' must be specified", self) unless arg(:to_email)
        valid &= complain("Attribute 'delivery_method' must be one of [ :smtp | :sendmail ]", self) unless [:smtp, :sendmail].include?(arg(:delivery_method))
        if arg(:delivery_method) == :smtp
          valid &= complain("Attribute 'server_host' must be specified", self) unless arg(:server_host)
          valid &= complain("Attribute 'server_port' must be specified", self) unless arg(:server_port)
          if arg(:server_auth)
            valid &= complain("Attribute 'server_domain' must be specified", self) unless arg(:server_domain)
            valid &= complain("Attribute 'server_user' must be specified", self) unless arg(:server_user)
            valid &= complain("Attribute 'server_password' must be specified", self) unless arg(:server_password)
          end
        end
        valid
      end

      def notify(message, time, priority, category, host)
        body = Email.format.call(self.name, arg(:from_email), arg(:from_name),
                                 arg(:to_email), arg(:to_name), message, time,
                                 priority, category, host)

        case arg(:delivery_method)
          when :smtp
            notify_smtp(body)
          when :sendmail
            notify_sendmail(body)
        end

        self.info = "sent email to #{arg(:to_email)} via #{arg(:delivery_method).to_s}"
      rescue Object = e
        applog(nil, :info, "failed to send email to #{arg(:to_email)} via #{arg(:delivery_method).to_s}: #{e.message}")
        applog(nil, :debug, e.backtrace.join("\n"))
      end

      def notify_smtp(mail)
        args = [arg(:server_host), arg(:server_port)]
        if arg(:server_auth)
          args  arg(:server_domain)
          args  arg(:server_user)
          args  arg(:server_password)
          args  arg(:server_auth)
        end

        Net::SMTP.start(*args) do |smtp|
          smtp.send_message(mail, arg(:from_email), arg(:to_email))
        end
      end

      def notify_sendmail(mail)
        IO.popen("#{arg(:sendmail_path)} #{arg(:sendmail_args)}","w+") do |sm|
          sm.print(mail.gsub(/\r/, ''))
          sm.flush
        end
      end
    end

  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>hipchat.rb</filename>
			<content># Send a notice to a Hipchat room (http://hipchat.com).
#
#  token     - The String token used for authentication.
#  room      - The String room name to which the message should be sent.
#  ssl       - A Boolean determining whether or not to use SSL
#              (default: false).
#  from      - The String representing who the message should be sent as.

require 'net/http'
require 'net/https'

CONTACT_DEPS[:hipchat] = ['json']
CONTACT_DEPS[:hipchat].each do |d|
  require d
end

module Marshmallow
  class Connection
    def initialize(options)
      raise "Required option :token not set." unless options[:token]
      @options = options
    end

    def base_url
      scheme = @options[:ssl] ? 'https' : 'http'
      "#{scheme}://api.hipchat.com/v1/rooms"
    end

    def find_room_id_by_name(room_name)
      url = URI.parse("#{base_url}/list?format=json&auth_token=#{@options[:token]}")
      http = Net::HTTP.new(url.host, url.port)
      http.use_ssl = true if @options[:ssl]

      req = Net::HTTP::Get.new(url.request_uri)
      req.set_content_type('application/json')

      res = http.request(req)
      case res
        when Net::HTTPSuccess
          rooms = JSON.parse(res.body)
          room = rooms['rooms'].select { |x| x['name'] == room_name }
          rooms.empty? ? nil : room.first['room_id'].to_i
        else
          raise res.error!
      end
    end

    def speak(room, message)
      room_id = find_room_id_by_name(room)
      puts "in spark: room_id = #{room_id}"
      raise "No such room: #{room}." unless room_id

      escaped_message = URI.escape(message)

      url = URI.parse("#{base_url}/message?message_format=text&format=json&auth_token=#{@options[:token]}&from=#{@options[:from]}&room_id=#{room}&message=#{escaped_message}")
      
      http = Net::HTTP.new(url.host, url.port)
      http.use_ssl = true if @options[:ssl]

      req = Net::HTTP::Post.new(url.request_uri)
      req.set_content_type('application/json')
      res = http.request(req)
      case res
        when Net::HTTPSuccess
          true
        else
          raise res.error!
      end
    end
  end
end

module God
  module Contacts

    class Hipchat  Contact
      class  self
        attr_accessor :token, :room, :ssl, :from
        attr_accessor :format
      end

      self.ssl = false

      self.format = lambda do |message, time, priority, category, host|
        "[#{time.strftime('%H:%M:%S')}] #{host} - #{message}"
      end

      attr_accessor :token, :room, :ssl, :from

      def valid?
        valid = true
        valid &= complain("Attribute 'token' must be specified", self) unless arg(:token)
        valid &= complain("Attribute 'room' must be specified", self) unless arg(:room)
        valid &= complain("Attribute 'from' must be specified", self) unless arg(:from)
        valid
      end

      def notify(message, time, priority, category, host)
        body = Hipchat.format.call(message, time, priority, category, host)

        conn = Marshmallow::Connection.new(
          :token = arg(:token),
          :ssl   = arg(:ssl),
          :from  = arg(:from)
        )

        conn.speak(arg(:room), body)

        self.info = "notified hipchat: #{arg(:room)}"
      rescue Object = e
        applog(nil, :info, "failed to notify hipchat: #{e.message}")
        applog(nil, :debug, e.backtrace.join("\n"))
      end
    end

  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>jabber.rb</filename>
			<content># Send a notice to a Jabber address.
#
# host     - The String hostname of the Jabber server.
# port     - The Integer port of the Jabber server (default: 5222).
# from_jid - The String Jabber ID of the sender.
# password - The String password of the sender.
# to_jid   - The String Jabber ID of the recipient.
# subject  - The String subject of the message (default: "God Notification").

CONTACT_DEPS[:jabber] = ['xmpp4r']
CONTACT_DEPS[:jabber].each do |d|
  require d
end

module God
  module Contacts

    class Jabber  Contact
      class  self
        attr_accessor :host, :port, :from_jid, :password, :to_jid, :subject
        attr_accessor :format
      end

      self.port = 5222
      self.subject = 'God Notification'

      self.format = lambda do |message, time, priority, category, host|
        text  = "Message: #{message}\n"
        text += "Host: #{host}\n"         if host
        text += "Priority: #{priority}\n" if priority
        text += "Category: #{category}\n" if category
        text
      end

      attr_accessor :host, :port, :from_jid, :password, :to_jid, :subject

      def valid?
        valid = true
        valid &= complain("Attribute 'host' must be specified", self) unless arg(:host)
        valid &= complain("Attribute 'port' must be specified", self) unless arg(:port)
        valid &= complain("Attribute 'from_jid' must be specified", self) unless arg(:from_jid)
        valid &= complain("Attribute 'to_jid' must be specified", self) unless arg(:to_jid)
        valid &= complain("Attribute 'password' must be specified", self) unless arg(:password)
        valid
      end

      def notify(message, time, priority, category, host)
        body = Jabber.format.call(message, time, priority, category, host)

        message = ::Jabber::Message.new(arg(:to_jid), body)
        message.set_type(:normal)
        message.set_id('1')
        message.set_subject(arg(:subject))

        jabber_id = ::Jabber::JID.new("#{arg(:from_jid)}/God")

        client = ::Jabber::Client.new(jabber_id)
        client.connect(arg(:host), arg(:port))
        client.auth(arg(:password))
        client.send(message)
        client.close

        self.info = "sent jabber message to #{self.to_jid}"
      rescue Object = e
        if e.respond_to?(:message)
          applog(nil, :info, "failed to send jabber message to #{arg(:to_jid)}: #{e.message}")
        else
          applog(nil, :info, "failed to send jabber message to #{arg(:to_jid)}: #{e.class}")
        end
        applog(nil, :debug, e.backtrace.join("\n"))
      end

    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>prowl.rb</filename>
			<content># Send a notice to Prowl (http://prowl.weks.net/).
#
# apikey - The String API key.

CONTACT_DEPS[:prowl] = ['prowly']
CONTACT_DEPS[:prowl].each do |d|
  require d
end

module God
  module Contacts
    class Prowl  Contact

      class  self
        attr_accessor :apikey
      end

      def valid?
        valid = true
        valid &= complain("Attribute 'apikey' must be specified", self) if self.apikey.nil?
        valid
      end

      attr_accessor :apikey

      def notify(message, time, priority, category, host)
        result = Prowly.notify do |n|
          n.apikey      = arg(:apikey)
          n.priority    = map_priority(priority.to_i)
          n.application = category || "God"
          n.event       = "on " + host.to_s
          n.description = message.to_s + " at " + time.to_s
        end

        if result.succeeded?
          self.info = "sent prowl notification to #{self.name}"
        else
          self.info = "failed to send prowl notification to #{self.name}: #{result.message}"
        end
      rescue Object = e
        applog(nil, :info, "failed to send prowl notification to #{self.name}: #{e.message}")
        applog(nil, :debug, e.backtrace.join("\n"))
      end

      def map_priority(priority)
        case priority
           when 1 then Prowly::Notification::Priority::EMERGENCY
           when 2 then Prowly::Notification::Priority::HIGH
           when 3 then Prowly::Notification::Priority::NORMAL
           when 4 then Prowly::Notification::Priority::MODERATE
           when 5 then Prowly::Notification::Priority::VERY_LOW
           else Prowly::Notification::Priority::NORMAL
        end
      end
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>scout.rb</filename>
			<content># Send a notice to Scout (http://scoutapp.com/).
#
# client_key - The String client key.
# plugin_id  - The String plugin id.

require 'net/http'
require 'uri'

module God
  module Contacts

    class Scout  Contact
      class  self
        attr_accessor :client_key, :plugin_id
        attr_accessor :format
      end

      self.format = lambda do |message, priority, category, host|
        text  = "Message: #{message}\n"
        text += "Host: #{host}\n"         if host
        text += "Priority: #{priority}\n" if priority
        text += "Category: #{category}\n" if category
        return text
      end

      attr_accessor :client_key, :plugin_id

      def valid?
        valid = true
        valid &= complain("Attribute 'client_key' must be specified", self) unless arg(:client_key)
        valid &= complain("Attribute 'plugin_id' must be specified", self) unless arg(:plugin_id)
        valid
      end

      def notify(message, time, priority, category, host)
        data = {
          :client_key = arg(:client_key),
          :plugin_id = arg(:plugin_id),
          :format = 'xml',
          'alert[subject]' = message,
          'alert[body]' = Scout.format.call(message, priority, category, host)
        }

        uri = URI.parse('http://scoutapp.com/alerts/create')
        Net::HTTP.post_form(uri, data)

        self.info = "sent scout alert to plugin ##{plugin_id}"
      rescue = e
        applog(nil, :info, "failed to send scout alert to plugin ##{plugin_id}: #{e.message}")
        applog(nil, :debug, e.backtrace.join("\n"))
      end
    end

  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>twitter.rb</filename>
			<content># Send a notice to a Twitter account (http://twitter.com/).
#
# consumer_token  - The String OAuth consumer token (defaults to God's
#                   existing consumer token).
# consumer_secret - The String OAuth consumer secret (defaults to God's
#                   existing consumer secret).
# access_token    - The String OAuth access token.
# access_secret   - The String OAuth access secret.

CONTACT_DEPS[:twitter] = ['twitter']
CONTACT_DEPS[:twitter].each do |d|
  require d
end

module God
  module Contacts
    class Twitter  Contact
      class  self
        attr_accessor :consumer_token, :consumer_secret,
                      :access_token, :access_secret
      end

      self.consumer_token = 'gOhjax6s0L3mLeaTtBWPw'
      self.consumer_secret = 'yz4gpAVXJHKxvsGK85tEyzQJ7o2FEy27H1KEWL75jfA'

      def valid?
        valid = true
        valid &= complain("Attribute 'consumer_token' must be specified", self) unless arg(:consumer_token)
        valid &= complain("Attribute 'consumer_secret' must be specified", self) unless arg(:consumer_secret)
        valid &= complain("Attribute 'access_token' must be specified", self) unless arg(:access_token)
        valid &= complain("Attribute 'access_secret' must be specified", self) unless arg(:access_secret)
        valid
      end

      attr_accessor :consumer_token, :consumer_secret,
                    :access_token, :access_secret

      def notify(message, time, priority, category, host)
        oauth = ::Twitter::OAuth.new(arg(:consumer_token), arg(:consumer_secret))
        oauth.authorize_from_access(arg(:access_token), arg(:access_secret))

        ::Twitter::Base.new(oauth).update(message)

        self.info = "sent twitter update"
      rescue = e
        applog(nil, :info, "failed to send twitter update: #{e.message}")
        applog(nil, :debug, e.backtrace.join("\n"))
      end
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>webhook.rb</filename>
			<content># Send a notice to a webhook.
#
# url    - The String webhook URL.
# format - The Symbol format [ :form | :json ] (default: :form).

require 'net/http'
require 'uri'

CONTACT_DEPS[:webhook] = ['json']
CONTACT_DEPS[:webhook].each do |d|
  require d
end

module God
  module Contacts

    class Webhook  Contact
      class  self
        attr_accessor :url, :format
      end

      self.format = :form

      def valid?
        valid = true
        valid &= complain("Attribute 'url' must be specified", self) unless arg(:url)
        valid &= complain("Attribute 'format' must be one of [ :form | :json ]", self) unless [:form, :json].include?(arg(:format))
        valid
      end

      attr_accessor :url, :format

      def notify(message, time, priority, category, host)
        data = {
          :message = message,
          :time = time,
          :priority = priority,
          :category = category,
          :host = host
        }

        uri = URI.parse(arg(:url))
        http = Net::HTTP.new(uri.host, uri.port)
        http.use_ssl = true if uri.scheme == "https"

        req = nil
        res = nil

        case arg(:format)
          when :form
            req = Net::HTTP::Post.new(uri.request_uri)
            req.set_form_data(data)
          when :json
            req = Net::HTTP::Post.new(uri.request_uri)
            req.body = data.to_json
        end

        res = http.request(req)

        case res
          when Net::HTTPSuccess
            self.info = "sent webhook to #{arg(:url)}"
          else
            self.info = "failed to send webhook to #{arg(:url)}: #{res.error!}"
        end
      rescue Object = e
        applog(nil, :info, "failed to send webhook to #{arg(:url)}: #{e.message}")
        applog(nil, :debug, e.backtrace.join("\n"))
      end

    end

  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>dummy_handler.rb</filename>
			<content>module God
  class DummyHandler
    EVENT_SYSTEM = "none"

    def self.register_process(pid, events)
      raise NotImplementedError
    end

    def self.handle_events
      raise NotImplementedError
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>kqueue_handler.rb</filename>
			<content>require 'kqueue_handler_ext'

module God
  class KQueueHandler
    EVENT_SYSTEM = "kqueue"

    def self.register_process(pid, events)
      monitor_process(pid, events_mask(events))
    end

    def self.events_mask(events)
      events.inject(0) do |mask, event|
        mask |= event_mask(event)
      end
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>netlink_handler.rb</filename>
			<content>require 'netlink_handler_ext'

module God
  class NetlinkHandler
    EVENT_SYSTEM = "netlink"

    def self.register_process(pid, events)
      # netlink doesn't need to do this
      # it just reads from the eventhandler actions to see if the pid
      # matches the list we're looking for -- Kev
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>portable_poller.rb</filename>
			<content>module God
  module System
    class PortablePoller
      def initialize(pid)
        @pid = pid
      end
      # Memory usage in kilobytes (resident set size)
      def memory
        ps_int('rss')
      end

      # Percentage memory usage
      def percent_memory
        ps_float('%mem')
      end

      # Percentage CPU usage
      def percent_cpu
        ps_float('%cpu')
      end

      private

      def ps_int(keyword)
        `ps -o #{keyword}= -p #{@pid}`.to_i
      end

      def ps_float(keyword)
        `ps -o #{keyword}= -p #{@pid}`.to_f
      end

      def ps_string(keyword)
        `ps -o #{keyword}= -p #{@pid}`.strip
      end

      def time_string_to_seconds(text)
        _, minutes, seconds, useconds = *text.match(/(\d+):(\d{2}).(\d{2})/)
        (minutes.to_i * 60) + seconds.to_i
      end
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>process.rb</filename>
			<content>module God
  module System

    class Process
      def self.fetch_system_poller
        @@poller ||= if SlashProcPoller.usable?
		       SlashProcPoller
		     else
		       PortablePoller
		     end
      end

      def initialize(pid)
        @pid = pid.to_i
        @poller = self.class.fetch_system_poller.new(@pid)
      end

      # Return true if this process is running, false otherwise
      def exists?
        !!::Process.kill(0, @pid) rescue false
      end

      # Memory usage in kilobytes (resident set size)
      def memory
        @poller.memory
      end

      # Percentage memory usage
      def percent_memory
        @poller.percent_memory
      end

      # Percentage CPU usage
      def percent_cpu
        @poller.percent_cpu
      end

      private

      def fetch_system_poller
        if SlashProcPoller.usable?
          SlashProcPoller
        else
          PortablePoller
        end
      end
    end

  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>slash_proc_poller.rb</filename>
			<content>module God
  module System
    class SlashProcPoller  PortablePoller
      @@kb_per_page = 4 # TODO: Need to make this portable
      @@hertz = 100
      @@total_mem = nil

      MeminfoPath = '/proc/meminfo'
      UptimePath = '/proc/uptime'

      RequiredPaths = [MeminfoPath, UptimePath]

      # FreeBSD has /proc by default, but nothing mounted there!
      # So we should check for the actual required paths!
      # Returns true if +RequiredPaths+ are readable.
      def self.usable?
        RequiredPaths.all? do |path|
          test(?r, path) && readable?(path)
        end
      end

      def initialize(pid)
        super(pid)

        unless @@total_mem # in K
          File.open(MeminfoPath) do |f|
            @@total_mem = f.gets.split[1]
          end
        end
      end

      def memory
        stat[:rss].to_i * @@kb_per_page
      rescue # This shouldn't fail is there's an error (or proc doesn't exist)
        0
      end

      def percent_memory
        (memory / @@total_mem.to_f) * 100
      rescue # This shouldn't fail is there's an error (or proc doesn't exist)
        0
      end

      # TODO: Change this to calculate the wma instead
      def percent_cpu
        stats = stat
        total_time = stats[:utime].to_i + stats[:stime].to_i # in jiffies
        seconds = uptime - stats[:starttime].to_i / @@hertz
        if seconds == 0
          0
        else
          ((total_time * 1000 / @@hertz) / seconds) / 10
        end
      rescue # This shouldn't fail is there's an error (or proc doesn't exist)
        0
      end

      private

      # Some systems (CentOS?) have a /proc, but they can hang when trying to
      # read from them. Try to use this sparingly as it is expensive.
      def self.readable?(path)
        begin
          timeout(1) { File.read(path) }
        rescue Timeout::Error
          false
        end
      end

      # in seconds
      def uptime
        File.read(UptimePath).split[0].to_f
      end

      def stat
        stats = {}
        stats[:pid], stats[:comm], stats[:state], stats[:ppid], stats[:pgrp],
        stats[:session], stats[:tty_nr], stats[:tpgid], stats[:flags],
        stats[:minflt], stats[:cminflt], stats[:majflt], stats[:cmajflt],
        stats[:utime], stats[:stime], stats[:cutime], stats[:cstime],
        stats[:priority], stats[:nice], _, stats[:itrealvalue],
        stats[:starttime], stats[:vsize], stats[:rss], stats[:rlim],
        stats[:startcode], stats[:endcode], stats[:startstack], stats[:kstkesp],
        stats[:kstkeip], stats[:signal], stats[:blocked], stats[:sigignore],
        stats[:sigcatch], stats[:wchan], stats[:nswap], stats[:cnswap],
        stats[:exit_signal], stats[:processor], stats[:rt_priority],
        stats[:policy] = File.read("/proc/#{@pid}/stat").scan(/\(.*?\)|\w+/)
        stats
      end
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>CNAME</filename>
			<content>godrb.com
</content>
		</actual_file>
		<actual_file>
			<filename>index.template.html</filename>
			<content>!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
html xmlns="http://www.w3.org/1999/xhtml"
head
  meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /
  titleGod - A Process Monitoring Framework in Ruby/title
  link href="stylesheets/layout.css" rel="stylesheet" type="text/css" /
  link href="stylesheets/highlight.css" rel="stylesheet" type="text/css" /
  script type="text/javascript" src="javascripts/code_highlighter.js"/script
  script type="text/javascript" src="javascripts/ruby.js"/script
/head

body id="page_home"

div id="mothership"

/div
div id="content"
	div class="banner"

	/div

  !-- div id="menu"
    div class="dots"/div
    ul
      li class="menu_home"a href="/"Home/a/li
      li class="menu_contact"a href="mailto:tom@projectmothership.com"Contact/a/li
    /ul
    div class="dots"/div
  /div --

	div class="columnleft"
		h2A Better Way to Monitor/h1
		pGod is an easy to configure, easy to extend monitoring framework written in Ruby./p
		pKeeping your server processes and tasks running should be a simple part of your deployment process. God aims to be the simplest, most powerful monitoring application available./p
		p style="text-align: right"Tom Preston-Wernerbr /a href="mailto:tom@mojombo.com"tom@mojombo.com/a/p
		p style="text-align: right"Google Group: a href="http://groups.google.com/group/god-rb"http://groups.google.com/group/god-rb/a/p
	/div

	div class="columnright"
  	h2Features/h1
	  ul class="features"
		  liConfig file is written in Ruby/li
		  liEasily write your own custom conditions in Ruby/li
		  liSupports both poll and event based conditions/li
		  liDifferent poll conditions can have different intervals/li
		  liIntegrated notification system (write your own too!)/li
		  liEasily control non-daemonizing scripts/li
	  /ul
	/div

  div class="main"
    {{ content }}
  /div

/div

div id="footer"
	pBrought to you by a href="http://tom.preston-werner.com/"Tom Preston-Werner/a/p
/div

script src="http://www.google-analytics.com/urchin.js" type="text/javascript"
/script
script type="text/javascript"
_uacct = "UA-2196727-1";
urchinTracker();
/script

/body
/html
</content>
		</actual_file>
		<actual_file>
			<filename>install.html</filename>
			<content>ln -s /usr/src/linux-headers-2.6.15-28/include/linux/connector.h /usr/include/linux/connector.h
ln -s /usr/src/linux-headers-2.6.15-28/include/linux/cn_proc.h /usr/include/linux/cn_proc.h
</content>
		</actual_file>
		<actual_file>
			<filename>code_highlighter.js</filename>
			<content>/* Unobtrustive Code Highlighter By Dan Webb 11/2005
   Version: 0.4

	Usage:
		Add a script tag for this script and any stylesets you need to use
		to the page in question, add correct class names to CODE elements,
		define CSS styles for elements. That's it!

	Known to work on:
		IE 5.5+ PC
		Firefox/Mozilla PC/Mac
		Opera 7.23 + PC
		Safari 2

	Known to degrade gracefully on:
		IE5.0 PC

	Note: IE5.0 fails due to the use of lookahead in some stylesets.  To avoid script errors
	in older browsers use expressions that use lookahead in string format when defining stylesets.

	This script is inspired by star-light by entirely cunning Dean Edwards
	http://dean.edwards.name/star-light/.
*/

// replace callback support for safari.
if ("a".replace(/a/, function() {return "b"}) != "b") (function(){
  var default_replace = String.prototype.replace;
  String.prototype.replace = function(search,replace){
	// replace is not function
	if(typeof replace != "function"){
		return default_replace.apply(this,arguments)
	}
	var str = "" + this;
	var callback = replace;
	// search string is not RegExp
	if(!(search instanceof RegExp)){
		var idx = str.indexOf(search);
		return (
			idx == -1 ? str :
			default_replace.apply(str,[search,callback(search, idx, str)])
		)
	}
	var reg = search;
	var result = [];
	var lastidx = reg.lastIndex;
	var re;
	while((re = reg.exec(str)) != null){
		var idx  = re.index;
		var args = re.concat(idx, str);
		result.push(
			str.slice(lastidx,idx),
			callback.apply(null,args).toString()
		);
		if(!reg.global){
			lastidx += RegExp.lastMatch.length;
			break
		}else{
			lastidx = reg.lastIndex;
		}
	}
	result.push(str.slice(lastidx));
	return result.join("")
  }
})();

var CodeHighlighter = { styleSets : new Array };

CodeHighlighter.addStyle = function(name, rules) {
	// using push test to disallow older browsers from adding styleSets
	if ([].push) this.styleSets.push({
		name : name,
		rules : rules,
		ignoreCase : arguments[2] || false
	})

	function setEvent() {
		// set highlighter to run on load (use LowPro if present)
		if (typeof Event != 'undefined' && typeof Event.onReady == 'function')
		  return Event.onReady(CodeHighlighter.init.bind(CodeHighlighter));

		var old = window.onload;

		if (typeof window.onload != 'function') {
			window.onload = function() { CodeHighlighter.init() };
		} else {
			window.onload = function() {
				old();
				CodeHighlighter.init();
			}
		}
	}

	// only set the event when the first style is added
	if (this.styleSets.length==1) setEvent();
}

CodeHighlighter.init = function() {
	if (!document.getElementsByTagName) return;
	if ("a".replace(/a/, function() {return "b"}) != "b") return; // throw out Safari versions that don't support replace function
	// throw out older browsers

	var codeEls = document.getElementsByTagName("CODE");
	// collect array of all pre elements
	codeEls.filter = function(f) {
		var a =  new Array;
		for (var i = 0; i  this.length; i++) if (f(this[i])) a[a.length] = this[i];
		return a;
	}

	var rules = new Array;
	rules.toString = function() {
		// joins regexes into one big parallel regex
		var exps = new Array;
		for (var i = 0; i  this.length; i++) exps.push(this[i].exp);
		return exps.join("|");
	}

	function addRule(className, rule) {
		// add a replace rule
		var exp = (typeof rule.exp != "string")?String(rule.exp).substr(1, String(rule.exp).length-2):rule.exp;
		// converts regex rules to strings and chops of the slashes
		rules.push({
			className : className,
			exp : "(" + exp + ")",
			length : (exp.match(/(^|[^\\])\([^?]/g) || "").length + 1, // number of subexps in rule
			replacement : rule.replacement || null
		});
	}

	function parse(text, ignoreCase) {
		// main text parsing and replacement
		return text.replace(new RegExp(rules, (ignoreCase)?"gi":"g"), function() {
			var i = 0, j = 1, rule;
			while (rule = rules[i++]) {
				if (arguments[j]) {
					// if no custom replacement defined do the simple replacement
					if (!rule.replacement) return "span class=\"" + rule.className + "\"" + arguments[0] + "/span";
					else {
						// replace $0 with the className then do normal replaces
						var str = rule.replacement.replace("$0", rule.className);
						for (var k = 1; k = rule.length - 1; k++) str = str.replace("$" + k, arguments[j + k]);
						return str;
					}
				} else j+= rule.length;
			}
		});
	}

	function highlightCode(styleSet) {
		// clear rules array
		var parsed, clsRx = new RegExp("(\\s|^)" + styleSet.name + "(\\s|$)");
		rules.length = 0;

		// get stylable elements by filtering out all code elements without the correct className
		var stylableEls = codeEls.filter(function(item) { return clsRx.test(item.className) });

		// add style rules to parser
		for (var className in styleSet.rules) addRule(className, styleSet.rules[className]);


		// replace for all elements
		for (var i = 0; i  stylableEls.length; i++) {
			// EVIL hack to fix IE whitespace badness if it's inside a pre
			if (/MSIE/.test(navigator.appVersion) && stylableEls[i].parentNode.nodeName == 'PRE') {
				stylableEls[i] = stylableEls[i].parentNode;

				parsed = stylableEls[i].innerHTML.replace(/(code[^]*)([^]*)\/code/i, function() {
					return arguments[1] + parse(arguments[2], styleSet.ignoreCase) + "/code"
				});
				parsed = parsed.replace(/\n( *)/g, function() {
					var spaces = "";
					for (var i = 0; i  arguments[1].length; i++) spaces+= "&nbsp;";
					return "\n" + spaces;
				});
				parsed = parsed.replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;");
				parsed = parsed.replace(/\n(\/\w+)?/g, "br /$1").replace(/br \/[\n\r\s]*br \//g, "pbr/p");

			} else parsed = parse(stylableEls[i].innerHTML, styleSet.ignoreCase);

			stylableEls[i].innerHTML = parsed;
		}
	}

	// run highlighter on all stylesets
	for (var i=0; i  this.styleSets.length; i++) {
		highlightCode(this.styleSets[i]);
	}
}
</content>
		</actual_file>
		<actual_file>
			<filename>ruby.js</filename>
			<content>CodeHighlighter.addStyle("ruby",{
	comment : {
		exp  : /#[^\n]+/
	},
	brackets : {
		exp  : /\(|\)/
	},
	string : {
		exp  : /'[^']*'|"[^"]*"/
	},
	keywords : {
		exp  : /\b(do|end|self|class|def|if|module|yield|then|else|for|until|unless|while|elsif|case|when|break|retry|redo|rescue|require|raise)\b/
	},
	/* Added by Shelly Fisher (shelly@agileevolved.com) */
	symbol : {
	  exp : /([^:])(:[A-Za-z0-9_!?]+)/
	}
});
</content>
		</actual_file>
		<actual_file>
			<filename>highlight.css</filename>
			<content>.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold; } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kn { font-weight: bold } /* Keyword.Namespace */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */

.type-csharp .highlight .k { color: #0000FF }
.type-csharp .highlight .kt { color: #0000FF }
.type-csharp .highlight .nf { color: #000000; font-weight: normal }
.type-csharp .highlight .nc { color: #2B91AF }
.type-csharp .highlight .nn { color: #000000 }
.type-csharp .highlight .s { color: #A31515 }
.type-csharp .highlight .sc { color: #A31515 }
</content>
		</actual_file>
		<actual_file>
			<filename>layout.css</filename>
			<content>* {
	margin: 0;
	font-size: 100%;
}

body {
	font: normal .8em/1.5em "Trebuchet MS", Verdana, Arial, Helvetica, sans-serif;
	color: #484848;
	background: #E6EAE9 url(../images/bg_grey.gif);
}

a {
	color: #c75f3e;
	text-decoration: none;
}

a:hover,
a:active {
	text-decoration: underline;
}

#mothership {
	width: 307px;
	height: 117px;
	margin: 0 auto;
	background: url(../images/god_logo.png);
}

#content {
	width: 700px;
	margin: 3px auto;
	background: white;
	border: 1px solid #444;
	padding: 0 24px;
	background: #f8f8ff;
	overflow: hidden;
}

.banner {
	margin-top: 24px;
	border: 1px solid #ddd;
	width: 698px;
	height: 150px;
	background: url(../images/banner.jpg);
}

#menu {
	margin-top: 5px;
}

#menu div.dots {
	background: url(../images/red_dot.gif) repeat;
	height: 5px;
	width: 700px;
	font-size: 0;
}

#menu ul {
	font-family: "Trebuchet MS", Verdana, Arial, Helvetica, sans-serif;
	font-weight: bold;
	text-transform: uppercase;
	color: #4D4D4D;
	font-size: 12px;
	padding: 0;
	margin: 0;
	margin-top: 0 !important;
	margin-top: -2px;
}

#menu li {
	display: inline;
	margin: 0 30px 0 0;
}

#menu a:link,
#menu a:visited {
	color: #4D4D4D;
	text-decoration: none;
}

#menu a:hover,
#menu a:active {
	color: black;
	text-decoration: none;
}

#page_home #menu li.menu_home a {
	color: #A70000;
}

.columnleft {
	float: left;
	width: 345px;
	margin-bottom: 20px;
}

.columnleft p {
		text-align: justify;
}

.columnright {
	float: right;
	width: 325px;
	margin-bottom: 20px;
}

.main {
  clear: both;
}

h2 {
	font: bold 1.5em "Trebuchet MS", Verdana, Arial, Helvetica, sans-serif;
	color: #f36e21;
	text-transform: uppercase;
	margin: 1.5em 0 .5em 0;
}

h3 {
	font: bold 1.25em "Trebuchet MS", Verdana, Arial, Helvetica, sans-serif;
	color: #f36e21;
	margin: 1.5em 0 .5em 0;
}

p {
	margin-bottom: 1em;
}

ul {
  margin-bottom: 1em;
}

ul.features {
	padding: 0;
	margin-left: 1.5em !important;
	margin-left: 1.3em;
}

ul.features li {
	list-style-position: outside;
	list-style-type: circle;
	list-style-image: url(../images/bullet.jpg);
	line-height: 1.4em;
}

#footer {
	text-align: center;
	color: white;
	margin-bottom: 50px;
}



pre {
  line-height: 1.3;
  border: 1px solid #ccc;
  padding: 1em;
  background-color: #efefef;
  margin: 1em 0;
  font-size: 1.2em;
}

tt {
  font-size: 1.2em;
}
</content>
		</actual_file>
		<actual_file>
			<filename>helper.rb</filename>
			<content>$:.unshift File.expand_path('../../lib', __FILE__) # For use/testing when no gem is installed

# Use this flag to actually load all of the god infrastructure
$load_god = true

require File.join(File.dirname(__FILE__), *%w[.. lib god sys_logger])
require File.join(File.dirname(__FILE__), *%w[.. lib god])
God::EventHandler.load

require 'test/unit'
require 'set'

include God

if Process.uid != 0 and RbConfig::CONFIG['host_os'] == "linux"
  abort -EOF
\n
*********************************************************************
*                                                                   *
*               You need to run these tests as root                 *
*           chroot and netlink (linux only) require it              *
*                                                                   *
*********************************************************************
EOF
end

begin
  require 'mocha/setup'
rescue LoadError
  unless gems ||= false
    require 'rubygems'
    gems = true
    retry
  else
    abort "= You need the Mocha gem to run these tests."
  end
end

module God
  module Conditions
    class FakeCondition  Condition
      def test
        true
      end
    end

    class FakePollCondition  PollCondition
      def test
        true
      end
    end

    class FakeEventCondition  EventCondition
      def register
      end
      def deregister
      end
    end
  end

  module Behaviors
    class FakeBehavior  Behavior
      def before_start
        'foo'
      end
      def after_start
        'bar'
      end
    end
  end

  module Contacts
    class FakeContact  Contact
    end

    class InvalidContact
    end
  end

  def self.reset
    self.watches = nil
    self.groups = nil
    self.server = nil
    self.inited = nil
    self.host = nil
    self.port = nil
    self.pid_file_directory = nil
    self.registry.reset
  end
end

def silence_warnings
  old_verbose, $VERBOSE = $VERBOSE, nil
  yield
ensure
  $VERBOSE = old_verbose
end

LOG.instance_variable_set(:@io, StringIO.new())

def output_logs
  io = LOG.instance_variable_get(:@io)
  LOG.instance_variable_set(:@io, $stderr)
  yield
ensure
  LOG.instance_variable_set(:@io, io)
end

# module Kernel
#   def abort(text)
#     raise SystemExit, text
#   end
#   def exit(code)
#     raise SystemExit, "Exit code: #{code}"
#   end
# end

module Test::Unit::Assertions
  def assert_abort
    assert_raise SystemExit do
      yield
    end
  end
end

# This allows you to be a good OOP citizen and honor encapsulation, but
# still make calls to private methods (for testing) by doing
#
#   obj.bypass.private_thingie(arg1, arg2)
#
# Which is easier on the eye than
#
#   obj.send(:private_thingie, arg1, arg2)
#
class Object
  class Bypass
    instance_methods.each do |m|
      undef_method m unless m =~ /^(__|object_id)/
    end

    def initialize(ref)
      @ref = ref
    end

    def method_missing(sym, *args)
      @ref.__send__(sym, *args)
    end
  end

  def bypass
    Bypass.new(self)
  end
end

# Make sure we return valid exit codes
if defined?(RUBY_ENGINE) && RUBY_ENGINE == "ruby" && RUBY_VERSION = "1.9"
  module Kernel
    alias :__at_exit :at_exit
    def at_exit(&block)
      __at_exit do
        exit_status = $!.status if $!.is_a?(SystemExit)
        block.call
        exit exit_status if exit_status
      end
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>suite.rb</filename>
			<content>require 'test/unit'

tests = Dir["#{File.dirname(__FILE__)}/test_*.rb"]
tests.each do |file|
  require file
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_airbrake.rb</filename>
			<content>#!/usr/bin/env ruby
require File.dirname(__FILE__) + '/helper'

class TestAirbrake  Test::Unit::TestCase
  def test_notify
    airbrake = God::Contacts::Airbrake.new
    airbrake.apikey = "put_your_apikey_here"
    airbrake.name = "Airbrake"

    Airbrake.expects(:notify).returns "123"

    airbrake.notify("Test message for airbrake", Time.now, "airbrake priority", "airbrake category", "")
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_behavior.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestBehavior  Test::Unit::TestCase
  def test_generate_should_return_an_object_corresponding_to_the_given_type
    assert_equal Behaviors::FakeBehavior, Behavior.generate(:fake_behavior, nil).class
  end

  def test_generate_should_raise_on_invalid_type
    assert_raise NoSuchBehaviorError do
      Behavior.generate(:foo, nil)
    end
  end

  def test_complain
    SysLogger.expects(:log).with(:error, 'foo')
    assert !Behavior.allocate.bypass.complain('foo')
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_campfire.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestCampfire  Test::Unit::TestCase
  def setup
    @campfire = God::Contacts::Campfire.new
  end

  def test_exists
    God::Contacts::Campfire
  end

  def test_notify
    @campfire.subdomain = 'github'
    @campfire.token = 'abc'
    @campfire.room = 'danger'

    time = Time.now
    body = "[#{time.strftime('%H:%M:%S')}] host - msg"
    Marshmallow::Connection.any_instance.expects(:speak).with('danger', body)
    @campfire.notify('msg', time, 'prio', 'cat', 'host')
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_condition.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class BadlyImplementedCondition  PollCondition
end

class TestCondition  Test::Unit::TestCase

  # generate

  def test_generate_should_return_an_object_corresponding_to_the_given_type
    assert_equal Conditions::ProcessRunning, Condition.generate(:process_running, nil).class
  end

  def test_generate_should_raise_on_invalid_type
    assert_raise NoSuchConditionError do
      Condition.generate(:foo, nil)
    end
  end

  def test_generate_should_abort_on_event_condition_without_loaded_event_system
    God::EventHandler.stubs(:operational?).returns(false)
    assert_abort do
      God::EventHandler.start
      Condition.generate(:process_exits, nil).class
    end
  ensure
    God::EventHandler.stop
  end

  def test_generate_should_return_a_good_error_message_for_invalid_types
    emsg = "No Condition found with the class name God::Conditions::FooBar"
    rmsg = nil

    begin
      Condition.generate(:foo_bar, nil)
    rescue = e
      rmsg = e.message
    end

    assert_equal emsg, rmsg
  end

  # test

  def test_test_should_raise_if_not_defined_in_subclass
    c = BadlyImplementedCondition.new

    assert_raise AbstractMethodNotOverriddenError do
      c.test
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_conditions_disk_usage.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestConditionsDiskUsage  Test::Unit::TestCase
  # valid?

  def test_valid_should_return_false_if_no_above_given
    c = Conditions::DiskUsage.new
    c.mount_point = '/'
    c.watch = stub(:name = 'foo')
    assert_equal false, c.valid?
  end

  def test_valid_should_return_false_if_no_mount_point_given
    c = Conditions::DiskUsage.new
    c.above = 90
    c.watch = stub(:name = 'foo')
    assert_equal false, c.valid?
  end

  def test_valid_should_return_true_if_required_options_all_set
    c = Conditions::DiskUsage.new
    c.above = 90
    c.mount_point = '/'
    c.watch = stub(:name = 'foo')

    assert_equal true, c.valid?
  end

  # test

  def test_test_should_return_true_if_above_limit
    c = Conditions::DiskUsage.new
    c.above = 90
    c.mount_point = '/'

    c.expects(:`).returns('91')

    assert_equal true, c.test
  end

  def test_test_should_return_false_if_below_limit
    c = Conditions::DiskUsage.new
    c.above = 90
    c.mount_point = '/'

    c.expects(:`).returns('90')

    assert_equal false, c.test
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_conditions_http_response_code.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestHttpResponseCode  Test::Unit::TestCase
  def valid_condition
    c = Conditions::HttpResponseCode.new()
    c.watch = stub(:name = 'foo')
    c.host = 'localhost'
    c.port = 8080
    c.path = '/'
    c.timeout = 10
    c.code_is = 200
    c.times = 1
    yield(c) if block_given?
    c.prepare
    c
  end

  # valid?

  def test_valid_condition_is_valid
    c = valid_condition
    assert c.valid?
  end

  def test_valid_should_return_false_if_both_code_is_and_code_is_not_are_set
    c = valid_condition do |cc|
      cc.code_is_not = 500
    end
    assert !c.valid?
  end

  def test_valid_should_return_false_if_no_host_set
    c = valid_condition do |cc|
      cc.host = nil
    end
    assert !c.valid?
  end

  # test

  def test_test_should_return_false_if_code_is_is_set_to_200_but_response_is_500
    c = valid_condition
    Net::HTTP.any_instance.expects(:start).yields(mock(:read_timeout= = nil, :get = mock(:code = 500)))
    assert_equal false, c.test
  end

  def test_test_should_return_false_if_code_is_not_is_set_to_200_and_response_is_200
    c = valid_condition do |cc|
      cc.code_is = nil
      cc.code_is_not = [200]
    end
    Net::HTTP.any_instance.expects(:start).yields(mock(:read_timeout= = nil, :get = mock(:code = 200)))
    assert_equal false, c.test
  end

  def test_test_should_return_true_if_code_is_is_set_to_200_and_response_is_200
    c = valid_condition
    Net::HTTP.any_instance.expects(:start).yields(mock(:read_timeout= = nil, :get = mock(:code = 200)))
    assert_equal true, c.test
  end

  def test_test_should_return_false_if_code_is_not_is_set_to_200_but_response_is_500
    c = valid_condition do |cc|
      cc.code_is = nil
      cc.code_is_not = [200]
    end
    Net::HTTP.any_instance.expects(:start).yields(mock(:read_timeout= = nil, :get = mock(:code = 500)))
    assert_equal true, c.test
  end

  def test_test_should_return_false_if_code_is_is_set_to_200_but_response_times_out
    c = valid_condition
    Net::HTTP.any_instance.expects(:start).raises(Timeout::Error, '')
    assert_equal false, c.test
  end

  def test_test_should_return_true_if_code_is_not_is_set_to_200_and_response_times_out
    c = valid_condition do |cc|
      cc.code_is = nil
      cc.code_is_not = [200]
    end
    Net::HTTP.any_instance.expects(:start).raises(Timeout::Error, '')
    assert_equal true, c.test
  end

  def test_test_should_return_false_if_code_is_is_set_to_200_but_cant_connect
    c = valid_condition
    Net::HTTP.any_instance.expects(:start).raises(Errno::ECONNREFUSED, '')
    assert_equal false, c.test
  end

  def test_test_should_return_true_if_code_is_not_is_set_to_200_and_cant_connect
    c = valid_condition do |cc|
      cc.code_is = nil
      cc.code_is_not = [200]
    end
    Net::HTTP.any_instance.expects(:start).raises(Errno::ECONNREFUSED, '')
    assert_equal true, c.test
  end

  def test_test_should_return_true_if_code_is_is_set_to_200_and_response_is_200_twice_for_times_two_of_two
    c = valid_condition do |cc|
      cc.times = [2, 2]
    end
    Net::HTTP.any_instance.expects(:start).yields(stub(:read_timeout= = nil, :get = stub(:code = 200))).times(2)
    assert_equal false, c.test
    assert_equal true, c.test
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_conditions_process_running.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestConditionsProcessRunning  Test::Unit::TestCase
  def test_missing_pid_file_returns_opposite
    [true, false].each do |r|
      c = Conditions::ProcessRunning.new
      c.running = r
      c.stubs(:watch).returns(stub(:pid = 99999999, :name = 'foo'))
      assert_equal !r, c.test
    end
  end

  def test_not_running_returns_opposite
    [true, false].each do |r|
      c = Conditions::ProcessRunning.new
      c.running = r

      File.stubs(:exist?).returns(true)
      c.stubs(:watch).returns(stub(:pid = 123))
      File.stubs(:read).returns('5')
      System::Process.any_instance.stubs(:exists?).returns(false)

      assert_equal !r, c.test
    end
  end

  def test_running_returns_same
    [true, false].each do |r|
      c = Conditions::ProcessRunning.new
      c.running = r

      File.stubs(:exist?).returns(true)
      c.stubs(:watch).returns(stub(:pid = 123))
      File.stubs(:read).returns('5')
      System::Process.any_instance.stubs(:exists?).returns(true)

      assert_equal r, c.test
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_conditions_socket_responding.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestConditionsSocketResponding  Test::Unit::TestCase
  # valid?

  def test_valid_should_return_false_if_no_options_set
    c = Conditions::SocketResponding.new
    c.watch = stub(:name = 'foo')
    assert_equal false, c.valid?

  end

  def test_valid_should_return_true_if_required_options_set_for_default
    c = Conditions::SocketResponding.new
    c.port = 443
    assert_equal true, c.valid?
  end

  def test_valid_should_return_true_if_required_options_set_for_tcp
    c = Conditions::SocketResponding.new
    c.family = 'tcp'
    c.port = 443
    assert_equal true, c.valid?
  end

  def test_valid_should_return_true_if_required_options_set_for_unix
    c = Conditions::SocketResponding.new
    c.path = 'some-path'
    c.family = 'unix'
    assert_equal true, c.valid?
  end

  def test_valid_should_return_true_if_family_is_tcp
    c = Conditions::SocketResponding.new
    c.port = 443
    c.family = 'tcp'
    assert_equal true, c.valid?
  end

  def test_valid_should_return_true_if_family_is_unix
    c = Conditions::SocketResponding.new
    c.path = 'some-path'
    c.family = 'unix'
    c.watch = stub(:name = 'foo')
    assert_equal true, c.valid?
  end

  # socket method
  def test_socket_should_return_127_0_0_1_for_default_addr
    c = Conditions::SocketResponding.new
    c.socket = 'tcp:443'
    assert_equal c.addr, '127.0.0.1'
  end

  def test_socket_should_set_properties_for_tcp
    c = Conditions::SocketResponding.new
    c.socket = 'tcp:127.0.0.1:443'
    assert_equal c.family, 'tcp'
    assert_equal c.addr, '127.0.0.1'
    assert_equal c.port, 443
    assert_equal c.responding, false
    # path should not be set for tcp sockets
    assert_equal c.path, nil
  end

  def test_socket_should_set_properties_for_unix
    c = Conditions::SocketResponding.new
    c.socket = 'unix:/tmp/process.sock'
    assert_equal c.family, 'unix'
    assert_equal c.path, '/tmp/process.sock'
    assert_equal c.responding, false
    # path should not be set for unix domain sockets
    assert_equal c.port, 0
  end

  # test : responding = false

  def test_test_tcp_should_return_false_if_socket_is_listening
    c = Conditions::SocketResponding.new
    c.prepare

    TCPSocket.expects(:new).returns(0)
    assert_equal false, c.test
  end

  def test_test_tcp_should_return_true_if_no_socket_is_listening
    c = Conditions::SocketResponding.new
    c.prepare

    TCPSocket.expects(:new).returns(nil)
    assert_equal true, c.test
  end

  def test_test_unix_should_return_false_if_socket_is_listening
    c = Conditions::SocketResponding.new
    c.socket = 'unix:/some/path'

    c.prepare
    UNIXSocket.expects(:new).returns(0)
    assert_equal false, c.test
  end

  def test_test_unix_should_return_true_if_no_socket_is_listening

    c = Conditions::SocketResponding.new
    c.socket = 'unix:/some/path'
    c.prepare

    UNIXSocket.expects(:new).returns(nil)
    assert_equal true, c.test
  end

  def test_test_unix_should_return_true_if_socket_is_listening_2_times

    c = Conditions::SocketResponding.new
    c.socket = 'unix:/some/path'
    c.times = [2, 2]
    c.prepare

    UNIXSocket.expects(:new).returns(nil).times(2)
    assert_equal false, c.test
    assert_equal true, c.test
  end

  # test : responding = true

  def test_test_tcp_should_return_true_if_socket_is_listening_with_responding_true
    c = Conditions::SocketResponding.new
    c.responding = true
    c.prepare

    TCPSocket.expects(:new).returns(0)
    assert_equal true, c.test
  end

  def test_test_tcp_should_return_false_if_no_socket_is_listening_with_responding_true
    c = Conditions::SocketResponding.new
    c.responding = true
    c.prepare

    TCPSocket.expects(:new).returns(nil)
    assert_equal false, c.test
  end

  def test_test_unix_should_return_true_if_socket_is_listening_with_responding_true
    c = Conditions::SocketResponding.new
    c.responding = true
    c.socket = 'unix:/some/path'

    c.prepare
    UNIXSocket.expects(:new).returns(0)
    assert_equal true, c.test
  end

  def test_test_unix_should_return_false_if_no_socket_is_listening_with_responding_true
    c = Conditions::SocketResponding.new
    c.socket = 'unix:/some/path'
    c.responding = true
    c.prepare

    UNIXSocket.expects(:new).returns(nil)
    assert_equal false, c.test
  end

  def test_test_unix_should_return_false_if_socket_is_listening_2_times_with_responding_true
    c = Conditions::SocketResponding.new
    c.socket = 'unix:/some/path'
    c.responding = true
    c.times = [2, 2]
    c.prepare

    UNIXSocket.expects(:new).returns(nil).times(2)
    assert_equal false, c.test
    assert_equal false, c.test
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_conditions_tries.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestConditionsTries  Test::Unit::TestCase
  # valid?

  def test_valid_should_return_false_if_times_not_set
    c = Conditions::Tries.new
    c.watch = stub(:name = 'foo')
    assert !c.valid?
  end
end


class TestConditionsTries  Test::Unit::TestCase
  def setup
    @c = Conditions::Tries.new
    @c.times = 3
    @c.prepare
  end

  # prepare

  def test_prepare_should_create_timeline
    assert_equal 3, @c.instance_variable_get(:@timeline).instance_variable_get(:@max_size)
  end

  # test

  def test_test_should_return_true_if_called_three_times_within_one_second
    assert !@c.test
    assert !@c.test
    assert @c.test
  end

  # reset

  def test_test_should_return_false_on_fourth_call_if_called_three_times_within_one_second
    3.times { @c.test }
    @c.reset
    assert !@c.test
  end
end


class TestConditionsTriesWithin  Test::Unit::TestCase
  def setup
    @c = Conditions::Tries.new
    @c.times = 3
    @c.within = 1.seconds
    @c.prepare
  end

  # test

  def test_test_should_return_true_if_called_three_times_within_one_second
    assert !@c.test
    assert !@c.test
    assert @c.test
  end

  def test_test_should_return_false_if_called_three_times_within_two_seconds
    assert !@c.test
    assert !@c.test
    assert sleep(1.1)
    assert !@c.test
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_contact.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestContact  Test::Unit::TestCase
  def test_exists
    God::Contact
  end

  # generate

  def test_generate_should_raise_on_invalid_kind
    assert_raise(NoSuchContactError) do
      Contact.generate(:invalid)
    end
  end

  def test_generate_should_abort_on_invalid_contact
    assert_abort do
      Contact.generate(:invalid_contact)
    end
  end

  # normalize

  def test_normalize_should_accept_a_string
    input = 'tom'
    output = {:contacts = ['tom']}
    assert_equal(output, Contact.normalize(input))
  end

  def test_normalize_should_accept_an_array_of_strings
    input = ['tom', 'kevin']
    output = {:contacts = ['tom', 'kevin']}
    assert_equal(output, Contact.normalize(input))
  end

  def test_normalize_should_accept_a_hash_with_contacts_string
    input = {:contacts = 'tom'}
    output = {:contacts = ['tom']}
    assert_equal(output, Contact.normalize(input))
  end

  def test_normalize_should_accept_a_hash_with_contacts_array_of_strings
    input = {:contacts = ['tom', 'kevin']}
    output = {:contacts = ['tom', 'kevin']}
    assert_equal(output, Contact.normalize(input))
  end

  def test_normalize_should_stringify_priority
    input = {:contacts = 'tom', :priority = 1}
    output = {:contacts = ['tom'], :priority = '1'}
    assert_equal(output, Contact.normalize(input))
  end

  def test_normalize_should_stringify_category
    input = {:contacts = 'tom', :category = :product}
    output = {:contacts = ['tom'], :category = 'product'}
    assert_equal(output, Contact.normalize(input))
  end

  def test_normalize_should_raise_on_non_string_array_hash
    input = 1
    assert_raise ArgumentError do
      Contact.normalize(input)
    end
  end

  def test_normalize_should_raise_on_non_string_array_contacts_key
    input = {:contacts = 1}
    assert_raise ArgumentError do
      Contact.normalize(input)
    end
  end

  def test_normalize_should_raise_on_non_string_containing_array
    input = [1]
    assert_raise ArgumentError do
      Contact.normalize(input)
    end
  end

  def test_normalize_should_raise_on_non_string_containing_array_contacts_key
    input = {:contacts = [1]}
    assert_raise ArgumentError do
      Contact.normalize(input)
    end
  end

  def test_normalize_should_raise_on_absent_contacts_key
    input = {}
    assert_raise ArgumentError do
      Contact.normalize(input)
    end
  end

  def test_normalize_should_raise_on_extra_keys
    input = {:contacts = ['tom'], :priority = 1, :category = 'product', :extra = 'foo'}
    assert_raise ArgumentError do
      Contact.normalize(input)
    end
  end

  # notify

  def test_notify_should_be_abstract
    assert_raise(AbstractMethodNotOverriddenError) do
      Contact.new.notify(:a, :b, :c, :d, :e)
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_driver.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestDriver  Test::Unit::TestCase
  def setup

  end

  def test_push_pop_wait
    eq = God::DriverEventQueue.new

    MonitorMixin::ConditionVariable.any_instance.expects(:wait).times(1)

    eq.push(God::TimedEvent.new(0))
    eq.push(God::TimedEvent.new(0.1))
    t = Thread.new do
      # This pop will see an event immediately available, so no wait.
      assert_equal TimedEvent, eq.pop.class

      # This pop will happen before the next event is due, so wait.
      assert_equal TimedEvent, eq.pop.class
    end

    t.join
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_email.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestEmail  Test::Unit::TestCase
  def setup
    God::Contacts::Email.to_email = 'dev@example.com'
    God::Contacts::Email.from_email = 'god@example.com'
    @email = God::Contacts::Email.new
  end

  def test_validity_delivery
    @email.delivery_method = :brainwaves
    assert_equal false, @email.valid?
  end

  def test_smtp_delivery_method_for_notify
    @email.delivery_method = :smtp

    God::Contacts::Email.any_instance.expects(:notify_sendmail).never
    God::Contacts::Email.any_instance.expects(:notify_smtp).once.returns(nil)

    @email.notify('msg', Time.now, 'prio', 'cat', 'host')
    assert_equal "sent email to dev@example.com via smtp", @email.info
  end

  def test_sendmail_delivery_method_for_notify
    @email.delivery_method = :sendmail

    God::Contacts::Email.any_instance.expects(:notify_smtp).never
    God::Contacts::Email.any_instance.expects(:notify_sendmail).once.returns(nil)

    @email.notify('msg', Time.now, 'prio', 'cat', 'host')
    assert_equal "sent email to dev@example.com via sendmail", @email.info
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_event_handler.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

module God
  class EventHandler

    def self.actions=(value)
      @@actions = value
    end

    def self.actions
      @@actions
    end

    def self.handler=(value)
      @@handler = value
    end
  end
end

class TestEventHandler  Test::Unit::TestCase
  def setup
    @h = God::EventHandler
  end

  def test_register_one_event
    pid = 4445
    event = :proc_exit
    block = lambda {
      puts "Hi"
    }

    mock_handler = mock()
    mock_handler.expects(:register_process).with(pid, [event])
    @h.handler = mock_handler

    @h.register(pid, event, &block)
    assert_equal @h.actions, {pid = {event = block}}
  end

  def test_register_multiple_events_per_process
    pid = 4445
    exit_block = lambda { puts "Hi" }
    @h.actions = {pid = {:proc_exit = exit_block}}

    mock_handler = mock()
    mock_handler.expects(:register_process).with do |a, b|
      a == pid &&
      b.to_set == [:proc_exit, :proc_fork].to_set
    end
    @h.handler = mock_handler

    fork_block = lambda { puts "Forking" }
    @h.register(pid, :proc_fork, &fork_block)
    assert_equal @h.actions, {pid = {:proc_exit = exit_block,
                                     :proc_fork = fork_block }}
  end

  # JIRA PLATFORM-75
  def test_call_should_check_for_pid_and_action_before_executing
    exit_block = mock()
    exit_block.expects(:call).times 1
    @h.actions = {4445 = {:proc_exit = exit_block}}
    @h.call(4446, :proc_exit) # shouldn't call, bad pid
    @h.call(4445, :proc_fork) # shouldn't call, bad event
    @h.call(4445, :proc_exit) # should call
  end

  def teardown
    # Reset handler
    @h.actions = {}
    @h.load
  end
end

# This doesn't currently work:
#
# class TestEventHandlerOperational  Test::Unit::TestCase
#   def test_operational
#     God::EventHandler.start
#     assert God::EventHandler.loaded?
#   end
# end
</content>
		</actual_file>
		<actual_file>
			<filename>test_god.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestGod  Test::Unit::TestCase
  def setup
    God::Socket.stubs(:new).returns(true)
    God.stubs(:setup).returns(true)
    God.stubs(:validater).returns(true)
    God.reset
    God.pid_file_directory = '/var/run/god'
  end

  def teardown
    God.main && God.main.kill
    if God.watches
      God.watches.each do |k, w|
        w.driver.thread.kill
      end
    end
  end

  # applog

  def test_applog
    LOG.expects(:log).with(nil, :debug, 'foo')
    applog(nil, :debug, 'foo')
  end

  # internal_init

  def test_init_should_initialize_watches_to_empty_array
    God.internal_init { }
    assert_equal Hash.new, God.watches
  end

  # init

  def test_pid_file_directory_should_abort_if_called_after_watch
    God.watch { |w| w.name = 'foo'; w.start = 'bar' }

    assert_abort do
      God.pid_file_directory = 'foo'
    end
  end

  # pid_file_directory

  def test_pid_file_directory_should_return_default_if_not_set_explicitly
    God.internal_init
    assert_equal '/var/run/god', God.pid_file_directory
  end

  def test_pid_file_directory_equals_should_set
    God.pid_file_directory = '/foo'
    God.internal_init
    assert_equal '/foo', God.pid_file_directory
  end

  # watch

  def test_watch_should_get_stored
    watch = nil
    God.watch do |w|
      w.name = 'foo'
      w.start = 'bar'
      watch = w
    end

    assert_equal 1, God.watches.size
    assert_equal watch, God.watches.values.first

    assert_equal 0, God.groups.size
  end

  def test_watch_should_get_stored_in_pending_watches
    watch = nil
    God.watch do |w|
      w.name = 'foo'
      w.start = 'bar'
      watch = w
    end

    assert_equal 1, God.pending_watches.size
    assert_equal watch, God.pending_watches.first
  end

  def test_watch_should_register_processes
    assert_nil God.registry['foo']
    God.watch do |w|
      w.name = 'foo'
      w.start = 'bar'
    end
    assert_kind_of God::Process, God.registry['foo']
  end

  def test_watch_should_get_stored_by_group
    a = nil

    God.watch do |w|
      a = w
      w.name = 'foo'
      w.start = 'bar'
      w.group = 'test'
    end

    assert_equal({'test' = [a]}, God.groups)
  end

  def test_watches_should_get_stored_by_group
    a = nil
    b = nil

    God.watch do |w|
      a = w
      w.name = 'foo'
      w.start = 'bar'
      w.group = 'test'
    end

    God.watch do |w|
      b = w
      w.name = 'bar'
      w.start = 'baz'
      w.group = 'test'
    end

    assert_equal({'test' = [a, b]}, God.groups)
  end

  def test_watch_should_allow_multiple_watches
    God.watch { |w| w.name = 'foo'; w.start = 'bar' }

    assert_nothing_raised do
      God.watch { |w| w.name = 'bar'; w.start = 'bar' }
    end
  end

  def test_watch_should_disallow_duplicate_watch_names
    God.watch { |w| w.name = 'foo'; w.start = 'bar' }

    assert_abort do
      God.watch { |w| w.name = 'foo'; w.start = 'bar' }
    end
  end

  def test_watch_should_disallow_identical_watch_and_group_names
    God.watch { |w| w.name = 'foo'; w.group = 'bar'; w.start = 'bar' }

    assert_abort do
      God.watch { |w| w.name = 'bar'; w.start = 'bar' }
    end
  end

  def test_watch_should_disallow_identical_watch_and_group_names_other_way
    God.watch { |w| w.name = 'bar'; w.start = 'bar' }

    assert_abort do
      God.watch { |w| w.name = 'foo'; w.group = 'bar'; w.start = 'bar' }
    end
  end

  def test_watch_should_unwatch_new_watch_if_running_and_duplicate_watch
    God.watch { |w| w.name = 'foo'; w.start = 'bar' }
    God.running = true

    assert_nothing_raised do
      God.watch { |w| w.name = 'foo'; w.start = 'bar' }
    end
  end

  # unwatch

  def test_unwatch_should_unmonitor_watch
    God.watch { |w| w.name = 'bar'; w.start = 'bar' }
    w = God.watches['bar']
    w.state = :up
    w.expects(:unmonitor)
    God.unwatch(w)
  end

  def test_unwatch_should_unregister_watch
    God.watch { |w| w.name = 'bar'; w.start = 'bar' }
    w = God.watches['bar']
    w.expects(:unregister!)
    God.unwatch(w)
  end

  def test_unwatch_should_remove_same_name_watches
    God.watch { |w| w.name = 'bar'; w.start = 'bar' }
    w = God.watches['bar']
    God.unwatch(w)
    assert_equal 0, God.watches.size
  end

  def test_unwatch_should_remove_from_group
    God.watch do |w|
      w.name = 'bar'
      w.start = 'baz'
      w.group = 'test'
    end
    w = God.watches['bar']
    God.unwatch(w)
    assert !God.groups[w.group].include?(w)
  end

  # contact

  def test_contact_should_ensure_init_is_called
    God.contact(:fake_contact) { |c| c.name = 'tom' }
    assert God.inited
  end

  def test_contact_should_abort_on_invalid_contact_kind
    assert_abort do
      God.contact(:foo) { |c| c.name = 'tom' }
    end
  end

  def test_contact_should_create_and_store_contact
    contact = nil
    God.contact(:fake_contact) { |c| c.name = 'tom'; contact = c }
    assert_equal({"tom" = contact}, God.contacts)
  end

  def test_contact_should_add_to_group
    God.contact(:fake_contact) { |c| c.name = 'tom'; c.group = 'devs' }
    God.contact(:fake_contact) { |c| c.name = 'chris'; c.group = 'devs' }
    assert_equal 2, God.contacts.size
    assert_equal 1, God.contact_groups.size
  end

  def test_contact_should_abort_on_no_name
    assert_abort do
      God.contact(:fake_contact) { |c| }
    end
  end

  def test_contact_should_abort_on_duplicate_contact_name
    God.contact(:fake_contact) { |c| c.name = 'tom' }
    assert_nothing_raised do
      God.contact(:fake_contact) { |c| c.name = 'tom' }
    end
  end

  def test_contact_should_abort_on_contact_with_same_name_as_group
    God.contact(:fake_contact) { |c| c.name = 'tom'; c.group = 'devs' }
    assert_nothing_raised do
      God.contact(:fake_contact) { |c| c.name = 'devs' }
    end
  end

  def test_contact_should_abort_on_contact_with_same_group_as_name
    God.contact(:fake_contact) { |c| c.name = 'tom' }
    assert_abort do
      God.contact(:fake_contact) { |c| c.name = 'chris'; c.group = 'tom' }
    end
  end

  def test_contact_should_abort_if_contact_is_invalid
    assert_abort do
      God.contact(:fake_contact) do |c|
        c.name = 'tom'
        c.stubs(:valid?).returns(false)
      end
    end
  end

  # control

  def test_control_should_monitor_on_start
    God.watch { |w| w.name = 'foo'; w.start = 'bar' }

    w = God.watches['foo']
    w.expects(:monitor)
    God.control('foo', 'start')
  end

  def test_control_should_move_to_restart_on_restart
    God.watch { |w| w.name = 'foo'; w.start = 'bar' }

    w = God.watches['foo']
    w.expects(:move).with(:restart)
    God.control('foo', 'restart')
  end

  def test_control_should_unmonitor_and_stop_on_stop
    God.watch { |w| w.name = 'foo'; w.start = 'bar' }

    w = God.watches['foo']
    w.state = :up
    w.expects(:unmonitor).returns(w)
    w.expects(:action).with(:stop)
    God.control('foo', 'stop')
  end

  def test_control_should_unmonitor_on_unmonitor
    God.watch { |w| w.name = 'foo'; w.start = 'bar' }

    w = God.watches['foo']
    w.state = :up
    w.expects(:unmonitor).returns(w)
    God.control('foo', 'unmonitor')
  end

  def test_control_should_unwatch_on_remove
    God.watch { |w| w.name = 'foo'; w.start = 'bar' }

    w = God.watches['foo']
    w.state = :up
    God.expects(:unwatch)
    God.control('foo', 'remove')
  end

  def test_control_should_raise_on_invalid_command
    God.watch { |w| w.name = 'foo'; w.start = 'bar' }

    assert_raise InvalidCommandError do
      God.control('foo', 'invalid')
    end
  end

  def test_control_should_operate_on_each_watch_in_group
    God.watch do |w|
      w.name = 'foo1'
      w.start = 'go'
      w.group = 'bar'
    end

    God.watch do |w|
      w.name = 'foo2'
      w.start = 'go'
      w.group = 'bar'
    end

    God.watch do |w|
      w.name = 'bar1'
      w.start = 'go'
      w.group = 'foo'
    end

    God.watches['foo1'].expects(:monitor)
    God.watches['foo2'].expects(:monitor)
    God.watches['bar1'].expects(:monitor).never

    God.control('bar', 'start')
  end

  def test_control_should_operate_on_all_watches_on_nil
    God.watch do |w|
      w.name = 'foo1'
      w.start = 'go'
      w.group = 'foo'
    end

    God.watch do |w|
      w.name = 'foo2'
      w.start = 'go'
      w.group = 'foo'
    end

    God.watch do |w|
      w.name = 'bar1'
      w.start = 'go'
      w.group = 'bar'
    end

    God.watches['foo1'].expects(:monitor)
    God.watches['foo2'].expects(:monitor)
    God.watches['bar1'].expects(:monitor)

    God.control(nil, 'start')
  end

  def test_control_should_operate_on_all_watches_on_empty_string
    God.watch do |w|
      w.name = 'foo1'
      w.start = 'go'
      w.group = 'foo'
    end

    God.watch do |w|
      w.name = 'foo2'
      w.start = 'go'
      w.group = 'foo'
    end

    God.watch do |w|
      w.name = 'bar1'
      w.start = 'go'
      w.group = 'bar'
    end

    God.watches['foo1'].expects(:monitor)
    God.watches['foo2'].expects(:monitor)
    God.watches['bar1'].expects(:monitor)

    God.control('', 'start')
  end


  # stop_all

  # terminate

  def test_terminate_should_exit
    God.pid = nil
    FileUtils.expects(:rm_f).never
    God.expects(:exit!)
    God.terminate
  end

  def test_terminate_should_delete_pid
    God.pid = '/foo/bar'
    FileUtils.expects(:rm_f).with("/foo/bar")
    God.expects(:exit!)
    God.terminate
  end

  # status

  def test_status_should_show_state
    God.watch { |w| w.name = 'foo'; w.start = 'bar' }

    w = God.watches['foo']
    w.state = :up
    assert_equal({'foo' = {:state = :up, :group = nil}}, God.status)
  end

  def test_status_should_show_state_with_group
    God.watch { |w| w.name = 'foo'; w.start = 'bar'; w.group = 'g' }

    w = God.watches['foo']
    w.state = :up
    assert_equal({'foo' = {:state = :up, :group = 'g'}}, God.status)
  end

  def test_status_should_show_unmonitored_for_nil_state
    God.watch { |w| w.name = 'foo'; w.start = 'bar' }

    w = God.watches['foo']
    assert_equal({'foo' = {:state = :unmonitored, :group = nil}}, God.status)
  end

  # running_log

  def test_running_log_should_call_watch_log_since_on_main_log
    God.watch { |w| w.name = 'foo'; w.start = 'bar' }
    t = Time.now
    LOG.expects(:watch_log_since).with('foo', t)
    God.running_log('foo', t)
  end

  def test_running_log_should_raise_on_unknown_watch
    God.internal_init
    assert_raise(NoSuchWatchError) do
      God.running_log('foo', Time.now)
    end
  end

  # running_load

  def test_running_load_should_eval_code
    code = -EOF
      God.watch do |w|
        w.name = 'foo'
        w.start = 'go'
      end
    EOF

    God.running_load(code, '/foo/bar.god')

    assert_equal 1, God.watches.size
  end

  def test_running_load_should_monitor_new_watches
    code = -EOF
      God.watch do |w|
        w.name = 'foo'
        w.start = 'go'
      end
    EOF

    Watch.any_instance.expects(:monitor)
    God.running_load(code, '/foo/bar.god')
  end

  def test_running_load_should_not_monitor_new_watches_with_autostart_false
    code = -EOF
      God.watch do |w|
        w.name = 'foo'
        w.start = 'go'
        w.autostart = false
      end
    EOF

    Watch.any_instance.expects(:monitor).never
    God.running_load(code, '/foo/bar.god')
  end

  def test_running_load_should_return_array_of_affected_watches
    code = -EOF
      God.watch do |w|
        w.name = 'foo'
        w.start = 'go'
      end
    EOF

    w = nil
    w, e = *God.running_load(code, '/foo/bar.god')
    assert_equal 1, w.size
    assert_equal 'foo', w.first
  end

  def test_running_load_should_clear_pending_watches
    code = -EOF
      God.watch do |w|
        w.name = 'foo'
        w.start = 'go'
      end
    EOF

    God.running_load(code, '/foo/bar.god')
    assert_equal 0, God.pending_watches.size
  end

  def test_running_load_with_stop
    code_one = -EOF
      God.watch do |w|
        w.name = 'foo'
        w.start = 'go'
      end
    EOF

    code_two = -EOF
      God.watch do |w|
        w.name = 'bar'
        w.start = 'go'
      end
    EOF

    a, e, r = *God.running_load(code_one, '/foo/one.god', 'stop')

    assert_equal 1, a.size
    assert_equal 0, r.size

    a, e, r = *God.running_load(code_two, '/foo/two.god', 'stop')

    assert_equal 1, a.size
    assert_equal 1, r.size
  end

  def test_running_load_with_remove
    code_one = -EOF
      God.watch do |w|
        w.name = 'foo'
        w.start = 'go'
      end
    EOF

    code_two = -EOF
      God.watch do |w|
        w.name = 'bar'
        w.start = 'go'
      end
    EOF

    a, e, r = *God.running_load(code_one, '/foo/one.god', 'remove')

    assert_equal 1, a.size
    assert_equal 0, r.size

    a, e, r = *God.running_load(code_two, '/foo/two.god', 'remove')

    assert_equal 1, a.size
    assert_equal 1, r.size
  end

  def test_running_load_with_leave
    code_one = -EOF
      God.watch do |w|
        w.name = 'foo'
        w.start = 'go'
      end
    EOF

    code_two = -EOF
      God.watch do |w|
        w.name = 'bar'
        w.start = 'go'
      end
    EOF

    a, e, r = *God.running_load(code_one, '/foo/one.god', 'leave')

    assert_equal 1, a.size
    assert_equal 0, r.size

    a, e, r = *God.running_load(code_two, '/foo/two.god', 'leave')

    assert_equal 1, a.size
    assert_equal 0, r.size
  end

  # load

  def test_load_should_collect_and_load_globbed_path
    Dir.expects(:[]).with('/path/to/*.thing').returns(['a', 'b'])
    Kernel.expects(:load).with('a').once
    Kernel.expects(:load).with('b').once
    God.load('/path/to/*.thing')
  end

  # start

  def test_start_should_kick_off_a_server_instance
    God::Socket.expects(:new).returns(true)
    God.start
  end

  def test_start_should_begin_monitoring_autostart_watches
    God.watch do |w|
      w.name = 'foo'
      w.start = 'go'
    end

    Watch.any_instance.expects(:monitor).once
    God.start
  end

  def test_start_should_not_begin_monitoring_non_autostart_watches
    God.watch do |w|
      w.name = 'foo'
      w.start = 'go'
      w.autostart = false
    end

    Watch.any_instance.expects(:monitor).never
    God.start
  end

  def test_start_should_get_and_join_timer
    God.watch { |w| w.name = 'foo'; w.start = 'bar' }
    God.start
  end

  # at_exit

  def test_at_exit_should_call_start
    God.expects(:start).once
    God.at_exit
  end

  # pattern_match

  def test_pattern_match
    list = %w{ mongrel-3000 mongrel-3001 fuzed22 fuzed fuzed2 apache mysql}

    assert_equal %w{ mongrel-3000 }, God.pattern_match('m3000', list)
    assert_equal %w{ mongrel-3001 }, God.pattern_match('m31', list)
    assert_equal %w{ fuzed fuzed2 fuzed22}, God.pattern_match('fu', list)
    assert_equal %w{ mysql }, God.pattern_match('sql', list)
  end
end


# class TestGodOther  Test::Unit::TestCase
#   def setup
#     God::Socket.stubs(:new).returns(true)
#     God.internal_init
#     God.reset
#   end
#
#   def teardown
#     God.main && God.main.kill
#   end
#
#   # setup
#
#   def test_setup_should_create_pid_file_directory_if_it_doesnt_exist
#     God.expects(:test).returns(false)
#     FileUtils.expects(:mkdir_p).with(God.pid_file_directory)
#     God.setup
#   end
#
#   def test_setup_should_raise_if_no_permissions_to_create_pid_file_directory
#     God.expects(:test).returns(false)
#     FileUtils.expects(:mkdir_p).raises(Errno::EACCES)
#
#     assert_abort do
#       God.setup
#     end
#   end
#
#   # validate
#
#   def test_validate_should_abort_if_pid_file_directory_is_unwriteable
#     God.expects(:test).returns(false)
#     assert_abort do
#       God.validater
#     end
#   end
#
#   def test_validate_should_not_abort_if_pid_file_directory_is_writeable
#     God.expects(:test).returns(true)
#     assert_nothing_raised do
#       God.validater
#     end
#   end
# end
</content>
		</actual_file>
		<actual_file>
			<filename>test_handlers_kqueue_handler.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

if God::EventHandler.event_system == "kqueue"

  class TestHandlersKqueueHandler  Test::Unit::TestCase
    def test_register_process
      KQueueHandler.expects(:monitor_process).with(1234, 2147483648)
      KQueueHandler.register_process(1234, [:proc_exit])
    end

    def test_events_mask
      assert_equal 2147483648, KQueueHandler.events_mask([:proc_exit])
    end
  end

end
</content>
		</actual_file>
		<actual_file>
			<filename>test_hipchat.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestHipchat  Test::Unit::TestCase
  def setup
    @hipchat = God::Contacts::Hipchat.new
  end

  def test_exists
    God::Contacts::Hipchat
  end

  def test_notify
    @hipchat.token = 'ee64d6e2337310af'
    @hipchat.ssl = 'true'
    @hipchat.room = 'testroom'
    @hipchat.from = 'test'

    time = Time.now
    body = "[#{time.strftime('%H:%M:%S')}] host - msg"
    Marshmallow::Connection.any_instance.expects(:speak).with('testroom', body)
    @hipchat.notify('msg', time, 'prio', 'cat', 'host')
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_jabber.rb</filename>
			<content>#!/usr/bin/env ruby
require File.dirname(__FILE__) + '/helper'

class TestJabber  Test::Unit::TestCase

  def setup
    @jabber = God::Contacts::Jabber.new
  end

  def test_notify
    @jabber.host = 'talk.google.com'
    @jabber.from_jid = 'god@jabber.org'
    @jabber.password = 'secret'
    @jabber.to_jid = 'dev@jabber.org'

    time = Time.now
    body = God::Contacts::Jabber.format.call('msg', time, 'prio', 'cat', 'host')

    assert_equal "Message: msg\nHost: host\nPriority: prio\nCategory: cat\n", body

    Jabber::Client.any_instance.expects(:connect).with('talk.google.com', 5222)
    Jabber::Client.any_instance.expects(:auth).with('secret')
    Jabber::Client.any_instance.expects(:send)
    Jabber::Client.any_instance.expects(:close)

    @jabber.notify('msg', Time.now, 'prio', 'cat', 'host')
    assert_equal "sent jabber message to dev@jabber.org", @jabber.info
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_logger.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestLogger  Test::Unit::TestCase
  def setup
    @log = God::Logger.new(StringIO.new('/dev/null'))
  end

  # log

  def test_log_should_keep_logs_when_wanted
    @log.watch_log_since('foo', Time.now)
    @log.expects(:info).with("qux")

    @log.log(stub(:name = 'foo'), :info, "qux")

    assert_equal 1, @log.logs.size
    assert_instance_of Time, @log.logs['foo'][0][0]
    assert_match(/qux/, @log.logs['foo'][0][1])
  end

  def test_log_should_send_to_syslog
    SysLogger.expects(:log).with(:fatal, 'foo')
    @log.log(stub(:name = 'foo'), :fatal, "foo")
  end

  # watch_log_since

  def test_watch_log_since
    t1 = Time.now

    @log.watch_log_since('foo', t1)

    @log.log(stub(:name = 'foo'), :info, "one")
    @log.log(stub(:name = 'foo'), :info, "two")

    assert_match(/one.*two/m, @log.watch_log_since('foo', t1))

    t2 = Time.now

    @log.log(stub(:name = 'foo'), :info, "three")

    out = @log.watch_log_since('foo', t2)

    assert_no_match(/one/, out)
    assert_no_match(/two/, out)
    assert_match(/three/, out)
  end

  # regular methods

  def test_fatal
    @log.fatal('foo')
    assert_equal 0, @log.logs.size
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_metric.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestMetric  Test::Unit::TestCase
  def setup
    @metric = Metric.new(stub(:interval = 10), nil)
  end

  # watch

  def test_watch
    w = stub()
    m = Metric.new(w, nil)
    assert_equal w, m.watch
  end

  # destination

  def test_destination
    d = stub()
    m = Metric.new(nil, d)
    assert_equal d, m.destination
  end

  # condition

  def test_condition_should_be_block_optional
    @metric.condition(:fake_poll_condition)
    assert_equal 1, @metric.conditions.size
  end

  def test_poll_condition_should_inherit_interval_from_watch_if_not_specified
    @metric.condition(:fake_poll_condition)
    assert_equal 10, @metric.conditions.first.interval
  end

  def test_poll_condition_should_abort_if_no_interval_and_no_watch_interval
    metric = Metric.new(stub(:name = 'foo', :interval = nil), nil)

    assert_abort do
      metric.condition(:fake_poll_condition)
    end
  end

  # This doesn't currently work:
  #
  # def test_condition_should_allow_generation_of_subclasses_of_poll_or_event
  #   metric = Metric.new(stub(:name = 'foo', :interval = 10), nil)
  #
  #   assert_nothing_raised do
  #     metric.condition(:fake_poll_condition)
  #     metric.condition(:fake_event_condition)
  #   end
  # end

  def test_condition_should_abort_if_not_subclass_of_poll_or_event
    metric = Metric.new(stub(:name = 'foo', :interval = 10), nil)

    assert_abort do
      metric.condition(:fake_condition) { |c| }
    end
  end

  def test_condition_should_abort_on_invalid_condition
    assert_abort do
      @metric.condition(:fake_poll_condition) { |c| c.stubs(:valid?).returns(false) }
    end
  end

  def test_condition_should_abort_on_no_such_condition
    assert_abort do
      @metric.condition(:invalid) { }
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_process.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

module God
  class Process
    # def fork
    #   raise "You forgot to stub fork"
    # end

    def exec(*args)
      raise "You forgot to stub exec"
    end
  end
end

class TestProcessChild  Test::Unit::TestCase
  def setup
    God.internal_init
    @p = God::Process.new
    @p.name = 'foo'
    @p.stubs(:test).returns true # so we don't try to mkdir_p
    Process.stubs(:detach) # because we stub fork

    ::Process::Sys.stubs(:setuid).returns(true)
    ::Process::Sys.stubs(:setgid).returns(true)
  end

  # valid?

  def test_valid_should_return_true_if_auto_daemonized_and_log
    @p.start = 'qux'
    @p.log = 'bar'

    assert @p.valid?
  end

  def test_valid_should_return_true_if_auto_daemonized_and_no_stop
    @p.start = 'qux'
    @p.log = 'bar'

    assert @p.valid?
  end

  def test_valid_should_return_true_if_uid_exists
    @p.start = 'qux'
    @p.log = '/tmp/foo.log'
    @p.uid = 'root'

    assert @p.valid?
  end

  def test_valid_should_return_true_if_uid_does_not_exists
    @p.start = 'qux'
    @p.log = '/tmp/foo.log'
    @p.uid = 'foobarbaz'

    assert !@p.valid?
  end

  def test_valid_should_return_true_if_gid_exists
    @p.start = 'qux'
    @p.log = '/tmp/foo.log'
    @p.gid = Etc.getgrgid(::Process.gid).name

    ::Process.stubs(:groups=)

    assert @p.valid?
  end

  def test_valid_should_return_false_if_gid_does_not_exists
    @p.start = 'qux'
    @p.log = '/tmp/foo.log'
    @p.gid = 'foobarbaz'

    assert !@p.valid?
  end

  def test_valid_should_return_true_if_dir_exists
    @p.start = 'qux'
    @p.log = '/tmp/foo.log'
    @p.dir = '/tmp'

    assert @p.valid?
  end

  def test_valid_should_return_false_if_dir_does_not_exists
    @p.start = 'qux'
    @p.log = '/tmp/foo.log'
    @p.dir = '/tmp/doesnotexist'

    assert !@p.valid?
  end

  def test_valid_should_return_false_if_dir_is_not_a_dir
    @p.start = 'qux'
    @p.log = '/tmp/foo.log'
    @p.dir = '/etc/passwd'

    assert !@p.valid?
  end

  def test_valid_should_return_false_with_bogus_chroot
    @p.chroot = '/bogusroot'

    assert !@p.valid?
  end

  def test_valid_should_return_true_with_chroot_and_valid_log
    @p.start = 'qux'
    @p.chroot = Dir.pwd
    @p.log = "#{@p.chroot}/foo.log"

    File.expects(:exist?).with(@p.chroot).returns(true)
    File.expects(:exist?).with(@p.log).returns(true)
    File.expects(:exist?).with("#{@p.chroot}/dev/null").returns(true)

    File.stubs(:writable?).with('/foo.log').returns(true)

    ::Dir.stubs(:chroot)

    assert @p.valid?
  end

  # call_action

  def test_call_action_should_write_pid
    # Only for start, restart
    [:start, :restart].each do |action|
      @p.stubs(:test).returns true
      IO.expects(:pipe).returns([StringIO.new('1234'), StringIO.new])
      @p.expects(:fork)
      Process.expects(:waitpid)
      File.expects(:open).with(@p.default_pid_file, 'w')
      @p.send("#{action}=", "run")
      @p.call_action(action)
    end
  end
end

###############################################################################
#
# Daemon
#
###############################################################################

class TestProcessDaemon  Test::Unit::TestCase
  def setup
    God.internal_init
    @p = God::Process.new
    @p.name = 'foo'
    @p.pid_file = 'blah.pid'
    @p.stubs(:test).returns true # so we don't try to mkdir_p
    Process.stubs(:detach) # because we stub fork
  end

  # alive?

  def test_alive_should_call_system_process_exists
    File.expects(:read).with('blah.pid').times(2).returns('1234')
    System::Process.any_instance.expects(:exists?).returns(false)
    assert !@p.alive?
  end

  def test_alive_should_return_false_if_no_such_file
    File.expects(:read).with('blah.pid').raises(Errno::ENOENT)
    assert !@p.alive?
  end

  # valid?

  def test_valid_should_return_false_if_no_start
    @p.name = 'foo'
    @p.stop = 'baz'
    assert !@p.valid?
  end

  # pid

  def test_pid_should_return_integer_for_valid_pid_files
    File.stubs(:read).returns("123")
    assert_equal 123, @p.pid
  end

  def test_pid_should_return_nil_for_missing_files
    @p.pid_file = ''
    assert_equal nil, @p.pid
  end

  def test_pid_should_return_nil_for_invalid_pid_files
    File.stubs(:read).returns("four score and seven years ago")
    assert_equal nil, @p.pid
  end

  def test_pid_should_retain_last_pid_value_if_pid_file_is_removed
    File.stubs(:read).returns("123")
    assert_equal 123, @p.pid

    File.stubs(:read).raises(Errno::ENOENT)
    assert_equal 123, @p.pid

    File.stubs(:read).returns("246")
    assert_equal 246, @p.pid
  end

  # default_pid_file

  def test_default_pid_file
    assert_equal File.join(God.pid_file_directory, 'foo.pid'), @p.default_pid_file
  end

  # unix socket

  def test_unix_socket_should_return_path_specified
    @p.unix_socket = '/path/to-socket'
    assert_equal '/path/to-socket', @p.unix_socket
  end

  # umask
  def test_umask_should_return_umask_specified
    @p.umask = 002
    assert_equal 002, @p.umask
  end

  # call_action
  # These actually excercise call_action in the back at this point - Kev

  def test_call_action_with_string_should_call_system
    @p.start = "do something"
    @p.expects(:fork)
    Process.expects(:waitpid2).returns([123, 0])
    @p.call_action(:start)
  end

  def test_call_action_with_lambda_should_call
    cmd = lambda { puts "Hi" }
    cmd.expects(:call)
    @p.start = cmd
    @p.call_action(:start)
  end

  def test_call_action_with_invalid_command_class_should_raise
    @p.start = 5
    @p.stop = 'baz'

    assert @p.valid?

    assert_raise NotImplementedError do
      @p.call_action(:start)
    end
  end

  # start!/stop!/restart!

  def test_start_stop_restart_bang
    [:start, :stop, :restart].each do |x|
      @p.expects(:call_action).with(x)
      @p.send("#{x}!")
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_prowl.rb</filename>
			<content>#!/usr/bin/env ruby
require File.dirname(__FILE__) + '/helper'

class TestProwl  Test::Unit::TestCase
  def test_live_notify
    prowl = God::Contacts::Prowl.new
    prowl.name = "Prowly"
    prowl.apikey = 'put_your_apikey_here'

    Prowly.expects(:notify).returns(mock(:succeeded? = true))

    prowl.notify("Test", Time.now, "Test", "Test", "")
    assert_equal "sent prowl notification to #{prowl.name}", prowl.info
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_registry.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestRegistry  Test::Unit::TestCase
  def setup
    God.registry.reset
  end

  def test_add
    foo = God::Process.new
    foo.name = 'foo'
    God.registry.add(foo)
    assert_equal 1, God.registry.size
    assert_equal foo, God.registry['foo']
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_socket.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestSocket  Test::Unit::TestCase
  def setup
    silence_warnings do
      Object.const_set(:DRb, stub_everything)
    end
  end

  def test_should_start_a_drb_server
    DRb.expects(:start_service)
    God::Socket.new
  end

  def test_should_use_supplied_port_and_host
    DRb.expects(:start_service).with { |uri, object| uri == "drbunix:///tmp/god.9999.sock" && object.is_a?(God::Socket) }
    server = God::Socket.new(9999)
  end

  def test_should_forward_foreign_method_calls_to_god
    server = nil
    server = God::Socket.new
    God.expects(:send).with(:something_random)
    server.something_random
  end

  # ping

  def test_ping_should_return_true
    server = nil
    server = God::Socket.new
    assert server.ping
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_sugar.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestSugar  Test::Unit::TestCase
  def test_seconds
    assert_equal 1, 1.seconds
    assert_equal 1, 1.second
  end

  def test_minutes
    assert_equal 60, 1.minutes
    assert_equal 60, 1.minute
  end

  def test_hours
    assert_equal 3600, 1.hours
    assert_equal 3600, 1.hour
  end

  def test_days
    assert_equal 86400, 1.days
    assert_equal 86400, 1.day
  end

  def test_kilobytes
    assert_equal 1, 1.kilobytes
    assert_equal 1, 1.kilobyte
  end

  def test_megabytes
    assert_equal 1024, 1.megabytes
    assert_equal 1024, 1.megabyte
  end

  def test_gigabytes
    assert_equal 1024 ** 2, 1.gigabytes
    assert_equal 1024 ** 2, 1.gigabyte
  end

  def test_percent
    assert_equal 1, 1.percent
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_system_portable_poller.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestSystemPortablePoller  Test::Unit::TestCase
  def setup
    pid = Process.pid
    @process = System::PortablePoller.new(pid)
  end

  def test_time_string_to_seconds
    assert_equal 0, @process.bypass.time_string_to_seconds('0:00:00')
    assert_equal 0, @process.bypass.time_string_to_seconds('0:00:55')
    assert_equal 27, @process.bypass.time_string_to_seconds('0:27:32')
    assert_equal 75, @process.bypass.time_string_to_seconds('1:15:13')
    assert_equal 735, @process.bypass.time_string_to_seconds('12:15:13')
  end
end

</content>
		</actual_file>
		<actual_file>
			<filename>test_system_process.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestSystemProcess  Test::Unit::TestCase
  def setup
    pid = Process.pid
    @process = System::Process.new(pid)
  end

  def test_exists_should_return_true_for_running_process
    assert_equal true, @process.exists?
  end

  def test_exists_should_return_false_for_non_existant_process
    assert_equal false, System::Process.new(9999999).exists?
  end

  def test_memory
    assert_kind_of Integer, @process.memory
    assert @process.memory  0
  end

  def test_percent_memory
    assert_kind_of Float, @process.percent_memory
  end

  def test_percent_cpu
    assert_kind_of Float, @process.percent_cpu
  end
end

</content>
		</actual_file>
		<actual_file>
			<filename>test_task.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestTask  Test::Unit::TestCase
  def setup
    God.internal_init
    @task = Task.new
    @task.name = 'foo'
    @task.valid_states = [:foo, :bar]
    @task.initial_state = :foo
    @task.interval = 5
    @task.prepare
  end

  # valid?

  def test_valid_should_return_false_if_no_name
    @task.name = nil
    assert !@task.valid?
  end

  def test_valid_should_return_false_if_no_valid_states
    @task.valid_states = nil
    assert !@task.valid?
  end

  def test_valid_should_return_false_if_no_initial_state
    @task.initial_state = nil
    assert !@task.valid?
  end

  # transition

  def test_transition_should_be_always_if_no_block_was_given
    @task.transition(:foo, :bar)

    assert_equal 5, @task.metrics.size
    assert_equal Conditions::Always, @task.metrics[:foo].first.conditions.first.class
  end

  # method_missing

  def test_method_missing_should_create_accessor_for_states
    assert_nothing_raised do
      @task.foo = 'testing'
    end
  end

  def test_method_missing_should_raise_for_non_states
    assert_raise NoMethodError do
      @task.baz = 5
    end
  end

  def test_method_missing_should_raise_for_non_setters
    assert_raise NoMethodError do
      @task.baz
    end
  end

  # action

  def test_action_should_send_string_commands_to_system
    @task.foo = 'foo'
    @task.driver.stubs(:in_driver_context?).returns(true)
    @task.expects(:system).with('foo')
    @task.action(:foo, nil)
  end

  def test_action_should_call_lambda_commands
    @task.foo = lambda { }
    @task.driver.stubs(:in_driver_context?).returns(true)
    @task.foo.expects(:call)
    @task.action(:foo, nil)
  end

  def test_action_should_raise_not_implemented_on_non_string_or_lambda_action
    @task.driver.stubs(:in_driver_context?).returns(true)
    assert_raise NotImplementedError do
      @task.foo = 7
      @task.action(:foo, nil)
    end
  end

  def test_action_from_outside_driver_should_send_message_to_driver
    @task.foo = 'foo'
    @task.driver.expects(:message).with(:action, [:foo, nil])
    @task.action(:foo, nil)
  end

  # attach

  def test_attach_should_schedule_for_poll_condition
    c = Conditions::FakePollCondition.new
    @task.driver.expects(:schedule).with(c, 0)
    @task.attach(c)
  end

  def test_attach_should_regsiter_for_event_condition
    c = Conditions::FakeEventCondition.new
    c.expects(:register)
    @task.attach(c)
  end

  # detach

  def test_detach_should_reset_poll_condition
    c = Conditions::FakePollCondition.new
    c.expects(:reset)
    c.expects(:deregister).never
    @task.detach(c)
  end

  def test_detach_should_deregister_event_conditions
    c = Conditions::FakeEventCondition.new
    c.expects(:deregister).once
    @task.detach(c)
  end

  # trigger

  def test_trigger_should_send_message_to_driver
    c = Conditions::FakePollCondition.new
    @task.driver.expects(:message).with(:handle_event, [c])
    @task.trigger(c)
  end

  # handle_poll

  def test_handle_poll_no_change_should_reschedule
    c = Conditions::FakePollCondition.new
    c.watch = @task
    c.interval = 10

    m = Metric.new(@task, {true = :up})
    @task.directory[c] = m

    c.expects(:test).returns(false)
    @task.driver.expects(:schedule)
    @task.handle_poll(c)
  end

  def test_handle_poll_change_should_move
    c = Conditions::FakePollCondition.new
    c.watch = @task
    c.interval = 10

    m = Metric.new(@task, {true = :up})
    @task.directory[c] = m

    c.expects(:test).returns(true)
    @task.expects(:move).with(:up)
    @task.handle_poll(c)
  end

  def test_handle_poll_should_use_overridden_transition
    c = Conditions::Tries.new
    c.watch = @task
    c.times = 1
    c.transition = :start
    c.prepare

    m = Metric.new(@task, {true = :up})
    @task.directory[c] = m

    @task.expects(:move).with(:start)
    @task.handle_poll(c)
  end

  def test_handle_poll_should_notify_if_triggering
    c = Conditions::FakePollCondition.new
    c.watch = @task
    c.interval = 10
    c.notify = 'tom'

    m = Metric.new(@task, {true = :up})
    @task.directory[c] = m

    c.expects(:test).returns(true)
    @task.expects(:notify)
    @task.handle_poll(c)
  end

  def test_handle_poll_should_not_notify_if_not_triggering
    c = Conditions::FakePollCondition.new
    c.watch = @task
    c.interval = 10
    c.notify = 'tom'

    m = Metric.new(@task, {true = :up})
    @task.directory[c] = m

    c.expects(:test).returns(false)
    @task.expects(:notify).never
    @task.handle_poll(c)
  end

  def test_handle_poll_unexpected_exception_should_reschedule
    c = Conditions::FakePollCondition.new
    c.watch = @task
    c.interval = 10

    m = Metric.new(@task, {true = :up})
    @task.directory[c] = m

    c.expects(:test).raises(StandardError)
    @task.driver.expects(:schedule)

    @task.handle_poll(c)
  end

  # handle_event

  def test_handle_event_should_move
    c = Conditions::FakeEventCondition.new
    c.watch = @task

    m = Metric.new(@task, {true = :up})
    @task.directory[c] = m

    @task.expects(:move).with(:up)
    @task.handle_event(c)
  end

  def test_handle_event_should_notify_if_triggering
    c = Conditions::FakeEventCondition.new
    c.watch = @task
    c.notify = 'tom'

    m = Metric.new(@task, {true = :up})
    @task.directory[c] = m

    @task.expects(:notify)
    @task.handle_event(c)
  end

  def test_handle_event_should_not_notify_if_no_notify_set
    c = Conditions::FakeEventCondition.new
    c.watch = @task

    m = Metric.new(@task, {true = :up})
    @task.directory[c] = m

    @task.expects(:notify).never
    @task.handle_event(c)
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_timeline.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestTimeline  Test::Unit::TestCase
  def setup
    @timeline = Timeline.new(5)
  end

  def test_new_should_be_empty
    assert_equal 0, @timeline.size
  end

  def test_should_not_grow_to_more_than_size
    (1..10).each do |i|
      @timeline.push(i)
    end

    assert_equal [6, 7, 8, 9, 10], @timeline
  end

  def test_clear_should_clear_array
    @timeline  1
    assert_equal [1], @timeline
    assert_equal [], @timeline.clear
  end

  # def test_benchmark
  #   require 'benchmark'
  #
  #   count = 1_000_000
  #
  #   t = Timeline.new(10)
  #
  #   Benchmark.bmbm do |x|
  #     x.report("go") { count.times { t.push(5) } }
  #   end
  # end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_trigger.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestTrigger  Test::Unit::TestCase
  def setup
    Trigger.reset
  end

  # base case

  def test_should_have_empty_triggers
    assert_equal({}, Trigger.triggers)
  end

  # register

  def test_register_should_add_condition_to_triggers
    c = Condition.new
    c.watch = stub(:name = 'foo')
    Trigger.register(c)

    assert_equal({'foo' = [c]}, Trigger.triggers)
  end

  def test_register_should_add_condition_to_triggers_twice
    watch = stub(:name = 'foo')
    c = Condition.new
    c.watch = watch
    Trigger.register(c)

    c2 = Condition.new
    c2.watch = watch
    Trigger.register(c2)

    assert_equal({'foo' = [c, c2]}, Trigger.triggers)
  end

  # deregister

  def test_deregister_should_remove_condition_from_triggers
    c = Condition.new
    c.watch = stub(:name = 'foo')
    Trigger.register(c)
    Trigger.deregister(c)

    assert_equal({}, Trigger.triggers)
  end

  # broadcast

  def test_broadcast_should_call_process_on_each_condition
    c = Condition.new
    c.watch = stub(:name = 'foo')
    Trigger.register(c)

    c.expects(:process).with(:state_change, [:up, :start])

    Trigger.broadcast(c.watch, :state_change, [:up, :start])
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_watch.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestWatch  Test::Unit::TestCase
  def setup
    God.internal_init
    @watch = Watch.new
    @watch.name = 'foo'
    @watch.start = lambda { }
    @watch.stop = lambda { }
    @watch.prepare
  end

  # new

  def test_new_should_have_no_behaviors
    assert_equal [], @watch.behaviors
  end

  def test_new_should_have_no_metrics
    Watch::VALID_STATES.each do |state|
      assert_equal [], @watch.metrics[state]
    end
  end

  def test_new_should_have_standard_attributes
    assert_nothing_raised do
      @watch.name = 'foo'
      @watch.start = 'start'
      @watch.stop = 'stop'
      @watch.restart = 'restart'
      @watch.interval = 30
      @watch.grace = 5
    end
  end

  def test_new_should_have_unmonitored_state
    assert_equal :unmonitored, @watch.state
  end

  # valid?

  def test_valid?
    God::Process.any_instance.expects(:valid?)
    @watch.valid?
  end

  # behavior

  def test_behavior_should_record_behavior
    beh = nil
    @watch.behavior(:fake_behavior) { |b| beh = b }
    assert_equal 1, @watch.behaviors.size
    assert_equal beh, @watch.behaviors.first
  end

  def test_invalid_behavior_should_abort
    assert_abort do
      @watch.behavior(:invalid)
    end
  end

  # transition

  def test_transition_should_abort_on_invalid_start_state
    assert_abort do
      @watch.transition(:foo, :bar)
    end
  end

  def test_transition_should_accept_all_valid_start_states
    assert_nothing_raised do
      Watch::VALID_STATES.each do |state|
        @watch.transition(state, :bar) { }
      end
    end
  end

  def test_transition_should_create_and_record_a_metric_for_the_given_start_state
    @watch.transition(:init, :start) { }
    assert_equal 1, @watch.metrics[:init].size
  end

  # lifecycle

  def test_lifecycle_should_create_and_record_a_metric_for_nil_start_state
    @watch.lifecycle { }
    assert_equal 1, @watch.metrics[nil].size
  end

  # keepalive

  def test_keepalive_should_place_metrics_on_up_state
    @watch.keepalive(:memory_max = 5.megabytes, :cpu_max = 50.percent)
    assert_equal 2, @watch.metrics[:up].size
  end

  # start_if

  def test_start_if_should_place_a_metric_on_up_state
    @watch.start_if { }
    assert_equal 1, @watch.metrics[:up].size
  end

  # restart_if

  def test_restart_if_should_place_a_metric_on_up_state
    @watch.restart_if { }
    assert_equal 1, @watch.metrics[:up].size
  end

  # monitor

  def test_monitor_should_move_to_init_if_available
    @watch.instance_eval do
      transition(:init, :up) { }
    end
    @watch.expects(:move).with(:init)
    @watch.monitor
  end

  def test_monitor_should_move_to_up_if_no_init_available
    @watch.expects(:move).with(:up)
    @watch.monitor
  end

  # unmonitor

  def test_unmonitor_should_move_to_nil
    @watch.expects(:move).with(:unmonitored)
    @watch.unmonitor
  end

  # move

  def test_move_should_not_clean_up_if_from_state_is_nil
    @watch.driver.stubs(:in_driver_context?).returns(true)
    @watch.driver.expects(:message).never

    metric = nil

    @watch.instance_eval do
      transition(:init, :up) do |on|
        metric = on
        on.condition(:process_running) do |c|
          c.running = true
          c.interval = 10
        end
      end
    end

    metric.expects(:disable).never

    @watch.move(:init)
  end

  def test_move_should_clean_up_from_state_if_not_nil
    @watch.driver.stubs(:in_driver_context?).returns(true)
    @watch.driver.expects(:message).never

    metric = nil

    @watch.instance_eval do
      transition(:init, :up) do |on|
        metric = on
        on.condition(:process_running) do |c|
          c.running = true
          c.interval = 10
        end
      end
    end

    @watch.move(:init)

    metric.expects(:disable)

    @watch.move(:up)
  end

  def test_move_should_call_action
    @watch.driver.stubs(:in_driver_context?).returns(true)
    @watch.driver.expects(:message).never

    @watch.expects(:action).with(:start)

    @watch.move(:start)
  end

  def test_move_should_move_to_up_state_if_no_start_or_restart_metric
    @watch.driver.stubs(:in_driver_context?).returns(true)
    @watch.driver.expects(:message).never

    [:start, :restart].each do |state|
      @watch.expects(:action)
      @watch.move(state)
      assert_equal :up, @watch.state
    end
  end

  def test_move_should_enable_destination_metric
    @watch.driver.stubs(:in_driver_context?).returns(true)
    @watch.driver.expects(:message).never

    metric = nil

    @watch.instance_eval do
      transition(:init, :up) do |on|
        metric = on
        on.condition(:process_running) do |c|
          c.running = true
          c.interval = 10
        end
      end
    end

    metric.expects(:enable)

    @watch.move(:init)
  end

  # action

  def test_action_should_pass_start_and_stop_actions_to_call_action
    @watch.driver.stubs(:in_driver_context?).returns(true)
    @watch.driver.expects(:message).never

    c = Conditions::FakePollCondition.new
    [:start, :stop].each do |cmd|
      @watch.expects(:call_action).with(c, cmd)
      @watch.action(cmd, c)
    end
  end

  def test_action_should_do_stop_then_start_if_no_restart_command
    @watch.driver.stubs(:in_driver_context?).returns(true)
    @watch.driver.expects(:message).never

    c = Conditions::FakePollCondition.new
    @watch.expects(:call_action).with(c, :stop)
    @watch.expects(:call_action).with(c, :start)
    @watch.action(:restart, c)
  end

  def test_action_should_restart_to_call_action_if_present
    @watch.driver.stubs(:in_driver_context?).returns(true)
    @watch.driver.expects(:message).never

    @watch.restart = lambda { }
    c = Conditions::FakePollCondition.new
    @watch.expects(:call_action).with(c, :restart)
    @watch.action(:restart, c)
  end

  # call_action

  def test_call_action
    c = Conditions::FakePollCondition.new
    God::Process.any_instance.expects(:call_action).with(:start)
    @watch.call_action(c, :start)
  end

  def test_call_action_should_call_before_start_when_behavior_has_that
    @watch.behavior(:fake_behavior)
    c = Conditions::FakePollCondition.new
    God::Process.any_instance.expects(:call_action).with(:start)
    Behaviors::FakeBehavior.any_instance.expects(:before_start)
    @watch.call_action(c, :start)
  end

  def test_call_action_should_call_after_start_when_behavior_has_that
    @watch.behavior(:fake_behavior)
    c = Conditions::FakePollCondition.new
    God::Process.any_instance.expects(:call_action).with(:start)
    Behaviors::FakeBehavior.any_instance.expects(:after_start)
    @watch.call_action(c, :start)
  end

  # canonical_hash_form

  def test_canonical_hash_form_should_convert_symbol_to_hash
    assert_equal({true = :foo}, @watch.canonical_hash_form(:foo))
  end

  def test_canonical_hash_form_should_convert_hash_to_hash
    assert_equal({true = :foo}, @watch.canonical_hash_form(true = :foo))
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>test_webhook.rb</filename>
			<content>require File.dirname(__FILE__) + '/helper'

class TestWebhook  Test::Unit::TestCase
  def setup
    @webhook = God::Contacts::Webhook.new
  end

  def test_notify
    @webhook.url = 'http://example.com/switch'
    Net::HTTP.any_instance.expects(:request).returns(Net::HTTPSuccess.new('a', 'b', 'c'))

    @webhook.notify('msg', Time.now, 'prio', 'cat', 'host')
    assert_equal "sent webhook to http://example.com/switch", @webhook.info
  end

  def test_notify_with_url_containing_query_parameters
    @webhook.url = 'http://example.com/switch?api_key=123'
    Net::HTTP::Post.expects(:new).with('/switch?api_key=123')

    @webhook.notify('msg', Time.now, 'prio', 'cat', 'host')
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>real.rb</filename>
			<content>if $0 == __FILE__
  require File.join(File.dirname(__FILE__), *%w[.. .. lib god])
end

RAILS_ROOT = "/Users/tom/dev/git/helloworld"

God.watch do |w|
  w.name = "local-3000"
  w.interval = 5 # seconds
  w.start = "mongrel_rails start -P ./log/mongrel.pid -c #{RAILS_ROOT} -d"
  w.stop = "mongrel_rails stop -P ./log/mongrel.pid -c #{RAILS_ROOT}"
  w.grace = 5

  pid_file = File.join(RAILS_ROOT, "log/mongrel.pid")

  # clean pid files before start if necessary
  w.behavior(:clean_pid_file) do |b|
    b.pid_file = pid_file
  end

  # start if process is not running
  w.start_if do |start|
    start.condition(:process_running) do |c|
      c.running = false
      c.pid_file = pid_file
    end
  end

  # restart if memory or cpu is too high
  w.restart_if do |restart|
    restart.condition(:memory_usage) do |c|
      c.interval = 20
      c.pid_file = pid_file
      c.above = (50 * 1024) # 50mb
      c.times = [3, 5]
    end

    restart.condition(:cpu_usage) do |c|
      c.interval = 10
      c.pid_file = pid_file
      c.above = 10 # percent
      c.times = [3, 5]
    end
  end
end

# clear old session files
# god.watch do |w|
#   w.name = "local-session-cleanup"
#   w.start = lambda do
#     Dir["#{RAILS_ROOT}/tmp/sessions/ruby_sess.*"].select do |f|
#       File.mtime(f)  Time.now - (7 * 24 * 60 * 60)
#     end.each { |f| File.delete(f) }
#   end
#
#   w.start_if do |start|
#     start.condition(:always)
#   end
# end
</content>
		</actual_file>
		<actual_file>
			<filename>test.rb</filename>
			<content>ENV['GOD_TEST_RAILS_ROOT'] || abort("Set a rails root for testing in an environment variable called GOD_TEST_RAILS_ROOT")

RAILS_ROOT = ENV['GOD_TEST_RAILS_ROOT']

port = 5000

God.watch do |w|
  w.name = "local-#{port}"
  w.interval = 5.seconds
  w.start = "mongrel_rails start -P ./log/mongrel.pid -c #{RAILS_ROOT} -p #{port} -d"
  w.restart = "mongrel_rails restart -P ./log/mongrel.pid -c #{RAILS_ROOT}"
  w.stop = "mongrel_rails stop -P ./log/mongrel.pid -c #{RAILS_ROOT}"
  w.group = 'mongrels'
  w.pid_file = File.join(RAILS_ROOT, "log/mongrel.pid")

  # clean pid files before start if necessary
  w.behavior(:clean_pid_file)

  # determine the state on startup
  w.transition(:init, { true = :up, false = :start }) do |on|
    on.condition(:process_running) do |c|
      c.running = true
    end
  end

  # determine when process has finished starting
  w.transition([:start, :restart], :up) do |on|
    on.condition(:process_running) do |c|
      c.running = true
    end
  end

  # start if process is not running
  w.transition(:up, :start) do |on|
    on.condition(:process_exits)
  end

  # restart if memory or cpu is too high
  w.transition(:up, :restart) do |on|
    on.condition(:memory_usage) do |c|
      c.interval = 1
      c.above = 50.megabytes
      c.times = [3, 5]
    end

    on.condition(:cpu_usage) do |c|
      c.interval = 1
      c.above = 10.percent
      c.times = [3, 5]
    end

    on.condition(:http_response_code) do |c|
      c.host = 'localhost'
      c.port = port
      c.path = '/'
      c.code_is_not = 200
      c.timeout = 10.seconds
      c.times = [3, 5]
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>child_events.god</filename>
			<content>God.watch do |w|
  w.name = "child-events"
  w.interval = 5.seconds
  w.start = File.join(GOD_ROOT, *%w[test configs child_events simple_server.rb])
  # w.log = File.join(GOD_ROOT, *%w[test configs child_events god.log])

  # determine the state on startup
  w.transition(:init, { true = :up, false = :start }) do |on|
    on.condition(:process_running) do |c|
      c.running = true
    end
  end

  # determine when process has finished starting
  w.transition([:start, :restart], :up) do |on|
    on.condition(:process_running) do |c|
      c.running = true
    end

    # failsafe
    on.condition(:tries) do |c|
      c.times = 2
      c.transition = :start
    end
  end

  # start if process is not running
  w.transition(:up, :start) do |on|
    on.condition(:process_exits)
  end

  # lifecycle
  w.lifecycle do |on|
    on.condition(:flapping) do |c|
      c.to_state = [:start, :restart]
      c.times = 5
      c.within = 20.seconds
      c.transition = :unmonitored
      c.retry_in = 10.seconds
      c.retry_times = 2
      c.retry_within = 5.minutes
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>simple_server.rb</filename>
			<content>#! /usr/bin/env ruby

loop { puts 'server'; sleep 1 }
</content>
		</actual_file>
		<actual_file>
			<filename>child_polls.god</filename>
			<content>God.watch do |w|
  w.name = 'child-polls'
  w.start = File.join(GOD_ROOT, *%w[test configs child_polls simple_server.rb])
  w.interval = 5
  w.grace = 2

  w.start_if do |start|
    start.condition(:process_running) do |c|
      c.running = false
    end
  end

  w.restart_if do |restart|
    restart.condition(:cpu_usage) do |c|
      c.above = 30.percent
      c.times = [3, 5]
    end

    restart.condition(:memory_usage) do |c|
      c.above = 10.megabytes
      c.times = [3, 5]
    end
  end

  # lifecycle
  w.lifecycle do |on|
    on.condition(:flapping) do |c|
      c.to_state = [:start, :restart]
      c.times = 3
      c.within = 60.seconds
      c.transition = :unmonitored
      c.retry_in = 10.seconds
      c.retry_times = 2
      c.retry_within = 5.minutes
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>simple_server.rb</filename>
			<content>#! /usr/bin/env ruby

data = ''

loop do
  STDOUT.puts('server');
  STDOUT.flush;

  100000.times { data  'x' }

  sleep 10
end
</content>
		</actual_file>
		<actual_file>
			<filename>complex.god</filename>
			<content>God.watch do |w|
  w.name = "complex"
  w.interval = 5.seconds
  w.start = File.join(GOD_ROOT, *%w[test configs complex simple_server.rb])
  # w.log = File.join(GOD_ROOT, *%w[test configs child_events god.log])

  # determine the state on startup
  w.transition(:init, { true = :up, false = :start }) do |on|
    on.condition(:process_running) do |c|
      c.running = true
    end
  end

  # determine when process has finished starting
  w.transition([:start, :restart], :up) do |on|
    on.condition(:process_running) do |c|
      c.running = true
    end

    # failsafe
    on.condition(:tries) do |c|
      c.times = 2
      c.transition = :start
    end
  end

  # start if process is not running
  w.transition(:up, :start) do |on|
    on.condition(:process_exits)
  end

  # restart if process is misbehaving
  w.transition(:up, :restart) do |on|
    on.condition(:complex) do |cc|
      cc.and(:cpu_usage) do |c|
        c.above = 0.percent
        c.times = 1
      end

      cc.and(:memory_usage) do |c|
        c.above = 0.megabytes
        c.times = 3
      end
    end
  end

  # lifecycle
  w.lifecycle do |on|
    on.condition(:flapping) do |c|
      c.to_state = [:start, :restart]
      c.times = 5
      c.within = 20.seconds
      c.transition = :unmonitored
      c.retry_in = 10.seconds
      c.retry_times = 2
      c.retry_within = 5.minutes
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>simple_server.rb</filename>
			<content>#! /usr/bin/env ruby

loop { puts 'server'; sleep 1 }
</content>
		</actual_file>
		<actual_file>
			<filename>contact.god</filename>
			<content># God::Contacts::Campfire.defaults do |d|
#   d.subdomain = 'github'
#   d.token = '9fb768e421975cc1c6ff3f4f8306f890cb46e24f'
#   d.room = 'Notices'
#   d.ssl = true
# end
#
# God.contact(:campfire) do |c|
#   c.name = 'tom4'
# end

# God::Contacts::Hipchat.defaults do |d|
#   d.token = '9fb768e421975cc1c6ff3f4f8306f890cb46e24f'
#   d.room = 'Notices'
#   d.ssl = true
# end
#
# God.contact(:hipchat) do |c|
#   c.name = 'hip1'
# end

# God.contact(:email) do |c|
#   c.name = 'tom'
#   c.group = 'developers'
#   c.to_email = 'tom@lepton.local'
#   c.from_email = 'god@github.com'
#   c.from_name = 'God'
#   c.delivery_method = :sendmail
# end

# God.contact(:email) do |c|
#   c.name = 'tom'
#   c.group = 'developers'
#   c.to_email = 'tom@mojombo.com'
#   c.from_email = 'god@github.com'
#   c.from_name = 'God'
#   c.server_host = 'smtp.rs.github.com'
# end

# God.contact(:prowl) do |c|
#   c.name = 'tom3'
#   c.apikey = 'f0fc8e1f3121672686337a631527eac2f1b6031c'
#   c.group = 'developers'
# end

# God.contact(:twitter) do |c|
#   c.name = 'tom6'
#   c.consumer_token = 'gOhjax6s0L3mLeaTtBWPw'
#   c.consumer_secret = 'yz4gpAVXJHKxvsGK85tEyzQJ7o2FEy27H1KEWL75jfA'
#   c.access_token = '17376380-qS391nCrgaP4HKXAmZtM38gB56xUXMhx1NYbjT6mQ'
#   c.access_secret = 'uMwCDeU4OXlEBWFQBc3KwGyY8OdWCtAV0Jg5KVB0'
# end

# God.contact(:scout) do |c|
#   c.name = 'tom5'
#   c.client_key = '583a51b5-acbc-2421-a830-b6f3f8e4b04e'
#   c.plugin_id = '230641'
# end

# God.contact(:webhook) do |c|
#   c.name = 'tom'
#   c.url = "http://www.postbin.org/wk7guh"
# end

# God.contact(:jabber) do |c|
#   c.name = 'tom'
#   c.host = 'talk.google.com'
#   c.to_jid = 'mojombo@jabber.org'
#   c.from_jid = 'mojombo@gmail.com'
#   c.password = 'secret'
# end

God.watch do |w|
  w.name = "contact"
  w.interval = 5.seconds
  w.start = "ruby " + File.join(File.dirname(__FILE__), *%w[simple_server.rb])
  w.log = "/Users/tom/contact.log"

  # determine the state on startup
  w.transition(:init, { true = :up, false = :start }) do |on|
    on.condition(:process_running) do |c|
      c.running = true
    end
  end

  # determine when process has finished starting
  w.transition([:start, :restart], :up) do |on|
    on.condition(:process_running) do |c|
      c.running = true
    end

    # failsafe
    on.condition(:tries) do |c|
      c.times = 2
      c.transition = :start
    end
  end

  # start if process is not running
  w.transition(:up, :start) do |on|
    on.condition(:process_exits) do |c|
      c.notify = {:contacts = ['tom'], :priority = 1, :category = 'product'}
    end
  end

  # lifecycle
  w.lifecycle do |on|
    on.condition(:flapping) do |c|
      c.to_state = [:start, :restart]
      c.times = 5
      c.within = 20.seconds
      c.transition = :unmonitored
      c.retry_in = 10.seconds
      c.retry_times = 2
      c.retry_within = 5.minutes
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>simple_server.rb</filename>
			<content>#! /usr/bin/env ruby

loop { puts 'server'; sleep 1 }
</content>
		</actual_file>
		<actual_file>
			<filename>daemon_events.god</filename>
			<content>God.watch do |w|
  w.name = "daemon-events"
  w.interval = 5.seconds
  w.start = 'ruby ' + File.join(File.dirname(__FILE__), *%w[simple_server.rb]) + ' start'
  w.stop = 'ruby ' + File.join(File.dirname(__FILE__), *%w[simple_server_stop.rb])
  w.pid_file = '/var/run/daemon-events.pid'
  w.log = File.join(File.dirname(__FILE__), 'daemon_events.log')
  w.uid = 'tom'
  w.gid = 'tom'

  w.behavior(:clean_pid_file)

  # determine the state on startup
  w.transition(:init, { true = :up, false = :start }) do |on|
    on.condition(:process_running) do |c|
      c.running = true
    end
  end

  # determine when process has finished starting
  w.transition([:start, :restart], :up) do |on|
    on.condition(:process_running) do |c|
      c.running = true
    end

    # failsafe
    on.condition(:tries) do |c|
      c.times = 2
      c.transition = :start
    end
  end

  # start if process is not running
  w.transition(:up, :start) do |on|
    on.condition(:process_exits)
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>simple_server.rb</filename>
			<content>require 'rubygems'
require 'daemons'

puts 'simple server ahoy!'

Daemons.run_proc('daemon-events', {:dir_mode = :system}) do
  loop { puts 'server'; sleep 1 }
end
</content>
		</actual_file>
		<actual_file>
			<filename>simple_server_stop.rb</filename>
			<content># exit!(2)

3.times do
  puts 'waiting'
  sleep 1
end

p ENV

command = '/usr/local/bin/ruby ' + File.join(File.dirname(__FILE__), *%w[simple_server.rb]) + ' stop'
system(command)
</content>
		</actual_file>
		<actual_file>
			<filename>daemon_polls.god</filename>
			<content>God.watch do |w|
  w.name = "daemon-polls"
  w.interval = 5.seconds
  w.start = 'ruby ' + File.join(File.dirname(__FILE__), *%w[simple_server.rb]) + ' start'
  w.stop = 'ruby ' + File.join(File.dirname(__FILE__), *%w[simple_server.rb]) + ' stop'
  w.pid_file = '/var/run/daemon-polls.pid'
  w.start_grace = 2.seconds
  w.log = File.join(File.dirname(__FILE__), *%w[out.log])

  w.behavior(:clean_pid_file)

  w.start_if do |start|
    start.condition(:process_running) do |c|
      c.running = false
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>simple_server.rb</filename>
			<content>require 'rubygems'
require 'daemons'

Daemons.run_proc('daemon-polls', {:dir_mode = :system}) do
  loop { STDOUT.puts('server'); STDOUT.flush; sleep 1 }
end
</content>
		</actual_file>
		<actual_file>
			<filename>degrading_lambda.god</filename>
			<content>God.watch do |w|
  w.name = 'degrading-lambda'
  w.start = 'ruby ' + File.join(File.dirname(__FILE__), *%w[tcp_server.rb])
  w.interval = 5
  w.grace = 2
  w.group = 'test'

  w.start_if do |start|
    start.condition(:process_running) do |c|
      c.running = false
    end
  end

  w.restart_if do |restart|
    restart.condition(:degrading_lambda) do |c|
      require 'socket'
      c.lambda = lambda {
        begin
          sock = TCPSocket.open('127.0.0.1', 9090)
          sock.send "2\n", 0
          retval = sock.gets
          puts "Retval is #{retval}"
          sock.close
          retval
        rescue
          false
        end
      }
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>tcp_server.rb</filename>
			<content>#! /usr/bin/env ruby

require 'socket'
server = TCPServer.new('127.0.0.1', 9090)
while (session = server.accept)
  puts "Found a session"
  request = session.gets
  puts "Request: #{request}"
  time = request.to_i
  puts "Sleeping for #{time}"
  sleep time
  session.print "Slept for #{time} seconds"
  session.close
  puts "Session closed"
end
</content>
		</actual_file>
		<actual_file>
			<filename>keepalive.god</filename>
			<content>God.watch do |w|
  w.name = 'keepalive'
  w.start = File.join(GOD_ROOT, *%w[test configs keepalive keepalive.rb])
  w.log = File.join(GOD_ROOT, *%w[test configs keepalive keepalive.log])

  w.keepalive(:interval = 5.seconds,
              :memory_max = 10.megabytes,
              :cpu_max = 30.percent)
end
</content>
		</actual_file>
		<actual_file>
			<filename>keepalive.rb</filename>
			<content>#! /usr/bin/env ruby

data = ''

loop do
  STDOUT.puts('server');
  STDOUT.flush;

  100000.times { data  'x' }

#  sleep 10
end
</content>
		</actual_file>
		<actual_file>
			<filename>lifecycle.god</filename>
			<content>God::Contacts::Twitter.settings = {
  # this is for my 'mojombo2' twitter test account
  # feel free to use it for testing your conditions
  :username = 'mojombo@gmail.com',
  :password  = 'gok9we3ot1av2e'
}

God.contact(:twitter) do |c|
  c.name      = 'tom2'
  c.group     = 'developers'
end

God.watch do |w|
  w.name = "lifecycle"
  w.interval = 5.seconds
  w.start = "/dev/null"

  # lifecycle
  w.lifecycle do |on|
    on.condition(:always) do |c|
      c.what = true
      c.notify = "tom2"
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>matias.god</filename>
			<content>$pid_file = "/tmp/matias.pid"

God.task do |w|
  w.name = "watcher"
  w.interval = 5.seconds
  w.valid_states = [:init, :up, :down]
  w.initial_state = :init

  # determine the state on startup
  w.transition(:init, { true = :up, false = :down }) do |on|
    on.condition(:process_running) do |c|
      c.running = true
      c.pid_file = $pid_file
    end
  end

  # when process is up
  w.transition(:up, :down) do |on|
    # transition to 'start' if process goes down
    on.condition(:process_running) do |c|
      c.running = false
      c.pid_file = $pid_file
    end

    # send up info
    on.condition(:lambda) do |c|
      c.lambda = lambda do
        puts 'yay I am up'
        false
      end
    end
  end

  # when process is down
  w.transition(:down, :up) do |on|
    # transition to 'up' if process comes up
    on.condition(:process_running) do |c|
      c.running = true
      c.pid_file = $pid_file
    end

    # send down info
    on.condition(:lambda) do |c|
      c.lambda = lambda do
        puts 'boo I am down'
        false
      end
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>running_load.god</filename>
			<content>God.watch do |w|
  w.name = 'running-load'
  w.start = '/Users/tom/dev/god/test/configs/child_polls/simple_server.rb'
  w.stop = ''
  w.interval = 5
  w.grace = 2
  w.uid = 'tom'
  w.gid = 'tom'
  w.group = 'test'

  w.start_if do |start|
    start.condition(:process_running) do |c|
      c.running = false
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>simple_server.rb</filename>
			<content>#! /usr/bin/env ruby

trap :USR1 do

end

loop do
  STDOUT.puts('server');
  STDOUT.flush;

  sleep 10
end
</content>
		</actual_file>
		<actual_file>
			<filename>stop_options.god</filename>
			<content>God.watch do |w|
  w.name = 'stop-options'
  w.start = File.join(GOD_ROOT, *%w[test configs stop_options simple_server.rb])
  w.stop_signal = 'USR1'
  w.stop_timeout = 5
  w.interval = 5
  w.grace = 2

  w.start_if do |start|
    start.condition(:process_running) do |c|
      c.running = false
    end
  end

  w.restart_if do |restart|
    restart.condition(:cpu_usage) do |c|
      c.above = 30.percent
      c.times = [3, 5]
    end

    restart.condition(:memory_usage) do |c|
      c.above = 10.megabytes
      c.times = [3, 5]
    end
  end

  # lifecycle
  w.lifecycle do |on|
    on.condition(:flapping) do |c|
      c.to_state = [:start, :restart]
      c.times = 3
      c.within = 60.seconds
      c.transition = :unmonitored
      c.retry_in = 10.seconds
      c.retry_times = 2
      c.retry_within = 5.minutes
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>simple_server.rb</filename>
			<content>#! /usr/bin/env ruby

loop { puts 'server'; sleep 1 }
</content>
		</actual_file>
		<actual_file>
			<filename>stress.god</filename>
			<content>('01'..'08').each do |i|
  God.watch do |w|
    w.name = "stress-#{i}"
    w.start = "ruby " + File.join(File.dirname(__FILE__), *%w[simple_server.rb])
    w.interval = 0
    w.grace = 2
    w.group = 'test'

    w.start_if do |start|
      start.condition(:process_running) do |c|
        c.running = false
      end
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>task.god</filename>
			<content>LOG_DIR = File.join(File.dirname(__FILE__), *%w[logs])

God.task do |t|
  t.name = 'task'
  t.valid_states = [:ok, :clean]
  t.initial_state = :ok
  t.interval = 5

  # t.clean = lambda do
  #   Dir[File.join(LOG_DIR, '*.log')].each do |f|
  #     File.delete(f)
  #   end
  # end

  t.clean = "rm #{File.join(LOG_DIR, '*.log')}"

  t.transition(:clean, :ok)

  t.transition(:ok, :clean) do |on|
    on.condition(:lambda) do |c|
      c.lambda = lambda do
        Dir[File.join(LOG_DIR, '*.log')].size  1
      end
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>.placeholder</filename>
			<content></content>
		</actual_file>
	</actual_files>
</repo>
<repo>
	<id>29</id>
	<name>jsawesome</name>
	<description>Awesome JSON</description>n	<owner>vanpelt</owner>
	<main_language>JavaScript</main_language>
	<created_at>2008-01-13T06:04:19Z</created_at>
	<updated_at>2014-01-13T16:22:02Z</updated_at>
	<clone_url>https://github.com/vanpelt/jsawesome.git</clone_url>
	<languages>
		<language>Ruby</language>
		<language>JavaScript</language>
	</languages>
	<branches>
		<branch>master</branch>
	</branches>
	<contributors>
		<contributor>vanpelt</contributor>
	</contributors>
	<commits>
		<commit>
			<sha>92bc59717195a6b6eebdf4b9bfde1c3ac5d90c0c</sha>
			<message>Version bump for proper duplication support... IE was freaking out</message>
			<author_name>Chris Van Pelt</author_name>
			<author_date>2008-05-29T20:11:32Z</author_date>
			<author_email>vanpelt@snowwhite-2.local</author_email>
			<committer_name>Chris Van Pelt</committer_name>
			<committer_date>2008-05-29T20:11:32Z</committer_date>
			<committer_email>vanpelt@snowwhite-2.local</committer_email>
			<files>
				<file>
					<file_name>Rakefile</file_name>
					<diff>@@ -12,7 +12,7 @@ require 'rake/packagetask'
 
 $:.unshift File.dirname(__FILE__) + "/lib"
 
-APP_VERSION  = '0.1.5'
+APP_VERSION  = '0.1.6'
 APP_NAME     = 'jsawesome'
 APP_FILE_NAME= "#{APP_NAME}.js"
 </diff>
				</file>
				<file>
					<file_name>src/base.js</file_name>
					<diff>@@ -256,7 +256,10 @@ JSAwesome = new Class({
 	    var ind = orig.name.match(/\[(\d+)\]$/)[1].toInt() + 1
 	    next = orig.name.replace(/\[\d+\]$/, '['+ind+']')
 	  }
-	  orig.clone().set('name', next).inject(orig, 'after')
+	  var inp = new Element(orig.get('tag')).set('name', next)
+	  if(orig.get('tag') != 'textarea')
+	    inp.set('type', orig.get('type'))
+	  inp.inject(orig, 'after')
 	  new Element('br').inject(orig, 'after')
 	},
 	_capitalize: function(string){</diff>
				</file>
				<file>
					<file_name>test/assets/sample.html</file_name>
					<diff>@@ -37,7 +37,7 @@
 	  ['sub_cats', 
 	    {'rad': ['cool', 'neat'], 
 	     'awesome':
-	       {'crazy': ['Indeed|~shit', 'man'],
+	       {'crazy': ['Indeed|~really', 'man'],
 	        'way': ['oh', 'yeah']}
 	    }],
 	  ['sub_cats2', 8]
@@ -48,7 +48,7 @@
     '{}':['Something', 'Something else'],
     'not':'Not Cool',
     'choices':'Many Choices',
-    'real_cool':{label:'Holy Shit', required:true},
+    'real_cool':{label:'Nice', required:true},
     'radios':{required:true, label:'So many choices'},
     sub_cats:{required:true, label:"Sub Categories"},
     textarea:{validation:["cool", "Text area must contain cool"]}</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>52bd2632ccf8b109d5b5d774d547bfd12664bfd3</sha>
			<message>minor bug where for disposing select tags in a floated row...</message>
			<author_name>Chris Van Pelt</author_name>
			<author_date>2008-05-02T19:54:20Z</author_date>
			<author_email>vanpelt@snowwhite.local</author_email>
			<committer_name>Chris Van Pelt</committer_name>
			<committer_date>2008-05-02T19:54:20Z</committer_date>
			<committer_email>vanpelt@snowwhite.local</committer_email>
			<files>
				<file>
					<file_name>src/base.js</file_name>
					<diff>@@ -310,8 +310,11 @@ JSAwesome = new Class({
           var klass = e.get('class').split(' ')[0]
           var verify = new RegExp("("+name+')_\\d+$')
           var next = klass.test(verify) ? klass.replace(verify, '$1_'+(level+1)) : klass+'_'+(level+1) 
-          //Dispose namespaced in a wrapper
-          $$('#'+this.name+' .'+klass.replace(verify,'$1'))[0].getElements('.custom, select').each(function(i){
+          //Dispose namespaced in a wrapper (Make this better for floated elements...)
+          var test = $$('#'+this.name+' .'+klass.replace(verify,'$1'))[0]
+          if(test.get('tag') != 'div')
+            test = test.getParent('div')
+          test.getElements('.custom, select').each(function(i){
             if(i.hasClass('custom') || i.retrieve('level')  level+1)
               i.dispose()
           })</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>fa39785a45bf1cec2acadbd5c4bc941c58c7a28e</sha>
			<message>Funky duplicate edge case dealt with because Mechanical Turk doesnt handle post data like the rest of the world.  Proper radio button validation.  Better form validation period.</message>
			<author_name>Chris Van Pelt</author_name>
			<author_date>2008-05-02T00:00:21Z</author_date>
			<author_email>vanpelt@snowwhite.local</author_email>
			<committer_name>Chris Van Pelt</committer_name>
			<committer_date>2008-05-02T00:00:21Z</committer_date>
			<committer_email>vanpelt@snowwhite.local</committer_email>
			<files>
				<file>
					<file_name>Rakefile</file_name>
					<diff>@@ -12,7 +12,7 @@ require 'rake/packagetask'
 
 $:.unshift File.dirname(__FILE__) + "/lib"
 
-APP_VERSION  = '0.1.4'
+APP_VERSION  = '0.1.5'
 APP_NAME     = 'jsawesome'
 APP_FILE_NAME= "#{APP_NAME}.js"
 </diff>
				</file>
				<file>
					<file_name>src/base.js</file_name>
					<diff>@@ -88,7 +88,7 @@ JSAwesome = new Class({
 	    $(this.name).getParent('form').removeEvent('submit', this.validater)
 	},
 	validate: function(e) {
-	  return this.validations.filter(function(r){
+	  var valid = this.validations.filter(function(r){
 	    var checking = $(this.name).getElement('div .'+this._clean(r))
 	    var error = checking.getParent('.error')
 	    var invalid = this._check(checking)
@@ -119,6 +119,9 @@ JSAwesome = new Class({
 	    } else 
 	      return false
 	  }, this).length == 0
+	  if(!valid && $type(e) == "event")
+      e.stop()
+    return valid
 	},
 	_reset: function() { delay = 100 },
 	_check: function(element) {
@@ -132,8 +135,8 @@ JSAwesome = new Class({
       });
       if(invalid) return ["This is a required field", element, 'change']
     } else if(element.get('type') == "radio" && label['required']) {
-      var radios = element.getParent('fieldset').getElements('input')
-      if(radios.some(function(r){return r.get('value')}))
+      var radios = element.getParent('fieldset').getElements('input[type=radio]')
+      if(radios.some(function(r){return r.checked}))
         return false
       else
         return ["You must choose an option", new Elements(radios), 'click']
@@ -244,9 +247,16 @@ JSAwesome = new Class({
 	duplicate: function(e) {
 	  e.stop()
 	  var orig = e.target.getPrevious()
-	  if(!orig.name.test(/\[\]$/))
-	    orig.name = orig.name+"[]"
-	  orig.clone().inject(orig, 'after')
+	  var next = ""
+	  //Because mechanical turk sucks ass
+	  if(!orig.name.test(/\[\d+\]$/)) {
+	    next = orig.name+"[1]"
+	    orig.name = orig.name+"[0]"
+	  } else {
+	    var ind = orig.name.match(/\[(\d+)\]$/)[1].toInt() + 1
+	    next = orig.name.replace(/\[\d+\]$/, '['+ind+']')
+	  }
+	  orig.clone().set('name', next).inject(orig, 'after')
 	  new Element('br').inject(orig, 'after')
 	},
 	_capitalize: function(string){</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>3e4cf5da1ae11745b5105bedf8ff4eebfa751511</sha>
			<message>Added reference to blog entry, made it work with the latest moo.  Set the stage for minimizing the amount of moo used</message>
			<author_name>Chris Van Pelt</author_name>
			<author_date>2008-04-22T09:34:30Z</author_date>
			<author_email>vanpelt@snowwhite.local</author_email>
			<committer_name>Chris Van Pelt</committer_name>
			<committer_date>2008-04-22T09:34:30Z</committer_date>
			<committer_email>vanpelt@snowwhite.local</committer_email>
			<files>
			</files>
		</commit>
		<commit>
			<sha>22f201bbf9dcc431fec113c1e5f724fb19d2d456</sha>
			<message>Made required work alongside regex so you can have a regex validation that only fires if the element isnt empty</message>
			<author_name>Chris Van Pelt</author_name>
			<author_date>2008-04-17T20:32:06Z</author_date>
			<author_email>vanpelt@snowwhite.local</author_email>
			<committer_name>Chris Van Pelt</committer_name>
			<committer_date>2008-04-17T20:32:06Z</committer_date>
			<committer_email>vanpelt@snowwhite.local</committer_email>
			<files>
				<file>
					<file_name>Rakefile</file_name>
					<diff>@@ -12,7 +12,7 @@ require 'rake/packagetask'
 
 $:.unshift File.dirname(__FILE__) + "/lib"
 
-APP_VERSION  = '0.1.3'
+APP_VERSION  = '0.1.4'
 APP_NAME     = 'jsawesome'
 APP_FILE_NAME= "#{APP_NAME}.js"
 </diff>
				</file>
				<file>
					<file_name>src/base.js</file_name>
					<diff>@@ -147,6 +147,8 @@ JSAwesome = new Class({
     else if(label['validation']) {
       var args = $splat(label['validation'][0])
       var regex = new RegExp(args[0], args[1])
+      if(!label['required'] && element.get('value').test(/^\s*$/))
+        return false
       return (regex.test(element.get('value')) ? false : [label['validation'][1], element])
     }
 	},</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>332a2e421abbe3a4d84ff90e428b71496964ee03</sha>
			<message>Wrong order for checkbox...</message>
			<author_name>Chris Van Pelt</author_name>
			<author_date>2008-04-10T01:15:37Z</author_date>
			<author_email>vanpelt@snowwhite.local</author_email>
			<committer_name>Chris Van Pelt</committer_name>
			<committer_date>2008-04-10T01:15:37Z</committer_date>
			<committer_email>vanpelt@snowwhite.local</committer_email>
			<files>
				<file>
					<file_name>src/base.js</file_name>
					<diff>@@ -264,7 +264,7 @@ JSAwesome = new Class({
     if(type == "checkbox") {
       e.set('checked', val ? "checked" : "")
       e.set('value', 'true')
-      e = new Element('span').adopt([this._input('hidden', name, 'false'), e])
+      e = new Element('span').adopt([e, this._input('hidden', name, 'false')])
     } else
       e.set('value', val)
     return e</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>2ec74792af723a358ce8ba0a549002dd6eb45332</sha>
			<message>Ahhh if only I used my testing framework...</message>
			<author_name>Chris Van Pelt</author_name>
			<author_date>2008-04-09T08:35:21Z</author_date>
			<author_email>vanpelt@snowwhite.local</author_email>
			<committer_name>Chris Van Pelt</committer_name>
			<committer_date>2008-04-09T08:35:21Z</committer_date>
			<committer_email>vanpelt@snowwhite.local</committer_email>
			<files>
				<file>
					<file_name>src/base.js</file_name>
					<diff>@@ -260,12 +260,12 @@ JSAwesome = new Class({
 	  return this.name+'_'+this._clean(name)
 	},
 	_input: function(type, name, val) {
-	  e = new Element('input', {type: type, 'class': this._clean(name), name: this._name(name), id: (type =='radio' ? '' : this._id(name))})
-    if(type == "checkbox")
+	  var e = new Element('input', {type: type, 'class': this._clean(name), name: this._name(name), id: (type =='radio' ? '' : this._id(name))})
+    if(type == "checkbox") {
       e.set('checked', val ? "checked" : "")
       e.set('value', 'true')
-      e = [this._input('hidden', name, 'false'), e]
-    else
+      e = new Element('span').adopt([this._input('hidden', name, 'false'), e])
+    } else
       e.set('value', val)
     return e
 	},</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>99a33ffae218542e9ebc73504c4a9aaf5e73759c</sha>
			<message>Checkboxes are submiting when not selected.  Version bump</message>
			<author_name>Chris Van Pelt</author_name>
			<author_date>2008-04-09T08:24:37Z</author_date>
			<author_email>vanpelt@snowwhite.local</author_email>
			<committer_name>Chris Van Pelt</committer_name>
			<committer_date>2008-04-09T08:24:37Z</committer_date>
			<committer_email>vanpelt@snowwhite.local</committer_email>
			<files>
				<file>
					<file_name>.gitignore</file_name>
					<diff>@@ -0,0 +1 @@
+dist</diff>
				</file>
				<file>
					<file_name>History.txt</file_name>
					<diff>@@ -1,3 +1,9 @@
+== 0.1.3 2008-04-09
+* Checkboxes automagically have a hidden field to make sure un-selected ones are sent.  Values are true / false
+
+== 0.1.2 2008-03-21
+* Fixed a bug where radio button groups didn't work in Firefox because of duplicate ids
+
 == 0.1.1 2008-03-13
 * Added a '+' delineator for any field that can be duplicated...
 * Made selects only sort if they are a sub-select</diff>
				</file>
				<file>
					<file_name>Rakefile</file_name>
					<diff>@@ -12,7 +12,7 @@ require 'rake/packagetask'
 
 $:.unshift File.dirname(__FILE__) + "/lib"
 
-APP_VERSION  = '0.1.2'
+APP_VERSION  = '0.1.3'
 APP_NAME     = 'jsawesome'
 APP_FILE_NAME= "#{APP_NAME}.js"
 </diff>
				</file>
				<file>
					<file_name>src/base.js</file_name>
					<diff>@@ -58,7 +58,7 @@ JSAwesome = new Class({
 	      newname = null
 	  }
 	  if(!$defined(newname))
-	    newname = name.replace(/_/g,' ').capitalize()
+	    newname = this._capitalize(name.replace(/_/g,' '))
 	  return ($type(wafor) == "element" ? wafor.set('html', newname) : new Element('label', {'for':this._id(wafor), 'html':newname}))
 	},
 	addValidation: function(wha){
@@ -247,6 +247,9 @@ JSAwesome = new Class({
 	  orig.clone().inject(orig, 'after')
 	  new Element('br').inject(orig, 'after')
 	},
+	_capitalize: function(string){
+		return string.replace(/^[a-z]/, function(match){ return match.toUpperCase() });
+	},
 	_clean: function(name) {
 	  return name.replace(/^[_#*^~]?\+?/,'')
 	},
@@ -260,6 +263,8 @@ JSAwesome = new Class({
 	  e = new Element('input', {type: type, 'class': this._clean(name), name: this._name(name), id: (type =='radio' ? '' : this._id(name))})
     if(type == "checkbox")
       e.set('checked', val ? "checked" : "")
+      e.set('value', 'true')
+      e = [this._input('hidden', name, 'false'), e]
     else
       e.set('value', val)
     return e</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>555d03005b384c9ab5849fd14f2b6ed10961495a</sha>
			<message>Dealt with multi id bug for radios in Firefox</message>
			<author_name>Chris Van Pelt</author_name>
			<author_date>2008-03-20T22:58:58Z</author_date>
			<author_email>vanpelt@snowwhite.local</author_email>
			<committer_name>Chris Van Pelt</committer_name>
			<committer_date>2008-03-20T22:58:58Z</committer_date>
			<committer_email>vanpelt@snowwhite.local</committer_email>
			<files>
				<file>
					<file_name>Rakefile</file_name>
					<diff>@@ -12,7 +12,7 @@ require 'rake/packagetask'
 
 $:.unshift File.dirname(__FILE__) + "/lib"
 
-APP_VERSION  = '0.1.1'
+APP_VERSION  = '0.1.2'
 APP_NAME     = 'jsawesome'
 APP_FILE_NAME= "#{APP_NAME}.js"
 
@@ -117,4 +117,4 @@ end
 
 Dir['tasks/**/*.rake'].each { |rake| load rake }
 
-end
\ No newline at end of file
+end</diff>
				</file>
				<file>
					<file_name>src/base.js</file_name>
					<diff>@@ -257,7 +257,7 @@ JSAwesome = new Class({
 	  return this.name+'_'+this._clean(name)
 	},
 	_input: function(type, name, val) {
-	  e = new Element('input', {type: type, 'class': this._clean(name), name: this._name(name), id: this._id(name)})
+	  e = new Element('input', {type: type, 'class': this._clean(name), name: this._name(name), id: (type =='radio' ? '' : this._id(name))})
     if(type == "checkbox")
       e.set('checked', val ? "checked" : "")
     else</diff>
				</file>
				<file>
					<file_name>test/assets/sample.html</file_name>
					<diff>@@ -53,9 +53,21 @@
     sub_cats:{required:true, label:"Sub Categories"},
     textarea:{validation:["cool", "Text area must contain cool"]}
   }
-	var js = new JSAwesome('test', json, labels)
-	js.to_html()
-	js.addValidation()
+	var test = new JSAwesome('test', json, labels)
+	test.to_html()
+	test.addValidation()
+	window.addEvent('load', function(){
+    $$('input.not').each(function(i){
+      i.addEvent('click', function(){
+        var id = this.getParent('div.error').getParent().get('id')
+        var awesome = eval(id)
+        if(this.checked)
+           awesome.stopValidation(/radio/)
+        else
+           awesome.addValidation(/radio/)
+      })
+    })
+  })
 /script
 /body
 /html
\ No newline at end of file</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>9c4cd600c55717011d45f522b11b5f973b21084a</sha>
			<message>Added a multiple input option, not sorting by default, label fixes</message>
			<author_name>Chris Van Pelt</author_name>
			<author_date>2008-03-13T23:10:05Z</author_date>
			<author_email>vanpelt@snowwhite.local</author_email>
			<committer_name>Chris Van Pelt</committer_name>
			<committer_date>2008-03-13T23:10:05Z</committer_date>
			<committer_email>vanpelt@snowwhite.local</committer_email>
			<files>
				<file>
					<file_name>History.txt</file_name>
					<diff>@@ -1,3 +1,11 @@
+== 0.1.1 2008-03-13
+* Added a '+' delineator for any field that can be duplicated...
+* Made selects only sort if they are a sub-select
+* Fixed label bug for delineated fields
+
+== 0.1.0 2008-03-05
+* Form validation start and stop (...buggy)
+
 == 0.0.9 2008-02-23
 
 * A major refactor of the sub-select logic</diff>
				</file>
				<file>
					<file_name>Rakefile</file_name>
					<diff>@@ -12,7 +12,7 @@ require 'rake/packagetask'
 
 $:.unshift File.dirname(__FILE__) + "/lib"
 
-APP_VERSION  = '0.1.0'
+APP_VERSION  = '0.1.1'
 APP_NAME     = 'jsawesome'
 APP_FILE_NAME= "#{APP_NAME}.js"
 </diff>
				</file>
				<file>
					<file_name>src/base.js</file_name>
					<diff>@@ -37,7 +37,7 @@ JSAwesome = new Class({
 	    var klass = $type(p[0]) == "string" ? this._clean(p[0]) : "row_"+(i+1)
 	    m.push(new Element('div', {'class':'error '+klass}).adopt(n))
 	  }, this);
-	  var adopted = $(this.name).adopt(m)
+	  var adopted = $(this.name).adopt(m.concat($(this.name).getChildren().dispose()))
 	  adopted.getElements('select').each(function(e){
 	    e.fireEvent('change', {target:e})
 	  })
@@ -48,6 +48,7 @@ JSAwesome = new Class({
 	},
 	label: function(name, wafor) {
 	  var newname = null
+	  name = this._clean(name)
 	  if($defined(this.labels[name])) {
 	    if($defined(this.labels[name]['label']))
 	      newname = this.labels[name]['label']
@@ -57,7 +58,7 @@ JSAwesome = new Class({
 	      newname = null
 	  }
 	  if(!$defined(newname))
-	    newname = this._clean(name).replace(/_/g,' ').capitalize()
+	    newname = name.replace(/_/g,' ').capitalize()
 	  return ($type(wafor) == "element" ? wafor.set('html', newname) : new Element('label', {'for':this._id(wafor), 'html':newname}))
 	},
 	addValidation: function(wha){
@@ -162,12 +163,14 @@ JSAwesome = new Class({
 	          }, this))
 	        );
 	      } else {          
-          //Sort the options, and make the other / custom field go to the end...
-          cur = cur.sort()
-          var other = false
-          cur.some(function(a){ return a.test(/~/) ? other = a : other})
-          if(other)
-            cur.remove(other).push(other)
+          //Sort the options, and make the other / custom field go to the end... if it's a nested select
+          if(parent) {
+            cur = cur.sort()
+            var other = false
+            cur.some(function(a){ return a.test(/~/) ? other = a : other})
+            if(other)
+              cur.remove(other).push(other)
+          }
           //Add the default header
           if(cur.length  1)
 	          cur = [parent ? select_default[1] : select_default[0]].concat(cur)
@@ -227,14 +230,25 @@ JSAwesome = new Class({
             e = this.label(tname, val || tname).grab(
               this._input('checkbox', (val || tname), parent === true), 'top')
 	        } else e = this._input('text', name, cur)
+	        //For duplication...
+	        if(name.test(/^.?\+/))
+	          e = [e, new Element('a', {html:' +', href:'#', events:{click:this.duplicate}, 'class':'plus'})]
 	        if(!name.test(/^[_*^]/))
 	          e = [this.label(name, name), e]
 	      }
 	      return e
 	  }
 	},
+	duplicate: function(e) {
+	  e.stop()
+	  var orig = e.target.getPrevious()
+	  if(!orig.name.test(/\[\]$/))
+	    orig.name = orig.name+"[]"
+	  orig.clone().inject(orig, 'after')
+	  new Element('br').inject(orig, 'after')
+	},
 	_clean: function(name) {
-	  return name.replace(/^[_#*^~]/,'')
+	  return name.replace(/^[_#*^~]?\+?/,'')
 	},
 	_name: function(name) {
 	  return this.name+'['+this._clean(name)+']'</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>e5473b9cd757ab5b79181da1e131f3d519dae340</sha>
			<message>Supports html inserstion, selective validation, better naming scheme, general sexyness</message>
			<author_name>Chris Van Pelt</author_name>
			<author_date>2008-03-04T09:14:22Z</author_date>
			<author_email>vanpelt@snowwhite.local</author_email>
			<committer_name>Chris Van Pelt</committer_name>
			<committer_date>2008-03-04T09:14:22Z</committer_date>
			<committer_email>vanpelt@snowwhite.local</committer_email>
			<files>
				<file>
					<file_name>src/base.js</file_name>
					<diff>@@ -9,6 +9,7 @@ JSAwesome = new Class({
 	  this.name = name
 		this.json = json
 		this.labels = labels || {}
+		this.validatables = []
 		this.validations = $H(labels).getKeys().filter(function(f){
 		  return labels[f]['required'] || labels[f]['validation']
 		})
@@ -23,12 +24,17 @@ JSAwesome = new Class({
 	    if($type(p[0])=="array"){
 	      n.push(p.map(function(r){
 	        r = $splat(r)
+	        n.push(this.extra('before', r[0]))
 	        return new Element('div', {style:'float:left;margin-right:5px'}).adopt(this._process(r[1],r[0]))
 	      }, this))
 	      n.push(new Element('br', {style:'clear:left'}))
-	    } else
+	      n.push(this.extra('after', $splat(p.getLast())[0]))
+	    } else {
+	      n.push(this.extra('before', p[0]))
 	      n.push(this._process(p[1],p[0]))
-	    var klass = $type(p[0]) == "string" ? p[0].replace(/^[_#*^]/,'') : "row_"+(i+1)
+	      n.push(this.extra('after', p[0]))
+	    }
+	    var klass = $type(p[0]) == "string" ? this._clean(p[0]) : "row_"+(i+1)
 	    m.push(new Element('div', {'class':'error '+klass}).adopt(n))
 	  }, this);
 	  var adopted = $(this.name).adopt(m)
@@ -37,6 +43,9 @@ JSAwesome = new Class({
 	  })
 	 return adopted
 	},
+	extra: function(where, what) {
+	  return this.labels[where+'_'+what] ? new Element('div', {html: this.labels[where+'_'+what]}) : null
+	},
 	label: function(name, wafor) {
 	  var newname = null
 	  if($defined(this.labels[name])) {
@@ -48,19 +57,38 @@ JSAwesome = new Class({
 	      newname = null
 	  }
 	  if(!$defined(newname))
-	    newname = name.replace(/^[_#*^]/,'').replace(/_/g,' ').capitalize()
-	  return ($type(wafor) == "element" ? wafor.set('html', newname) : new Element('label', {'for':wafor, 'html':newname}))
+	    newname = this._clean(name).replace(/_/g,' ').capitalize()
+	  return ($type(wafor) == "element" ? wafor.set('html', newname) : new Element('label', {'for':this._id(wafor), 'html':newname}))
 	},
-	addValidation: function(){
-	  this.validater = this.validate.bind(this)
-	  $(this.name).getParent('form').addEvent('submit', this.validater)
+	addValidation: function(wha){
+	  if(wha) {
+	    this.validatables.each(function(v){
+	      //There is an undefined element in IE for some sick reason
+	      if(v && v.test(wha)) {
+	        this.validatables.remove(v)
+	        this.validations.push(v)
+	      }
+	    }, this)
+	  } else {
+	    this.validater = this.validate.bind(this)
+	    $(this.name).getParent('form').addEvent('submit', this.validater)
+	  }
 	},
-	stopValidation: function(){
-	  $(this.name).getParent('form').removeEvent('submit', this.validater)
+	stopValidation: function(wha){
+	  if(wha) {
+	    this.validations.each(function(v){
+	      //There is an undefined element in IE for some sick reason
+	      if(v && v.test(wha)) {
+	        this.validations.remove(v)
+	        this.validatables.push(v)
+	      }
+	    }, this)
+	  } else
+	    $(this.name).getParent('form').removeEvent('submit', this.validater)
 	},
 	validate: function(e) {
 	  return this.validations.filter(function(r){
-	    var checking = $(this.name).getElement('div .'+r.replace(/^[_#~*^]/,''))
+	    var checking = $(this.name).getElement('div .'+this._clean(r))
 	    var error = checking.getParent('.error')
 	    var invalid = this._check(checking)
 	    if(invalid) {
@@ -128,7 +156,7 @@ JSAwesome = new Class({
 	    case 'array':
 	      if(name.test(/^[*^]/)) {
 	        return new Element('fieldset').adopt(
-	          [this.label(name.replace(/^[*^]/,''), new Element('legend'))].concat(cur.map(function(c){
+	          [this.label(this._clean(name), new Element('legend'))].concat(cur.map(function(c){
 	            c = $splat(c)
 	            return this._process(c[0], name, c.getLast());
 	          }, this))
@@ -149,7 +177,7 @@ JSAwesome = new Class({
 	          parent.$attributes.extra = this._select(name, cur, klass, level)
 	          return null
 	        } else if(cur.length  0)
-	          return [this.label(name, this.name+'_'+name),this._select(name, cur, klass, level)]
+	          return [this.label(name, name),this._select(name, cur, klass, level)]
 	        else return null
 	      }
 	    case 'object':
@@ -169,43 +197,53 @@ JSAwesome = new Class({
 	        //There should be a better way to do this
 	        var reversed = [].concat(select_default).reverse()
 	        var val = cur.split('|').getLast().replace(new RegExp(reversed.join("|")),'')
-	        cur = cur.split('|')[0].replace(/^[~*]/,'')
+	        cur = this._clean(cur.split('|')[0])
 	      }
 	      if($type(parent) == "element") {
 	        //Allows for custom values
-	        e = new Element('option', {html: cur, value: val.replace(/^~/,'')})
+	        e = new Element('option', {html: cur, value: this._clean(val)})
 	        if(val.test(/^~/))
-            e.$attributes.extra = this._custom(parent.get('name')+'_other', parent.get('name'))
+            e.$attributes.extra = this._custom(parent.get('name').replace(/(.+)\[(.+)\]/, '$1[$2_other]'), parent.get('class'))
 	      } else {
 	        if(name.test(/^#/)) {
 	          e = new Element('textarea', {
-	            name: this.name+'_'+name.substring(1), 
-	            'class':name.substring(1), 
+	            name: this._name(name),
+	            id: this._id(name),
+	            'class':this._clean(name), 
 	            html: cur})
 	        } else if(name.test(/^_/)) {
-	          e = this._input('hidden', name.substring(1), cur)
+	          e = this._input('hidden', name, cur)
 	        } else if(name.test(/^\*/)) {
-            e = this.label(cur, this.name+'_'+name.substring(1)).grab(
-              this._input('radio', name.substring(1), val), 'top')
+            e = this.label(cur, name).grab(
+              this._input('radio', name, val), 'top')
           } else if(name.test(/^\^/)) {
             //handles both grouped checkboxes and individual ones... Kindof a Mind FFFF
             if($defined(parent))
               var tname = cur
             else {
               parent = cur
-              var tname = name.substring(1)
+              var tname = name
             }
-            e = this.label(tname, this.name+'_'+(val || tname)).grab(
+            e = this.label(tname, val || tname).grab(
               this._input('checkbox', (val || tname), parent === true), 'top')
 	        } else e = this._input('text', name, cur)
 	        if(!name.test(/^[_*^]/))
-	          e = [this.label(name, e.name), e]
+	          e = [this.label(name, name), e]
 	      }
 	      return e
 	  }
 	},
+	_clean: function(name) {
+	  return name.replace(/^[_#*^~]/,'')
+	},
+	_name: function(name) {
+	  return this.name+'['+this._clean(name)+']'
+	},
+	_id: function(name) {
+	  return this.name+'_'+this._clean(name)
+	},
 	_input: function(type, name, val) {
-	  e = new Element('input', {type: type, 'class': name, name: this.name+'_'+name})
+	  e = new Element('input', {type: type, 'class': this._clean(name), name: this._name(name), id: this._id(name)})
     if(type == "checkbox")
       e.set('checked', val ? "checked" : "")
     else
@@ -229,8 +267,10 @@ JSAwesome = new Class({
 	},
 	_select: function(name, options, klass, level) {
 	  var level = level || 0
+	  var leveled = level  0 ? name + '_' + level : name
 	  var select = new Element("select", {
-      name: this.name + '_' + (level  0 ? name + '_' + level : name),
+      name: this._name(leveled),
+      id: this._id(leveled),
       'class': klass,
       events: {
         change: function(event){</diff>
				</file>
				<file>
					<file_name>test/functional/select_test.html</file_name>
					<diff>@@ -71,7 +71,7 @@
       tb = new JSAwesome(name, [['select',['1','2','3','4']]])
       tb.to_html()
       var select = $N('select.select')[0]
-      assertEqual(name+"_select", select.name)
+      assertEqual(name+"[select]", select.name)
       assertEqual(5,select.getElements('option').length)
       assertEqual("", select.value)
       var label = $N('label')
@@ -84,7 +84,7 @@
       })
       tb.to_html()
       var select = $N('select.select')[0]
-      assertEqual(name+"_select", select.name)
+      assertEqual(name+"[select]", select.name)
       assertEqual(5,select.getElements('option').length)
       assertEqual("", select.value)
       var label = $N('label')</diff>
				</file>
				<file>
					<file_name>test/functional/text_box_test.html</file_name>
					<diff>@@ -64,7 +64,7 @@
       var tb = new JSAwesome(name, [['text_box','']])
       tb.to_html()
       var box = $N('input.text_box')[0]
-      assertEqual(name+"_text_box", box.name)
+      assertEqual(name+"[text_box]", box.name)
       assertEqual("", box.value)
       var label = $N('label')[0]
       assertEqual("Text Box", label.get("html"))
@@ -74,7 +74,7 @@
       var tb = new JSAwesome(name, [['text_box','Default value']], {text_box:"Custom"})
       tb.to_html()
       var box = $N('input.text_box')[0]
-      assertEqual(name+"_text_box", box.name)
+      assertEqual(name+"[text_box]", box.name)
       assertEqual("Default value", box.value)
       var label = $N('label')[0]
       assertEqual("Custom", label.get("html"))
@@ -84,7 +84,7 @@
       var tb = new JSAwesome(name, [['text_box', 'invalid']], {text_box: {validation:["^valid", "Is invalid"]}})
       tb.to_html()
       var box = $N('input.text_box')[0]
-      assertEqual(name+"_text_box", box.name)
+      assertEqual(name+"[text_box]", box.name)
       assertEqual("invalid", box.value)
       var label = $N('label')[0]
       assertEqual("Text Box", label.get("html"))
@@ -97,7 +97,7 @@
       var tb = new JSAwesome(name, [['text_box', null]], {text_box: {required:true}})
       tb.to_html()
       var box = $N('input.text_box')[0]
-      assertEqual(name+"_text_box", box.name)
+      assertEqual(name+"[text_box]", box.name)
       assertEqual("", box.value)
       assert(!tb.validate())
       var warning = $N('div.error span')[0]
@@ -125,8 +125,8 @@
       tb.to_html()
       var boxes = $$('div.row_1 input')
       assertEqual(2, boxes.length)
-      assertEqual(name+"_text_box1", boxes[0].name)
-      assertEqual(name+"_text_box2", boxes[1].name)
+      assertEqual(name+"[text_box1]", boxes[0].name)
+      assertEqual(name+"[text_box2]", boxes[1].name)
       assertEqual("", boxes[0].value)
       assertEqual("", boxes[1].value)
       assertEqual("Text Box1", $E('label[for='+name+'_text_box1]').get("html"))
@@ -140,7 +140,7 @@
       var labels = $N('label')
       assertEqual(2, boxes.length)
       assertEqual(2, labels.length)
-      assertEqual(name+"_text_box1", boxes[0].name)      
+      assertEqual(name+"[text_box1]", boxes[0].name)      
       assertEqual("default", boxes[0].value)
       assertEqual("", boxes[1].value)
       assertEqual("Text Box1", labels[0].get("html"))</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>414ef5ab1613a74ec33565ea6199a52c5e28ed5e</sha>
			<message>Handles nested selects better</message>
			<author_name>Chris Van Pelt</author_name>
			<author_date>2008-02-29T22:33:35Z</author_date>
			<author_email>vanpelt@snowwhite.local</author_email>
			<committer_name>Chris Van Pelt</committer_name>
			<committer_date>2008-02-29T22:33:35Z</committer_date>
			<committer_email>vanpelt@snowwhite.local</committer_email>
			<files>
				<file>
					<file_name>Rakefile</file_name>
					<diff>@@ -12,7 +12,7 @@ require 'rake/packagetask'
 
 $:.unshift File.dirname(__FILE__) + "/lib"
 
-APP_VERSION  = '0.0.9'
+APP_VERSION  = '0.1.0'
 APP_NAME     = 'jsawesome'
 APP_FILE_NAME= "#{APP_NAME}.js"
 </diff>
				</file>
				<file>
					<file_name>src/base.js</file_name>
					<diff>@@ -30,7 +30,6 @@ JSAwesome = new Class({
 	      n.push(this._process(p[1],p[0]))
 	    var klass = $type(p[0]) == "string" ? p[0].replace(/^[_#*^]/,'') : "row_"+(i+1)
 	    m.push(new Element('div', {'class':'error '+klass}).adopt(n))
-	    this.level = 0
 	  }, this);
 	  var adopted = $(this.name).adopt(m)
 	  adopted.getElements('select').each(function(e){
@@ -134,28 +133,30 @@ JSAwesome = new Class({
 	            return this._process(c[0], name, c.getLast());
 	          }, this))
 	        );
-	      } else {
+	      } else {          
           //Sort the options, and make the other / custom field go to the end...
           cur = cur.sort()
           var other = false
-          cur.some(function(a){ return a.test(/~/) ? a : other})
+          cur.some(function(a){ return a.test(/~/) ? other = a : other})
           if(other)
             cur.remove(other).push(other)
           //Add the default header
-	        cur = [parent ? select_default[1] : select_default[0]].concat(cur)
+          if(cur.length  1)
+	          cur = [parent ? select_default[1] : select_default[0]].concat(cur)
 	        var level = parent ? parent.getParent().$attributes.level : null
 	        var klass = [name,level].clean().join("_")
-	        if(parent) {
-	          parent.$attributes.extra = this._select(name, cur, klass)
+	        if(parent && cur.length  0) {
+	          parent.$attributes.extra = this._select(name, cur, klass, level)
 	          return null
-	        } else
-	          return [this.label(name, this.name+'_'+name),this._select(name, cur, klass)]
+	        } else if(cur.length  0)
+	          return [this.label(name, this.name+'_'+name),this._select(name, cur, klass, level)]
+	        else return null
 	      }
 	    case 'object':
 	      cur = $H(cur)
 	      var t = [this._process(cur.getKeys(), name, parent)]
 	      var root = parent ? parent.$attributes.extra : t[0][1]
-	      t.push(this._process([], name, root.getElement('option')))
+	      t.push(this._process([select_default[1]], name, root.getElement('option')))
 	      return t.concat(cur.getValues().map(function(v){
 	        var val = cur.keyOf(v).split('|').getLast()
 	        var parent = root.getElement('option[value='+val+']')
@@ -226,8 +227,8 @@ JSAwesome = new Class({
       }
     })
 	},
-	_select: function(name, options, klass) {
-	  var level = klass.split("_").pop().toInt() || 0
+	_select: function(name, options, klass, level) {
+	  var level = level || 0
 	  var select = new Element("select", {
       name: this.name + '_' + (level  0 ? name + '_' + level : name),
       'class': klass,
@@ -235,12 +236,12 @@ JSAwesome = new Class({
         change: function(event){
           var e = event.target
           var option = e[e.selectedIndex]
-          var level = e.$attributes.level
           var klass = e.get('class').split(' ')[0]
-          var next = klass.test(/\d+$/) ? klass.replace(/\d+$/, level) : klass+'_'+level 
+          var verify = new RegExp("("+name+')_\\d+$')
+          var next = klass.test(verify) ? klass.replace(verify, '$1_'+(level+1)) : klass+'_'+(level+1) 
           //Dispose namespaced in a wrapper
-          $E('#'+this.name+' .'+klass.replace(/_\d+$/,'')).getElements('.custom, select').each(function(i){
-            if(i.hasClass('custom') || i.$attributes.level  level)
+          $E('#'+this.name+' .'+klass.replace(verify,'$1')).getElements('.custom, select').each(function(i){
+            if(i.hasClass('custom') || i.$attributes.level  level+1)
               i.dispose()
           })
           if(!option.$attributes.extra) return</diff>
				</file>
				<file>
					<file_name>test/assets/nested.html</file_name>
					<diff>@@ -0,0 +1,50 @@
+!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
+	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
+
+html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
+head
+	meta http-equiv="Content-Type" content="text/html; charset=utf-8"/
+
+	titleJSAwesome!/title
+	script src="../../src/mootools.js" type="text/javascript" charset="utf-8"/script
+	script src="../../src/base.js" type="text/javascript" charset="utf-8"/script
+	style type="text/css" media="screen"
+		label{
+			display:block;
+		}
+		div {
+		  margin-bottom:10px;
+		}
+	/style
+/head
+
+body
+	form method="post" id="form" action="http://www.doloreslabs.com"
+		div id="test"
+		/div
+		input type="submit"/
+	/form
+script type="text/javascript" charset="utf-8"
+  var json = [["category_1",{
+    "Other|~11":[],
+    "Performing Arts|8":["Ballet|39","Cabaret &amp; Review|40","Comedy|41","Literary Arts|42","Musicals|43","Opera|44","Poetry|45","Puppetry|46","Street Performance|47","Symphony|48","Theater|49","Other|~0"],
+    "Music|7":["Alternative|34","Jazz|35","R&amp;B|36","Rock|37","Techno &amp; Dance|38","Country|72","Classical|80","Folk|1044","World Music|1045","Gospel|1046","Pop|1047","Blues|1048","Rap\/Hip-Hop|1087","Other|~0"],
+    "Fairs &amp; Festivals|5":[],
+    "Community|2":["Activism|15","Charity &amp; Volunteer|16","Ethnic &amp; Cultural|17","Libraries|18","Parades|19","Religion|20","Talks &amp; Lectures|21","Workshops &amp; Classes|22","Antiques &amp; Collectibles|68","Home &amp; Garden|69","Pets|81","History|1052","Health|1053","Science|1054","Other|~0"],
+    "Visual Arts|10": ["Animation|61","Film|62","Galleries|63","Museums|64", "Painting|65","Photography|66","Other|~0"],
+    "Dance|4":["Ballet|25","Ballroom|26","Waltz|27","Salsa|28","Swing|29","Tango|30","Other|~0"],
+    "Arts &amp; Crafts|1": ["Ceramics|12","Knitting|13","Quilting|14","Bazaar|1057","Other|~0"],
+    "Shopping|1049":["Retail|1050","Fashion|1051"],
+    "Sports &amp; Outdoors|9": ["Auto Racing|50","Baseball|51","Basketball|52","Boating|53", "Camping|54","Cycling|55","Football|56","Hiking|57","Hockey|58","Running|59","Soccer|60","Swimming|73","Nature|74","Amateur|75","Volleyball|76","Tennis|77","Wrestling|78","Track &amp; Field|79","Golf|1042","Surf &amp; Beach|1043","Yoga|1055","Aviation|1056","Other|~0"],
+    "Food &amp; Dining|6":["Farmers' Markets|32","Wine|33","Other|~0"],
+    "Business &amp; Tech|3":["Real Estate|23","Gaming &amp; Technology|24","Conferences &amp; Trade Shows|67","Cars|71","Other|~0"]
+  }],["category_2",0],["category_3",0],["_id",null]]
+	var labels = {
+    category_1: {required:true},
+  }
+	var js = new JSAwesome('test', json, labels)
+	js.to_html()
+	js.addValidation()
+/script
+/body
+/html
\ No newline at end of file</diff>
				</file>
				<file>
					<file_name>test/assets/sample.html</file_name>
					<diff>@@ -6,8 +6,8 @@
 	meta http-equiv="Content-Type" content="text/html; charset=utf-8"/
 
 	titleJSAwesome!/title
-	script src="js/base.js" type="text/javascript" charset="utf-8"/script
-	script src="js/jsawesome_new.js" type="text/javascript" charset="utf-8"/script
+	script src="../../src/mootools.js" type="text/javascript" charset="utf-8"/script
+	script src="../../src/base.js" type="text/javascript" charset="utf-8"/script
 	style type="text/css" media="screen"
 		label{
 			display:block;</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>fd2cbfb9430e3443b4328df3fbe29e166d9128a2</sha>
			<message>A couple nice functional tests</message>
			<author_name>Chris Van Pelt</author_name>
			<author_date>2008-02-27T09:43:00Z</author_date>
			<author_email>vanpelt@snowwhite.local</author_email>
			<committer_name>Chris Van Pelt</committer_name>
			<committer_date>2008-02-27T09:43:00Z</committer_date>
			<committer_email>vanpelt@snowwhite.local</committer_email>
			<files>
				<file>
					<file_name>Rakefile</file_name>
					<diff>@@ -105,7 +105,7 @@ JavaScriptTestTask.new(:test_functionals, 4712) do |t|
     t.run(tests) unless tests_to_run && !tests_to_run.include?(test_filename)
   end
 
-  %w( safari firefox ie konqueror ).each do |browser| # opera 
+  %w( firefox safari ie konqueror ).each do |browser| # opera 
     t.browser(browser.to_sym) unless browsers_to_test && !browsers_to_test.include?(browser)
   end
 end</diff>
				</file>
				<file>
					<file_name>src/base.js</file_name>
					<diff>@@ -28,7 +28,7 @@ JSAwesome = new Class({
 	      n.push(new Element('br', {style:'clear:left'}))
 	    } else
 	      n.push(this._process(p[1],p[0]))
-	    var klass = $type(p[0]) == "string" ? p[0].replace(/^[_#*^]/,'') : "row_"+i+1
+	    var klass = $type(p[0]) == "string" ? p[0].replace(/^[_#*^]/,'') : "row_"+(i+1)
 	    m.push(new Element('div', {'class':'error '+klass}).adopt(n))
 	    this.level = 0
 	  }, this);
@@ -68,8 +68,8 @@ JSAwesome = new Class({
 	      this.delay = (delay -= 20)
 	      invalid[1].set('style', 'background:#d88b7e')
 	      if(error.getChildren().getLast().innerHTML != invalid[0]) {
-	        var mes = new Element('div', {
-	          style: 'color:red',
+	        var mes = new Element('span', {
+	          style: 'color:red;display:block',
 	          html:invalid[0]
 	        }).inject(error)
 	      }
@@ -116,7 +116,7 @@ JSAwesome = new Class({
         return ["You must check this box", element, 'click']
     } else if(label['required'] && element.get('value') === "")
       return ["This is a required field", element]
-    else if(label['validation'] && element.get('value') !== "") {
+    else if(label['validation']) {
       var args = $splat(label['validation'][0])
       var regex = new RegExp(args[0], args[1])
       return (regex.test(element.get('value')) ? false : [label['validation'][1], element])</diff>
				</file>
				<file>
					<file_name>test/assets/test_helper.js</file_name>
					<diff>@@ -0,0 +1,53 @@
+//I assume mootools was already required
+String.implement('sexify', function(){
+  return this.replace('test','').replace(/[A-Z]/g, function(match){
+    return ' ' + match.charAt(0);
+  })
+})
+
+DrNicTest.Unit.Testcase.prototype.$N = function(selector){
+  return $$('#'+this.name+' '+selector)
+}
+
+var JSON = new Hash({
+
+	encode: function(obj){
+		switch ($type(obj)){
+			case 'string':
+				return '"' + obj.replace(/[\x00-\x1f\\"]/g, JSON.$replaceChars) + '"';
+			case 'array':
+				return '[' + String(obj.map(JSON.encode).filter($defined)) + ']';
+			case 'object': case 'hash':
+				var string = [];
+				Hash.each(obj, function(value, key){
+					var json = JSON.encode(value);
+					if (json) string.push(JSON.encode(key) + ':' + json);
+				});
+				return '{' + String(string) + '}';
+			case 'number': case 'boolean': return String(obj);
+			case false: return 'null';
+		}
+		return null;
+	},
+
+	$specialChars: {'\b': '\\b', '\t': '\\t', '\n': '\\n', '\f': '\\f', '\r': '\\r', '"' : '\\"', '\\': '\\\\'},
+
+	$replaceChars: function(chr){
+		return JSON.$specialChars[chr] || '\\u00' + Math.floor(chr.charCodeAt() / 16).toString(16) + (chr.charCodeAt() % 16).toString(16);
+	},
+
+	decode: function(string, secure){
+		if ($type(string) != 'string' || !string.length) return null;
+		if (secure && !(/^[,:{}\[\]0-9.\-+Eaeflnr-u \n\r\t]*$/).test(string.replace(/\\./g, '@').replace(/"[^"\\\n\r]*"/g, ''))) return null;
+		return eval('(' + string + ')');
+	}
+
+});
+
+Native.implement([Hash, Array, String, Number], {
+
+	toJSON: function(){
+		return JSON.encode(this);
+	}
+
+});
\ No newline at end of file</diff>
				</file>
				<file>
					<file_name>test/functional/select_test.html</file_name>
					<diff>@@ -0,0 +1,125 @@
+!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
+        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
+html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
+head
+  titleJavaScript unit test file/title
+  meta http-equiv="content-type" content="text/html; charset=utf-8" /
+  script src="../assets/jsunittest.js" type="text/javascript"/script
+  
+  script src="../../dist/jsawesome.js" type="text/javascript"/script
+  
+  script src="../assets/test_helper.js" type="text/javascript"/script
+  
+  
+  link rel="stylesheet" href="../assets/unittest.css" type="text/css" /
+  style type="text/css" media="screen"
+		label{
+			display:block;
+		}
+		div.error {
+		  margin-top:10px;
+		}
+	/style
+/head
+body
+
+div id="content"
+
+  div id="header"
+    h1JSAwesome select functional tests/h1
+    p
+      Functional tests for demonstrating single and nested select menus.
+    /p
+  /div
+  pre[["cool","nice"]]/pre
+
+  !-- Log output (one per Runner, via {testLog: "testlog"} option)--
+  h2Single selects/h2
+  div id="singlelog"/div
+  div id="single"/div
+  
+  
+  h2Nested selects/h2
+  div id="nestedlog"/div
+  div id="nested"/div
+  
+  !-- Put sample/test html here --
+/div
+
+script type="text/javascript"
+// ![CDATA[
+
+  new Test.Unit.Runner({
+    // replace this with your real tests
+    setup: function() {
+      $('single').grab(new Element('div', {
+        id:this.name
+      }).grab(new Element('h3', {
+        html:this.name.sexify()
+      })))
+    },
+    
+    teardown: function() {
+      $('single').adopt([new Element('pre', {
+        text:tb.json.toJSON()
+      }), new Element('pre', {
+        text:$H(tb.labels).toJSON()
+      })])
+    },
+    
+    testSimpleSelect: function() { with(this) {
+      tb = new JSAwesome(name, [['select',['1','2','3','4']]])
+      tb.to_html()
+      var select = $N('select.select')[0]
+      assertEqual(name+"_select", select.name)
+      assertEqual(5,select.getElements('option').length)
+      assertEqual("", select.value)
+      var label = $N('label')
+      assertEqual("Select", label.get("html"))
+    }},
+    
+    testRequiredSelectWithCustomLabel: function() { with(this){
+      tb = new JSAwesome(name, [['select',['1','2','3','4']]],{
+        select:{label:'Cool select', required:true}
+      })
+      tb.to_html()
+      var select = $N('select.select')[0]
+      assertEqual(name+"_select", select.name)
+      assertEqual(5,select.getElements('option').length)
+      assertEqual("", select.value)
+      var label = $N('label')
+      assertEqual("Cool select", label.get("html"))
+      assert(!tb.validate())
+      var warning = $N('span')[0]
+      assertEqual("This is a required field", warning.get("html"))
+    }}
+      
+  }, {testLog: "singlelog"}); 
+  
+  new Test.Unit.Runner({
+    // replace this with your real tests
+    setup: function() {
+      $('multi').grab(new Element('div', {
+        id:this.name
+      }).grab(new Element('h3', {
+        html:this.name.sexify()
+      })))
+    },
+    
+    teardown: function() {
+      //$('basic').set("html", "")
+    },
+    
+    testNestedSelect: function() { with(this) {
+      assert(true)
+    }}
+  }, {testLog: "nestedlog"}); 
+  // For each Test.UnitRunner instance, specify the element id where results will be
+  // published; e.g. div id="testlog"/ above.
+  // That is, you can have multiple "new Test.Unit.Runner() { ... }" on this page, just
+  // create more div id="testlog2"/div etc, and pass the element id to the hash above:
+  // e.g. {testLog: "testlog2"}
+// ]]
+/script
+/body
+/html
\ No newline at end of file</diff>
				</file>
				<file>
					<file_name>test/functional/text_box_test.html</file_name>
					<diff>@@ -0,0 +1,204 @@
+!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
+        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
+html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
+head
+  titleJavaScript unit test file/title
+  meta http-equiv="content-type" content="text/html; charset=utf-8" /
+  script src="../assets/jsunittest.js" type="text/javascript"/script
+  
+  script src="../../dist/jsawesome.js" type="text/javascript"/script
+  
+  script src="../assets/test_helper.js" type="text/javascript"/script
+  
+  link rel="stylesheet" href="../assets/unittest.css" type="text/css" /
+  style type="text/css" media="screen"
+		label{
+			display:block;
+		}
+		div.error {
+		  margin-top:10px;
+		}
+	/style
+/head
+body
+
+div id="content"
+
+  div id="header"
+    h1JSAwesome text box functional tests/h1
+    p
+      Functional tests for demonstrating basic text box usage.
+    /p
+  /div
+  !-- Log output (one per Runner, via {testLog: "testlog"} option)--
+  h2Single text boxes/h2
+  div id="singlelog"/div
+  div id="single"/div
+  
+  
+  h2Multiple text boxes/h2
+  div id="multilog"/div
+  div id="multi"/div
+  
+  !-- Put sample/test html here --
+/div
+
+script type="text/javascript"
+// ![CDATA[
+
+  new Test.Unit.Runner({
+    // replace this with your real tests
+    setup: function() {
+      $('single').grab(new Element('div', {
+        id:this.name
+      }).grab(new Element('h3', {
+        html:this.name.sexify()
+      })))
+    },
+    
+    teardown: function() {
+      //$('basic').set("html", "")
+    },
+    
+    testSingleEmptyTextBox: function() { with(this) {
+      var tb = new JSAwesome(name, [['text_box','']])
+      tb.to_html()
+      var box = $N('input.text_box')[0]
+      assertEqual(name+"_text_box", box.name)
+      assertEqual("", box.value)
+      var label = $N('label')[0]
+      assertEqual("Text Box", label.get("html"))
+    }},
+    
+    testSingleCustomTextBox: function() { with(this) {
+      var tb = new JSAwesome(name, [['text_box','Default value']], {text_box:"Custom"})
+      tb.to_html()
+      var box = $N('input.text_box')[0]
+      assertEqual(name+"_text_box", box.name)
+      assertEqual("Default value", box.value)
+      var label = $N('label')[0]
+      assertEqual("Custom", label.get("html"))
+    }},
+    
+    testSingleValidatedTextBox: function() { with(this) {
+      var tb = new JSAwesome(name, [['text_box', 'invalid']], {text_box: {validation:["^valid", "Is invalid"]}})
+      tb.to_html()
+      var box = $N('input.text_box')[0]
+      assertEqual(name+"_text_box", box.name)
+      assertEqual("invalid", box.value)
+      var label = $N('label')[0]
+      assertEqual("Text Box", label.get("html"))
+      assert(!tb.validate())
+      var warning = $E('div.error span')
+      assertEqual("Is invalid", warning.get("html"))
+    }},
+    
+    testSingleRequiredTextBox: function() { with(this) {
+      var tb = new JSAwesome(name, [['text_box', null]], {text_box: {required:true}})
+      tb.to_html()
+      var box = $N('input.text_box')[0]
+      assertEqual(name+"_text_box", box.name)
+      assertEqual("", box.value)
+      assert(!tb.validate())
+      var warning = $N('div.error span')[0]
+      assertEqual("This is a required field", warning.get("html"))
+    }}
+      
+  }, {testLog: "singlelog"}); 
+  
+  new Test.Unit.Runner({
+    // replace this with your real tests
+    setup: function() {
+      $('multi').grab(new Element('div', {
+        id:this.name
+      }).grab(new Element('h3', {
+        html:this.name.sexify()
+      })))
+    },
+    
+    teardown: function() {
+      //$('basic').set("html", "")
+    },
+    
+    testMultipleEmptyTextBox: function() { with(this) {
+      var tb = new JSAwesome(name, [[['text_box1',''], ['text_box2', '']]])
+      tb.to_html()
+      var boxes = $$('div.row_1 input')
+      assertEqual(2, boxes.length)
+      assertEqual(name+"_text_box1", boxes[0].name)
+      assertEqual(name+"_text_box2", boxes[1].name)
+      assertEqual("", boxes[0].value)
+      assertEqual("", boxes[1].value)
+      assertEqual("Text Box1", $E('label[for='+name+'_text_box1]').get("html"))
+      assertEqual("Text Box2", $E('label[for='+name+'_text_box2]').get("html"))
+    }},
+    
+    testMultipleCustomTextBox: function() { with(this) {
+      var tb = new JSAwesome(name, [[['text_box1','default'], ['text_box2', '']]], {text_box2:"Custom label"})
+      tb.to_html()
+      var boxes = $N('input')
+      var labels = $N('label')
+      assertEqual(2, boxes.length)
+      assertEqual(2, labels.length)
+      assertEqual(name+"_text_box1", boxes[0].name)      
+      assertEqual("default", boxes[0].value)
+      assertEqual("", boxes[1].value)
+      assertEqual("Text Box1", labels[0].get("html"))
+      assertEqual("Custom label", labels[1].get("html"))
+    }},
+    
+    testMultipleValidatedTextBox: function() { with(this) {
+      var tb = new JSAwesome(name, [
+        [['text_box1','default'], ['text_box2', '']], 
+        ['text_box3','']], {
+          text_box2: {label:"custom", validation:[".{10}","Must be 10 chars long"]},
+          text_box1: {vaidation:[".{7}","Must be 7 chars long"]}
+      })
+      tb.to_html()
+      var boxes = $N('input')
+      var labels = $N('label')
+      assertEqual(3, boxes.length)
+      assertEqual(3, labels.length)
+      assertEqual(3, boxes.getElements('div').length)
+      assertEqual("", boxes[1].value)
+      assert(!tb.validate())
+      var warning = $N('div.error span').getLast()
+      assertEqual("Must be 10 chars long", warning.get("html"))
+      assertEqual("custom", labels[1].get("html"))
+    }},
+    
+    testMultipleRequiredTextBox: function() { with(this) {
+      var tb = new JSAwesome(name, [
+        [['text_box1','default'], ['text_box2', '']], 
+        [['text_box3',''],['text_box4',''],['text_box5', '']]], {
+          text_box2: {label:"custom", required:true},
+          text_box1: {required:true},
+          text_box5: {required:true}
+      })
+      tb.to_html()
+      var boxes = $N('input')
+      var labels = $N('label')
+      assertEqual(5, boxes.length)
+      assertEqual(5, labels.length)
+      assertEqual(5, boxes.getElements('div').length)
+      assertEqual("", boxes[1].value)
+      assert(!tb.validate())
+      var warnings = $N('div.error span')
+      assertEqual("This is a required field", warnings.getLast().get("html"))
+      assertEqual("This is a required field", warnings[0].get("html"))
+      assertEqual("custom", labels[1].get("html"))
+      assertMatch(/background/, boxes[1].get('style'))
+      assertNoMatch(/background/, boxes[0].get('style'))
+      assertMatch(/background/, boxes[4].get('style'))
+    }},
+  
+  }, {testLog: "multilog"}); 
+  // For each Test.UnitRunner instance, specify the element id where results will be
+  // published; e.g. div id="testlog"/ above.
+  // That is, you can have multiple "new Test.Unit.Runner() { ... }" on this page, just
+  // create more div id="testlog2"/div etc, and pass the element id to the hash above:
+  // e.g. {testLog: "testlog2"}
+// ]]
+/script
+/body
+/html
\ No newline at end of file</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>1888c968cf680f1aaea9f1ad63ae9b145689b034</sha>
			<message>removed svn directory</message>
			<author_name>Chris Van Pelt</author_name>
			<author_date>2008-02-25T02:09:49Z</author_date>
			<author_email>vanpelt@snowwhite.local</author_email>
			<committer_name>Chris Van Pelt</committer_name>
			<committer_date>2008-02-25T02:09:49Z</committer_date>
			<committer_email>vanpelt@snowwhite.local</committer_email>
			<files>
				<file>
					<file_name>.svn/all-wcprops</file_name>
					<diff>@@ -1,11 +0,0 @@
-K 25
-svn:wc:ra_dav:version-url
-V 22
-/!svn/ver/54/jsawesome
-END
-index.html
-K 25
-svn:wc:ra_dav:version-url
-V 33
-/!svn/ver/63/jsawesome/index.html
-END</diff>
				</file>
				<file>
					<file_name>.svn/entries</file_name>
					<diff>@@ -1,46 +0,0 @@
-8
-
-dir
-54
-http://svn.doloreslabs.com/jsawesome
-http://svn.doloreslabs.com
-
-
-
-2008-01-08T07:52:52.890966Z
-54
-vanpelt
-
-
-svn:special svn:externals svn:needs-lock
-
-
-
-
-
-
-
-
-
-
-
-d314e387-0142-0410-bb01-808b2bd285b2
-
-css
-dir
-
-index.html
-file
-63
-
-
-
-2008-01-10T02:44:17.000000Z
-dc73da3d4412c59b0684f0cad3eb717a
-2008-01-10T02:46:27.348354Z
-63
-vanpelt
-
-js
-dir
-</diff>
				</file>
				<file>
					<file_name>.svn/format</file_name>
					<diff>@@ -1 +0,0 @@
-8</diff>
				</file>
				<file>
					<file_name>.svn/text-base/index.html.svn-base</file_name>
					<diff>@@ -1,58 +0,0 @@
-!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
-	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
-
-html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
-head
-	meta http-equiv="Content-Type" content="text/html; charset=utf-8"/
-
-	titleJSAwesome!/title
-	script src="js/base.js" type="text/javascript" charset="utf-8"/script
-	script src="js/jsawesome.js" type="text/javascript" charset="utf-8"/script
-	style type="text/css" media="screen"
-		label{
-			display:block;
-		}
-	/style
-/head
-
-body
-	form method="post" id="form" action="http://www.doloreslabs.com"
-		div id="test"
-		/div
-		div id="sub"
-		/div
-		div id="neat"
-		/div
-		input type="submit"/
-	/form
-script type="text/javascript" charset="utf-8"
-	var js = new JSAwesome('test', {
-	  'drop': ['single', 'dude'],
-	  'text':'',
-	  '#textarea':'Default text',
-	  '_hidden':'invisible', 
-	  'sub_cats': 
-	    {'rad': ['cool', 'neat'], 
-	     'awesome': 
-	       {'crazy': ['indeed', 'man'],
-	        'way': ['oh', 'yeah']}
-	    }})
-	js.to_html()
-	var yup = new JSAwesome('sub', {
-	  'sub_cats': 
-	    {'rad': ['cool', 'neat'], 
-	     'awesome': 
-	       {'crazy': ['indeed', 'man'],
-	        'way': []}
-	    },
-	  '_hidden':'invisible'
-	})
-	yup.to_html()
-	var neat = new JSAwesome('neat', {"category_1":{"Sports & Outdoors":["Amateur","Auto Racing","Aviation","Baseball","Basketball","Boating","Camping","Cycling","Football","Golf","Hiking","Hockey","Nature","Running","Soccer","Surf & Beach","Swimming","Tennis","Track & Field","Volleyball","Wrestling","Yoga","~Other"],"Shopping":["Fashion","Retail","~Other"],"Dance":["Ballet","Ballroom","Salsa","Swing","Tango","~Other"],"Community":["Activism","Antiques & Collectibles","Charity & Volunteer","Ethnic & Cultural","Health","History","Home & Garden","Libraries","Parades","Pets","Religion","Science","Talks & Lectures","Workshops & Classes","~Other"],"Food & Dining":["Farmers' Markets","Wine","~Other"],"Performing Arts":["Ballet","Cabaret & Review","Comedy","Literary Arts","Musicals","Opera","Poetry","Puppetry","Street Performance","Symphony","Theater","~Other"],"Other":[],"Fairs & Festivals":[],"Arts & Crafts":["Bazaar","Ceramics","Knitting","Quilting","~Other"],"Visual Arts":["Animation","Film","Galleries","Museums","Painting","Photography"],"Music":["Alternative","Blues","Classical","Country","Folk","Gospel","Jazz","Pop","R&B","Rock","Techno & Dance","World Music","~Other"],"Business & Tech":["Cars","Conferences & Trade Shows","Gaming & Technology","Real Estate","~Other"]},"category_2":{"Sports & Outdoors":["Amateur","Auto Racing","Aviation","Baseball","Basketball","Boating","Camping","Cycling","Football","Golf","Hiking","Hockey","Nature","Running","Soccer","Surf & Beach","Swimming","Tennis","Track & Field","Volleyball","Wrestling","Yoga","~Other"],"Shopping":["Fashion","Retail","~Other"],"Dance":["Ballet","Ballroom","Salsa","Swing","Tango","~Other"],"Community":["Activism","Antiques & Collectibles","Charity & Volunteer","Ethnic & Cultural","Health","History","Home & Garden","Libraries","Parades","Pets","Religion","Science","Talks & Lectures","Workshops & Classes","~Other"],"Food & Dining":["Farmers' Markets","Wine","~Other"],"Performing Arts":["Ballet","Cabaret & Review","Comedy","Literary Arts","Musicals","Opera","Poetry","Puppetry","Street Performance","Symphony","Theater","~Other"],"Other":[],"Fairs & Festivals":[],"Arts & Crafts":["Bazaar","Ceramics","Knitting","Quilting","~Other"],"Visual Arts":["Animation","Film","Galleries","Museums","Painting","Photography"],"Music":["Alternative","Blues","Classical","Country","Folk","Gospel","Jazz","Pop","R&B","Rock","Techno & Dance","World Music","~Other"],"Business & Tech":["Cars","Conferences & Trade Shows","Gaming & Technology","Real Estate","~Other"]},"category_3":{"Sports & Outdoors":["Amateur","Auto Racing","Aviation","Baseball","Basketball","Boating","Camping","Cycling","Football","Golf","Hiking","Hockey","Nature","Running","Soccer","Surf & Beach","Swimming","Tennis","Track & Field","Volleyball","Wrestling","Yoga","~Other"],"Shopping":["Fashion","Retail","~Other"],"Dance":["Ballet","Ballroom","Salsa","Swing","Tango","~Other"],"Community":["Activism","Antiques & Collectibles","Charity & Volunteer","Ethnic & Cultural","Health","History","Home & Garden","Libraries","Parades","Pets","Religion","Science","Talks & Lectures","Workshops & Classes","~Other"],"Food & Dining":["Farmers' Markets","Wine","~Other"],"Performing Arts":["Ballet","Cabaret & Review","Comedy","Literary Arts","Musicals","Opera","Poetry","Puppetry","Street Performance","Symphony","Theater","~Other"],"Other":[],"Fairs & Festivals":[],"Arts & Crafts":["Bazaar","Ceramics","Knitting","Quilting","~Other"],"Visual Arts":["Animation","Film","Galleries","Museums","Painting","Photography"],"Music":["Alternative","Blues","Classical","Country","Folk","Gospel","Jazz","Pop","R&B","Rock","Techno & Dance","World Music","~Other"],"Business & Tech":["Cars","Conferences & Trade Shows","Gaming & Technology","Real Estate","~Other"]}}, {'category_2': 'Category 2 i(Optional)/i'}, ['category_1'])
-	neat.to_html()
-	$('form').addEvent('submit', function(){
-	  return neat.validate();
-	})
-/script
-/body
-/html</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>8f48d17652b4edb7056d605cdb5f7776e6ebee4b</sha>
			<message>restructured the whole thing for testing and maintainablity using drnics newjs</message>
			<author_name>Chris Van Pelt</author_name>
			<author_date>2008-02-25T02:08:18Z</author_date>
			<author_email>vanpelt@snowwhite.local</author_email>
			<committer_name>Chris Van Pelt</committer_name>
			<committer_date>2008-02-25T02:08:18Z</committer_date>
			<committer_email>vanpelt@snowwhite.local</committer_email>
			<files>
				<file>
					<file_name>History.txt</file_name>
					<diff>@@ -0,0 +1,4 @@
+== 0.0.9 2008-02-23
+
+* A major refactor of the sub-select logic
+* Support for all basic form elements</diff>
				</file>
				<file>
					<file_name>License.txt</file_name>
					<diff>@@ -0,0 +1,20 @@
+Copyright (c) 2008 Chris Van Pelt
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
\ No newline at end of file</diff>
				</file>
				<file>
					<file_name>README</file_name>
					<diff>@@ -1 +0,0 @@
-I change json into an interactive form!</diff>
				</file>
				<file>
					<file_name>README.txt</file_name>
					<diff>@@ -0,0 +1,19 @@
+Jsawesome
+
+Description:
+    JSAwesome provides a powerful JSON based DSL for creating interactive forms.
+
+Example:
+    new JSAwesome('rad', [['cool','neat'], ['^neat',true]], {'cool':{label:'Cool man', validation:'cool'}).to_html()
+    =
+      label for="rad_cool"Cool man/label
+      input type="text" name="rad_cool" value="neat"/
+      label for="rad_neat"input type="checkbox" name="rad_neat" checked="checked"/ Neat/label
+      
+    See the functional tests for detailed examples of what is possible
+
+More information:
+    http://github.com/vanpelt/jsawesome/tree/master
+    
+Author:
+    Chris Van Pelt, vanpelt@doloreslabs.com
\ No newline at end of file</diff>
				</file>
				<file>
					<file_name>Rakefile</file_name>
					<diff>@@ -0,0 +1,120 @@
+require 'rubygems'
+begin
+  require 'rake'
+rescue LoadError
+  puts 'This script should only be accessed via the "rake" command.'
+  puts 'Installation: gem install rake -y'
+  exit
+end
+require 'rake'
+require 'rake/clean'
+require 'rake/packagetask'
+
+$:.unshift File.dirname(__FILE__) + "/lib"
+
+APP_VERSION  = '0.0.9'
+APP_NAME     = 'jsawesome'
+APP_FILE_NAME= "#{APP_NAME}.js"
+
+APP_ROOT     = File.expand_path(File.dirname(__FILE__))
+APP_SRC_DIR  = File.join(APP_ROOT, 'src')
+APP_DIST_DIR = File.join(APP_ROOT, 'dist')
+APP_PKG_DIR  = File.join(APP_ROOT, 'pkg')
+
+
+unless ENV['rakefile_just_config']
+
+task :default = [:dist, :package, :clean_package_source]
+
+desc "Builds the distribution"
+task :dist do
+  $:.unshift File.join(APP_ROOT, 'lib')
+  require 'protodoc'
+  require 'fileutils'
+  FileUtils.mkdir_p APP_DIST_DIR
+
+  Dir.chdir(APP_SRC_DIR) do
+    File.open(File.join(APP_DIST_DIR, APP_FILE_NAME), 'w+') do |dist|
+      dist  Protodoc::Preprocessor.new(APP_FILE_NAME)
+    end
+  end
+  Dir.chdir(APP_DIST_DIR) do
+    FileUtils.copy_file APP_FILE_NAME, "#{APP_NAME}-#{APP_VERSION}.js"
+  end
+  if File.directory?("website")
+    FileUtils.mkdir_p "website/dist"
+    FileUtils.copy_file "dist/#{APP_FILE_NAME}",       "website/dist/#{APP_FILE_NAME}"
+    FileUtils.copy_file "dist/#{APP_FILE_NAME}",       "website/dist/#{APP_NAME}-#{APP_VERSION}.js"
+  end
+end
+
+Rake::PackageTask.new(APP_NAME, APP_VERSION) do |package|
+  package.need_tar_gz = true
+  package.package_dir = APP_PKG_DIR
+  package.package_files.include(
+    '[A-Z]*',
+    'config/*.sample',
+    "dist/#{APP_FILE_NAME}",
+    'lib/**',
+    'src/**',
+    'script/**',
+    'tasks/**',
+    'test/**',
+    'website/**'
+  )
+end
+
+desc "Builds the distribution, runs the JavaScript unit + functional tests and collects their results."
+task :test = [:dist, :test_units, :test_functionals]
+
+require 'jstest'
+desc "Runs all the JavaScript unit tests and collects the results"
+JavaScriptTestTask.new(:test_units, 4711) do |t|
+  testcases        = ENV['TESTCASES']
+  tests_to_run     = ENV['TESTS']    && ENV['TESTS'].split(',')
+  browsers_to_test = ENV['BROWSERS'] && ENV['BROWSERS'].split(',')
+
+  t.mount("/dist")
+  t.mount("/src")
+  t.mount("/test")
+
+  Dir["test/unit/*_test.html"].sort.each do |test_file|
+    tests = testcases ? { :url = "/#{test_file}", :testcases = testcases } : "/#{test_file}"
+    test_filename = test_file[/.*\/(.+?)\.html/, 1]
+    t.run(tests) unless tests_to_run && !tests_to_run.include?(test_filename)
+  end
+
+  %w( firefox safari ie konqueror ).each do |browser|# opera 
+    t.browser(browser.to_sym) unless browsers_to_test && !browsers_to_test.include?(browser)
+  end
+end
+
+desc "Runs all the JavaScript functional tests and collects the results"
+JavaScriptTestTask.new(:test_functionals, 4712) do |t|
+  testcases        = ENV['TESTCASES']
+  tests_to_run     = ENV['TESTS']    && ENV['TESTS'].split(',')
+  browsers_to_test = ENV['BROWSERS'] && ENV['BROWSERS'].split(',')
+
+  t.mount("/dist")
+  t.mount("/src")
+  t.mount("/test")
+
+  Dir["test/functional/*_test.html"].sort.each do |test_file|
+    tests = testcases ? { :url = "/#{test_file}", :testcases = testcases } : "/#{test_file}"
+    test_filename = test_file[/.*\/(.+?)\.html/, 1]
+    t.run(tests) unless tests_to_run && !tests_to_run.include?(test_filename)
+  end
+
+  %w( safari firefox ie konqueror ).each do |browser| # opera 
+    t.browser(browser.to_sym) unless browsers_to_test && !browsers_to_test.include?(browser)
+  end
+end
+
+
+task :clean_package_source do
+  rm_rf File.join(APP_PKG_DIR, "#{APP_NAME}-#{APP_VERSION}")
+end
+
+Dir['tasks/**/*.rake'].each { |rake| load rake }
+
+end
\ No newline at end of file</diff>
				</file>
				<file>
					<file_name>config/javascript_test_autotest.yml</file_name>
					<diff>@@ -0,0 +1,3 @@
+browsers:
+  firefox: '/Applications/Firefox.app/Contents/MacOS/firefox-bin'
+  safari: '/Applications/Safari.app/Contents/MacOS/Safari'
\ No newline at end of file</diff>
				</file>
				<file>
					<file_name>index.html</file_name>
					<diff>@@ -1,75 +0,0 @@
-!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
-	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
-
-html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
-head
-	meta http-equiv="Content-Type" content="text/html; charset=utf-8"/
-
-	titleJSAwesome!/title
-	script src="js/base.js" type="text/javascript" charset="utf-8"/script
-	script src="js/jsawesome.js" type="text/javascript" charset="utf-8"/script
-	style type="text/css" media="screen"
-		label{
-			display:block;
-		}
-		div {
-		  margin-bottom:10px;
-		}
-	/style
-/head
-
-body
-	form method="post" id="form" action="http://www.doloreslabs.com"
-		div id="test"
-		/div
-		div id="radio"
-		/div
-		div id="sub"
-		/div
-		div id="neat"
-		/div
-		input type="submit"/
-	/form
-script type="text/javascript" charset="utf-8"
-	var js = new JSAwesome('test', [
-	  ['drop', ['~single', 'dude']],
-	  [['text',''], ['more_text','Oh yeah'], ['cool','Booyah']],
-	  ['#textarea','Default text'],
-	  ['_hidden','invisible'], 
-	  ['sub_cats', 
-	    {'rad': ['cool', 'neat'], 
-	     'awesome': 
-	       {'crazy': ['indeed', 'man'],
-	        'way': ['oh', 'yeah']}
-	    }]],{cool:'Um Thats right'},true)
-	js.to_html()
-	var radio = new JSAwesome('radio', [
-	  ['*cool', ['Rad', 'Neat', 'Crazy|32']],
-	  ['*something', ['odd', 'fun', 'neat', 'crazy']],
-	  [['^Check me', false], ['^Or me', true]]
-	],{'cool': "This is really cool"});
-	radio.to_html()
-	var yup = new JSAwesome('sub', [
-	  ['sub_cats', 
-	    {'rad': ['cool', 'neat'], 
-	     'awesome': 
-	       {'crazy': ['indeed', 'man'],
-	        'way': [],
-	        'Other': []}}
-	    ],
-	  ['_hidden','invisible']
-	], {'~':'Suggestions...', 'sub_cats':'Sub Fucking Cats'})
-	yup.to_html()
-	var json = [["category_1",{"Other|~11":[],"Performing Arts|8":["Ballet|39","Cabaret & Review|40","Comedy|41","Literary Arts|42","Musicals|43","Opera|44","Poetry|45","Puppetry|46","Street Performance|47","Symphony|48","Theater|49","Other|~0"],"Music|7":["Alternative|34","Jazz|35","R&B|36","Rock|37","Techno & Dance|38","Country|72","Classical|80","Folk|1044","World Music|1045","Gospel|1046","Pop|1047","Blues|1048","Rap\/Hip-Hop|1087","Other|~0"],"Business & Tech|3":["Real Estate|23","Gaming & Technology|24","Conferences & Trade Shows|67","Cars|71","Other|~0"],"Fairs & Festivals|5":[],"Community|2":["Activism|15","Charity & Volunteer|16","Ethnic & Cultural|17","Libraries|18","Parades|19","Religion|20","Talks & Lectures|21","Workshops & Classes|22","Antiques & Collectibles|68","Home & Garden|69","Pets|81","History|1052","Health|1053","Science|1054","Other|~0"],"Visual Arts|10":["Animation|61","Film|62","Galleries|63","Museums|64","Painting|65","Photography|66","Other|~0"],"Dance|4":["Ballet|25","Ballroom|26","Ballroom|27","Salsa|28","Swing|29","Tango|30","Other|~0"],"Shopping|1049":["Retail|1050","Fashion|1051"],"Arts & Crafts|1":["Ceramics|12","Knitting|13","Quilting|14","Bazaar|1057","Other|~0"],"Sports & Outdoors|9":["Auto Racing|50","Baseball|51","Basketball|52","Boating|53","Camping|54","Cycling|55","Football|56","Hiking|57","Hockey|58","Running|59","Soccer|60","Swimming|73","Nature|74","Amateur|75","Volleyball|76","Tennis|77","Wrestling|78","Track & Field|79","Golf|1042","Surf & Beach|1043","Yoga|1055","Aviation|1056","Other|~0"],"Food & Dining|6":["Farmers' Markets|32","Wine|33","Other|~0"]}],["category_2",0],["category_3",0]]
-        var legend = {"category_3":"Category 3 i(Optional)\/i","category_1":{"required":true},"category_2":"Category 2 i(Optional)\/i"}
-
-
-        var j975 = json.concat([["_id","40859"]])
-        var neat = new JSAwesome('neat', j975, legend)
-        neat.to_html()
-	$('form').addEvent('submit', js.validate.bind(js));
-	$('form').addEvent('submit', neat.validate.bind(neat));
-	console.log(neat)
-/script
-/body
-/html</diff>
				</file>
				<file>
					<file_name>js/jsawesome.js</file_name>
					<diff>@@ -1,347 +0,0 @@
-//Globals...
-Scroller = null
-delay = 100
-window.addEvent('load', function(){
-  Scroller = new Fx.Scroll(window, {link:'chain', offset:{x:0,y:-25}})
-})
-JSAwesome = new Class({
-	initialize: function(name, json, labels){
-	  this.name = name
-		this.json = json
-		this.labels = labels || {}
-		this.validations = $H(labels).getKeys().filter(function(f){
-		  return labels[f]['required'] || labels[f]['validation']
-		})
-		this.level = 0
-		this.delay = (delay -= 20) 
-		this.in_select = false
-		this.nested = {}
-	},
-	to_html: function() {
-	  var m = []
-	  $A(this.json).each(function(p){
-	    var n = []
-	    //Allows you to reference previous selects...
-	    if($type(p[1])=="number" && this.json[p[1]])
-	      p[1] = this.json[p[1]][1]
-	    if($type(p[0])=="array"){
-	      n.push(p.map(function(r){
-	        return new Element('div', {style:'float:left;margin-right:5px'}).adopt(this._process(r[1],r[0]))
-	      }, this))
-	      n.push(new Element('br', {style:'clear:left'}))
-	    } else
-	      n.push(this._process(p[1],p[0]))
-	    m.push(new Element('div', {'class':'error '+($type(p[0]) == "string" ? p[0].replace(/^[*~^#]/,'') : "")}).adopt(n))
-	    this.level = 0
-	  }, this);
-	 return $(this.name).adopt(m)
-	},
-	label: function(name, wafor) {
-	  var newname = null
-	  if($defined(this.labels[name])) {
-	    if($defined(this.labels[name]['label']))
-	      newname = this.labels[name]['label']
-	    else
-	      newname = this.labels[name]
-	    if($type(newname) == "object")
-	      newname = null
-	  }
-	  if(!$defined(newname))
-	    newname = name.replace(/^[_#*^]/,'').replace(/_/g,' ').replace(/^\w/, function(m){return m.toUpperCase()})
-	  return ($type(wafor) == "element" ? wafor.set('html', newname) : new Element('label', {'for':wafor, 'html':newname}))
-	},
-	addValidation: function(){
-	  this.validater = this.validate.bind(this)
-	  $(this.name).getParent('form').addEvent('submit', this.validater)
-	},
-	stopValidation: function(){
-	  $(this.name).getParent('form').removeEvent('submit', this.validater)
-	},
-	validate: function(e) {
-	  return this.validations.every(function(r){
-	    var checking = $(this.name).getElement('div .'+r.replace(/^[_#~*]/,''))
-	    var error = checking.getParent('.error')
-	    var invalid = this._check(checking)
-	    if(invalid) {
-	      invalid[1].set('style', 'background:#d88b7e')
-	      if(error.getChildren().getLast().innerHTML != invalid[0]) {
-	        var mes = new Element('div', {
-	          style: 'color:red',
-	          html:invalid[0]
-	        }).inject(error)
-	      }
-	      invalid[1].addEvent(invalid[2] ? 'change' : 'blur', function(){
-	        var check = this._check(checking)
-	        if(!check || invalid[1] != check[1]) {
-	          invalid[1].set('style', 'background:')
-	          if(mes){
-	            mes.dispose()
-	            mes = false
-	          }
-	        }
-	      }.bind(this))
-	      if(this.delay  0)
-	        Scroller.toElement.delay(this.delay, Scroller, checking)
-	      else
-	        this._reset.delay(500)
-	      return false
-	    } else 
-	      return true
-	  }, this)
-	},
-	_reset: function() { delay = 100 },
-	_check: function(element) {
-	  var invalid = false
-	  var label = this.labels[element.get('class')]
-	  if(element.get('tag') == 'div') {
-      invalid = !element.getChildren().every(function(c){
-        element = c
-        return !(c.get('value') === "")
-      });
-      if(invalid) return ["This is a required field", element, 'change']
-    } else if(element.get('type') == "radio" && label['required']) {
-      var radios = element.getParent('fieldset').getElements('input')
-      if(radios.some(function(r){return r.get('value')}))
-        return false
-      else
-        return ["You must choose an option", new Elements(radios), 'click']
-    } else if(label['required'] && element.get('value') === "")
-      return ["This is a required field", element]
-    else if(label['validation'] && element.get('value') !== "") {
-      var args = $splat(label['validation'][0])
-      var regex = new RegExp(args[0], args[1])
-      return (regex.test(element.get('value')) ? false : [label['validation'][1], element])
-    }
-	},
-	_process: function(cur, names, nested) {
-	  names = $splat(names);    
-	  switch($type(cur)) {
-	    //a select tag
-	    case 'array':
-	      if(names[0].test(/^\*/)) {
-          return new Element('fieldset').adopt(
-          [this.label(names[0].substring(1), new Element('legend'))].concat(cur.map(function(c){
-            return this._process(c, names);
-          }, this)));
-        } else { 
-	        this.in_select = true
-	        var root = !this.level
-	        cur = cur.sort()
-          //Make the other / custom field go to the end...
-          var other = false
-          cur.some(function(a){ 
-            return other = a.test(/~/) ? a : other
-          })
-          if(other)
-            cur.remove(other).push(other)
-	        if(cur.length  1)
-	          cur = ["Choose "+(this.level==0 ? "Category" : "Subcategory")].concat(cur)
-	        else if(this.level = 1 && cur.length  0)
-	          root = true
-	        var name = this.name+"_"+names[0]
-	        var klass = [names[0],this.level].join("_")
-	        var els = []
-	        if(!root) {
-	          //Add the subcategory dropdown
-	          var store = klass
-	          if(names.getLast() == "_") {
-	            var classes = klass.split('_')
-	            //Go back one level
-	            store = classes.concat([classes.pop().toInt() - 1]).join('_')
-	            names.pop()
-	          }
-	          this._store(store, names.getLast(), cur, klass, name)
-	          this.in_select = false
-	          return null
-	        } else {
-	          if(this.level==0)
-	            els.push(this.label(names[0], name))
-	          if(!nested)
-	            klass += ' '+names[0]
-	          els = els.concat(this._nested(name, cur, klass))
-	          this.in_select = false
-  	        return els
-	        }
-	      }
-	    case 'object':
-	      cur = $H(cur)
-	      var t = [this._process(cur.getKeys(), names, true)]
-	      this.level += 1
-	      t.push(this._process(["Choose Subcategory"], names.concat(['_']), true))
-	      return t.concat(cur.getValues().map(function(v){
-	        return this._process(v, names.concat([cur.keyOf(v).split('|').getLast()]), true)
-	      }, this));
-	    default:
-	      var name = names.join("_");
-	      var e = null
-	      //AKA not a checkbox
-	      if($type(cur)=="string") {
-	        var val = cur.split('|').getLast().replace(/Choose (Sub)?Category/i,'')
-	        cur = cur.split('|')[0].replace(/^[~*]/,'')
-	      }
-	      if(this.in_select) {
-	        //Allows for custom values
-	        e = new Element('option', {html: cur, value: val})
-	        //Wow this is sketchy as F
-	        var name = name.split(' ')[0]
-	        if(val.test(/^~/)) this._store(name, val, [], name, this.name+'_'+name)
-	      } else {
-	        if(name.test(/^#/)) {
-	          e = new Element('textarea', {
-	            name: this.name+'_'+name.substring(1), 
-	            'class':name.substring(1), 
-	            html: cur})
-	        } else if(name.test(/^_/)) {
-	          e = new Element('input', {
-	            type: 'hidden',
-	            'class': name.substring(1),
-	            name: this.name+'_'+name.substring(1), 
-	            value: cur
-	          })
-	        } else if(name.test(/^\*/)) {
-            e = this.label(cur, this.name+'_'+name.substring(1)).grab(new Element('input', {
-              type: 'radio',
-              'class': name.substring(1),
-              name: this.name+'_'+name.substring(1),
-              value: val
-            }), 'top')
-          } else if(name.test(/^\^/)) {
-            e = this.label(name, this.name+'_'+name.substring(1)).grab(new Element('input', {
-              type: 'checkbox',
-              'class': name.substring(1),
-              name: this.name+'_'+name.substring(1),
-              checked: (cur ? "checked" : "")
-            }), 'top')
-	        } else e = new Element('input', {type: 'text', 'class': name, name: this.name+'_'+name, value: cur})
-	        if(!name.test(/^[_*^]/))
-	          e = [this.label(name, e.name), e]
-	      }
-	      return e
-	  }
-	},
-	_custom: function(name, klass) {
-	  var val = this.labels['~'] || "Custom..."
-	  if(this.level == 1)
-	    name = name.replace(/_sub1/,'')
-	  return new Element('input', {
-      'class':(this.level  1 ? klass+' sub' : klass)+' custom', 
-      type: 'text', 
-      name: name+'_other', 
-      value: val,
-      events: {
-        'focus': function(){
-          if(this.value == val)
-            this.set('value', "")
-        }
-      }
-    })
-	},
-	_store: function(store, key, options, klass, name) {
-	  name = name+'_sub'+this.level
-	  if(key.test(/^~/))
-      var type = "custom"
-    else
-      var type = options.length == 0 ? "disabled" : "select"
-	  this.nested[store] = this.nested[store] || {}
-    this.nested[store][key] = this.nested[store][key] || []
-    this.nested[store][key].push(this._nested(name, options, klass, type))
-	},
-	_nested: function(name, options, klass, type) {
-	  type = type || 'select'
-	  if(type == "custom") {
-	    return this._custom(name, klass)
-	  } else {
-	    var select = new Element("select", {
-        name: name,
-        'class': this.level  1 ? klass+' sub' : klass,
-        events: {
-          change: function(event){
-            var e = event.target
-            var classes = e.get('class').split('_')
-            var level = classes.pop().toInt()+1
-            var klass = classes.concat([level]).join('_')
-            var it = e.get('value')
-            //Dispose namespaced in a wrapper
-            //This is wrong in so many ways
-            if(classes.getLast().test(/^0/)) classes.pop()
-            var wrapper = $E('#'+this.name+' .'+classes.join('_'))
-            if(wrapper)
-              wrapper.getElements('.custom, .sub').dispose()
-            //Add a custom input...
-            var child = false
-            if(it.test(/^~/))
-              child = [this._custom(name, klass+' sub')]
-            if(this.nested[klass])
-              child = this.nested[klass][it]
-            if(!child) return
-            
-            var test = $(this.name).getElement('.'+klass)
-            var made = (test ? child[0].replaces(test) : child[0].inject(e.getParent()))
-            //Restore the old value instead of an empty select
-            if(child.length  1) {
-              if(made.selectedIndex  0)
-                var child = this.nested[classes.concat([level+1]).join('_')][made.get('value')]
-              child.getLast().inject(made, 'after')
-            }
-            //$E('#'+this.name+' .'+classes.join('_')).getElements('select').fireEvent('change')      
-          }.bind(this)
-        }
-      })
-      if(type == "disabled")
-        select.set('style', 'display:none').set('disabled', 'disabled')
-      return select.adopt(options.map(
-        function(o){
-          return this._process(o, klass)
-        },this)
-      )
-    }
-	}
-});
-
-/*
-{'text':'',
-  '#textarea':'Default text',
-  '_hidden':'invisible', 
-  {'sub_cats': 
-    {'rad': ['cool', 'neat'], 
-     'awesome': 
-       {'crazy': ['indeed', 'man'],
-        'way': ['oh', 'yeah']}
-    }
-  },
-  {'drop': ['single', 'dude']}} =
-  input type="text" name="text" value=""/
-  textarea name="textarea"Default text/textarea
-  input type="hidden" name="hidden" value="invisible"/
-  select name="sub_cats" class="sub_cats_0"
-    optionChoose Category/option
-    optionrad/option
-    optionawesome/option
-  /select
-  select name="sub_cats_0" class="sub_cats_1"
-    optionChoose Subcategory/option
-  /select
-  select name="sub_cats_rad" class="sub_cats_1" style="display:none"
-    optioncool/option
-    optionneat/option
-  /select
-  select name="sub_cats_awesome" class="sub_cats_1" style="display:none"
-    optioncrazy/option
-    optionway/option
-  /select
-  select name="sub_cats_awesome_0" class="sub_cats_2" style="display:none"
-    optionChoose Subcategory/option
-  /select
-  select name="sub_cats_awesome_crazy" class="sub_cats_2" style="display:none"
-    optionindeed/option
-    optionman/option
-  /select
-  select name="sub_cats_awesome_way" class="sub_cats_2" style="display:none"
-    optionoh/option
-    optionyeah/option
-  /select
-  select name="drop"
-    optionsingle/option
-    optiondude/option
-  /select
-  */
\ No newline at end of file</diff>
				</file>
				<file>
					<file_name>js/jsawesome_new.js</file_name>
					<diff>@@ -1,299 +0,0 @@
-//Globals...
-Scroller = null
-delay = 100
-window.addEvent('load', function(){
-  Scroller = new Fx.Scroll(window, {link:'chain', offset:{x:0,y:-25}})
-})
-JSAwesome = new Class({
-	initialize: function(name, json, labels){
-	  this.name = name
-		this.json = json
-		this.labels = labels || {}
-		this.validations = $H(labels).getKeys().filter(function(f){
-		  return labels[f]['required'] || labels[f]['validation']
-		})
-		this.level = 0 
-		this.in_select = false
-		this.nested = {}
-	},
-	to_html: function() {
-	  var m = []
-	  $A(this.json).each(function(p){
-	    var n = []
-	    //Allows you to reference previous selects...
-	    if($type(p[1])=="number" && this.json[p[1]])
-	      p[1] = this.json[p[1]][1]
-	    if($type(p[0])=="array"){
-	      n.push(p.map(function(r){
-	        return new Element('div', {style:'float:left;margin-right:5px'}).adopt(this._process(r[1],r[0]))
-	      }, this))
-	      n.push(new Element('br', {style:'clear:left'}))
-	    } else
-	      n.push(this._process(p[1],p[0]))
-	    m.push(new Element('div', {'class':'error '+p[0]}).adopt(n))
-	    this.level = 0
-	  }, this);
-	 return $(this.name).adopt(m)
-	},
-	label: function(name, wafor) {
-	  var newname = null
-	  if($defined(this.labels[name])) {
-	    if($defined(this.labels[name]['label']))
-	      newname = this.labels[name]['label']
-	    else
-	      newname = this.labels[name]
-	    if($type(newname) == "object")
-	      newname = null
-	  }
-	  if(!$defined(newname))
-	    newname = name.replace(/^[_#*^]/,'').replace(/_/g,' ').capitalize()
-	  return ($type(wafor) == "element" ? wafor.set('html', newname) : new Element('label', {'for':wafor, 'html':newname}))
-	},
-	validate: function(e) {
-	  return this.validations.every(function(r){
-	    var checking = $(this.name).getElement('.'+r.replace(/^[_#~*^]/,''))
-	    var error = checking.getParent('.error')
-	    var invalid = this._check(checking)
-	    if(invalid) {
-	      this.delay = (delay -= 20)
-	      invalid[1].set('style', 'background:#d88b7e')
-	      if(error.getChildren().getLast().innerHTML != invalid[0]) {
-	        var mes = new Element('div', {
-	          style: 'color:red',
-	          html:invalid[0]
-	        }).inject(error)
-	      }
-	      invalid[1].addEvent(invalid[2] || 'blur', function(){
-	        var check = this._check(checking)
-	        if(!check || invalid[1] != check[1]) {
-	          invalid[1].set('style', 'background:')
-	          if(mes){
-	            mes.dispose()
-	            mes = false
-	          }
-	        }
-	      }.bind(this))
-	      if(this.delay  0)
-	        Scroller.toElement.delay(this.delay, Scroller, checking)
-	      else
-	        this._reset.delay(500)
-	      return false
-	    } else 
-	      return true
-	  }, this)
-	},
-	_reset: function() { delay = 100 },
-	_check: function(element) {
-	  var invalid = false
-	  var label = this.labels[element.get('class')]
-	  if(element.get('tag') == 'div') {
-      invalid = !element.getChildren().every(function(c){
-        element = c
-        return !(c.get('value') === "")
-      });
-      if(invalid) return ["This is a required field", element, 'change']
-    } else if(element.get('type') == "radio" && label['required']) {
-      var radios = element.getParent('fieldset').getElements('input')
-      if(radios.some(function(r){return r.get('value')}))
-        return false
-      else
-        return ["You must choose an option", new Elements(radios), 'click']
-    } else if(label['required'] && element.get('value') === "")
-      return ["This is a required field", element]
-    else if(label['validation'] && element.get('value') !== "") {
-      var args = $splat(label['validation'][0])
-      var regex = new RegExp(args[0], args[1])
-      return (regex.test(element.get('value')) ? false : [label['validation'][1], element])
-    }
-	},
-	_process: function(cur, name, parent) {
-	  switch($type(cur)) {
-	    //a select tag
-	    case 'array':
-	      if(name.test(/^\*/)) {
-	        return new Element('fieldset').adopt(
-	        [this.label(names[0].substring(1), new Element('legend'))].concat(cur.map(function(c){
-	          return this._process(c, names);
-	        }, this)));
-	      } else {
-	        cur = cur.sort()
-	        //Make the other / custom field go to the end...
-	        var other = false
-	        cur.some(function(a){ return a.test(/~/) ? a : other})
-	        if(other)
-	          cur.remove(other).push(other)
-	        if(cur.length  1)
-	          cur = ["Choose "+(parent ? "Subcategory" : "Category")].concat(cur)
-	        var named = this.name+"_"+name
-	        var level = parent ? parent.$attributes.level : null
-	        var klass = [named,level].clean().join("_")
-	        var els = []
-	        if(parent) {
-	          //DO SOMETHING TO REFERENCE SUB SELECTS
-	          parent.$attributes.children = this._nested(name, cur, klass, level)
-	          return null
-	        } else {
-	          els.push(this.label(name, named))
-	          return els.concat(this._nested(name, cur, klass, level))
-	        }
-	      }
-	    case 'object':
-	      cur = $H(cur)
-	      var t = [this._process(cur.getKeys(), names, parent)]
-	      t.push(this._process(["Choose Subcategory"], names.concat(['_']), true))
-	      return t.concat(cur.getValues().map(function(v){
-	        return this._process(v, names.concat([cur.keyOf(v).split('|').getLast()]), true)
-	      }, this));
-	    default:
-	      var name = names.join("_");
-	      var e = null
-	      //AKA not a checkbox
-	      if($type(cur)=="string") {
-	        var val = cur.split('|').getLast().replace(/Choose (Sub)?Category/i,'')
-	        cur = cur.split('|')[0].replace(/^[~*]/,'')
-	      }
-	      if(parent) {
-	        //Allows for custom values
-	        e = new Element('option', {html: cur, value: val})
-	        if(val.test(/^~/))
-            e.$attributes.extra = this._custom(parent.get('name')+'_other', 'rad')
-	      } else {
-	        if(name.test(/^#/)) {
-	          e = new Element('textarea', {
-	            name: this.name+'_'+name.substring(1), 
-	            'class':name.substring(1), 
-	            html: cur})
-	        } else if(name.test(/^_/)) {
-	          e = new Element('input', {
-	            type: 'hidden',
-	            'class': name.substring(1),
-	            name: this.name+'_'+name.substring(1), 
-	            value: cur
-	          })
-	        } else if(name.test(/^\*/)) {
-            e = this.label(cur, this.name+'_'+name.substring(1)).grab(new Element('input', {
-              type: 'radio',
-              'class': name.substring(1),
-              name: this.name+'_'+name.substring(1),
-              value: val
-            }), 'top')
-          } else if(name.test(/^\^/)) {
-            e = this.label(name, this.name+'_'+name.substring(1)).grab(new Element('input', {
-              type: 'checkbox',
-              'class': name.substring(1),
-              name: this.name+'_'+name.substring(1),
-              checked: (cur ? "checked" : "")
-            }), 'top')
-	        } else e = new Element('input', {type: 'text', 'class': name, name: this.name+'_'+name, value: cur})
-	        if(!name.test(/^[_*^]/))
-	          e = [this.label(name, e.name), e]
-	      }
-	      return e
-	  }
-	},
-	_custom: function(name, klass) {
-	  var val = this.labels['~'] || "Custom..."
-	  return new Element('input', {
-      'class':klass+' custom', 
-      type: 'text', 
-      name: name, 
-      value: val,
-      events: {
-        'focus': function(){
-          if(this.value == val)
-            this.set('value', "")
-        }
-      }
-    })
-	},
-	_nested: function(name, options, klass, level, type) {
-	  type = type || 'select'
-	  if(type == "custom") {
-	    return this._custom(name, klass)
-	  } else {
-	    var select = new Element("select", {
-        name: name,
-        'class': level  1 ? klass+' sub' : klass,
-        events: {
-          change: function(event){
-            var e = event.target
-            var it = e.get('value')
-            var option = e[e.selectedIndex]
-            //Dispose namespaced in a wrapper
-            $E('#'+this.name+' .'+classes.join('_')).getElements('.custom, .sub').dispose()
-            if(!option.$attributes.extra) return
-            var test = $(this.name).getElement('.'+klass)
-            //Replace or add the extras
-            if(test)
-              var made = option.$attributes.extra.replaces(test)
-            else
-              var made = option.$attributes.extra.inject(e.getParent())
-            //Restore the old value instead of an empty select
-          //  if(child.length  1) {
-          //    if(made.selectedIndex  0)                
-          //      var child = this.nested[classes.concat([level+1]).join('_')][made.get('value')]
-          //    child.getLast().inject(made, 'after')
-          //  }
-            //$E('#'+this.name+' .'+classes.join('_')).getElements('select').fireEvent('change')      
-          }.bind(this)
-        }
-      })
-      select.$attributes.level = (level || -1) + 1
-      if(type == "disabled")
-        select.set({style: 'display:none',disabled:'disabled')
-      return select.adopt(options.map(
-        function(o){
-          return this._process(o, klass, select)
-        },this)
-      )
-    }
-	}
-});
-
-/*
-{'text':'',
-  '#textarea':'Default text',
-  '_hidden':'invisible', 
-  {'sub_cats': 
-    {'rad': ['cool', 'neat'], 
-     'awesome': 
-       {'crazy': ['indeed', 'man'],
-        'way': ['oh', 'yeah']}
-    }
-  },
-  {'drop': ['single', 'dude']}} =
-  input type="text" name="text" value=""/
-  textarea name="textarea"Default text/textarea
-  input type="hidden" name="hidden" value="invisible"/
-  select name="sub_cats" class="sub_cats_0"
-    optionChoose Category/option
-    optionrad/option
-    optionawesome/option
-  /select
-  select name="sub_cats_0" class="sub_cats_1"
-    optionChoose Subcategory/option
-  /select
-  select name="sub_cats_rad" class="sub_cats_1" style="display:none"
-    optioncool/option
-    optionneat/option
-  /select
-  select name="sub_cats_awesome" class="sub_cats_1" style="display:none"
-    optioncrazy/option
-    optionway/option
-  /select
-  select name="sub_cats_awesome_0" class="sub_cats_2" style="display:none"
-    optionChoose Subcategory/option
-  /select
-  select name="sub_cats_awesome_crazy" class="sub_cats_2" style="display:none"
-    optionindeed/option
-    optionman/option
-  /select
-  select name="sub_cats_awesome_way" class="sub_cats_2" style="display:none"
-    optionoh/option
-    optionyeah/option
-  /select
-  select name="drop"
-    optionsingle/option
-    optiondude/option
-  /select
-  */
\ No newline at end of file</diff>
				</file>
				<file>
					<file_name>js/jsawesome_pre.js</file_name>
					<diff>@@ -1,340 +0,0 @@
-//Globals...
-Scroller = null
-delay = 100
-window.addEvent('load', function(){
-  Scroller = new Fx.Scroll(window, {link:'chain', offset:{x:0,y:-25}})
-})
-JSAwesome = new Class({
-	initialize: function(name, json, labels){
-	  this.name = name
-		this.json = json
-		this.labels = labels || {}
-		this.validations = $H(labels).getKeys().filter(function(f){
-		  return labels[f]['required'] || labels[f]['validation']
-		})
-		this.level = 0 
-		this.in_select = false
-		this.nested = {}
-	},
-	to_html: function() {
-	  var m = []
-	  $A(this.json).each(function(p){
-	    var n = []
-	    //Allows you to reference previous selects...
-	    if($type(p[1])=="number" && this.json[p[1]])
-	      p[1] = this.json[p[1]][1]
-	    if($type(p[0])=="array"){
-	      n.push(p.map(function(r){
-	        return new Element('div', {style:'float:left;margin-right:5px'}).adopt(this._process(r[1],r[0]))
-	      }, this))
-	      n.push(new Element('br', {style:'clear:left'}))
-	    } else
-	      n.push(this._process(p[1],p[0]))
-	    m.push(new Element('div', {'class':'error '+p[0]}).adopt(n))
-	    this.level = 0
-	  }, this);
-	 return $(this.name).adopt(m)
-	},
-	label: function(name, wafor) {
-	  var newname = null
-	  if($defined(this.labels[name])) {
-	    if($defined(this.labels[name]['label']))
-	      newname = this.labels[name]['label']
-	    else
-	      newname = this.labels[name]
-	    if($type(newname) == "object")
-	      newname = null
-	  }
-	  if(!$defined(newname))
-	    newname = name.replace(/^[_#*^]/,'').replace(/_/g,' ').capitalize()
-	  return ($type(wafor) == "element" ? wafor.set('html', newname) : new Element('label', {'for':wafor, 'html':newname}))
-	},
-	validate: function(e) {
-	  return this.validations.every(function(r){
-	    var checking = $(this.name).getElement('.'+r.replace(/^[_#~*^]/,''))
-	    var error = checking.getParent('.error')
-	    var invalid = this._check(checking)
-	    if(invalid) {
-	      this.delay = (delay -= 20)
-	      invalid[1].set('style', 'background:#d88b7e')
-	      if(error.getChildren().getLast().innerHTML != invalid[0]) {
-	        var mes = new Element('div', {
-	          style: 'color:red',
-	          html:invalid[0]
-	        }).inject(error)
-	      }
-	      invalid[1].addEvent(invalid[2] || 'blur', function(){
-	        var check = this._check(checking)
-	        if(!check || invalid[1] != check[1]) {
-	          invalid[1].set('style', 'background:')
-	          if(mes){
-	            mes.dispose()
-	            mes = false
-	          }
-	        }
-	      }.bind(this))
-	      if(this.delay  0)
-	        Scroller.toElement.delay(this.delay, Scroller, checking)
-	      else
-	        this._reset.delay(500)
-	      return false
-	    } else 
-	      return true
-	  }, this)
-	},
-	_reset: function() { delay = 100 },
-	_check: function(element) {
-	  var invalid = false
-	  var label = this.labels[element.get('class')]
-	  if(element.get('tag') == 'div') {
-      invalid = !element.getChildren().every(function(c){
-        element = c
-        return !(c.get('value') === "")
-      });
-      if(invalid) return ["This is a required field", element, 'change']
-    } else if(element.get('type') == "radio" && label['required']) {
-      var radios = element.getParent('fieldset').getElements('input')
-      if(radios.some(function(r){return r.get('value')}))
-        return false
-      else
-        return ["You must choose an option", new Elements(radios), 'click']
-    } else if(label['required'] && element.get('value') === "")
-      return ["This is a required field", element]
-    else if(label['validation'] && element.get('value') !== "") {
-      var args = $splat(label['validation'][0])
-      var regex = new RegExp(args[0], args[1])
-      return (regex.test(element.get('value')) ? false : [label['validation'][1], element])
-    }
-	},
-	_process: function(cur, names, nested) {
-	  names = $splat(names);
-	  switch($type(cur)) {
-	    //a select tag
-	    case 'array':
-	      if(names[0].test(/^\*/)) {
-	        return new Element('fieldset').adopt(
-	        [this.label(names[0].substring(1), new Element('legend'))].concat(cur.map(function(c){
-	          return this._process(c, names);
-	        }, this)));
-	      } else {
-	        this.in_select = true
-	        var root = !this.level
-	        cur = cur.sort()
-	        //Make the other / custom field go to the end...
-	        var other = false
-	        cur.some(function(a){
-	          if(a.test(/~/))
-	            other = a
-	          return other
-	        })
-	        if(other)
-	          cur.remove(other).push(other)
-	        if(cur.length  1)
-	          cur = ["Choose "+(this.level==0 ? "Category" : "Subcategory")].concat(cur)
-	        else if(this.level = 1 && cur.length  0)
-	          root = true
-	        var name = this.name+"_"+names[0]
-	        var klass = [names[0],this.level].join("_")
-	        var els = []
-	        if(!root) {
-	          //Add the subcategory dropdown
-	          var store = klass
-	          if(names.getLast() == "_") {
-	            var classes = klass.split('_')
-	            //Go back one level
-	            store = classes.concat([classes.pop().toInt() - 1]).join('_')
-	            names.pop()
-	          }
-	          if(cur.length  0) this._store(store, names.getLast(), cur, klass, name)
-	          this.in_select = false
-	          return null
-	        } else {
-	          if(this.level==0)
-	            els.push(this.label(names[0], name))
-	          if(!nested)
-	            klass += ' '+names[0]
-	          els = els.concat(this._nested(name, cur, klass))
-	          this.in_select = false
-  	        return els
-	        }
-	      }
-	    case 'object':
-	      cur = $H(cur)
-	      var t = [this._process(cur.getKeys(), names, true)]
-	      this.level += 1
-	      t.push(this._process(["Choose Subcategory"], names.concat(['_']), true))
-	      return t.concat(cur.getValues().map(function(v){
-	        return this._process(v, names.concat([cur.keyOf(v).split('|').getLast()]), true)
-	      }, this));
-	    default:
-	      var name = names.join("_");
-	      var e = null
-	      //AKA not a checkbox
-	      if($type(cur)=="string") {
-	        var val = cur.split('|').getLast().replace(/Choose (Sub)?Category/i,'')
-	        cur = cur.split('|')[0].replace(/^[~*]/,'')
-	      }
-	      if(this.in_select) {
-	        //Allows for custom values
-	        e = new Element('option', {html: cur, value: val})
-	        //Wow this is sketchy as F
-	        var name = name.split(' ')[0]
-	        if(val.test(/^~/)) this._store(name, val, [], name, this.name+'_'+name)
-	      } else {
-	        if(name.test(/^#/)) {
-	          e = new Element('textarea', {
-	            name: this.name+'_'+name.substring(1), 
-	            'class':name.substring(1), 
-	            html: cur})
-	        } else if(name.test(/^_/)) {
-	          e = new Element('input', {
-	            type: 'hidden',
-	            'class': name.substring(1),
-	            name: this.name+'_'+name.substring(1), 
-	            value: cur
-	          })
-	        } else if(name.test(/^\*/)) {
-            e = this.label(cur, this.name+'_'+name.substring(1)).grab(new Element('input', {
-              type: 'radio',
-              'class': name.substring(1),
-              name: this.name+'_'+name.substring(1),
-              value: val
-            }), 'top')
-          } else if(name.test(/^\^/)) {
-            e = this.label(name, this.name+'_'+name.substring(1)).grab(new Element('input', {
-              type: 'checkbox',
-              'class': name.substring(1),
-              name: this.name+'_'+name.substring(1),
-              checked: (cur ? "checked" : "")
-            }), 'top')
-	        } else e = new Element('input', {type: 'text', 'class': name, name: this.name+'_'+name, value: cur})
-	        if(!name.test(/^[_*^]/))
-	          e = [this.label(name, e.name), e]
-	      }
-	      return e
-	  }
-	},
-	_custom: function(name, klass) {
-	  var val = this.labels['~'] || "Custom..."
-	  return new Element('input', {
-      'class':(this.level  1 ? klass+' sub' : klass)+' custom', 
-      type: 'text', 
-      name: name, 
-      value: val,
-      events: {
-        'focus': function(){
-          if(this.value == val)
-            this.set('value', "")
-        }
-      }
-    })
-	},
-	_store: function(store, key, options, klass, name) {
-	  if(key.test(/^~/)){
-      var type = "custom"
-      name = name+'_other'
-    }else{
-      name = name+'_sub'+this.level
-      var type = options.length == 0 ? "disabled" : "select"
-    }
-    //if(this.nested[store] && this.nested[store][key]) return
-	  this.nested[store] = this.nested[store] || {}
-    this.nested[store][key] = this.nested[store][key] || []
-    this.nested[store][key].push(this._nested(name, options, klass, type))
-	},
-	_nested: function(name, options, klass, type) {
-	  type = type || 'select'
-	  if(type == "custom") {
-	    return this._custom(name, klass)
-	  } else {
-	    var select = new Element("select", {
-        name: name,
-        'class': this.level  1 ? klass+' sub' : klass,
-        events: {
-          change: function(event){
-            var e = event.target
-            var classes = e.get('class').split('_')
-            var level = classes.pop().toInt()+1
-            var klass = classes.concat([level]).join('_')
-            var it = e.get('value')
-            //Dispose namespaced in a wrapper
-            if(level  3)
-              $E('#'+this.name+' .'+classes.join('_')).getElements('.custom, .sub').dispose()
-            console.log('Checking for', klass, 'or', e.get('class').split(' ')[0])
-            var there = this.nested[klass] || this.nested[e.get('class').split(' ')[0]];
-            if(!there) return
-            var child = there[it]
-            if(!child) return
-            var test = $(this.name).getElement('.'+klass)
-            if(test)
-              var made = child[0].replaces(test)
-            else
-              var made = child[0].inject(e.getParent())
-            //Restore the old value instead of an empty select
-            if(child.length  1) {
-              if(made.selectedIndex  0)                
-                var child = this.nested[classes.concat([level+1]).join('_')][made.get('value')]
-              child.getLast().inject(made, 'after')
-            }
-            //$E('#'+this.name+' .'+classes.join('_')).getElements('select').fireEvent('change')      
-          }.bind(this)
-        }
-      })
-      if(type == "disabled")
-        select.set('style', 'display:none').set('disabled', 'disabled')
-      return select.adopt(options.map(
-        function(o){
-          return this._process(o, klass)
-        },this)
-      )
-    }
-	}
-});
-
-/*
-{'text':'',
-  '#textarea':'Default text',
-  '_hidden':'invisible', 
-  {'sub_cats': 
-    {'rad': ['cool', 'neat'], 
-     'awesome': 
-       {'crazy': ['indeed', 'man'],
-        'way': ['oh', 'yeah']}
-    }
-  },
-  {'drop': ['single', 'dude']}} =
-  input type="text" name="text" value=""/
-  textarea name="textarea"Default text/textarea
-  input type="hidden" name="hidden" value="invisible"/
-  select name="sub_cats" class="sub_cats_0"
-    optionChoose Category/option
-    optionrad/option
-    optionawesome/option
-  /select
-  select name="sub_cats_0" class="sub_cats_1"
-    optionChoose Subcategory/option
-  /select
-  select name="sub_cats_rad" class="sub_cats_1" style="display:none"
-    optioncool/option
-    optionneat/option
-  /select
-  select name="sub_cats_awesome" class="sub_cats_1" style="display:none"
-    optioncrazy/option
-    optionway/option
-  /select
-  select name="sub_cats_awesome_0" class="sub_cats_2" style="display:none"
-    optionChoose Subcategory/option
-  /select
-  select name="sub_cats_awesome_crazy" class="sub_cats_2" style="display:none"
-    optionindeed/option
-    optionman/option
-  /select
-  select name="sub_cats_awesome_way" class="sub_cats_2" style="display:none"
-    optionoh/option
-    optionyeah/option
-  /select
-  select name="drop"
-    optionsingle/option
-    optiondude/option
-  /select
-  */
\ No newline at end of file</diff>
				</file>
				<file>
					<file_name>lib/jstest.rb</file_name>
					<diff>@@ -0,0 +1,382 @@
+require 'rake/tasklib'
+require 'thread'
+require 'webrick'
+require 'fileutils'
+include FileUtils
+
+class Browser
+  def supported?; true; end
+  def setup ; end
+  def open(url) ; end
+  def teardown ; end
+
+  def host
+    require 'rbconfig'
+    Config::CONFIG['host']
+  end
+  
+  def macos?
+    host.include?('darwin')
+  end
+  
+  def windows?
+    host.include?('mswin')
+  end
+  
+  def linux?
+    host.include?('linux')
+  end
+  
+  def applescript(script)
+    raise "Can't run AppleScript on #{host}" unless macos?
+    system "osascript -e '#{script}' 2&1 /dev/null"
+  end
+end
+
+class FirefoxBrowser  Browser
+  def initialize(path=File.join(ENV['ProgramFiles'] || 'c:\Program Files', '\Mozilla Firefox\firefox.exe'))
+    @path = path
+  end
+
+  def visit(url)
+    system("open -a Firefox '#{url}'") if macos?
+    system("#{@path} #{url}") if windows? 
+    system("firefox #{url}") if linux?
+  end
+
+  def to_s
+    "Firefox"
+  end
+end
+
+class SafariBrowser  Browser
+  def supported?
+    macos?
+  end
+  
+  def setup
+    applescript('tell application "Safari" to make new document')
+  end
+  
+  def visit(url)
+    applescript('tell application "Safari" to set URL of front document to "' + url + '"')
+  end
+
+  def teardown
+    #applescript('tell application "Safari" to close front document')
+  end
+
+  def to_s
+    "Safari"
+  end
+end
+
+class IEBrowser  Browser
+  def setup
+    require 'win32ole' if windows?
+  end
+
+  def supported?
+    windows?
+  end
+  
+  def visit(url)
+    if windows?
+      ie = WIN32OLE.new('InternetExplorer.Application')
+      ie.visible = true
+      ie.Navigate(url)
+      while ie.ReadyState != 4 do
+        sleep(1)
+      end
+    end
+  end
+
+  def to_s
+    "Internet Explorer"
+  end
+end
+
+class KonquerorBrowser  Browser
+  @@configDir = File.join((ENV['HOME'] || ''), '.kde', 'share', 'config')
+  @@globalConfig = File.join(@@configDir, 'kdeglobals')
+  @@konquerorConfig = File.join(@@configDir, 'konquerorrc')
+
+  def supported?
+    linux?
+  end
+
+  # Forces KDE's default browser to be Konqueror during the tests, and forces
+  # Konqueror to open external URL requests in new tabs instead of a new
+  # window.
+  def setup
+    cd @@configDir, :verbose = false do
+      copy @@globalConfig, "#{@@globalConfig}.bak", :preserve = true, :verbose = false
+      copy @@konquerorConfig, "#{@@konquerorConfig}.bak", :preserve = true, :verbose = false
+      # Too lazy to write it in Ruby...  Is sed dependency so bad?
+      system "sed -ri /^BrowserApplication=/d  '#{@@globalConfig}'"
+      system "sed -ri /^KonquerorTabforExternalURL=/s:false:true: '#{@@konquerorConfig}'"
+    end
+  end
+
+  def teardown
+    cd @@configDir, :verbose = false do
+      copy "#{@@globalConfig}.bak", @@globalConfig, :preserve = true, :verbose = false
+      copy "#{@@konquerorConfig}.bak", @@konquerorConfig, :preserve = true, :verbose = false
+    end
+  end
+  
+  def visit(url)
+    system("kfmclient openURL #{url}")
+  end
+  
+  def to_s
+    "Konqueror"
+  end
+end
+
+class OperaBrowser  Browser
+  def initialize(path='c:\Program Files\Opera\Opera.exe')
+    @path = path
+  end
+  
+  def setup
+    if windows?
+      puts %{
+        MAJOR ANNOYANCE on Windows.
+        You have to shut down Opera manually after each test
+        for the script to proceed.
+        Any suggestions on fixing this is GREATLY appreciated!
+        Thank you for your understanding.
+      }
+    end
+  end
+  
+  def visit(url)
+    applescript('tell application "Opera" to GetURL "' + url + '"') if macos? 
+    system("#{@path} #{url}") if windows? 
+    system("opera #{url}")  if linux?
+  end
+
+  def to_s
+    "Opera"
+  end
+end
+
+# shut up, webrick :-)
+class ::WEBrick::HTTPServer
+  def access_log(config, req, res)
+    # nop
+  end
+end
+
+class ::WEBrick::BasicLog
+  def log(level, data)
+    # nop
+  end
+end
+
+class WEBrick::HTTPResponse
+  alias send send_response
+  def send_response(socket)
+    send(socket) unless fail_silently?
+  end
+  
+  def fail_silently?
+    @fail_silently
+  end
+  
+  def fail_silently
+    @fail_silently = true
+  end
+end
+
+class WEBrick::HTTPRequest
+  def to_json
+    headers = []
+    each { |k, v| headers.push "#{k.inspect}: #{v.inspect}" }
+    headers = "{"  headers.join(', ')  "}"
+    %({ "headers": #{headers}, "body": #{body.inspect}, "method": #{request_method.inspect} })
+  end
+end
+
+class WEBrick::HTTPServlet::AbstractServlet
+  def prevent_caching(res)
+    res['ETag'] = nil
+    res['Last-Modified'] = Time.now + 100**4
+    res['Cache-Control'] = 'no-store, no-cache, must-revalidate, post-check=0, pre-check=0'
+    res['Pragma'] = 'no-cache'
+    res['Expires'] = Time.now - 100**4
+  end
+end
+
+class BasicServlet  WEBrick::HTTPServlet::AbstractServlet
+  def do_GET(req, res)
+    prevent_caching(res)
+    res['Content-Type'] = "text/plain"
+    
+    req.query.each do |k, v|
+      res[k] = v unless k == 'responseBody'
+    end
+    res.body = req.query["responseBody"]
+    
+    raise WEBrick::HTTPStatus::OK
+  end
+  
+  def do_POST(req, res)
+    do_GET(req, res)
+  end
+end
+
+class SlowServlet  BasicServlet
+  def do_GET(req, res)
+    sleep(2)
+    super
+  end
+end
+
+class DownServlet  BasicServlet
+  def do_GET(req, res)
+    res.fail_silently
+  end
+end
+
+class InspectionServlet  BasicServlet
+  def do_GET(req, res)
+    prevent_caching(res)
+    res['Content-Type'] = "application/json"
+    res.body = req.to_json
+    raise WEBrick::HTTPStatus::OK
+  end
+end
+
+class NonCachingFileHandler  WEBrick::HTTPServlet::FileHandler
+  def do_GET(req, res)
+    super
+    set_default_content_type(res, req.path)
+    prevent_caching(res)
+  end
+  
+  def set_default_content_type(res, path)
+    res['Content-Type'] = case path
+      when /\.js$/   then 'text/javascript'
+      when /\.html$/ then 'text/html'
+      when /\.css$/  then 'text/css'
+      else 'text/plain'
+    end
+  end
+end
+
+class JavaScriptTestTask  ::Rake::TaskLib
+
+  def initialize(name=:test, port=4711)
+    @name = name
+    @tests = []
+    @browsers = []
+    @port = port
+    @queue = Queue.new
+
+    @server = WEBrick::HTTPServer.new(:Port = @port) # TODO: make port configurable
+    @server.mount_proc("/results") do |req, res|
+      @queue.push({
+        :tests = req.query['tests'].to_i,
+        :assertions = req.query['assertions'].to_i,
+        :failures = req.query['failures'].to_i,
+        :errors = req.query['errors'].to_i
+      })
+      res.body = "OK"
+    end
+    @server.mount("/response", BasicServlet)
+    @server.mount("/slow", SlowServlet)
+    @server.mount("/down", DownServlet)
+    @server.mount("/inspect", InspectionServlet)
+    yield self if block_given?
+    define
+  end
+
+  def define
+    task @name do
+      trap("INT") { @server.shutdown }
+      t = Thread.new { @server.start }
+      
+      # run all combinations of browsers and tests
+      @browsers.each do |browser|
+        if browser.supported?
+          t0 = Time.now
+          results = {:tests = 0, :assertions = 0, :failures = 0, :errors = 0}
+          errors = []
+          failures = []
+          browser.setup
+          puts "\nStarted tests in #{browser}"
+          @tests.each do |test|
+            params = "resultsURL=http://localhost:#{@port}/results&t=" + ("%.6f" % Time.now.to_f)
+            if test.is_a?(Hash)
+              params  "&tests=#{test[:testcases]}" if test[:testcases]
+              test = test[:url]
+            end
+            browser.visit("http://localhost:#{@port}#{test}?#{params}")
+ 
+            result = @queue.pop
+            result.each { |k, v| results[k] += v }
+            value = "."
+            
+            if result[:failures]  0
+              value = "F"
+              failures.push(test)
+            end
+            
+            if result[:errors]  0
+              value = "E"
+              errors.push(test)
+            end
+            
+            print value
+          end
+          
+          puts "\nFinished in #{(Time.now - t0).round.to_s} seconds."
+          puts "  Failures: #{failures.join(', ')}" unless failures.empty?
+          puts "  Errors:   #{errors.join(', ')}" unless errors.empty?
+          puts "#{results[:tests]} tests, #{results[:assertions]} assertions, #{results[:failures]} failures, #{results[:errors]} errors"
+          browser.teardown
+        else
+          puts "\nSkipping #{browser}, not supported on this OS"
+        end
+      end
+
+      @server.shutdown
+      t.join
+    end
+  end
+
+  def mount(path, dir=nil)
+    dir = Dir.pwd + path unless dir
+
+    # don't cache anything in our tests
+    @server.mount(path, NonCachingFileHandler, dir)
+  end
+
+  # test should be specified as a url or as a hash of the form
+  # {:url = "url", :testcases = "testFoo,testBar"}
+  def run(test)
+    @teststest
+  end
+
+  def browser(browser)
+    browser =
+      case(browser)
+        when :firefox
+          FirefoxBrowser.new
+        when :safari
+          SafariBrowser.new
+        when :ie
+          IEBrowser.new
+        when :konqueror
+          KonquerorBrowser.new
+        when :opera
+          OperaBrowser.new
+        else
+          browser
+      end
+
+    @browsersbrowser
+  end
+end</diff>
				</file>
				<file>
					<file_name>lib/protodoc.rb</file_name>
					<diff>@@ -0,0 +1,36 @@
+require 'erb'
+
+class String
+  def lines
+    split $/
+  end
+  
+  def strip_whitespace_at_line_ends
+    lines.map {|line| line.gsub(/\s+$/, '')} * $/
+  end
+end
+
+module Protodoc
+  module Environment
+    def include(*filenames)
+      filenames.map {|filename| Preprocessor.new(filename).to_s}.join("\n")
+    end
+  end
+  
+  class Preprocessor
+    include Environment
+    
+    def initialize(filename)
+      @filename = File.expand_path(filename)
+      @template = ERB.new(IO.read(@filename), nil, '%')
+    end
+    
+    def to_s
+      @template.result(binding).strip_whitespace_at_line_ends
+    end
+  end  
+end
+
+if __FILE__ == $0
+  print Protodoc::Preprocessor.new(ARGV.first)
+end</diff>
				</file>
				<file>
					<file_name>push_js.rb</file_name>
					<diff>@@ -1,14 +0,0 @@
-#!/usr/bin/env ruby
-ARGV[0] ||= 'turk.js'
-compress = ARGV[1] || false
-`cat js/base.js js/jsawesome.js  js/#{ARGV[0]}`
-if compress
-  puts "Compressing..."
-  `yuicompressor js/#{ARGV[0]}`
-  `mv js/#{ARGV[0].sub('.js','-min.js')} js/#{ARGV[0]}`
-else
-  puts "Pushing non compressed"
-end
-scp = "scp js/#{ARGV[0]} deployer@sh2.doloreslabs.com:/var/www/assets"
-puts `#{scp}`
-`rm js/#{ARGV[0]}`
\ No newline at end of file</diff>
				</file>
				<file>
					<file_name>script/destroy</file_name>
					<diff>@@ -0,0 +1,14 @@
+#!/usr/bin/env ruby
+APP_ROOT = File.expand_path(File.join(File.dirname(__FILE__), '..'))
+
+begin
+  require 'rubigen'
+rescue LoadError
+  require 'rubygems'
+  require 'rubigen'
+end
+require 'rubigen/scripts/destroy'
+
+ARGV.shift if ['--help', '-h'].include?(ARGV[0])
+RubiGen::Base.use_component_sources! [:javascript, :javascript_test, :newjs, :newjs_theme]
+RubiGen::Scripts::Destroy.new.run(ARGV)</diff>
				</file>
				<file>
					<file_name>script/generate</file_name>
					<diff>@@ -0,0 +1,14 @@
+#!/usr/bin/env ruby
+APP_ROOT = File.expand_path(File.join(File.dirname(__FILE__), '..'))
+
+begin
+  require 'rubigen'
+rescue LoadError
+  require 'rubygems'
+  require 'rubigen'
+end
+require 'rubigen/scripts/generate'
+
+ARGV.shift if ['--help', '-h'].include?(ARGV[0])
+RubiGen::Base.use_component_sources! [:javascript, :javascript_test, :newjs, :newjs_theme]
+RubiGen::Scripts::Generate.new.run(ARGV)</diff>
				</file>
				<file>
					<file_name>script/js_autotest</file_name>
					<diff>@@ -0,0 +1 @@
+script/rstakeout "rake test:recent:javascript" test/unit/*_test.html src/*.js</diff>
				</file>
				<file>
					<file_name>script/push_js</file_name>
					<diff>@@ -0,0 +1,14 @@
+#!/usr/bin/env ruby
+ARGV[0] ||= 'jsawesome.js'
+compress = ARGV[1] || false
+`cat js/base.js js/jsawesome.js  js/#{ARGV[0]}.local`
+if compress
+  puts "Compressing..."
+  `yuicompressor js/#{ARGV[0]}`
+  `mv js/#{ARGV[0].sub('.js','-min.js')} js/#{ARGV[0]}.local`
+else
+  puts "Pushing non compressed"
+end
+scp = "scp js/#{ARGV[0]}.local deployer@sh2.doloreslabs.com:/var/www/assets/#{ARGV[0]}"
+puts `#{scp}`
+`rm js/#{ARGV[0]}.local`
\ No newline at end of file</diff>
				</file>
				<file>
					<file_name>script/rstakeout</file_name>
					<diff>@@ -0,0 +1,98 @@
+#!/usr/local/bin/ruby -w
+
+
+config = File.dirname(__FILE__) + "/../config/javascript_test_autotest.yml"
+unless File.exists?(config)
+  puts -EOS
+Edit config/javascript_test_autotest.yml for the browser(s) to use for autotesting.
+See config/javascript_test_autotest.yml.sample for examples.
+EOS
+  exit
+end
+
+##
+# Originally by Mike Clark.
+#
+# From http://www.pragmaticautomation.com/cgi-bin/pragauto.cgi/Monitor/StakingOutFileChanges.rdoc
+#
+# Runs a user-defined command when files are modified.
+#
+# Like autotest, but more customizable. This is useful when you want to do
+# something other than run tests. For example, generate a PDF book, run
+# a single test, or run a legacy Test::Unit suite in an app that also
+# has an rSpec suite.
+#
+# Can use Ruby's Dir[] to get file glob. Quote your args to take advantage of this.
+#
+#  rstakeout 'rake test:recent' **/*.rb
+#  = Only watches Ruby files one directory down (no quotes)
+#
+#  rstakeout 'rake test:recent' '**/*.rb'
+#  = Watches all Ruby files in all directories and subdirectories
+#
+# Modified (with permission) by Geoffrey Grosenbach to call growlnotify for
+# rspec and Test::Unit output.
+#
+# See the PeepCode screencast on rSpec or other blog articles for instructions on
+# setting up growlnotify.
+
+def growl(title, msg, img, pri=0, sticky="")
+  system "growlnotify -n autotest --image ~/.autotest_images/#{img} -p #{pri} -m #{msg.inspect} #{title} #{sticky}"
+end
+
+def self.growl_fail(output)
+  growl "FAIL", "#{output}", "fail.png", 2
+end
+
+def self.growl_pass(output)
+  growl "Pass", "#{output}", "pass.png"
+end
+
+command = ARGV.shift
+files = {}
+
+ARGV.each do |arg|
+  Dir[arg].each { |file|
+    files[file] = File.mtime(file)
+  }
+end
+
+puts "Watching #{files.keys.join(', ')}\n\nFiles: #{files.keys.length}"
+
+trap('INT') do
+  puts "\nQuitting..."
+  exit
+end
+
+
+loop do
+
+  sleep 1
+
+  changed_file, last_changed = files.find { |file, last_changed|
+    File.mtime(file)  last_changed
+  }
+
+  if changed_file
+    files[changed_file] = File.mtime(changed_file)
+    puts "= #{changed_file} changed, running #{command}"
+    results = `#{command}`
+    puts results
+
+    if results.include? 'tests'
+      output = results.slice(/(\d+)\s+tests?,\s*(\d+)\s+assertions?,\s*(\d+)\s+failures?(,\s*(\d+)\s+errors)?/)
+      if output
+        $~[3].to_i + $~[5].to_i  0 ? growl_fail(output) : growl_pass(output)
+      end
+    else
+      output = results.slice(/(\d+)\s+examples?,\s*(\d+)\s+failures?(,\s*(\d+)\s+not implemented)?/)
+      if output
+        $~[2].to_i  0 ? growl_fail(output) : growl_pass(output)
+      end
+    end
+    # TODO Generic growl notification for other actions
+
+    puts "= done"
+  end
+
+end</diff>
				</file>
				<file>
					<file_name>src/HEADER</file_name>
					<diff>@@ -0,0 +1,8 @@
+/*  Jsawesome, version %= APP_VERSION %
+ *  (c) 2008 Chris Van Pelt
+ *
+ *  Jsawesome is freely distributable under 
+ *  the terms of an MIT-style license.
+ *  For details, see the web site: http://github.com/vanpelt/jsawesome/tree/master
+ *
+ *--------------------------------------------------------------------------*/
\ No newline at end of file</diff>
				</file>
				<file>
					<file_name>src/base.js</file_name>
					<diff>@@ -0,0 +1,264 @@
+//Globals...
+Scroller = null
+delay = 100
+window.addEvent('load', function(){
+  Scroller = new Fx.Scroll(window, {link:'chain', offset:{x:0,y:-25}})
+})
+JSAwesome = new Class({
+	initialize: function(name, json, labels){
+	  this.name = name
+		this.json = json
+		this.labels = labels || {}
+		this.validations = $H(labels).getKeys().filter(function(f){
+		  return labels[f]['required'] || labels[f]['validation']
+		})
+	},
+	to_html: function() {
+	  var m = []
+	  $A(this.json).each(function(p,i){
+	    var n = []
+	    //Allows you to reference previous selects...
+	    if($type(p[1])=="number" && this.json[p[1]])
+	      p[1] = this.json[p[1]][1]
+	    if($type(p[0])=="array"){
+	      n.push(p.map(function(r){
+	        r = $splat(r)
+	        return new Element('div', {style:'float:left;margin-right:5px'}).adopt(this._process(r[1],r[0]))
+	      }, this))
+	      n.push(new Element('br', {style:'clear:left'}))
+	    } else
+	      n.push(this._process(p[1],p[0]))
+	    var klass = $type(p[0]) == "string" ? p[0].replace(/^[_#*^]/,'') : "row_"+i+1
+	    m.push(new Element('div', {'class':'error '+klass}).adopt(n))
+	    this.level = 0
+	  }, this);
+	  var adopted = $(this.name).adopt(m)
+	  adopted.getElements('select').each(function(e){
+	    e.fireEvent('change', {target:e})
+	  })
+	 return adopted
+	},
+	label: function(name, wafor) {
+	  var newname = null
+	  if($defined(this.labels[name])) {
+	    if($defined(this.labels[name]['label']))
+	      newname = this.labels[name]['label']
+	    else
+	      newname = this.labels[name]
+	    if($type(newname) == "object")
+	      newname = null
+	  }
+	  if(!$defined(newname))
+	    newname = name.replace(/^[_#*^]/,'').replace(/_/g,' ').capitalize()
+	  return ($type(wafor) == "element" ? wafor.set('html', newname) : new Element('label', {'for':wafor, 'html':newname}))
+	},
+	addValidation: function(){
+	  this.validater = this.validate.bind(this)
+	  $(this.name).getParent('form').addEvent('submit', this.validater)
+	},
+	stopValidation: function(){
+	  $(this.name).getParent('form').removeEvent('submit', this.validater)
+	},
+	validate: function(e) {
+	  return this.validations.filter(function(r){
+	    var checking = $(this.name).getElement('div .'+r.replace(/^[_#~*^]/,''))
+	    var error = checking.getParent('.error')
+	    var invalid = this._check(checking)
+	    if(invalid) {
+	      this.delay = (delay -= 20)
+	      invalid[1].set('style', 'background:#d88b7e')
+	      if(error.getChildren().getLast().innerHTML != invalid[0]) {
+	        var mes = new Element('div', {
+	          style: 'color:red',
+	          html:invalid[0]
+	        }).inject(error)
+	      }
+	      invalid[1].addEvent(invalid[2] || 'blur', function(){
+	        var check = this._check(checking)
+	        if(!check || invalid[1] != check[1]) {
+	          invalid[1].set('style', 'background:')
+	          if(mes){
+	            mes.dispose()
+	            mes = false
+	          }
+	        }
+	      }.bind(this))
+	      if(this.delay  0)
+	        Scroller.toElement.delay(this.delay, Scroller, checking)
+	      else
+	        this._reset.delay(500)
+	      return true
+	    } else 
+	      return false
+	  }, this).length == 0
+	},
+	_reset: function() { delay = 100 },
+	_check: function(element) {
+	  var invalid = false
+	  var label = this.labels[element.get('class')]
+	  //Validate chained selects
+	  if(element.get('tag') == 'select') {
+      invalid = element.getParent().getElements("select, .custom").some(function(c){
+        element = c
+        return c.get('value') === ""
+      });
+      if(invalid) return ["This is a required field", element, 'change']
+    } else if(element.get('type') == "radio" && label['required']) {
+      var radios = element.getParent('fieldset').getElements('input')
+      if(radios.some(function(r){return r.get('value')}))
+        return false
+      else
+        return ["You must choose an option", new Elements(radios), 'click']
+    } else if(element.get('type') == "checkbox" && label['required']) {
+      if(element.checked)
+        return false
+      else
+        return ["You must check this box", element, 'click']
+    } else if(label['required'] && element.get('value') === "")
+      return ["This is a required field", element]
+    else if(label['validation'] && element.get('value') !== "") {
+      var args = $splat(label['validation'][0])
+      var regex = new RegExp(args[0], args[1])
+      return (regex.test(element.get('value')) ? false : [label['validation'][1], element])
+    }
+	},
+	_process: function(cur, name, parent) {
+	  var select_default = this.labels['{}'] || ["Choose Category", "Choose Subcategory"]
+	  switch($type(cur)) {
+	    //a select tag or group of radios/checkboxes
+	    case 'array':
+	      if(name.test(/^[*^]/)) {
+	        return new Element('fieldset').adopt(
+	          [this.label(name.replace(/^[*^]/,''), new Element('legend'))].concat(cur.map(function(c){
+	            c = $splat(c)
+	            return this._process(c[0], name, c.getLast());
+	          }, this))
+	        );
+	      } else {
+          //Sort the options, and make the other / custom field go to the end...
+          cur = cur.sort()
+          var other = false
+          cur.some(function(a){ return a.test(/~/) ? a : other})
+          if(other)
+            cur.remove(other).push(other)
+          //Add the default header
+	        cur = [parent ? select_default[1] : select_default[0]].concat(cur)
+	        var level = parent ? parent.getParent().$attributes.level : null
+	        var klass = [name,level].clean().join("_")
+	        if(parent) {
+	          parent.$attributes.extra = this._select(name, cur, klass)
+	          return null
+	        } else
+	          return [this.label(name, this.name+'_'+name),this._select(name, cur, klass)]
+	      }
+	    case 'object':
+	      cur = $H(cur)
+	      var t = [this._process(cur.getKeys(), name, parent)]
+	      var root = parent ? parent.$attributes.extra : t[0][1]
+	      t.push(this._process([], name, root.getElement('option')))
+	      return t.concat(cur.getValues().map(function(v){
+	        var val = cur.keyOf(v).split('|').getLast()
+	        var parent = root.getElement('option[value='+val+']')
+	        return this._process(v, name, parent)
+	      }, this));
+	    default:
+	      var e = null
+        //Ugggggg
+	      if($type(cur)=="string") {
+	        //There should be a better way to do this
+	        var reversed = [].concat(select_default).reverse()
+	        var val = cur.split('|').getLast().replace(new RegExp(reversed.join("|")),'')
+	        cur = cur.split('|')[0].replace(/^[~*]/,'')
+	      }
+	      if($type(parent) == "element") {
+	        //Allows for custom values
+	        e = new Element('option', {html: cur, value: val.replace(/^~/,'')})
+	        if(val.test(/^~/))
+            e.$attributes.extra = this._custom(parent.get('name')+'_other', parent.get('name'))
+	      } else {
+	        if(name.test(/^#/)) {
+	          e = new Element('textarea', {
+	            name: this.name+'_'+name.substring(1), 
+	            'class':name.substring(1), 
+	            html: cur})
+	        } else if(name.test(/^_/)) {
+	          e = this._input('hidden', name.substring(1), cur)
+	        } else if(name.test(/^\*/)) {
+            e = this.label(cur, this.name+'_'+name.substring(1)).grab(
+              this._input('radio', name.substring(1), val), 'top')
+          } else if(name.test(/^\^/)) {
+            //handles both grouped checkboxes and individual ones... Kindof a Mind FFFF
+            if($defined(parent))
+              var tname = cur
+            else {
+              parent = cur
+              var tname = name.substring(1)
+            }
+            e = this.label(tname, this.name+'_'+(val || tname)).grab(
+              this._input('checkbox', (val || tname), parent === true), 'top')
+	        } else e = this._input('text', name, cur)
+	        if(!name.test(/^[_*^]/))
+	          e = [this.label(name, e.name), e]
+	      }
+	      return e
+	  }
+	},
+	_input: function(type, name, val) {
+	  e = new Element('input', {type: type, 'class': name, name: this.name+'_'+name})
+    if(type == "checkbox")
+      e.set('checked', val ? "checked" : "")
+    else
+      e.set('value', val)
+    return e
+	},
+	_custom: function(name, klass) {
+	  var val = this.labels['~'] || "Custom..."
+	  return new Element('input', {
+      'class':klass+' custom', 
+      type: 'text', 
+      name: name, 
+      value: val,
+      events: {
+        'focus': function(){
+          if(this.value == val)
+            this.set('value', "")
+        }
+      }
+    })
+	},
+	_select: function(name, options, klass) {
+	  var level = klass.split("_").pop().toInt() || 0
+	  var select = new Element("select", {
+      name: this.name + '_' + (level  0 ? name + '_' + level : name),
+      'class': klass,
+      events: {
+        change: function(event){
+          var e = event.target
+          var option = e[e.selectedIndex]
+          var level = e.$attributes.level
+          var klass = e.get('class').split(' ')[0]
+          var next = klass.test(/\d+$/) ? klass.replace(/\d+$/, level) : klass+'_'+level 
+          //Dispose namespaced in a wrapper
+          $E('#'+this.name+' .'+klass.replace(/_\d+$/,'')).getElements('.custom, select').each(function(i){
+            if(i.hasClass('custom') || i.$attributes.level  level)
+              i.dispose()
+          })
+          if(!option.$attributes.extra) return
+          var test = $(this.name).getElement('.'+next)
+          //Replace or add the extras
+          if(test)
+            var made = option.$attributes.extra.replaces(test)
+          else
+            var made = option.$attributes.extra.inject(e, "after")
+          made.fireEvent('change', {target:made})
+        }.bind(this)
+      }
+    })    
+    select.$attributes.level = (level || 0) + 1
+    return select.adopt(options.map(
+      function(o){
+        return this._process(o, klass, select)
+      },this)
+    )
+	}
+});
\ No newline at end of file</diff>
				</file>
				<file>
					<file_name>src/jsawesome.js</file_name>
					<diff>@@ -0,0 +1,5 @@
+%= include 'HEADER' %
+
+%= include 'mootools.js' %
+
+%= include 'base.js' %
\ No newline at end of file</diff>
				</file>
				<file>
					<file_name>src/mootools.js</file_name>
					<diff>@@ -2623,4 +2623,4 @@ Fx.Scroll = new Class({
 		return this.start(position.x, position.y);
 	}
 
-});
+});
\ No newline at end of file</diff>
				</file>
				<file>
					<file_name>tasks/deploy.rake</file_name>
					<diff>@@ -0,0 +1,29 @@
+desc 'Package and upload the release to rubyforge.'
+task :release = [:clean, :dist, :package] do |t|
+  require 'rubyforge'
+  version = APP_VERSION
+  name    = APP_NAME
+  rubyforge_name = RUBYFORGE_PROJECT
+  v = ENV["VERSION"] or abort "Must supply VERSION=x.y.z"
+  abort "Versions don't match #{v} vs #{version}" if v != version
+  pkg = "pkg/#{name}-#{version}"
+
+  if $DEBUG then
+    puts "release_id = rf.add_release #{rubyforge_name.inspect}, #{name.inspect}, #{version.inspect}, \"#{pkg}.tgz\""
+    puts "rf.add_file #{rubyforge_name.inspect}, #{name.inspect}, release_id, \"#{pkg}.gem\""
+  end
+
+  rf = RubyForge.new
+  puts "Logging in"
+  rf.login
+
+  c = rf.userconfig
+  c["release_notes"] = APP_DESCRIPTION if Object.const_defined?("APP_DESCRIPTION")
+  c["release_changes"] = APP_CHANGES   if Object.const_defined?("APP_CHANGES")
+  c["preformatted"] = true
+
+  files = ["#{pkg}.tar.gz", "dist/#{name}-#{version}.js"].compact
+
+  puts "Releasing #{name} v. #{version}"
+  rf.add_release rubyforge_name, name, version, *files
+end</diff>
				</file>
				<file>
					<file_name>tasks/environment.rake</file_name>
					<diff>@@ -0,0 +1,7 @@
+task :ruby_env do
+  RUBY_APP = if RUBY_PLATFORM =~ /java/
+    "jruby"
+  else
+    "ruby"
+  end unless defined? RUBY_APP
+end</diff>
				</file>
				<file>
					<file_name>tasks/javascript_test_autotest_tasks.rake</file_name>
					<diff>@@ -0,0 +1,45 @@
+TEST_CHANGES_SINCE = Time.now - 600
+
+namespace :test do
+  namespace :recent do
+    desc "Open recently modified files into browser"
+    task :javascript do
+      require 'rubygems'
+      gem 'activesupport'
+      require 'active_support'
+
+      since = TEST_CHANGES_SINCE
+      touched = FileList[
+        'test/unit/*_test.html', 
+        'src/*.js'].select { |path| File.mtime(path)  since }
+      next if touched.blank?
+      
+      gem 'newjs'
+      require 'newjs'
+      require 'newjs/autotest'
+      
+      touched.each do |file|
+        if file =~ /\/([^\/]+)\.js$/
+          file = "test/unit/#{$1}_test.html"
+        end
+        file = "#{APP_ROOT}/#{file}"
+        unless File.exists?(file)
+          # puts "Notice: Test file does not exist: #{file}"
+          next
+        end
+        puts "Launching test: #{file}"
+        browsers = JavascriptTestAutotest::Config.get :browsers
+        if browsers.blank?
+          puts "WARNING: No browsers setup in config/javascript_test_autotest.yml"
+          next
+        end
+        browsers.each_pair do |name, path|
+          browser = JavascriptTestAutotest::Browser.browser(name, path)
+          browser.setup
+          browser.visit(file)
+          browser.teardown          
+        end
+      end
+    end
+  end
+end</diff>
				</file>
				<file>
					<file_name>test/assets/jsunittest.js</file_name>
					<diff>@@ -0,0 +1,964 @@
+/*  Jsunittest, version 0.6.1
+ *  (c) 2008 Dr Nic Williams
+ *
+ *  Jsunittest is freely distributable under
+ *  the terms of an MIT-style license.
+ *  For details, see the web site: http://jsunittest.rubyforge.org
+ *
+ *--------------------------------------------------------------------------*/
+
+var JsUnitTest = {
+  Version: '0.6.1',
+};
+
+var DrNicTest = {
+  Unit: {},
+  inspect: function(object) {
+    try {
+      if (typeof object == "undefined") return 'undefined';
+      if (object === null) return 'null';
+      if (typeof object == "string") {
+        var useDoubleQuotes = arguments[1];
+        var escapedString = this.gsub(object, /[\x00-\x1f\\]/, function(match) {
+          var character = String.specialChar[match[0]];
+          return character ? character : '\\u00' + match[0].charCodeAt().toPaddedString(2, 16);
+        });
+        if (useDoubleQuotes) return '"' + escapedString.replace(/"/g, '\\"') + '"';
+        return "'" + escapedString.replace(/'/g, '\\\'') + "'";
+      };
+      return String(object);
+    } catch (e) {
+      if (e instanceof RangeError) return '...';
+      throw e;
+    }
+  },
+  $: function(element) {
+    if (arguments.length  1) {
+      for (var i = 0, elements = [], length = arguments.length; i  length; i++)
+        elements.push(this.$(arguments[i]));
+      return elements;
+    }
+    if (typeof element == "string")
+      element = document.getElementById(element);
+    return element;
+  },
+  gsub: function(source, pattern, replacement) {
+    var result = '', match;
+    replacement = arguments.callee.prepareReplacement(replacement);
+
+    while (source.length  0) {
+      if (match = source.match(pattern)) {
+        result += source.slice(0, match.index);
+        result += DrNicTest.String.interpret(replacement(match));
+        source  = source.slice(match.index + match[0].length);
+      } else {
+        result += source, source = '';
+      }
+    }
+    return result;
+  },
+  scan: function(source, pattern, iterator) {
+    this.gsub(source, pattern, iterator);
+    return String(source);
+  },
+  escapeHTML: function(data) {
+    return data.replace(/&/g,'&amp;').replace(//g,'&lt;').replace(//g,'&gt;');
+  },
+  arrayfromargs: function(args) {
+  	var myarray = new Array();
+  	var i;
+
+  	for (i=0;iargs.length;i++)
+  		myarray[i] = args[i];
+
+  	return myarray;
+  },
+  hashToSortedArray: function(hash) {
+    var results = [];
+    for (key in hash) {
+      results.push([key, hash[key]]);
+    }
+    return results.sort();
+  },
+  flattenArray: function(array) {
+    var results = arguments[1] || [];
+    for (var i=0; i  array.length; i++) {
+      var object = array[i];
+      if (object != null && typeof object == "object" &&
+        'splice' in object && 'join' in object) {
+          this.flattenArray(object, results);
+      } else {
+        results.push(object);
+      }
+    };
+    return results;
+  },
+  selectorMatch: function(expression, element) {
+    var tokens = [];
+    var patterns = {
+      // combinators must be listed first
+      // (and descendant needs to be last combinator)
+      laterSibling: /^\s*~\s*/,
+      child:        /^\s*\s*/,
+      adjacent:     /^\s*\+\s*/,
+      descendant:   /^\s/,
+
+      // selectors follow
+      tagName:      /^\s*(\*|[\w\-]+)(\b|$)?/,
+      id:           /^#([\w\-\*]+)(\b|$)/,
+      className:    /^\.([\w\-\*]+)(\b|$)/,
+      pseudo:
+  /^:((first|last|nth|nth-last|only)(-child|-of-type)|empty|checked|(en|dis)abled|not)(\((.*?)\))?(\b|$|(?=\s|[:+~]))/,
+      attrPresence: /^\[((?:[\w]+:)?[\w]+)\]/,
+      attr:         /\[((?:[\w-]*:)?[\w-]+)\s*(?:([!^$*~|]?=)\s*((['"])([^\4]*?)\4|([^'"][^\]]*?)))?\]/
+    };
+
+    var assertions = {
+      tagName: function(element, matches) {
+        return matches[1].toUpperCase() == element.tagName.toUpperCase();
+      },
+
+      className: function(element, matches) {
+        return Element.hasClassName(element, matches[1]);
+      },
+
+      id: function(element, matches) {
+        return element.id === matches[1];
+      },
+
+      attrPresence: function(element, matches) {
+        return Element.hasAttribute(element, matches[1]);
+      },
+
+      attr: function(element, matches) {
+        var nodeValue = Element.readAttribute(element, matches[1]);
+        return nodeValue && operators[matches[2]](nodeValue, matches[5] || matches[6]);
+      }
+    };
+    var e = this.expression, ps = patterns, as = assertions;
+    var le, p, m;
+
+    while (e && le !== e && (/\S/).test(e)) {
+      le = e;
+      for (var i in ps) {
+        p = ps[i];
+        if (m = e.match(p)) {
+          // use the Selector.assertions methods unless the selector
+          // is too complex.
+          if (as[i]) {
+            tokens.push([i, Object.clone(m)]);
+            e = e.replace(m[0], '');
+          }
+        }
+      }
+    }
+
+    var match = true, name, matches;
+    for (var i = 0, token; token = tokens[i]; i++) {
+      name = token[0], matches = token[1];
+      if (!assertions[name](element, matches)) {
+        match = false; break;
+      }
+    }
+
+    return match;
+  },
+  toQueryParams: function(query, separator) {
+    var query = query || window.location.search;
+    var match = query.replace(/^\s+/, '').replace(/\s+$/, '').match(/([^?#]*)(#.*)?$/);
+    if (!match) return { };
+
+    var hash = {};
+    var parts = match[1].split(separator || '&');
+    for (var i=0; i  parts.length; i++) {
+      var pair = parts[i].split('=');
+      if (pair[0]) {
+        var key = decodeURIComponent(pair.shift());
+        var value = pair.length  1 ? pair.join('=') : pair[0];
+        if (value != undefined) value = decodeURIComponent(value);
+
+        if (key in hash) {
+          var object = hash[key];
+          var isArray = object != null && typeof object == "object" &&
+            'splice' in object && 'join' in object
+          if (!isArray) hash[key] = [hash[key]];
+          hash[key].push(value);
+        }
+        else hash[key] = value;
+      }
+    };
+    return hash;
+  },
+
+  String: {
+    interpret: function(value) {
+      return value == null ? '' : String(value);
+    }
+  }
+};
+
+DrNicTest.gsub.prepareReplacement = function(replacement) {
+  if (typeof replacement == "function") return replacement;
+  var template = new Template(replacement);
+  return function(match) { return template.evaluate(match) };
+};
+
+DrNicTest.Template = function(template, pattern) {
+  this.template = template; //template.toString();
+  this.pattern = pattern || DrNicTest.Template.Pattern;
+};
+
+DrNicTest.Template.prototype.evaluate = function(object) {
+  if (typeof object.toTemplateReplacements == "function")
+    object = object.toTemplateReplacements();
+
+  return DrNicTest.gsub(this.template, this.pattern, function(match) {
+    if (object == null) return '';
+
+    var before = match[1] || '';
+    if (before == '\\') return match[2];
+
+    var ctx = object, expr = match[3];
+    var pattern = /^([^.[]+|\[((?:.*?[^\\])?)\])(\.|\[|$)/;
+    match = pattern.exec(expr);
+    if (match == null) return before;
+
+    while (match != null) {
+      var comp = (match[1].indexOf('[]') === 0) ? match[2].gsub('\\\\]', ']') : match[1];
+      ctx = ctx[comp];
+      if (null == ctx || '' == match[3]) break;
+      expr = expr.substring('[' == match[3] ? match[1].length : match[0].length);
+      match = pattern.exec(expr);
+    }
+
+    return before + DrNicTest.String.interpret(ctx);
+  });
+}
+
+DrNicTest.Template.Pattern = /(^|.|\r|\n)(#\{(.*?)\})/;
+DrNicTest.Event = {};
+// written by Dean Edwards, 2005
+// with input from Tino Zijdel, Matthias Miller, Diego Perini
+// namespaced by Dr Nic Williams 2008
+
+// http://dean.edwards.name/weblog/2005/10/add-event/
+// http://dean.edwards.name/weblog/2005/10/add-event2/
+DrNicTest.Event.addEvent = function(element, type, handler) {
+	if (element.addEventListener) {
+		element.addEventListener(type, handler, false);
+	} else {
+		// assign each event handler a unique ID
+		if (!handler.$$guid) handler.$$guid = addEvent.guid++;
+		// create a hash table of event types for the element
+		if (!element.events) element.events = {};
+		// create a hash table of event handlers for each element/event pair
+		var handlers = element.events[type];
+		if (!handlers) {
+			handlers = element.events[type] = {};
+			// store the existing event handler (if there is one)
+			if (element["on" + type]) {
+				handlers[0] = element["on" + type];
+			}
+		}
+		// store the event handler in the hash table
+		handlers[handler.$$guid] = handler;
+		// assign a global event handler to do all the work
+		element["on" + type] = handleEvent;
+	}
+};
+// a counter used to create unique IDs
+DrNicTest.Event.addEvent.guid = 1;
+
+DrNicTest.Event.removeEvent = function(element, type, handler) {
+	if (element.removeEventListener) {
+		element.removeEventListener(type, handler, false);
+	} else {
+		// delete the event handler from the hash table
+		if (element.events && element.events[type]) {
+			delete element.events[type][handler.$$guid];
+		}
+	}
+};
+
+DrNicTest.Event.handleEvent = function(event) {
+	var returnValue = true;
+	// grab the event object (IE uses a global event object)
+	event = event || fixEvent(((this.ownerDocument || this.document || this).parentWindow || window).event);
+	// get a reference to the hash table of event handlers
+	var handlers = this.events[event.type];
+	// execute each event handler
+	for (var i in handlers) {
+		this.$$handleEvent = handlers[i];
+		if (this.$$handleEvent(event) === false) {
+			returnValue = false;
+		}
+	}
+	return returnValue;
+};
+
+DrNicTest.Event.fixEvent = function(event) {
+	// add W3C standard event methods
+	event.preventDefault = fixEvent.preventDefault;
+	event.stopPropagation = fixEvent.stopPropagation;
+	return event;
+};
+DrNicTest.Event.fixEvent.preventDefault = function() {
+	this.returnValue = false;
+};
+DrNicTest.Event.fixEvent.stopPropagation = function() {
+	this.cancelBubble = true;
+};
+
+DrNicTest.Unit.Logger = function(element) {
+  this.element = DrNicTest.$(element);
+  if (this.element) this._createLogTable();
+};
+
+DrNicTest.Unit.Logger.prototype.start = function(testName) {
+  if (!this.element) return;
+  var tbody = this.element.getElementsByTagName('tbody')[0];
+  tbody.innerHTML = tbody.innerHTML + 'trtd' + testName + '/tdtd/tdtd/td/tr';
+};
+
+DrNicTest.Unit.Logger.prototype.setStatus = function(status) {
+  var logline = this.getLastLogLine();
+  logline.className = status;
+  var statusCell = logline.getElementsByTagName('td')[1];
+  statusCell.innerHTML = status;
+};
+
+DrNicTest.Unit.Logger.prototype.finish = function(status, summary) {
+  if (!this.element) return;
+  this.setStatus(status);
+  this.message(summary);
+};
+
+DrNicTest.Unit.Logger.prototype.message = function(message) {
+  if (!this.element) return;
+  var cell = this.getMessageCell();
+  cell.innerHTML = this._toHTML(message);
+};
+
+DrNicTest.Unit.Logger.prototype.summary = function(summary) {
+  if (!this.element) return;
+  var div = this.element.getElementsByTagName('div')[0];
+  div.innerHTML = this._toHTML(summary);
+};
+
+DrNicTest.Unit.Logger.prototype.getLastLogLine = function() {
+  var tbody = this.element.getElementsByTagName('tbody')[0];
+  var loglines = tbody.getElementsByTagName('tr');
+  return loglines[loglines.length - 1];
+};
+
+DrNicTest.Unit.Logger.prototype.getMessageCell = function() {
+  var logline = this.getLastLogLine();
+  return logline.getElementsByTagName('td')[2];
+};
+
+DrNicTest.Unit.Logger.prototype._createLogTable = function() {
+  var html = 'div class="logsummary"running.../div' +
+  'table class="logtable"' +
+  'theadtrthStatus/ththTest/ththMessage/th/tr/thead' +
+  'tbody class="loglines"/tbody' +
+  '/table';
+  this.element.innerHTML = html;
+};
+
+DrNicTest.Unit.Logger.prototype.appendActionButtons = function(actions) {
+  // actions = $H(actions);
+  // if (!actions.any()) return;
+  // var div = new Element("div", {className: 'action_buttons'});
+  // actions.inject(div, function(container, action) {
+  //   var button = new Element("input").setValue(action.key).observe("click", action.value);
+  //   button.type = "button";
+  //   return container.insert(button);
+  // });
+  // this.getMessageCell().insert(div);
+};
+
+DrNicTest.Unit.Logger.prototype._toHTML = function(txt) {
+  return DrNicTest.escapeHTML(txt).replace(/\n/g,"br/");
+};
+DrNicTest.Unit.MessageTemplate = function(string) {
+  var parts = [];
+  var str = DrNicTest.scan((string || ''), /(?=[^\\])\?|(?:\\\?|[^\?])+/, function(part) {
+    parts.push(part[0]);
+  });
+  this.parts = parts;
+};
+
+DrNicTest.Unit.MessageTemplate.prototype.evaluate = function(params) {
+  var results = [];
+  for (var i=0; i  this.parts.length; i++) {
+    var part = this.parts[i];
+    var result = (part == '?') ? DrNicTest.inspect(params.shift()) : part.replace(/\\\?/, '?');
+    results.push(result);
+  };
+  return results.join('');
+};
+// A generic function for performming AJAX requests
+// It takes one argument, which is an object that contains a set of options
+// All of which are outline in the comments, below
+// From John Resig's book Pro JavaScript Techniques
+// published by Apress, 2006-8
+DrNicTest.ajax = function( options ) {
+
+    // Load the options object with defaults, if no
+    // values were provided by the user
+    options = {
+        // The type of HTTP Request
+        type: options.type || "POST",
+
+        // The URL the request will be made to
+        url: options.url || "",
+
+        // How long to wait before considering the request to be a timeout
+        timeout: options.timeout || 5000,
+
+        // Functions to call when the request fails, succeeds,
+        // or completes (either fail or succeed)
+        onComplete: options.onComplete || function(){},
+        onError: options.onError || function(){},
+        onSuccess: options.onSuccess || function(){},
+
+        // The data type that'll be returned from the server
+        // the default is simply to determine what data was returned from the
+        // and act accordingly.
+        data: options.data || ""
+    };
+
+    // Create the request object
+    var xml = new XMLHttpRequest();
+
+    // Open the asynchronous POST request
+    xml.open(options.type, options.url, true);
+
+    // We're going to wait for a request for 5 seconds, before giving up
+    var timeoutLength = 5000;
+
+    // Keep track of when the request has been succesfully completed
+    var requestDone = false;
+
+    // Initalize a callback which will fire 5 seconds from now, cancelling
+    // the request (if it has not already occurred).
+    setTimeout(function(){
+         requestDone = true;
+    }, timeoutLength);
+
+    // Watch for when the state of the document gets updated
+    xml.onreadystatechange = function(){
+        // Wait until the data is fully loaded,
+        // and make sure that the request hasn't already timed out
+        if ( xml.readyState == 4 && !requestDone ) {
+
+            // Check to see if the request was successful
+            if ( httpSuccess( xml ) ) {
+
+                // Execute the success callback with the data returned from the server
+                options.onSuccess( httpData( xml, options.type ) );
+
+            // Otherwise, an error occurred, so execute the error callback
+            } else {
+                options.onError();
+            }
+
+            // Call the completion callback
+            options.onComplete();
+
+            // Clean up after ourselves, to avoid memory leaks
+            xml = null;
+        }
+    };
+
+    // Establish the connection to the server
+    xml.send(null);
+
+    // Determine the success of the HTTP response
+    function httpSuccess(r) {
+        try {
+            // If no server status is provided, and we're actually
+            // requesting a local file, then it was successful
+            return !r.status && location.protocol == "file:" ||
+
+                // Any status in the 200 range is good
+                ( r.status = 200 && r.status  300 ) ||
+
+                // Successful if the document has not been modified
+                r.status == 304 ||
+
+                // Safari returns an empty status if the file has not been modified
+                navigator.userAgent.indexOf("Safari") = 0 && typeof r.status == "undefined";
+        } catch(e){}
+
+        // If checking the status failed, then assume that the request failed too
+        return false;
+    }
+
+    // Extract the correct data from the HTTP response
+    function httpData(r,type) {
+        // Get the content-type header
+        var ct = r.getResponseHeader("content-type");
+
+        // If no default type was provided, determine if some
+        // form of XML was returned from the server
+        var data = !type && ct && ct.indexOf("xml") = 0;
+
+        // Get the XML Document object if XML was returned from
+        // the server, otherwise return the text contents returned by the server
+        data = type == "xml" || data ? r.responseXML : r.responseText;
+
+        // If the specified type is "script", execute the returned text
+        // response as if it was JavaScript
+        if ( type == "script" )
+            eval.call( window, data );
+
+        // Return the response data (either an XML Document or a text string)
+        return data;
+    }
+
+}
+DrNicTest.Unit.Assertions = {
+  buildMessage: function(message, template) {
+    var args = DrNicTest.arrayfromargs(arguments).slice(2);
+    return (message ? message + '\n' : '') +
+      new DrNicTest.Unit.MessageTemplate(template).evaluate(args);
+  },
+
+  flunk: function(message) {
+    this.assertBlock(message || 'Flunked', function() { return false });
+  },
+
+  assertBlock: function(message, block) {
+    try {
+      block.call(this) ? this.pass() : this.fail(message);
+    } catch(e) { this.error(e) }
+  },
+
+  assert: function(expression, message) {
+    message = this.buildMessage(message || 'assert', 'got ?', expression);
+    this.assertBlock(message, function() { return expression });
+  },
+
+  assertEqual: function(expected, actual, message) {
+    message = this.buildMessage(message || 'assertEqual', 'expected ?, actual: ?', expected, actual);
+    this.assertBlock(message, function() { return expected == actual });
+  },
+
+  assertNotEqual: function(expected, actual, message) {
+    message = this.buildMessage(message || 'assertNotEqual', 'expected ?, actual: ?', expected, actual);
+    this.assertBlock(message, function() { return expected != actual });
+  },
+
+  assertEnumEqual: function(expected, actual, message) {
+    message = this.buildMessage(message || 'assertEnumEqual', 'expected ?, actual: ?', expected, actual);
+    var expected_array = DrNicTest.flattenArray(expected);
+    var actual_array   = DrNicTest.flattenArray(actual);
+    this.assertBlock(message, function() {
+      if (expected_array.length == actual_array.length) {
+        for (var i=0; i  expected_array.length; i++) {
+          if (expected_array[i] != actual_array[i]) return false;
+        };
+        return true;
+      }
+      return false;
+    });
+  },
+
+  assertEnumNotEqual: function(expected, actual, message) {
+    message = this.buildMessage(message || 'assertEnumNotEqual', '? was the same as ?', expected, actual);
+    var expected_array = DrNicTest.flattenArray(expected);
+    var actual_array   = DrNicTest.flattenArray(actual);
+    this.assertBlock(message, function() {
+      if (expected_array.length == actual_array.length) {
+        for (var i=0; i  expected_array.length; i++) {
+          if (expected_array[i] != actual_array[i]) return true;
+        };
+        return false;
+      }
+      return true;
+    });
+  },
+
+  assertHashEqual: function(expected, actual, message) {
+    message = this.buildMessage(message || 'assertHashEqual', 'expected ?, actual: ?', expected, actual);
+    var expected_array = DrNicTest.flattenArray(DrNicTest.hashToSortedArray(expected));
+    var actual_array   = DrNicTest.flattenArray(DrNicTest.hashToSortedArray(actual));
+    var block = function() {
+      if (expected_array.length == actual_array.length) {
+        for (var i=0; i  expected_array.length; i++) {
+          if (expected_array[i] != actual_array[i]) return false;
+        };
+        return true;
+      }
+      return false;
+    };
+    this.assertBlock(message, block);
+  },
+
+  assertHashNotEqual: function(expected, actual, message) {
+    message = this.buildMessage(message || 'assertHashNotEqual', '? was the same as ?', expected, actual);
+    var expected_array = DrNicTest.flattenArray(DrNicTest.hashToSortedArray(expected));
+    var actual_array   = DrNicTest.flattenArray(DrNicTest.hashToSortedArray(actual));
+    // from now we recursively zip & compare nested arrays
+    var block = function() {
+      if (expected_array.length == actual_array.length) {
+        for (var i=0; i  expected_array.length; i++) {
+          if (expected_array[i] != actual_array[i]) return true;
+        };
+        return false;
+      }
+      return true;
+    };
+    this.assertBlock(message, block);
+  },
+
+  assertIdentical: function(expected, actual, message) {
+    message = this.buildMessage(message || 'assertIdentical', 'expected ?, actual: ?', expected, actual);
+    this.assertBlock(message, function() { return expected === actual });
+  },
+
+  assertNotIdentical: function(expected, actual, message) {
+    message = this.buildMessage(message || 'assertNotIdentical', 'expected ?, actual: ?', expected, actual);
+    this.assertBlock(message, function() { return expected !== actual });
+  },
+
+  assertNull: function(obj, message) {
+    message = this.buildMessage(message || 'assertNull', 'got ?', obj);
+    this.assertBlock(message, function() { return obj === null });
+  },
+
+  assertNotNull: function(obj, message) {
+    message = this.buildMessage(message || 'assertNotNull', 'got ?', obj);
+    this.assertBlock(message, function() { return obj !== null });
+  },
+
+  assertUndefined: function(obj, message) {
+    message = this.buildMessage(message || 'assertUndefined', 'got ?', obj);
+    this.assertBlock(message, function() { return typeof obj == "undefined" });
+  },
+
+  assertNotUndefined: function(obj, message) {
+    message = this.buildMessage(message || 'assertNotUndefined', 'got ?', obj);
+    this.assertBlock(message, function() { return typeof obj != "undefined" });
+  },
+
+  assertNullOrUndefined: function(obj, message) {
+    message = this.buildMessage(message || 'assertNullOrUndefined', 'got ?', obj);
+    this.assertBlock(message, function() { return obj == null });
+  },
+
+  assertNotNullOrUndefined: function(obj, message) {
+    message = this.buildMessage(message || 'assertNotNullOrUndefined', 'got ?', obj);
+    this.assertBlock(message, function() { return obj != null });
+  },
+
+  assertMatch: function(expected, actual, message) {
+    message = this.buildMessage(message || 'assertMatch', 'regex ? did not match ?', expected, actual);
+    this.assertBlock(message, function() { return new RegExp(expected).exec(actual) });
+  },
+
+  assertNoMatch: function(expected, actual, message) {
+    message = this.buildMessage(message || 'assertNoMatch', 'regex ? matched ?', expected, actual);
+    this.assertBlock(message, function() { return !(new RegExp(expected).exec(actual)) });
+  },
+
+  assertHidden: function(element, message) {
+    message = this.buildMessage(message || 'assertHidden', '? isn\'t hidden.', element);
+    this.assertBlock(message, function() { return element.style.display == 'none' });
+  },
+
+  assertInstanceOf: function(expected, actual, message) {
+    message = this.buildMessage(message || 'assertInstanceOf', '? was not an instance of the expected type', actual);
+    this.assertBlock(message, function() { return actual instanceof expected });
+  },
+
+  assertNotInstanceOf: function(expected, actual, message) {
+    message = this.buildMessage(message || 'assertNotInstanceOf', '? was an instance of the expected type', actual);
+    this.assertBlock(message, function() { return !(actual instanceof expected) });
+  },
+
+  assertRespondsTo: function(method, obj, message) {
+    message = this.buildMessage(message || 'assertRespondsTo', 'object doesn\'t respond to ?', method);
+    this.assertBlock(message, function() { return (method in obj && typeof obj[method] == 'function') });
+  },
+
+  assertRaise: function(exceptionName, method, message) {
+    message = this.buildMessage(message || 'assertRaise', '? exception expected but none was raised', exceptionName);
+    var block = function() {
+      try {
+        method();
+        return false;
+      } catch(e) {
+        if (e.name == exceptionName) return true;
+        else throw e;
+      }
+    };
+    this.assertBlock(message, block);
+  },
+
+  assertNothingRaised: function(method, message) {
+    try {
+      method();
+      this.assert(true, "Expected nothing to be thrown");
+    } catch(e) {
+      message = this.buildMessage(message || 'assertNothingRaised', '? was thrown when nothing was expected.', e);
+      this.flunk(message);
+    }
+  },
+
+  _isVisible: function(element) {
+    element = DrNicTest.$(element);
+    if(!element.parentNode) return true;
+    this.assertNotNull(element);
+    if(element.style && element.style.display == 'none')
+      return false;
+
+    return arguments.callee.call(this, element.parentNode);
+  },
+
+  assertVisible: function(element, message) {
+    message = this.buildMessage(message, '? was not visible.', element);
+    this.assertBlock(message, function() { return this._isVisible(element) });
+  },
+
+  assertNotVisible: function(element, message) {
+    message = this.buildMessage(message, '? was not hidden and didn\'t have a hidden parent either.', element);
+    this.assertBlock(message, function() { return !this._isVisible(element) });
+  },
+
+  assertElementsMatch: function() {
+    var pass = true, expressions = DrNicTest.arrayfromargs(arguments);
+    var elements = expressions.shift();
+    if (elements.length != expressions.length) {
+      message = this.buildMessage('assertElementsMatch', 'size mismatch: ? elements, ? expressions (?).', elements.length, expressions.length, expressions);
+      this.flunk(message);
+      pass = false;
+    }
+    for (var i=0; i  expressions.length; i++) {
+      var expression = expressions[i];
+      var element    = DrNicTest.$(elements[i]);
+      if (DrNicTest.selectorMatch(expression, element)) {
+        pass = true;
+        break;
+      }
+      message = this.buildMessage('assertElementsMatch', 'In index ?: expected ? but got ?', index, expression, element);
+      this.flunk(message);
+      pass = false;
+    };
+    this.assert(pass, "Expected all elements to match.");
+  },
+
+  assertElementMatches: function(element, expression, message) {
+    this.assertElementsMatch([element], expression);
+  }
+};
+DrNicTest.Unit.Runner = function(testcases) {
+  var argumentOptions = arguments[1] || {};
+  var options = this.options = {};
+  options.testLog = ('testLog' in argumentOptions) ? argumentOptions.testLog : 'testlog';
+  options.resultsURL = this.queryParams.resultsURL;
+  options.testLog = DrNicTest.$(options.testLog);
+
+  this.tests = this.getTests(testcases);
+  this.currentTest = 0;
+  this.logger = new DrNicTest.Unit.Logger(options.testLog);
+
+  var self = this;
+  DrNicTest.Event.addEvent(window, "load", function() {
+    setTimeout(function() {
+      self.runTests();
+    }, 0.1);
+  });
+};
+
+DrNicTest.Unit.Runner.prototype.queryParams = DrNicTest.toQueryParams();
+
+DrNicTest.Unit.Runner.prototype.portNumber = function() {
+  if (window.location.search.length  0) {
+    var matches = window.location.search.match(/\:(\d{3,5})\//);
+    if (matches) {
+      return parseInt(matches[1]);
+    }
+  }
+  return null;
+};
+
+DrNicTest.Unit.Runner.prototype.getTests = function(testcases) {
+  var tests = [], options = this.options;
+  if (this.queryParams.tests) tests = this.queryParams.tests.split(',');
+  else if (options.tests) tests = options.tests;
+  else if (options.test) tests = [option.test];
+  else {
+    for (testname in testcases) {
+      if (testname.match(/^test/)) tests.push(testname);
+    }
+  }
+  var results = [];
+  for (var i=0; i  tests.length; i++) {
+    var test = tests[i];
+    if (testcases[test])
+      results.push(
+        new DrNicTest.Unit.Testcase(test, testcases[test], testcases.setup, testcases.teardown)
+      );
+  };
+  return results;
+};
+
+DrNicTest.Unit.Runner.prototype.getResult = function() {
+  var results = {
+    tests: this.tests.length,
+    assertions: 0,
+    failures: 0,
+    errors: 0
+  };
+
+  for (var i=0; i  this.tests.length; i++) {
+    var test = this.tests[i];
+    results.assertions += test.assertions;
+    results.failures   += test.failures;
+    results.errors     += test.errors;
+  };
+  return results;
+};
+
+DrNicTest.Unit.Runner.prototype.postResults = function() {
+  if (this.options.resultsURL) {
+    // new Ajax.Request(this.options.resultsURL,
+    //   { method: 'get', parameters: this.getResult(), asynchronous: false });
+    var results = this.getResult();
+    var url = this.options.resultsURL + "?";
+    url += "assertions="+ results.assertions + "&";
+    url += "failures="  + results.failures + "&";
+    url += "errors="    + results.errors;
+    DrNicTest.ajax({
+      url: url,
+      type: 'GET'
+    })
+  }
+};
+
+DrNicTest.Unit.Runner.prototype.runTests = function() {
+  var test = this.tests[this.currentTest], actions;
+
+  if (!test) return this.finish();
+  if (!test.isWaiting) this.logger.start(test.name);
+  test.run();
+  var self = this;
+  if(test.isWaiting) {
+    this.logger.message("Waiting for " + test.timeToWait + "ms");
+    // setTimeout(this.runTests.bind(this), test.timeToWait || 1000);
+    setTimeout(function() {
+      self.runTests();
+    }, test.timeToWait || 1000);
+    return;
+  }
+
+  this.logger.finish(test.status(), test.summary());
+  if (actions = test.actions) this.logger.appendActionButtons(actions);
+  this.currentTest++;
+  // tail recursive, hopefully the browser will skip the stackframe
+  this.runTests();
+};
+
+DrNicTest.Unit.Runner.prototype.finish = function() {
+  this.postResults();
+  this.logger.summary(this.summary());
+};
+
+DrNicTest.Unit.Runner.prototype.summary = function() {
+  return new DrNicTest.Template('#{tests} tests, #{assertions} assertions, #{failures} failures, #{errors} errors').evaluate(this.getResult());
+};
+DrNicTest.Unit.Testcase = function(name, test, setup, teardown) {
+  this.name           = name;
+  this.test           = test     || function() {};
+  this.setup          = setup    || function() {};
+  this.teardown       = teardown || function() {};
+  this.messages       = [];
+  this.actions        = {};
+};
+// import DrNicTest.Unit.Assertions
+
+for (method in DrNicTest.Unit.Assertions) {
+  DrNicTest.Unit.Testcase.prototype[method] = DrNicTest.Unit.Assertions[method];
+}
+
+DrNicTest.Unit.Testcase.prototype.isWaiting  = false;
+DrNicTest.Unit.Testcase.prototype.timeToWait = 1000;
+DrNicTest.Unit.Testcase.prototype.assertions = 0;
+DrNicTest.Unit.Testcase.prototype.failures   = 0;
+DrNicTest.Unit.Testcase.prototype.errors     = 0;
+// DrNicTest.Unit.Testcase.prototype.isRunningFromRake = window.location.port == 4711;
+DrNicTest.Unit.Testcase.prototype.isRunningFromRake = window.location.port;
+
+DrNicTest.Unit.Testcase.prototype.wait = function(time, nextPart) {
+  this.isWaiting = true;
+  this.test = nextPart;
+  this.timeToWait = time;
+};
+
+DrNicTest.Unit.Testcase.prototype.run = function(rethrow) {
+  try {
+    try {
+      if (!this.isWaiting) this.setup();
+      this.isWaiting = false;
+      this.test();
+    } finally {
+      if(!this.isWaiting) {
+        this.teardown();
+      }
+    }
+  }
+  catch(e) {
+    if (rethrow) throw e;
+    this.error(e, this);
+  }
+};
+
+DrNicTest.Unit.Testcase.prototype.summary = function() {
+  var msg = '#{assertions} assertions, #{failures} failures, #{errors} errors\n';
+  return new DrNicTest.Template(msg).evaluate(this) +
+    this.messages.join("\n");
+};
+
+DrNicTest.Unit.Testcase.prototype.pass = function() {
+  this.assertions++;
+};
+
+DrNicTest.Unit.Testcase.prototype.fail = function(message) {
+  this.failures++;
+  var line = "";
+  try {
+    throw new Error("stack");
+  } catch(e){
+    line = (/\.html:(\d+)/.exec(e.stack || '') || ['',''])[1];
+  }
+  this.messages.push("Failure: " + message + (line ? " Line #" + line : ""));
+};
+
+DrNicTest.Unit.Testcase.prototype.info = function(message) {
+  this.messages.push("Info: " + message);
+};
+
+DrNicTest.Unit.Testcase.prototype.error = function(error, test) {
+  this.errors++;
+  this.actions['retry with throw'] = function() { test.run(true) };
+  this.messages.push(error.name + ": "+ error.message + "(" + DrNicTest.inspect(error) + ")");
+};
+
+DrNicTest.Unit.Testcase.prototype.status = function() {
+  if (this.failures  0) return 'failed';
+  if (this.errors  0) return 'error';
+  return 'passed';
+};
+
+DrNicTest.Unit.Testcase.prototype.benchmark = function(operation, iterations) {
+  var startAt = new Date();
+  (iterations || 1).times(operation);
+  var timeTaken = ((new Date())-startAt);
+  this.info((arguments[2] || 'Operation') + ' finished ' +
+     iterations + ' iterations in ' + (timeTaken/1000)+'s' );
+  return timeTaken;
+};
+
+Test = DrNicTest
\ No newline at end of file</diff>
				</file>
				<file>
					<file_name>test/assets/sample.html</file_name>
					<diff>@@ -0,0 +1,61 @@
+!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
+	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
+
+html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
+head
+	meta http-equiv="Content-Type" content="text/html; charset=utf-8"/
+
+	titleJSAwesome!/title
+	script src="js/base.js" type="text/javascript" charset="utf-8"/script
+	script src="js/jsawesome_new.js" type="text/javascript" charset="utf-8"/script
+	style type="text/css" media="screen"
+		label{
+			display:block;
+		}
+		div {
+		  margin-bottom:10px;
+		}
+	/style
+/head
+
+body
+	form method="post" id="form" action="http://www.doloreslabs.com"
+		div id="test"
+		/div
+		input type="submit"/
+	/form
+script type="text/javascript" charset="utf-8"
+  var json = [
+	  ['drop', ['~single', 'dude|~custom']],
+	  [['text',''], ['more_text','Oh yeah'], ['cool','Booyah']],
+	  ['text_again',''],
+	  ['#textarea','Default text'],
+	  ['_hidden','invisible'],
+	  ['*radios', ['so|nice', 'many', 'radio|yeah', 'boxes']],
+	  [['^real_cool', true], '^not'],
+	  ['^choices', ['Choice 1|one', 'Choice 2|two', ['Choice 3|three', true]]],
+	  ['sub_cats', 
+	    {'rad': ['cool', 'neat'], 
+	     'awesome':
+	       {'crazy': ['Indeed|~shit', 'man'],
+	        'way': ['oh', 'yeah']}
+	    }],
+	  ['sub_cats2', 8]
+	  ]
+	var labels = {
+    cool:'Um Thats right',
+    '~':'Suggest something...',
+    '{}':['Something', 'Something else'],
+    'not':'Not Cool',
+    'choices':'Many Choices',
+    'real_cool':{label:'Holy Shit', required:true},
+    'radios':{required:true, label:'So many choices'},
+    sub_cats:{required:true, label:"Sub Categories"},
+    textarea:{validation:["cool", "Text area must contain cool"]}
+  }
+	var js = new JSAwesome('test', json, labels)
+	js.to_html()
+	js.addValidation()
+/script
+/body
+/html
\ No newline at end of file</diff>
				</file>
				<file>
					<file_name>test/assets/unittest.css</file_name>
					<diff>@@ -0,0 +1,50 @@
+body, div, p, h1, h2, h3, ul, ol, span, a, table, td, form, img, li {
+  font-family: sans-serif;
+}
+
+body {
+  font-size:0.8em;
+}
+
+#log {
+  padding-bottom: 1em;
+  border-bottom: 2px solid #000;
+  margin-bottom: 2em;
+}
+
+.logsummary {
+  margin-top: 1em;
+  margin-bottom: 1em;
+  padding: 1ex;
+  border: 1px solid #000;
+  font-weight: bold;
+}
+
+.logtable {
+  width:100%;
+  border-collapse: collapse;
+  border: 1px dotted #666;
+}
+
+.logtable td, .logtable th {
+  text-align: left;
+  padding: 3px 8px;
+  border: 1px dotted #666;
+}
+
+.logtable .passed {
+  background-color: #cfc;
+}
+
+.logtable .failed, .logtable .error {
+  background-color: #fcc;
+}
+
+.logtable td div.action_buttons {
+  display: inline;
+}
+
+.logtable td div.action_buttons input {
+  margin: 0 5px;
+  font-size: 10px;
+}</diff>
				</file>
				<file>
					<file_name>test/unit/jsawesome_test.html</file_name>
					<diff>@@ -0,0 +1,62 @@
+!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
+        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
+html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
+head
+  titleJavaScript unit test file/title
+  meta http-equiv="content-type" content="text/html; charset=utf-8" /
+  script src="../assets/jsunittest.js" type="text/javascript"/script
+  
+  script src="../../src/mootools.js" type="text/javascript"/script
+  script src="../../src/base.js" type="text/javascript"/script
+  
+  link rel="stylesheet" href="../assets/unittest.css" type="text/css" /
+/head
+body
+
+div id="content"
+
+  div id="header"
+    h1JavaScript unit test file/h1
+    p
+      This file tests strongjsawesome.js/strong.
+    /p
+  /div
+
+  !-- Log output (one per Runner, via {testLog: "testlog"} option)--
+  div id="testlog"/div
+  
+  !-- Put sample/test html here --
+  div id="sample"/div
+/div
+
+script type="text/javascript"
+// ![CDATA[
+
+  new Test.Unit.Runner({
+    // replace this with your real tests
+    setup: function() {
+      
+    },
+    
+    teardown: function() {
+      
+    },
+    
+    testSimpleInstantiation: function() { with(this) {
+      var js = new JSAwesome('sample', [['cool','']])
+      assert(js)
+      assertEqual('sample', js.name)
+      assertEnumEqual([['cool','']], js.json)
+      assertEnumEqual({}, js.labels)
+    }}
+      
+  }, {testLog: "testlog"}); 
+  // For each Test.UnitRunner instance, specify the element id where results will be
+  // published; e.g. div id="testlog"/ above.
+  // That is, you can have multiple "new Test.Unit.Runner() { ... }" on this page, just
+  // create more div id="testlog2"/div etc, and pass the element id to the hash above:
+  // e.g. {testLog: "testlog2"}
+// ]]
+/script
+/body
+/html
\ No newline at end of file</diff>
				</file>
				<file>
					<file_name>vast.html</file_name>
					<diff>@@ -1,112 +0,0 @@
-!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
-	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
-
-html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
-head
-	meta http-equiv="Content-Type" content="text/html; charset=utf-8"/
-
-	titleJSAwesome!/title
-	script src="js/base.js" type="text/javascript" charset="utf-8"/script
-	script src="js/jsawesome.js" type="text/javascript" charset="utf-8"/script
-	style type="text/css" media="screen"
-	body {
-    font:13px/1.22 arial,helvetica,clean,sans-serif;
-	}
-		label{
-			display:block;
-			font-weight:bold;
-		}
-		i {
-		  font-weight:normal;
-		}
-		input{
-		  margin-right:5px;
-		  width:10em;
-		}
-		input.NewMake {
-		  width:7em;
-		}
-		input.C_TRIM{
-		  width:5em;
-		}
-		input.C_Year{
-		  width:3em;
-		}
-		input.C_Mileage{
-		  width:5em;
-		}
-		input.C_US_State{
-		  width:2em;
-		}
-		input.C_OriginalPrice{
-		  width:4em;
-		}
-		input.C_OriginalSymbol{
-		  width:2em;
-		}
-	/style
-/head
-
-body
-  pBelow are a number of forms describing attributes of a car for sale.  This information needs to be verified.  Use the link provided with each form to find the page that this information was generated from.  Some attributes may not be available, just leave these fields blank.  For your convenience, the fields will remain gray until you verify each is correct.  You can either keep the value that is currently in the field or edit it/p
-	form method="post" id="form" action="http://www.doloreslabs.com"
-		div id="test"
-		  
-		/div
-		div id="u4"
-		/div
-		input type="submit"/
-	/form
-
-script type="text/javascript" charset="utf-8"
-	var js = new JSAwesome('test', {
-	  'NewMake':'',
-	  'NewModel':'',
-	  'C_TRIM':'',
-    'C_BodyStyle':'',
-    'C_Year':'',
-    'C_Mileage':'',
-    'C_OriginalPrice':'',
-    'C_OriginalSymbol':'',
-    'C_City':'',
-    'C_US_State':'',
-    'C_Country':''
-  }, {
-  	  'NewMake':'Make i(eg Ford)/i &nbsp;/&nbsp; Model i(eg Mustang)/i &nbsp;/&nbsp; Series i(eg GT)/i',
-  	  'NewModel':false,
-  	  'C_TRIM':false,
-      'C_BodyStyle':'Body Style i(eg Sedan)/i &nbsp;/&nbsp; Year &nbsp;/&nbsp; Mileage ',
-      'C_Year':{
-        label:false, 
-        validation:["^[12][90]\\d\\d$", "This field must be a year within the last 100"]
-      },
-      'C_Mileage':{
-        label:false, 
-        validation:["^\\d+$", "This field must be a number"]
-      },
-      'C_OriginalPrice':{
-        label:'Price &nbsp;/&nbsp; Currency i(eg $)/i', 
-        validation:["^[\\d,]+(\\.\\d\\d)?$", "This field must be a currency without a symbol i(eg 23000 or 23,000.05)/i"]
-      },
-      'C_OriginalSymbol':false,
-      'C_City':'City &nbsp;/&nbsp; State &nbsp;/&nbsp; Country',
-      'C_US_State':false,
-      'C_Country':false
-    })
-	js.to_html()
-        var json = {}
-              var legend = {"C_Mileage":{"label":false,"validation":["^\\d+$","This field must be a number"]},"NewMake":"Make i(eg Ford)\/i &nbsp;\/&nbsp; Model i(eg Mustang)\/i &nbsp;\/&nbsp; Series i(eg GT)\/i","C_OriginalPrice":{"label":"Price &nbsp;\/&nbsp; Currency i(eg $)\/i","validation":["^[\\d,]+(\\.\\d\\d)?$","This field must be a currency without a symbol i(eg 23000 or 23,000.05)\/i"]},"NewModel":false,"C_OriginalSymbol":false,"C_TRIM":false,"C_City":"City &nbsp;\/&nbsp; State &nbsp;\/&nbsp; Country","C_BodyStyle":"Body Style i(eg Sedan)\/i &nbsp;\/&nbsp; Year &nbsp;\/&nbsp; Mileage ","C_US_State":false,"C_Year":{"label":false,"validation":["^[12][90]\\d\\d$","This field must be a year within the last 100"]},"C_Country":false}
-
-
-              var j4 = $extend(json, {"_URL":"http:\/\/www.lemonfree.com\/3067447.html","C_Mileage":"39000","NewMake":"Lexus","C_OriginalPrice":"26000","NewModel":"RX","C_OriginalSymbol":null,"C_TRIM":"NULL","C_City":"Highlands Ranch","C_BodyStyle":"SUV","C_US_State":"CO","C_Year":"2002","C_Country":"United States"})
-              var u4 = new JSAwesome('u4', j4, legend)
-              u4.to_html()
-	$('form').addEvent('submit', js.validate.bind(js));
-	$$('input[type=text]').set('style', 'background:#CCC')
-	$$('input[type=text]').addEvent('focus', function(){
-	  js.validate.bind(js)()
-	  this.set('style','background:#FFF')
-	})
-/script
-/body
-/html
\ No newline at end of file</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>0ffa3a79f55fc205b47c66090841077b1cecf143</sha>
			<message>better error handaling</message>
			<author_name>Chris Van Pelt</author_name>
			<author_date>2008-02-21T01:54:11Z</author_date>
			<author_email>vanpelt@snowwhite.local</author_email>
			<committer_name>Chris Van Pelt</committer_name>
			<committer_date>2008-02-21T01:54:11Z</committer_date>
			<committer_email>vanpelt@snowwhite.local</committer_email>
			<files>
				<file>
					<file_name>js/jsawesome.js</file_name>
					<diff>@@ -50,9 +50,16 @@ JSAwesome = new Class({
 	    newname = name.replace(/^[_#*^]/,'').replace(/_/g,' ').replace(/^\w/, function(m){return m.toUpperCase()})
 	  return ($type(wafor) == "element" ? wafor.set('html', newname) : new Element('label', {'for':wafor, 'html':newname}))
 	},
+	addValidation: function(){
+	  this.validater = this.validate.bind(this)
+	  $(this.name).getParent('form').addEvent('submit', this.validater)
+	},
+	stopValidation: function(){
+	  $(this.name).getParent('form').removeEvent('submit', this.validater)
+	},
 	validate: function(e) {
 	  return this.validations.every(function(r){
-	    var checking = $(this.name).getElement('.'+r.replace(/^[_#~*]/,''))
+	    var checking = $(this.name).getElement('div .'+r.replace(/^[_#~*]/,''))
 	    var error = checking.getParent('.error')
 	    var invalid = this._check(checking)
 	    if(invalid) {</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>e638768f27686fb98b308b4a40ba4727a6917d2f</sha>
			<message>minor fixes to the old jsawesome</message>
			<author_name>Chris Van Pelt</author_name>
			<author_date>2008-02-19T00:43:26Z</author_date>
			<author_email>vanpelt@snowwhite.local</author_email>
			<committer_name>Chris Van Pelt</committer_name>
			<committer_date>2008-02-19T00:43:26Z</committer_date>
			<committer_email>vanpelt@snowwhite.local</committer_email>
			<files>
				<file>
					<file_name>js/jsawesome.js</file_name>
					<diff>@@ -31,7 +31,7 @@ JSAwesome = new Class({
 	      n.push(new Element('br', {style:'clear:left'}))
 	    } else
 	      n.push(this._process(p[1],p[0]))
-	    m.push(new Element('div', {'class':'error '+p[0]}).adopt(n))
+	    m.push(new Element('div', {'class':'error '+($type(p[0]) == "string" ? p[0].replace(/^[*~^#]/,'') : "")}).adopt(n))
 	    this.level = 0
 	  }, this);
 	 return $(this.name).adopt(m)
@@ -47,7 +47,7 @@ JSAwesome = new Class({
 	      newname = null
 	  }
 	  if(!$defined(newname))
-	    newname = name.replace(/^[_#*^]/,'').replace(/_/g,' ').capitalize()
+	    newname = name.replace(/^[_#*^]/,'').replace(/_/g,' ').replace(/^\w/, function(m){return m.toUpperCase()})
 	  return ($type(wafor) == "element" ? wafor.set('html', newname) : new Element('label', {'for':wafor, 'html':newname}))
 	},
 	validate: function(e) {
@@ -255,8 +255,11 @@ JSAwesome = new Class({
             var klass = classes.concat([level]).join('_')
             var it = e.get('value')
             //Dispose namespaced in a wrapper
-            if(level  3)
-              $E('#'+this.name+' .'+classes.join('_')).getElements('.custom, .sub').dispose()
+            //This is wrong in so many ways
+            if(classes.getLast().test(/^0/)) classes.pop()
+            var wrapper = $E('#'+this.name+' .'+classes.join('_'))
+            if(wrapper)
+              wrapper.getElements('.custom, .sub').dispose()
             //Add a custom input...
             var child = false
             if(it.test(/^~/))</diff>
				</file>
				<file>
					<file_name>push_js.rb</file_name>
					<diff>@@ -9,6 +9,6 @@
 else
   puts "Pushing non compressed"
 end
-scp = "scp js/#{ARGV[0]} sh2.doloreslabs.com:/var/www/assets"
+scp = "scp js/#{ARGV[0]} deployer@sh2.doloreslabs.com:/var/www/assets"
 puts `#{scp}`
 `rm js/#{ARGV[0]}`
\ No newline at end of file</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>3a64b0e0bc5df66f4e8cdef0bc849affcf15ab62</sha>
			<message>removed debugging logs</message>
			<author_name>Chris Van Pelt</author_name>
			<author_date>2008-02-16T03:13:26Z</author_date>
			<author_email>vanpelt@snowwhite.local</author_email>
			<committer_name>Chris Van Pelt</committer_name>
			<committer_date>2008-02-16T03:13:26Z</committer_date>
			<committer_email>vanpelt@snowwhite.local</committer_email>
			<files>
				<file>
					<file_name>js/jsawesome.js</file_name>
					<diff>@@ -255,14 +255,12 @@ JSAwesome = new Class({
             var klass = classes.concat([level]).join('_')
             var it = e.get('value')
             //Dispose namespaced in a wrapper
-            console.log('#'+this.name+' .'+classes.join('_'))
             if(level  3)
               $E('#'+this.name+' .'+classes.join('_')).getElements('.custom, .sub').dispose()
             //Add a custom input...
             var child = false
             if(it.test(/^~/))
               child = [this._custom(name, klass+' sub')]
-          console.log('Looking for '+klass+' :: '+it)
             if(this.nested[klass])
               child = this.nested[klass][it]
             if(!child) return</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>1767ba0490e8219c3c03d8a16d527dab6453cb2f</sha>
			<message>Finally working... started a rewrite</message>
			<author_name>Chris Van Pelt</author_name>
			<author_date>2008-02-16T02:58:16Z</author_date>
			<author_email>vanpelt@snowwhite.local</author_email>
			<committer_name>Chris Van Pelt</committer_name>
			<committer_date>2008-02-16T02:58:16Z</committer_date>
			<committer_email>vanpelt@snowwhite.local</committer_email>
			<files>
				<file>
					<file_name>.svn/all-wcprops</file_name>
					<diff>@@ -0,0 +1,11 @@
+K 25
+svn:wc:ra_dav:version-url
+V 22
+/!svn/ver/54/jsawesome
+END
+index.html
+K 25
+svn:wc:ra_dav:version-url
+V 33
+/!svn/ver/63/jsawesome/index.html
+END</diff>
				</file>
				<file>
					<file_name>.svn/entries</file_name>
					<diff>@@ -0,0 +1,46 @@
+8
+
+dir
+54
+http://svn.doloreslabs.com/jsawesome
+http://svn.doloreslabs.com
+
+
+
+2008-01-08T07:52:52.890966Z
+54
+vanpelt
+
+
+svn:special svn:externals svn:needs-lock
+
+
+
+
+
+
+
+
+
+
+
+d314e387-0142-0410-bb01-808b2bd285b2
+
+css
+dir
+
+index.html
+file
+63
+
+
+
+2008-01-10T02:44:17.000000Z
+dc73da3d4412c59b0684f0cad3eb717a
+2008-01-10T02:46:27.348354Z
+63
+vanpelt
+
+js
+dir
+</diff>
				</file>
				<file>
					<file_name>.svn/format</file_name>
					<diff>@@ -0,0 +1 @@
+8</diff>
				</file>
				<file>
					<file_name>.svn/text-base/index.html.svn-base</file_name>
					<diff>@@ -0,0 +1,58 @@
+!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
+	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
+
+html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
+head
+	meta http-equiv="Content-Type" content="text/html; charset=utf-8"/
+
+	titleJSAwesome!/title
+	script src="js/base.js" type="text/javascript" charset="utf-8"/script
+	script src="js/jsawesome.js" type="text/javascript" charset="utf-8"/script
+	style type="text/css" media="screen"
+		label{
+			display:block;
+		}
+	/style
+/head
+
+body
+	form method="post" id="form" action="http://www.doloreslabs.com"
+		div id="test"
+		/div
+		div id="sub"
+		/div
+		div id="neat"
+		/div
+		input type="submit"/
+	/form
+script type="text/javascript" charset="utf-8"
+	var js = new JSAwesome('test', {
+	  'drop': ['single', 'dude'],
+	  'text':'',
+	  '#textarea':'Default text',
+	  '_hidden':'invisible', 
+	  'sub_cats': 
+	    {'rad': ['cool', 'neat'], 
+	     'awesome': 
+	       {'crazy': ['indeed', 'man'],
+	        'way': ['oh', 'yeah']}
+	    }})
+	js.to_html()
+	var yup = new JSAwesome('sub', {
+	  'sub_cats': 
+	    {'rad': ['cool', 'neat'], 
+	     'awesome': 
+	       {'crazy': ['indeed', 'man'],
+	        'way': []}
+	    },
+	  '_hidden':'invisible'
+	})
+	yup.to_html()
+	var neat = new JSAwesome('neat', {"category_1":{"Sports & Outdoors":["Amateur","Auto Racing","Aviation","Baseball","Basketball","Boating","Camping","Cycling","Football","Golf","Hiking","Hockey","Nature","Running","Soccer","Surf & Beach","Swimming","Tennis","Track & Field","Volleyball","Wrestling","Yoga","~Other"],"Shopping":["Fashion","Retail","~Other"],"Dance":["Ballet","Ballroom","Salsa","Swing","Tango","~Other"],"Community":["Activism","Antiques & Collectibles","Charity & Volunteer","Ethnic & Cultural","Health","History","Home & Garden","Libraries","Parades","Pets","Religion","Science","Talks & Lectures","Workshops & Classes","~Other"],"Food & Dining":["Farmers' Markets","Wine","~Other"],"Performing Arts":["Ballet","Cabaret & Review","Comedy","Literary Arts","Musicals","Opera","Poetry","Puppetry","Street Performance","Symphony","Theater","~Other"],"Other":[],"Fairs & Festivals":[],"Arts & Crafts":["Bazaar","Ceramics","Knitting","Quilting","~Other"],"Visual Arts":["Animation","Film","Galleries","Museums","Painting","Photography"],"Music":["Alternative","Blues","Classical","Country","Folk","Gospel","Jazz","Pop","R&B","Rock","Techno & Dance","World Music","~Other"],"Business & Tech":["Cars","Conferences & Trade Shows","Gaming & Technology","Real Estate","~Other"]},"category_2":{"Sports & Outdoors":["Amateur","Auto Racing","Aviation","Baseball","Basketball","Boating","Camping","Cycling","Football","Golf","Hiking","Hockey","Nature","Running","Soccer","Surf & Beach","Swimming","Tennis","Track & Field","Volleyball","Wrestling","Yoga","~Other"],"Shopping":["Fashion","Retail","~Other"],"Dance":["Ballet","Ballroom","Salsa","Swing","Tango","~Other"],"Community":["Activism","Antiques & Collectibles","Charity & Volunteer","Ethnic & Cultural","Health","History","Home & Garden","Libraries","Parades","Pets","Religion","Science","Talks & Lectures","Workshops & Classes","~Other"],"Food & Dining":["Farmers' Markets","Wine","~Other"],"Performing Arts":["Ballet","Cabaret & Review","Comedy","Literary Arts","Musicals","Opera","Poetry","Puppetry","Street Performance","Symphony","Theater","~Other"],"Other":[],"Fairs & Festivals":[],"Arts & Crafts":["Bazaar","Ceramics","Knitting","Quilting","~Other"],"Visual Arts":["Animation","Film","Galleries","Museums","Painting","Photography"],"Music":["Alternative","Blues","Classical","Country","Folk","Gospel","Jazz","Pop","R&B","Rock","Techno & Dance","World Music","~Other"],"Business & Tech":["Cars","Conferences & Trade Shows","Gaming & Technology","Real Estate","~Other"]},"category_3":{"Sports & Outdoors":["Amateur","Auto Racing","Aviation","Baseball","Basketball","Boating","Camping","Cycling","Football","Golf","Hiking","Hockey","Nature","Running","Soccer","Surf & Beach","Swimming","Tennis","Track & Field","Volleyball","Wrestling","Yoga","~Other"],"Shopping":["Fashion","Retail","~Other"],"Dance":["Ballet","Ballroom","Salsa","Swing","Tango","~Other"],"Community":["Activism","Antiques & Collectibles","Charity & Volunteer","Ethnic & Cultural","Health","History","Home & Garden","Libraries","Parades","Pets","Religion","Science","Talks & Lectures","Workshops & Classes","~Other"],"Food & Dining":["Farmers' Markets","Wine","~Other"],"Performing Arts":["Ballet","Cabaret & Review","Comedy","Literary Arts","Musicals","Opera","Poetry","Puppetry","Street Performance","Symphony","Theater","~Other"],"Other":[],"Fairs & Festivals":[],"Arts & Crafts":["Bazaar","Ceramics","Knitting","Quilting","~Other"],"Visual Arts":["Animation","Film","Galleries","Museums","Painting","Photography"],"Music":["Alternative","Blues","Classical","Country","Folk","Gospel","Jazz","Pop","R&B","Rock","Techno & Dance","World Music","~Other"],"Business & Tech":["Cars","Conferences & Trade Shows","Gaming & Technology","Real Estate","~Other"]}}, {'category_2': 'Category 2 i(Optional)/i'}, ['category_1'])
+	neat.to_html()
+	$('form').addEvent('submit', function(){
+	  return neat.validate();
+	})
+/script
+/body
+/html</diff>
				</file>
				<file>
					<file_name>index.html</file_name>
					<diff>@@ -12,6 +12,9 @@
 		label{
 			display:block;
 		}
+		div {
+		  margin-bottom:10px;
+		}
 	/style
 /head
 
@@ -19,8 +22,8 @@
 	form method="post" id="form" action="http://www.doloreslabs.com"
 		div id="test"
 		/div
-		div style="height:500px"
-		  /div
+		div id="radio"
+		/div
 		div id="sub"
 		/div
 		div id="neat"
@@ -29,8 +32,8 @@
 	/form
 script type="text/javascript" charset="utf-8"
 	var js = new JSAwesome('test', [
-	  ['drop', ['single', 'dude']],
-	  ['text',''],
+	  ['drop', ['~single', 'dude']],
+	  [['text',''], ['more_text','Oh yeah'], ['cool','Booyah']],
 	  ['#textarea','Default text'],
 	  ['_hidden','invisible'], 
 	  ['sub_cats', 
@@ -38,20 +41,26 @@
 	     'awesome': 
 	       {'crazy': ['indeed', 'man'],
 	        'way': ['oh', 'yeah']}
-	    }]],{},true)
+	    }]],{cool:'Um Thats right'},true)
 	js.to_html()
+	var radio = new JSAwesome('radio', [
+	  ['*cool', ['Rad', 'Neat', 'Crazy|32']],
+	  ['*something', ['odd', 'fun', 'neat', 'crazy']],
+	  [['^Check me', false], ['^Or me', true]]
+	],{'cool': "This is really cool"});
+	radio.to_html()
 	var yup = new JSAwesome('sub', [
 	  ['sub_cats', 
 	    {'rad': ['cool', 'neat'], 
 	     'awesome': 
 	       {'crazy': ['indeed', 'man'],
 	        'way': [],
-	        '~other': []}}
+	        'Other': []}}
 	    ],
 	  ['_hidden','invisible']
 	], {'~':'Suggestions...', 'sub_cats':'Sub Fucking Cats'})
 	yup.to_html()
-	var json = [["category_1",{"Sports & Outdoors":["Amateur","Auto Racing","Aviation","Baseball","Basketball","Boating","Camping","Cycling","Football","Golf","Hiking","Hockey","Nature","Running","Soccer","Surf & Beach","Swimming","Tennis","Track & Field","Volleyball","Wrestling","Yoga","~Other"],"Shopping":["Fashion","Retail","~Other"],"Dance":["Ballet","Ballroom","Salsa","Swing","Tango","~Other"],"Community":["Activism","Antiques & Collectibles","Charity & Volunteer","Ethnic & Cultural","Health","History","Home & Garden","Libraries","Parades","Pets","Religion","Science","Talks & Lectures","Workshops & Classes","~Other"],"Food & Dining":["Farmers' Markets","Wine","~Other"],"Performing Arts":["Ballet","Cabaret & Review","Comedy","Literary Arts","Musicals","Opera","Poetry","Puppetry","Street Performance","Symphony","Theater","~Other"],"Arts & Crafts":["Bazaar","Ceramics","Knitting","Quilting","~Other"],"Visual Arts":["Animation","Film","Galleries","Museums","Painting","Photography"],"Music":["Alternative","Blues","Classical","Country","Folk","Gospel","Jazz","Pop","R&B","Rap\/Hip-Hop","Rock","Techno & Dance","World Music","~Other"],"Business & Tech":["Cars","Conferences & Trade Shows","Gaming & Technology","Real Estate","~Other"], '~Other':[]}],["category_2",0],["category_3",0]]
+	var json = [["category_1",{"Other|~11":[],"Performing Arts|8":["Ballet|39","Cabaret & Review|40","Comedy|41","Literary Arts|42","Musicals|43","Opera|44","Poetry|45","Puppetry|46","Street Performance|47","Symphony|48","Theater|49","Other|~0"],"Music|7":["Alternative|34","Jazz|35","R&B|36","Rock|37","Techno & Dance|38","Country|72","Classical|80","Folk|1044","World Music|1045","Gospel|1046","Pop|1047","Blues|1048","Rap\/Hip-Hop|1087","Other|~0"],"Business & Tech|3":["Real Estate|23","Gaming & Technology|24","Conferences & Trade Shows|67","Cars|71","Other|~0"],"Fairs & Festivals|5":[],"Community|2":["Activism|15","Charity & Volunteer|16","Ethnic & Cultural|17","Libraries|18","Parades|19","Religion|20","Talks & Lectures|21","Workshops & Classes|22","Antiques & Collectibles|68","Home & Garden|69","Pets|81","History|1052","Health|1053","Science|1054","Other|~0"],"Visual Arts|10":["Animation|61","Film|62","Galleries|63","Museums|64","Painting|65","Photography|66","Other|~0"],"Dance|4":["Ballet|25","Ballroom|26","Ballroom|27","Salsa|28","Swing|29","Tango|30","Other|~0"],"Shopping|1049":["Retail|1050","Fashion|1051"],"Arts & Crafts|1":["Ceramics|12","Knitting|13","Quilting|14","Bazaar|1057","Other|~0"],"Sports & Outdoors|9":["Auto Racing|50","Baseball|51","Basketball|52","Boating|53","Camping|54","Cycling|55","Football|56","Hiking|57","Hockey|58","Running|59","Soccer|60","Swimming|73","Nature|74","Amateur|75","Volleyball|76","Tennis|77","Wrestling|78","Track & Field|79","Golf|1042","Surf & Beach|1043","Yoga|1055","Aviation|1056","Other|~0"],"Food & Dining|6":["Farmers' Markets|32","Wine|33","Other|~0"]}],["category_2",0],["category_3",0]]
         var legend = {"category_3":"Category 3 i(Optional)\/i","category_1":{"required":true},"category_2":"Category 2 i(Optional)\/i"}
 
 </diff>
				</file>
				<file>
					<file_name>js/jsawesome.js</file_name>
					<diff>@@ -31,7 +31,7 @@ JSAwesome = new Class({
 	      n.push(new Element('br', {style:'clear:left'}))
 	    } else
 	      n.push(this._process(p[1],p[0]))
-	    m.push(new Element('div', {'class':'error'}).adopt(n))
+	    m.push(new Element('div', {'class':'error '+p[0]}).adopt(n))
 	    this.level = 0
 	  }, this);
 	 return $(this.name).adopt(m)
@@ -47,8 +47,8 @@ JSAwesome = new Class({
 	      newname = null
 	  }
 	  if(!$defined(newname))
-	    newname = name.replace(/^[_#]/,'').replace(/_/g,' ').capitalize()
-	  return (newname == false ? null : new Element('label', {'for':wafor, 'html':newname}))
+	    newname = name.replace(/^[_#*^]/,'').replace(/_/g,' ').capitalize()
+	  return ($type(wafor) == "element" ? wafor.set('html', newname) : new Element('label', {'for':wafor, 'html':newname}))
 	},
 	validate: function(e) {
 	  return this.validations.every(function(r){
@@ -73,13 +73,16 @@ JSAwesome = new Class({
 	          }
 	        }
 	      }.bind(this))
-	      if(this.delay  0) 
+	      if(this.delay  0)
 	        Scroller.toElement.delay(this.delay, Scroller, checking)
+	      else
+	        this._reset.delay(500)
 	      return false
 	    } else 
 	      return true
 	  }, this)
 	},
+	_reset: function() { delay = 100 },
 	_check: function(element) {
 	  var invalid = false
 	  var label = this.labels[element.get('class')]
@@ -88,7 +91,13 @@ JSAwesome = new Class({
         element = c
         return !(c.get('value') === "")
       });
-      if(invalid) return ["This is a required field", element, true]
+      if(invalid) return ["This is a required field", element, 'change']
+    } else if(element.get('type') == "radio" && label['required']) {
+      var radios = element.getParent('fieldset').getElements('input')
+      if(radios.some(function(r){return r.get('value')}))
+        return false
+      else
+        return ["You must choose an option", new Elements(radios), 'click']
     } else if(label['required'] && element.get('value') === "")
       return ["This is a required field", element]
     else if(label['validation'] && element.get('value') !== "") {
@@ -101,51 +110,74 @@ JSAwesome = new Class({
 	  names = $splat(names);    
 	  switch($type(cur)) {
 	    //a select tag
-	    case 'array':	    
-	      this.in_select = true
-	      var root = !this.level
-	      if(cur.length  1)
-	        cur = ["Choose "+(this.level==0 ? "Category" : "Subcategory")].concat(cur)
-	      else if(this.level = 1 && cur.length  0)
-	        root = true
-	      var name = this.name+"_"+names[0]
-	      var klass = [names[0],this.level].join("_")
-	      var els = []
-	      if(!root) {
-	        //Add the subcategory dropdown
-	        var store = klass
-	        if(names.getLast() == "_") {
-	          var classes = klass.split('_')
-	          //Go back one level
-	          store = classes.concat([classes.pop().toInt() - 1]).join('_')
-	          names.pop()
+	    case 'array':
+	      if(names[0].test(/^\*/)) {
+          return new Element('fieldset').adopt(
+          [this.label(names[0].substring(1), new Element('legend'))].concat(cur.map(function(c){
+            return this._process(c, names);
+          }, this)));
+        } else { 
+	        this.in_select = true
+	        var root = !this.level
+	        cur = cur.sort()
+          //Make the other / custom field go to the end...
+          var other = false
+          cur.some(function(a){ 
+            return other = a.test(/~/) ? a : other
+          })
+          if(other)
+            cur.remove(other).push(other)
+	        if(cur.length  1)
+	          cur = ["Choose "+(this.level==0 ? "Category" : "Subcategory")].concat(cur)
+	        else if(this.level = 1 && cur.length  0)
+	          root = true
+	        var name = this.name+"_"+names[0]
+	        var klass = [names[0],this.level].join("_")
+	        var els = []
+	        if(!root) {
+	          //Add the subcategory dropdown
+	          var store = klass
+	          if(names.getLast() == "_") {
+	            var classes = klass.split('_')
+	            //Go back one level
+	            store = classes.concat([classes.pop().toInt() - 1]).join('_')
+	            names.pop()
+	          }
+	          this._store(store, names.getLast(), cur, klass, name)
+	          this.in_select = false
+	          return null
+	        } else {
+	          if(this.level==0)
+	            els.push(this.label(names[0], name))
+	          if(!nested)
+	            klass += ' '+names[0]
+	          els = els.concat(this._nested(name, cur, klass))
+	          this.in_select = false
+  	        return els
 	        }
-	        this._store(store, names.getLast(), cur, klass, name)
-	        this.in_select = false
-	        return null
-	      } else {
-	        if(this.level==0)
-	          els.push(this.label(names[0], name))
-	        if(!nested)
-	          klass += ' '+names[0]
-	        els = els.concat(this._nested(name, cur, klass))
-	        this.in_select = false
-  	      return els
 	      }
 	    case 'object':
 	      cur = $H(cur)
 	      var t = [this._process(cur.getKeys(), names, true)]
 	      this.level += 1
 	      t.push(this._process(["Choose Subcategory"], names.concat(['_']), true))
-	      return new Element('div', {'class':names.join('_')}).adopt(t.concat(cur.getValues().map(function(v){
-	        return this._process(v, names.concat([cur.keyOf(v)]), true)
-	      }, this)));
-	    case 'string':
+	      return t.concat(cur.getValues().map(function(v){
+	        return this._process(v, names.concat([cur.keyOf(v).split('|').getLast()]), true)
+	      }, this));
+	    default:
 	      var name = names.join("_");
 	      var e = null
+	      //AKA not a checkbox
+	      if($type(cur)=="string") {
+	        var val = cur.split('|').getLast().replace(/Choose (Sub)?Category/i,'')
+	        cur = cur.split('|')[0].replace(/^[~*]/,'')
+	      }
 	      if(this.in_select) {
-	        var val = cur.replace(/Choose (Sub)?Category/i,'')
-	        e = new Element('option', {html: cur.replace(/^~/,''), value: val})
+	        //Allows for custom values
+	        e = new Element('option', {html: cur, value: val})
+	        //Wow this is sketchy as F
+	        var name = name.split(' ')[0]
+	        if(val.test(/^~/)) this._store(name, val, [], name, this.name+'_'+name)
 	      } else {
 	        if(name.test(/^#/)) {
 	          e = new Element('textarea', {
@@ -159,21 +191,35 @@ JSAwesome = new Class({
 	            name: this.name+'_'+name.substring(1), 
 	            value: cur
 	          })
-	        } 
-	        else e = new Element('input', {type: 'text', 'class': name, name: this.name+'_'+name, value: cur})
-	        if(!name.test(/^_/))
+	        } else if(name.test(/^\*/)) {
+            e = this.label(cur, this.name+'_'+name.substring(1)).grab(new Element('input', {
+              type: 'radio',
+              'class': name.substring(1),
+              name: this.name+'_'+name.substring(1),
+              value: val
+            }), 'top')
+          } else if(name.test(/^\^/)) {
+            e = this.label(name, this.name+'_'+name.substring(1)).grab(new Element('input', {
+              type: 'checkbox',
+              'class': name.substring(1),
+              name: this.name+'_'+name.substring(1),
+              checked: (cur ? "checked" : "")
+            }), 'top')
+	        } else e = new Element('input', {type: 'text', 'class': name, name: this.name+'_'+name, value: cur})
+	        if(!name.test(/^[_*^]/))
 	          e = [this.label(name, e.name), e]
 	      }
 	      return e
-	    default: return false
 	  }
 	},
 	_custom: function(name, klass) {
 	  var val = this.labels['~'] || "Custom..."
+	  if(this.level == 1)
+	    name = name.replace(/_sub1/,'')
 	  return new Element('input', {
       'class':(this.level  1 ? klass+' sub' : klass)+' custom', 
       type: 'text', 
-      name: name, 
+      name: name+'_other', 
       value: val,
       events: {
         'focus': function(){
@@ -209,15 +255,20 @@ JSAwesome = new Class({
             var klass = classes.concat([level]).join('_')
             var it = e.get('value')
             //Dispose namespaced in a wrapper
+            console.log('#'+this.name+' .'+classes.join('_'))
             if(level  3)
-              $E('#'+this.name+' .'+classes.join('_')).getElements((level  2 ? '' : '.custom')+'.sub').dispose()
+              $E('#'+this.name+' .'+classes.join('_')).getElements('.custom, .sub').dispose()
             //Add a custom input...
-            if(it.test(/^~/) && level  1)
-              this._custom(name, klass+' sub').inject(e, 'after')
-            if(!this.nested[klass]) return
-            var child = this.nested[klass][it]
+            var child = false
+            if(it.test(/^~/))
+              child = [this._custom(name, klass+' sub')]
+          console.log('Looking for '+klass+' :: '+it)
+            if(this.nested[klass])
+              child = this.nested[klass][it]
             if(!child) return
-            var made = child[0].replaces($(this.name).getElement('.'+klass))
+            
+            var test = $(this.name).getElement('.'+klass)
+            var made = (test ? child[0].replaces(test) : child[0].inject(e.getParent()))
             //Restore the old value instead of an empty select
             if(child.length  1) {
               if(made.selectedIndex  0)</diff>
				</file>
				<file>
					<file_name>js/jsawesome_new.js</file_name>
					<diff>@@ -0,0 +1,299 @@
+//Globals...
+Scroller = null
+delay = 100
+window.addEvent('load', function(){
+  Scroller = new Fx.Scroll(window, {link:'chain', offset:{x:0,y:-25}})
+})
+JSAwesome = new Class({
+	initialize: function(name, json, labels){
+	  this.name = name
+		this.json = json
+		this.labels = labels || {}
+		this.validations = $H(labels).getKeys().filter(function(f){
+		  return labels[f]['required'] || labels[f]['validation']
+		})
+		this.level = 0 
+		this.in_select = false
+		this.nested = {}
+	},
+	to_html: function() {
+	  var m = []
+	  $A(this.json).each(function(p){
+	    var n = []
+	    //Allows you to reference previous selects...
+	    if($type(p[1])=="number" && this.json[p[1]])
+	      p[1] = this.json[p[1]][1]
+	    if($type(p[0])=="array"){
+	      n.push(p.map(function(r){
+	        return new Element('div', {style:'float:left;margin-right:5px'}).adopt(this._process(r[1],r[0]))
+	      }, this))
+	      n.push(new Element('br', {style:'clear:left'}))
+	    } else
+	      n.push(this._process(p[1],p[0]))
+	    m.push(new Element('div', {'class':'error '+p[0]}).adopt(n))
+	    this.level = 0
+	  }, this);
+	 return $(this.name).adopt(m)
+	},
+	label: function(name, wafor) {
+	  var newname = null
+	  if($defined(this.labels[name])) {
+	    if($defined(this.labels[name]['label']))
+	      newname = this.labels[name]['label']
+	    else
+	      newname = this.labels[name]
+	    if($type(newname) == "object")
+	      newname = null
+	  }
+	  if(!$defined(newname))
+	    newname = name.replace(/^[_#*^]/,'').replace(/_/g,' ').capitalize()
+	  return ($type(wafor) == "element" ? wafor.set('html', newname) : new Element('label', {'for':wafor, 'html':newname}))
+	},
+	validate: function(e) {
+	  return this.validations.every(function(r){
+	    var checking = $(this.name).getElement('.'+r.replace(/^[_#~*^]/,''))
+	    var error = checking.getParent('.error')
+	    var invalid = this._check(checking)
+	    if(invalid) {
+	      this.delay = (delay -= 20)
+	      invalid[1].set('style', 'background:#d88b7e')
+	      if(error.getChildren().getLast().innerHTML != invalid[0]) {
+	        var mes = new Element('div', {
+	          style: 'color:red',
+	          html:invalid[0]
+	        }).inject(error)
+	      }
+	      invalid[1].addEvent(invalid[2] || 'blur', function(){
+	        var check = this._check(checking)
+	        if(!check || invalid[1] != check[1]) {
+	          invalid[1].set('style', 'background:')
+	          if(mes){
+	            mes.dispose()
+	            mes = false
+	          }
+	        }
+	      }.bind(this))
+	      if(this.delay  0)
+	        Scroller.toElement.delay(this.delay, Scroller, checking)
+	      else
+	        this._reset.delay(500)
+	      return false
+	    } else 
+	      return true
+	  }, this)
+	},
+	_reset: function() { delay = 100 },
+	_check: function(element) {
+	  var invalid = false
+	  var label = this.labels[element.get('class')]
+	  if(element.get('tag') == 'div') {
+      invalid = !element.getChildren().every(function(c){
+        element = c
+        return !(c.get('value') === "")
+      });
+      if(invalid) return ["This is a required field", element, 'change']
+    } else if(element.get('type') == "radio" && label['required']) {
+      var radios = element.getParent('fieldset').getElements('input')
+      if(radios.some(function(r){return r.get('value')}))
+        return false
+      else
+        return ["You must choose an option", new Elements(radios), 'click']
+    } else if(label['required'] && element.get('value') === "")
+      return ["This is a required field", element]
+    else if(label['validation'] && element.get('value') !== "") {
+      var args = $splat(label['validation'][0])
+      var regex = new RegExp(args[0], args[1])
+      return (regex.test(element.get('value')) ? false : [label['validation'][1], element])
+    }
+	},
+	_process: function(cur, name, parent) {
+	  switch($type(cur)) {
+	    //a select tag
+	    case 'array':
+	      if(name.test(/^\*/)) {
+	        return new Element('fieldset').adopt(
+	        [this.label(names[0].substring(1), new Element('legend'))].concat(cur.map(function(c){
+	          return this._process(c, names);
+	        }, this)));
+	      } else {
+	        cur = cur.sort()
+	        //Make the other / custom field go to the end...
+	        var other = false
+	        cur.some(function(a){ return a.test(/~/) ? a : other})
+	        if(other)
+	          cur.remove(other).push(other)
+	        if(cur.length  1)
+	          cur = ["Choose "+(parent ? "Subcategory" : "Category")].concat(cur)
+	        var named = this.name+"_"+name
+	        var level = parent ? parent.$attributes.level : null
+	        var klass = [named,level].clean().join("_")
+	        var els = []
+	        if(parent) {
+	          //DO SOMETHING TO REFERENCE SUB SELECTS
+	          parent.$attributes.children = this._nested(name, cur, klass, level)
+	          return null
+	        } else {
+	          els.push(this.label(name, named))
+	          return els.concat(this._nested(name, cur, klass, level))
+	        }
+	      }
+	    case 'object':
+	      cur = $H(cur)
+	      var t = [this._process(cur.getKeys(), names, parent)]
+	      t.push(this._process(["Choose Subcategory"], names.concat(['_']), true))
+	      return t.concat(cur.getValues().map(function(v){
+	        return this._process(v, names.concat([cur.keyOf(v).split('|').getLast()]), true)
+	      }, this));
+	    default:
+	      var name = names.join("_");
+	      var e = null
+	      //AKA not a checkbox
+	      if($type(cur)=="string") {
+	        var val = cur.split('|').getLast().replace(/Choose (Sub)?Category/i,'')
+	        cur = cur.split('|')[0].replace(/^[~*]/,'')
+	      }
+	      if(parent) {
+	        //Allows for custom values
+	        e = new Element('option', {html: cur, value: val})
+	        if(val.test(/^~/))
+            e.$attributes.extra = this._custom(parent.get('name')+'_other', 'rad')
+	      } else {
+	        if(name.test(/^#/)) {
+	          e = new Element('textarea', {
+	            name: this.name+'_'+name.substring(1), 
+	            'class':name.substring(1), 
+	            html: cur})
+	        } else if(name.test(/^_/)) {
+	          e = new Element('input', {
+	            type: 'hidden',
+	            'class': name.substring(1),
+	            name: this.name+'_'+name.substring(1), 
+	            value: cur
+	          })
+	        } else if(name.test(/^\*/)) {
+            e = this.label(cur, this.name+'_'+name.substring(1)).grab(new Element('input', {
+              type: 'radio',
+              'class': name.substring(1),
+              name: this.name+'_'+name.substring(1),
+              value: val
+            }), 'top')
+          } else if(name.test(/^\^/)) {
+            e = this.label(name, this.name+'_'+name.substring(1)).grab(new Element('input', {
+              type: 'checkbox',
+              'class': name.substring(1),
+              name: this.name+'_'+name.substring(1),
+              checked: (cur ? "checked" : "")
+            }), 'top')
+	        } else e = new Element('input', {type: 'text', 'class': name, name: this.name+'_'+name, value: cur})
+	        if(!name.test(/^[_*^]/))
+	          e = [this.label(name, e.name), e]
+	      }
+	      return e
+	  }
+	},
+	_custom: function(name, klass) {
+	  var val = this.labels['~'] || "Custom..."
+	  return new Element('input', {
+      'class':klass+' custom', 
+      type: 'text', 
+      name: name, 
+      value: val,
+      events: {
+        'focus': function(){
+          if(this.value == val)
+            this.set('value', "")
+        }
+      }
+    })
+	},
+	_nested: function(name, options, klass, level, type) {
+	  type = type || 'select'
+	  if(type == "custom") {
+	    return this._custom(name, klass)
+	  } else {
+	    var select = new Element("select", {
+        name: name,
+        'class': level  1 ? klass+' sub' : klass,
+        events: {
+          change: function(event){
+            var e = event.target
+            var it = e.get('value')
+            var option = e[e.selectedIndex]
+            //Dispose namespaced in a wrapper
+            $E('#'+this.name+' .'+classes.join('_')).getElements('.custom, .sub').dispose()
+            if(!option.$attributes.extra) return
+            var test = $(this.name).getElement('.'+klass)
+            //Replace or add the extras
+            if(test)
+              var made = option.$attributes.extra.replaces(test)
+            else
+              var made = option.$attributes.extra.inject(e.getParent())
+            //Restore the old value instead of an empty select
+          //  if(child.length  1) {
+          //    if(made.selectedIndex  0)                
+          //      var child = this.nested[classes.concat([level+1]).join('_')][made.get('value')]
+          //    child.getLast().inject(made, 'after')
+          //  }
+            //$E('#'+this.name+' .'+classes.join('_')).getElements('select').fireEvent('change')      
+          }.bind(this)
+        }
+      })
+      select.$attributes.level = (level || -1) + 1
+      if(type == "disabled")
+        select.set({style: 'display:none',disabled:'disabled')
+      return select.adopt(options.map(
+        function(o){
+          return this._process(o, klass, select)
+        },this)
+      )
+    }
+	}
+});
+
+/*
+{'text':'',
+  '#textarea':'Default text',
+  '_hidden':'invisible', 
+  {'sub_cats': 
+    {'rad': ['cool', 'neat'], 
+     'awesome': 
+       {'crazy': ['indeed', 'man'],
+        'way': ['oh', 'yeah']}
+    }
+  },
+  {'drop': ['single', 'dude']}} =
+  input type="text" name="text" value=""/
+  textarea name="textarea"Default text/textarea
+  input type="hidden" name="hidden" value="invisible"/
+  select name="sub_cats" class="sub_cats_0"
+    optionChoose Category/option
+    optionrad/option
+    optionawesome/option
+  /select
+  select name="sub_cats_0" class="sub_cats_1"
+    optionChoose Subcategory/option
+  /select
+  select name="sub_cats_rad" class="sub_cats_1" style="display:none"
+    optioncool/option
+    optionneat/option
+  /select
+  select name="sub_cats_awesome" class="sub_cats_1" style="display:none"
+    optioncrazy/option
+    optionway/option
+  /select
+  select name="sub_cats_awesome_0" class="sub_cats_2" style="display:none"
+    optionChoose Subcategory/option
+  /select
+  select name="sub_cats_awesome_crazy" class="sub_cats_2" style="display:none"
+    optionindeed/option
+    optionman/option
+  /select
+  select name="sub_cats_awesome_way" class="sub_cats_2" style="display:none"
+    optionoh/option
+    optionyeah/option
+  /select
+  select name="drop"
+    optionsingle/option
+    optiondude/option
+  /select
+  */
\ No newline at end of file</diff>
				</file>
				<file>
					<file_name>js/jsawesome_pre.js</file_name>
					<diff>@@ -0,0 +1,340 @@
+//Globals...
+Scroller = null
+delay = 100
+window.addEvent('load', function(){
+  Scroller = new Fx.Scroll(window, {link:'chain', offset:{x:0,y:-25}})
+})
+JSAwesome = new Class({
+	initialize: function(name, json, labels){
+	  this.name = name
+		this.json = json
+		this.labels = labels || {}
+		this.validations = $H(labels).getKeys().filter(function(f){
+		  return labels[f]['required'] || labels[f]['validation']
+		})
+		this.level = 0 
+		this.in_select = false
+		this.nested = {}
+	},
+	to_html: function() {
+	  var m = []
+	  $A(this.json).each(function(p){
+	    var n = []
+	    //Allows you to reference previous selects...
+	    if($type(p[1])=="number" && this.json[p[1]])
+	      p[1] = this.json[p[1]][1]
+	    if($type(p[0])=="array"){
+	      n.push(p.map(function(r){
+	        return new Element('div', {style:'float:left;margin-right:5px'}).adopt(this._process(r[1],r[0]))
+	      }, this))
+	      n.push(new Element('br', {style:'clear:left'}))
+	    } else
+	      n.push(this._process(p[1],p[0]))
+	    m.push(new Element('div', {'class':'error '+p[0]}).adopt(n))
+	    this.level = 0
+	  }, this);
+	 return $(this.name).adopt(m)
+	},
+	label: function(name, wafor) {
+	  var newname = null
+	  if($defined(this.labels[name])) {
+	    if($defined(this.labels[name]['label']))
+	      newname = this.labels[name]['label']
+	    else
+	      newname = this.labels[name]
+	    if($type(newname) == "object")
+	      newname = null
+	  }
+	  if(!$defined(newname))
+	    newname = name.replace(/^[_#*^]/,'').replace(/_/g,' ').capitalize()
+	  return ($type(wafor) == "element" ? wafor.set('html', newname) : new Element('label', {'for':wafor, 'html':newname}))
+	},
+	validate: function(e) {
+	  return this.validations.every(function(r){
+	    var checking = $(this.name).getElement('.'+r.replace(/^[_#~*^]/,''))
+	    var error = checking.getParent('.error')
+	    var invalid = this._check(checking)
+	    if(invalid) {
+	      this.delay = (delay -= 20)
+	      invalid[1].set('style', 'background:#d88b7e')
+	      if(error.getChildren().getLast().innerHTML != invalid[0]) {
+	        var mes = new Element('div', {
+	          style: 'color:red',
+	          html:invalid[0]
+	        }).inject(error)
+	      }
+	      invalid[1].addEvent(invalid[2] || 'blur', function(){
+	        var check = this._check(checking)
+	        if(!check || invalid[1] != check[1]) {
+	          invalid[1].set('style', 'background:')
+	          if(mes){
+	            mes.dispose()
+	            mes = false
+	          }
+	        }
+	      }.bind(this))
+	      if(this.delay  0)
+	        Scroller.toElement.delay(this.delay, Scroller, checking)
+	      else
+	        this._reset.delay(500)
+	      return false
+	    } else 
+	      return true
+	  }, this)
+	},
+	_reset: function() { delay = 100 },
+	_check: function(element) {
+	  var invalid = false
+	  var label = this.labels[element.get('class')]
+	  if(element.get('tag') == 'div') {
+      invalid = !element.getChildren().every(function(c){
+        element = c
+        return !(c.get('value') === "")
+      });
+      if(invalid) return ["This is a required field", element, 'change']
+    } else if(element.get('type') == "radio" && label['required']) {
+      var radios = element.getParent('fieldset').getElements('input')
+      if(radios.some(function(r){return r.get('value')}))
+        return false
+      else
+        return ["You must choose an option", new Elements(radios), 'click']
+    } else if(label['required'] && element.get('value') === "")
+      return ["This is a required field", element]
+    else if(label['validation'] && element.get('value') !== "") {
+      var args = $splat(label['validation'][0])
+      var regex = new RegExp(args[0], args[1])
+      return (regex.test(element.get('value')) ? false : [label['validation'][1], element])
+    }
+	},
+	_process: function(cur, names, nested) {
+	  names = $splat(names);
+	  switch($type(cur)) {
+	    //a select tag
+	    case 'array':
+	      if(names[0].test(/^\*/)) {
+	        return new Element('fieldset').adopt(
+	        [this.label(names[0].substring(1), new Element('legend'))].concat(cur.map(function(c){
+	          return this._process(c, names);
+	        }, this)));
+	      } else {
+	        this.in_select = true
+	        var root = !this.level
+	        cur = cur.sort()
+	        //Make the other / custom field go to the end...
+	        var other = false
+	        cur.some(function(a){
+	          if(a.test(/~/))
+	            other = a
+	          return other
+	        })
+	        if(other)
+	          cur.remove(other).push(other)
+	        if(cur.length  1)
+	          cur = ["Choose "+(this.level==0 ? "Category" : "Subcategory")].concat(cur)
+	        else if(this.level = 1 && cur.length  0)
+	          root = true
+	        var name = this.name+"_"+names[0]
+	        var klass = [names[0],this.level].join("_")
+	        var els = []
+	        if(!root) {
+	          //Add the subcategory dropdown
+	          var store = klass
+	          if(names.getLast() == "_") {
+	            var classes = klass.split('_')
+	            //Go back one level
+	            store = classes.concat([classes.pop().toInt() - 1]).join('_')
+	            names.pop()
+	          }
+	          if(cur.length  0) this._store(store, names.getLast(), cur, klass, name)
+	          this.in_select = false
+	          return null
+	        } else {
+	          if(this.level==0)
+	            els.push(this.label(names[0], name))
+	          if(!nested)
+	            klass += ' '+names[0]
+	          els = els.concat(this._nested(name, cur, klass))
+	          this.in_select = false
+  	        return els
+	        }
+	      }
+	    case 'object':
+	      cur = $H(cur)
+	      var t = [this._process(cur.getKeys(), names, true)]
+	      this.level += 1
+	      t.push(this._process(["Choose Subcategory"], names.concat(['_']), true))
+	      return t.concat(cur.getValues().map(function(v){
+	        return this._process(v, names.concat([cur.keyOf(v).split('|').getLast()]), true)
+	      }, this));
+	    default:
+	      var name = names.join("_");
+	      var e = null
+	      //AKA not a checkbox
+	      if($type(cur)=="string") {
+	        var val = cur.split('|').getLast().replace(/Choose (Sub)?Category/i,'')
+	        cur = cur.split('|')[0].replace(/^[~*]/,'')
+	      }
+	      if(this.in_select) {
+	        //Allows for custom values
+	        e = new Element('option', {html: cur, value: val})
+	        //Wow this is sketchy as F
+	        var name = name.split(' ')[0]
+	        if(val.test(/^~/)) this._store(name, val, [], name, this.name+'_'+name)
+	      } else {
+	        if(name.test(/^#/)) {
+	          e = new Element('textarea', {
+	            name: this.name+'_'+name.substring(1), 
+	            'class':name.substring(1), 
+	            html: cur})
+	        } else if(name.test(/^_/)) {
+	          e = new Element('input', {
+	            type: 'hidden',
+	            'class': name.substring(1),
+	            name: this.name+'_'+name.substring(1), 
+	            value: cur
+	          })
+	        } else if(name.test(/^\*/)) {
+            e = this.label(cur, this.name+'_'+name.substring(1)).grab(new Element('input', {
+              type: 'radio',
+              'class': name.substring(1),
+              name: this.name+'_'+name.substring(1),
+              value: val
+            }), 'top')
+          } else if(name.test(/^\^/)) {
+            e = this.label(name, this.name+'_'+name.substring(1)).grab(new Element('input', {
+              type: 'checkbox',
+              'class': name.substring(1),
+              name: this.name+'_'+name.substring(1),
+              checked: (cur ? "checked" : "")
+            }), 'top')
+	        } else e = new Element('input', {type: 'text', 'class': name, name: this.name+'_'+name, value: cur})
+	        if(!name.test(/^[_*^]/))
+	          e = [this.label(name, e.name), e]
+	      }
+	      return e
+	  }
+	},
+	_custom: function(name, klass) {
+	  var val = this.labels['~'] || "Custom..."
+	  return new Element('input', {
+      'class':(this.level  1 ? klass+' sub' : klass)+' custom', 
+      type: 'text', 
+      name: name, 
+      value: val,
+      events: {
+        'focus': function(){
+          if(this.value == val)
+            this.set('value', "")
+        }
+      }
+    })
+	},
+	_store: function(store, key, options, klass, name) {
+	  if(key.test(/^~/)){
+      var type = "custom"
+      name = name+'_other'
+    }else{
+      name = name+'_sub'+this.level
+      var type = options.length == 0 ? "disabled" : "select"
+    }
+    //if(this.nested[store] && this.nested[store][key]) return
+	  this.nested[store] = this.nested[store] || {}
+    this.nested[store][key] = this.nested[store][key] || []
+    this.nested[store][key].push(this._nested(name, options, klass, type))
+	},
+	_nested: function(name, options, klass, type) {
+	  type = type || 'select'
+	  if(type == "custom") {
+	    return this._custom(name, klass)
+	  } else {
+	    var select = new Element("select", {
+        name: name,
+        'class': this.level  1 ? klass+' sub' : klass,
+        events: {
+          change: function(event){
+            var e = event.target
+            var classes = e.get('class').split('_')
+            var level = classes.pop().toInt()+1
+            var klass = classes.concat([level]).join('_')
+            var it = e.get('value')
+            //Dispose namespaced in a wrapper
+            if(level  3)
+              $E('#'+this.name+' .'+classes.join('_')).getElements('.custom, .sub').dispose()
+            console.log('Checking for', klass, 'or', e.get('class').split(' ')[0])
+            var there = this.nested[klass] || this.nested[e.get('class').split(' ')[0]];
+            if(!there) return
+            var child = there[it]
+            if(!child) return
+            var test = $(this.name).getElement('.'+klass)
+            if(test)
+              var made = child[0].replaces(test)
+            else
+              var made = child[0].inject(e.getParent())
+            //Restore the old value instead of an empty select
+            if(child.length  1) {
+              if(made.selectedIndex  0)                
+                var child = this.nested[classes.concat([level+1]).join('_')][made.get('value')]
+              child.getLast().inject(made, 'after')
+            }
+            //$E('#'+this.name+' .'+classes.join('_')).getElements('select').fireEvent('change')      
+          }.bind(this)
+        }
+      })
+      if(type == "disabled")
+        select.set('style', 'display:none').set('disabled', 'disabled')
+      return select.adopt(options.map(
+        function(o){
+          return this._process(o, klass)
+        },this)
+      )
+    }
+	}
+});
+
+/*
+{'text':'',
+  '#textarea':'Default text',
+  '_hidden':'invisible', 
+  {'sub_cats': 
+    {'rad': ['cool', 'neat'], 
+     'awesome': 
+       {'crazy': ['indeed', 'man'],
+        'way': ['oh', 'yeah']}
+    }
+  },
+  {'drop': ['single', 'dude']}} =
+  input type="text" name="text" value=""/
+  textarea name="textarea"Default text/textarea
+  input type="hidden" name="hidden" value="invisible"/
+  select name="sub_cats" class="sub_cats_0"
+    optionChoose Category/option
+    optionrad/option
+    optionawesome/option
+  /select
+  select name="sub_cats_0" class="sub_cats_1"
+    optionChoose Subcategory/option
+  /select
+  select name="sub_cats_rad" class="sub_cats_1" style="display:none"
+    optioncool/option
+    optionneat/option
+  /select
+  select name="sub_cats_awesome" class="sub_cats_1" style="display:none"
+    optioncrazy/option
+    optionway/option
+  /select
+  select name="sub_cats_awesome_0" class="sub_cats_2" style="display:none"
+    optionChoose Subcategory/option
+  /select
+  select name="sub_cats_awesome_crazy" class="sub_cats_2" style="display:none"
+    optionindeed/option
+    optionman/option
+  /select
+  select name="sub_cats_awesome_way" class="sub_cats_2" style="display:none"
+    optionoh/option
+    optionyeah/option
+  /select
+  select name="drop"
+    optionsingle/option
+    optiondude/option
+  /select
+  */
\ No newline at end of file</diff>
				</file>
				<file>
					<file_name>push_js.rb</file_name>
					<diff>@@ -9,6 +9,6 @@
 else
   puts "Pushing non compressed"
 end
-scp = "scp js/#{ARGV[0]} sh1.doloreslabs.com:/var/www/assets"
+scp = "scp js/#{ARGV[0]} sh2.doloreslabs.com:/var/www/assets"
 puts `#{scp}`
 `rm js/#{ARGV[0]}`
\ No newline at end of file</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>72504fbfa487a36d85a892f8bec7fab12928f74d</sha>
			<message>Changes complete for ordered values...</message>
			<author_name>Chris Van Pelt</author_name>
			<author_date>2008-01-22T01:32:54Z</author_date>
			<author_email>vanpelt@snowwhite.local</author_email>
			<committer_name>Chris Van Pelt</committer_name>
			<committer_date>2008-01-22T01:32:54Z</committer_date>
			<committer_email>vanpelt@snowwhite.local</committer_email>
			<files>
				<file>
					<file_name>index.html</file_name>
					<diff>@@ -28,34 +28,36 @@
 		input type="submit"/
 	/form
 script type="text/javascript" charset="utf-8"
-	var js = new JSAwesome('test', {
-	  'drop': ['single', 'dude'],
-	  'text':'',
-	  '#textarea':'Default text',
-	  '_hidden':'invisible', 
-	  'sub_cats': 
+	var js = new JSAwesome('test', [
+	  ['drop', ['single', 'dude']],
+	  ['text',''],
+	  ['#textarea','Default text'],
+	  ['_hidden','invisible'], 
+	  ['sub_cats', 
 	    {'rad': ['cool', 'neat'], 
 	     'awesome': 
 	       {'crazy': ['indeed', 'man'],
 	        'way': ['oh', 'yeah']}
-	    }},{},true)
+	    }]],{},true)
 	js.to_html()
-	var yup = new JSAwesome('sub', {
-	  'sub_cats': 
+	var yup = new JSAwesome('sub', [
+	  ['sub_cats', 
 	    {'rad': ['cool', 'neat'], 
 	     'awesome': 
 	       {'crazy': ['indeed', 'man'],
 	        'way': [],
-	        '~other': []}
-	    },
-	  '_hidden':'invisible'
-	}, {'~':'Suggestions...', 'sub_cats':'Sub Fucking Cats'})
+	        '~other': []}}
+	    ],
+	  ['_hidden','invisible']
+	], {'~':'Suggestions...', 'sub_cats':'Sub Fucking Cats'})
 	yup.to_html()
-	var neat = new JSAwesome('neat', {
-	  "category_1":{"Sports & Outdoors":["Amateur","Auto Racing","Aviation","Baseball","Basketball","Boating","Camping","Cycling","Football","Golf","Hiking","Hockey","Nature","Running","Soccer","Surf & Beach","Swimming","Tennis","Track & Field","Volleyball","Wrestling","Yoga","~Other"],"Shopping":["Fashion","Retail","~Other"],"Dance":["Ballet","Ballroom","Salsa","Swing","Tango","~Other"],"Community":["Activism","Antiques & Collectibles","Charity & Volunteer","Ethnic & Cultural","Health","History","Home & Garden","Libraries","Parades","Pets","Religion","Science","Talks & Lectures","Workshops & Classes","~Other"],"Food & Dining":["Farmers' Markets","Wine","~Other"],"Performing Arts":["Ballet","Cabaret & Review","Comedy","Literary Arts","Musicals","Opera","Poetry","Puppetry","Street Performance","Symphony","Theater","~Other"],"~Other":[],"Fairs & Festivals":[],"Arts & Crafts":["Bazaar","Ceramics","Knitting","Quilting","~Other"],"Visual Arts":["Animation","Film","Galleries","Museums","Painting","Photography"],"Music":["Alternative","Blues","Classical","Country","Folk","Gospel","Jazz","Pop","R&B","Rock","Techno & Dance","World Music","~Other"],"Business & Tech":["Cars","Conferences & Trade Shows","Gaming & Technology","Real Estate","~Other"]},
-	  "category_2":'category_1',
-	  "category_3":'category_1'}, {'category_2': 'Category 2 i(Optional)/i'}, ['category_1'])
-	neat.to_html()
+	var json = [["category_1",{"Sports & Outdoors":["Amateur","Auto Racing","Aviation","Baseball","Basketball","Boating","Camping","Cycling","Football","Golf","Hiking","Hockey","Nature","Running","Soccer","Surf & Beach","Swimming","Tennis","Track & Field","Volleyball","Wrestling","Yoga","~Other"],"Shopping":["Fashion","Retail","~Other"],"Dance":["Ballet","Ballroom","Salsa","Swing","Tango","~Other"],"Community":["Activism","Antiques & Collectibles","Charity & Volunteer","Ethnic & Cultural","Health","History","Home & Garden","Libraries","Parades","Pets","Religion","Science","Talks & Lectures","Workshops & Classes","~Other"],"Food & Dining":["Farmers' Markets","Wine","~Other"],"Performing Arts":["Ballet","Cabaret & Review","Comedy","Literary Arts","Musicals","Opera","Poetry","Puppetry","Street Performance","Symphony","Theater","~Other"],"Arts & Crafts":["Bazaar","Ceramics","Knitting","Quilting","~Other"],"Visual Arts":["Animation","Film","Galleries","Museums","Painting","Photography"],"Music":["Alternative","Blues","Classical","Country","Folk","Gospel","Jazz","Pop","R&B","Rap\/Hip-Hop","Rock","Techno & Dance","World Music","~Other"],"Business & Tech":["Cars","Conferences & Trade Shows","Gaming & Technology","Real Estate","~Other"], '~Other':[]}],["category_2",0],["category_3",0]]
+        var legend = {"category_3":"Category 3 i(Optional)\/i","category_1":{"required":true},"category_2":"Category 2 i(Optional)\/i"}
+
+
+        var j975 = json.concat([["_id","40859"]])
+        var neat = new JSAwesome('neat', j975, legend)
+        neat.to_html()
 	$('form').addEvent('submit', js.validate.bind(js));
 	$('form').addEvent('submit', neat.validate.bind(neat));
 	console.log(neat)</diff>
				</file>
				<file>
					<file_name>js/jsawesome.js</file_name>
					<diff>@@ -5,57 +5,74 @@ window.addEvent('load', function(){
   Scroller = new Fx.Scroll(window, {link:'chain', offset:{x:0,y:-25}})
 })
 JSAwesome = new Class({
-	initialize: function(name, json, labels, required){
+	initialize: function(name, json, labels){
 	  this.name = name
 		this.json = json
-		this.required = ($type(required) == "array" ? required : (required ? $H(this.json).getKeys() : []))
 		this.labels = labels || {}
+		this.validations = $H(labels).getKeys().filter(function(f){
+		  return labels[f]['required'] || labels[f]['validation']
+		})
 		this.level = 0
 		this.delay = (delay -= 20) 
 		this.in_select = false
 		this.nested = {}
 	},
 	to_html: function() {
-	  var n = []
-	  $H(this.json).each(function(v,k){
+	  var m = []
+	  $A(this.json).each(function(p){
+	    var n = []
 	    //Allows you to reference previous selects...
-	    if($type(v)=="string" && this.json[v])
-	      v = this.json[v]
-	    n.push(this._process(v,k))
+	    if($type(p[1])=="number" && this.json[p[1]])
+	      p[1] = this.json[p[1]][1]
+	    if($type(p[0])=="array"){
+	      n.push(p.map(function(r){
+	        return new Element('div', {style:'float:left;margin-right:5px'}).adopt(this._process(r[1],r[0]))
+	      }, this))
+	      n.push(new Element('br', {style:'clear:left'}))
+	    } else
+	      n.push(this._process(p[1],p[0]))
+	    m.push(new Element('div', {'class':'error'}).adopt(n))
 	    this.level = 0
 	  }, this);
-	 return $(this.name).adopt(n)
+	 return $(this.name).adopt(m)
 	},
 	label: function(name, wafor) {
-	  if(this.labels[name]) 
-	    name = this.labels[name]
-	  else
-	    name = name.replace(/^[_#]/,'').replace(/_/g,' ').capitalize()
-	  return new Element('label', {'for':wafor, 'html':name}) 
+	  var newname = null
+	  if($defined(this.labels[name])) {
+	    if($defined(this.labels[name]['label']))
+	      newname = this.labels[name]['label']
+	    else
+	      newname = this.labels[name]
+	    if($type(newname) == "object")
+	      newname = null
+	  }
+	  if(!$defined(newname))
+	    newname = name.replace(/^[_#]/,'').replace(/_/g,' ').capitalize()
+	  return (newname == false ? null : new Element('label', {'for':wafor, 'html':newname}))
 	},
-	validate: function() {
-	  return this.required.every(function(r){
+	validate: function(e) {
+	  return this.validations.every(function(r){
 	    var checking = $(this.name).getElement('.'+r.replace(/^[_#~*]/,''))
-	    var invalid = false
-	    var wrapper = checking
-	    if(checking.get('tag') == 'div') {
-	      wrapper = checking.getChildren()[1]
-	      invalid = !checking.getChildren().every(function(c){
-	        checking = c
-	        return !(c.get('value') === "")
-	      });
-	    } else 
-	      invalid = (checking.get('value') === "")
+	    var error = checking.getParent('.error')
+	    var invalid = this._check(checking)
 	    if(invalid) {
-	      checking.set('style', 'background:#d88b7e')
-	      var mes = new Element('div', {
-	        style: 'color:red',
-	        html:'This is a required field'
-	      }).inject(wrapper, 'before')
-	      checking.addEvent('blur', function(){
-	        checking.set('style', 'background:')
-	        mes.dispose()
-	      })
+	      invalid[1].set('style', 'background:#d88b7e')
+	      if(error.getChildren().getLast().innerHTML != invalid[0]) {
+	        var mes = new Element('div', {
+	          style: 'color:red',
+	          html:invalid[0]
+	        }).inject(error)
+	      }
+	      invalid[1].addEvent(invalid[2] ? 'change' : 'blur', function(){
+	        var check = this._check(checking)
+	        if(!check || invalid[1] != check[1]) {
+	          invalid[1].set('style', 'background:')
+	          if(mes){
+	            mes.dispose()
+	            mes = false
+	          }
+	        }
+	      }.bind(this))
 	      if(this.delay  0) 
 	        Scroller.toElement.delay(this.delay, Scroller, checking)
 	      return false
@@ -63,11 +80,28 @@ JSAwesome = new Class({
 	      return true
 	  }, this)
 	},
+	_check: function(element) {
+	  var invalid = false
+	  var label = this.labels[element.get('class')]
+	  if(element.get('tag') == 'div') {
+      invalid = !element.getChildren().every(function(c){
+        element = c
+        return !(c.get('value') === "")
+      });
+      if(invalid) return ["This is a required field", element, true]
+    } else if(label['required'] && element.get('value') === "")
+      return ["This is a required field", element]
+    else if(label['validation'] && element.get('value') !== "") {
+      var args = $splat(label['validation'][0])
+      var regex = new RegExp(args[0], args[1])
+      return (regex.test(element.get('value')) ? false : [label['validation'][1], element])
+    }
+	},
 	_process: function(cur, names, nested) {
-	  names = [names].flatten();
+	  names = $splat(names);    
 	  switch($type(cur)) {
 	    //a select tag
-	    case 'array':
+	    case 'array':	    
 	      this.in_select = true
 	      var root = !this.level
 	      if(cur.length  1)</diff>
				</file>
				<file>
					<file_name>push_js.rb</file_name>
					<diff>@@ -1,7 +1,14 @@
 #!/usr/bin/env ruby
 ARGV[0] ||= 'turk.js'
+compress = ARGV[1] || false
 `cat js/base.js js/jsawesome.js  js/#{ARGV[0]}`
-`yuicompressor js/#{ARGV[0]}`
-`mv js/#{ARGV[0].sub('.js','-min.js')} js/#{ARGV[0]}`
-`scp js/#{ARGV[0]} sh1:/var/www/labs`
+if compress
+  puts "Compressing..."
+  `yuicompressor js/#{ARGV[0]}`
+  `mv js/#{ARGV[0].sub('.js','-min.js')} js/#{ARGV[0]}`
+else
+  puts "Pushing non compressed"
+end
+scp = "scp js/#{ARGV[0]} sh1.doloreslabs.com:/var/www/assets"
+puts `#{scp}`
 `rm js/#{ARGV[0]}`
\ No newline at end of file</diff>
				</file>
				<file>
					<file_name>vast.html</file_name>
					<diff>@@ -0,0 +1,112 @@
+!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
+	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
+
+html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
+head
+	meta http-equiv="Content-Type" content="text/html; charset=utf-8"/
+
+	titleJSAwesome!/title
+	script src="js/base.js" type="text/javascript" charset="utf-8"/script
+	script src="js/jsawesome.js" type="text/javascript" charset="utf-8"/script
+	style type="text/css" media="screen"
+	body {
+    font:13px/1.22 arial,helvetica,clean,sans-serif;
+	}
+		label{
+			display:block;
+			font-weight:bold;
+		}
+		i {
+		  font-weight:normal;
+		}
+		input{
+		  margin-right:5px;
+		  width:10em;
+		}
+		input.NewMake {
+		  width:7em;
+		}
+		input.C_TRIM{
+		  width:5em;
+		}
+		input.C_Year{
+		  width:3em;
+		}
+		input.C_Mileage{
+		  width:5em;
+		}
+		input.C_US_State{
+		  width:2em;
+		}
+		input.C_OriginalPrice{
+		  width:4em;
+		}
+		input.C_OriginalSymbol{
+		  width:2em;
+		}
+	/style
+/head
+
+body
+  pBelow are a number of forms describing attributes of a car for sale.  This information needs to be verified.  Use the link provided with each form to find the page that this information was generated from.  Some attributes may not be available, just leave these fields blank.  For your convenience, the fields will remain gray until you verify each is correct.  You can either keep the value that is currently in the field or edit it/p
+	form method="post" id="form" action="http://www.doloreslabs.com"
+		div id="test"
+		  
+		/div
+		div id="u4"
+		/div
+		input type="submit"/
+	/form
+
+script type="text/javascript" charset="utf-8"
+	var js = new JSAwesome('test', {
+	  'NewMake':'',
+	  'NewModel':'',
+	  'C_TRIM':'',
+    'C_BodyStyle':'',
+    'C_Year':'',
+    'C_Mileage':'',
+    'C_OriginalPrice':'',
+    'C_OriginalSymbol':'',
+    'C_City':'',
+    'C_US_State':'',
+    'C_Country':''
+  }, {
+  	  'NewMake':'Make i(eg Ford)/i &nbsp;/&nbsp; Model i(eg Mustang)/i &nbsp;/&nbsp; Series i(eg GT)/i',
+  	  'NewModel':false,
+  	  'C_TRIM':false,
+      'C_BodyStyle':'Body Style i(eg Sedan)/i &nbsp;/&nbsp; Year &nbsp;/&nbsp; Mileage ',
+      'C_Year':{
+        label:false, 
+        validation:["^[12][90]\\d\\d$", "This field must be a year within the last 100"]
+      },
+      'C_Mileage':{
+        label:false, 
+        validation:["^\\d+$", "This field must be a number"]
+      },
+      'C_OriginalPrice':{
+        label:'Price &nbsp;/&nbsp; Currency i(eg $)/i', 
+        validation:["^[\\d,]+(\\.\\d\\d)?$", "This field must be a currency without a symbol i(eg 23000 or 23,000.05)/i"]
+      },
+      'C_OriginalSymbol':false,
+      'C_City':'City &nbsp;/&nbsp; State &nbsp;/&nbsp; Country',
+      'C_US_State':false,
+      'C_Country':false
+    })
+	js.to_html()
+        var json = {}
+              var legend = {"C_Mileage":{"label":false,"validation":["^\\d+$","This field must be a number"]},"NewMake":"Make i(eg Ford)\/i &nbsp;\/&nbsp; Model i(eg Mustang)\/i &nbsp;\/&nbsp; Series i(eg GT)\/i","C_OriginalPrice":{"label":"Price &nbsp;\/&nbsp; Currency i(eg $)\/i","validation":["^[\\d,]+(\\.\\d\\d)?$","This field must be a currency without a symbol i(eg 23000 or 23,000.05)\/i"]},"NewModel":false,"C_OriginalSymbol":false,"C_TRIM":false,"C_City":"City &nbsp;\/&nbsp; State &nbsp;\/&nbsp; Country","C_BodyStyle":"Body Style i(eg Sedan)\/i &nbsp;\/&nbsp; Year &nbsp;\/&nbsp; Mileage ","C_US_State":false,"C_Year":{"label":false,"validation":["^[12][90]\\d\\d$","This field must be a year within the last 100"]},"C_Country":false}
+
+
+              var j4 = $extend(json, {"_URL":"http:\/\/www.lemonfree.com\/3067447.html","C_Mileage":"39000","NewMake":"Lexus","C_OriginalPrice":"26000","NewModel":"RX","C_OriginalSymbol":null,"C_TRIM":"NULL","C_City":"Highlands Ranch","C_BodyStyle":"SUV","C_US_State":"CO","C_Year":"2002","C_Country":"United States"})
+              var u4 = new JSAwesome('u4', j4, legend)
+              u4.to_html()
+	$('form').addEvent('submit', js.validate.bind(js));
+	$$('input[type=text]').set('style', 'background:#CCC')
+	$$('input[type=text]').addEvent('focus', function(){
+	  js.validate.bind(js)()
+	  this.set('style','background:#FFF')
+	})
+/script
+/body
+/html
\ No newline at end of file</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>15f4f6c70cbe26471b07c5a4173e527485ebeb0d</sha>
			<message>Ordered forms in a row</message>
			<author_name>Chris Van Pelt</author_name>
			<author_date>2008-01-18T19:07:55Z</author_date>
			<author_email>vanpelt@snowwhite.local</author_email>
			<committer_name>Chris Van Pelt</committer_name>
			<committer_date>2008-01-18T19:07:55Z</committer_date>
			<committer_email>vanpelt@snowwhite.local</committer_email>
			<files>
				<file>
					<file_name>push_js.rb</file_name>
					<diff>@@ -0,0 +1,7 @@
+#!/usr/bin/env ruby
+ARGV[0] ||= 'turk.js'
+`cat js/base.js js/jsawesome.js  js/#{ARGV[0]}`
+`yuicompressor js/#{ARGV[0]}`
+`mv js/#{ARGV[0].sub('.js','-min.js')} js/#{ARGV[0]}`
+`scp js/#{ARGV[0]} sh1:/var/www/labs`
+`rm js/#{ARGV[0]}`
\ No newline at end of file</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>472db77d2260543125689900ececca4958e53955</sha>
			<message>Removed .svn directories</message>
			<author_name>Chris Van Pelt</author_name>
			<author_date>2008-01-12T22:09:12Z</author_date>
			<author_email>vanpelt@snowwhite.local</author_email>
			<committer_name>Chris Van Pelt</committer_name>
			<committer_date>2008-01-12T22:09:12Z</committer_date>
			<committer_email>vanpelt@snowwhite.local</committer_email>
			<files>
			</files>
		</commit>
		<commit>
			<sha>302a7f7df155b0163b4b2a9791ee37bef37f199d</sha>
			<message>First git commit ever!</message>
			<author_name>Chris Van Pelt</author_name>
			<author_date>2008-01-12T22:07:44Z</author_date>
			<author_email>vanpelt@snowwhite.local</author_email>
			<committer_name>Chris Van Pelt</committer_name>
			<committer_date>2008-01-12T22:07:44Z</committer_date>
			<committer_email>vanpelt@snowwhite.local</committer_email>
			<files>
			</files>
		</commit>
	</commits>
	<actual_files>
		<actual_file>
			<filename>.gitignore</filename>
			<content>dist
</content>
		</actual_file>
		<actual_file>
			<filename>History.txt</filename>
			<content>== 0.1.3 2008-04-09
* Checkboxes automagically have a hidden field to make sure un-selected ones are sent.  Values are true / false

== 0.1.2 2008-03-21
* Fixed a bug where radio button groups didn't work in Firefox because of duplicate ids

== 0.1.1 2008-03-13
* Added a '+' delineator for any field that can be duplicated...
* Made selects only sort if they are a sub-select
* Fixed label bug for delineated fields

== 0.1.0 2008-03-05
* Form validation start and stop (...buggy)

== 0.0.9 2008-02-23

* A major refactor of the sub-select logic
* Support for all basic form elements
</content>
		</actual_file>
		<actual_file>
			<filename>License.txt</filename>
			<content>Copyright (c) 2008 Chris Van Pelt

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</content>
		</actual_file>
		<actual_file>
			<filename>Rakefile</filename>
			<content>require 'rubygems'
begin
  require 'rake'
rescue LoadError
  puts 'This script should only be accessed via the "rake" command.'
  puts 'Installation: gem install rake -y'
  exit
end
require 'rake'
require 'rake/clean'
require 'rake/packagetask'

$:.unshift File.dirname(__FILE__) + "/lib"

APP_VERSION  = '0.1.6'
APP_NAME     = 'jsawesome'
APP_FILE_NAME= "#{APP_NAME}.js"

APP_ROOT     = File.expand_path(File.dirname(__FILE__))
APP_SRC_DIR  = File.join(APP_ROOT, 'src')
APP_DIST_DIR = File.join(APP_ROOT, 'dist')
APP_PKG_DIR  = File.join(APP_ROOT, 'pkg')


unless ENV['rakefile_just_config']

task :default = [:dist, :package, :clean_package_source]

desc "Builds the distribution"
task :dist do
  $:.unshift File.join(APP_ROOT, 'lib')
  require 'protodoc'
  require 'fileutils'
  FileUtils.mkdir_p APP_DIST_DIR

  Dir.chdir(APP_SRC_DIR) do
    File.open(File.join(APP_DIST_DIR, APP_FILE_NAME), 'w+') do |dist|
      dist  Protodoc::Preprocessor.new(APP_FILE_NAME)
    end
  end
  Dir.chdir(APP_DIST_DIR) do
    FileUtils.copy_file APP_FILE_NAME, "#{APP_NAME}-#{APP_VERSION}.js"
  end
  if File.directory?("website")
    FileUtils.mkdir_p "website/dist"
    FileUtils.copy_file "dist/#{APP_FILE_NAME}",       "website/dist/#{APP_FILE_NAME}"
    FileUtils.copy_file "dist/#{APP_FILE_NAME}",       "website/dist/#{APP_NAME}-#{APP_VERSION}.js"
  end
end

Rake::PackageTask.new(APP_NAME, APP_VERSION) do |package|
  package.need_tar_gz = true
  package.package_dir = APP_PKG_DIR
  package.package_files.include(
    '[A-Z]*',
    'config/*.sample',
    "dist/#{APP_FILE_NAME}",
    'lib/**',
    'src/**',
    'script/**',
    'tasks/**',
    'test/**',
    'website/**'
  )
end

desc "Builds the distribution, runs the JavaScript unit + functional tests and collects their results."
task :test = [:dist, :test_units, :test_functionals]

require 'jstest'
desc "Runs all the JavaScript unit tests and collects the results"
JavaScriptTestTask.new(:test_units, 4711) do |t|
  testcases        = ENV['TESTCASES']
  tests_to_run     = ENV['TESTS']    && ENV['TESTS'].split(',')
  browsers_to_test = ENV['BROWSERS'] && ENV['BROWSERS'].split(',')

  t.mount("/dist")
  t.mount("/src")
  t.mount("/test")

  Dir["test/unit/*_test.html"].sort.each do |test_file|
    tests = testcases ? { :url = "/#{test_file}", :testcases = testcases } : "/#{test_file}"
    test_filename = test_file[/.*\/(.+?)\.html/, 1]
    t.run(tests) unless tests_to_run && !tests_to_run.include?(test_filename)
  end

  %w( firefox safari ie konqueror ).each do |browser|# opera 
    t.browser(browser.to_sym) unless browsers_to_test && !browsers_to_test.include?(browser)
  end
end

desc "Runs all the JavaScript functional tests and collects the results"
JavaScriptTestTask.new(:test_functionals, 4712) do |t|
  testcases        = ENV['TESTCASES']
  tests_to_run     = ENV['TESTS']    && ENV['TESTS'].split(',')
  browsers_to_test = ENV['BROWSERS'] && ENV['BROWSERS'].split(',')

  t.mount("/dist")
  t.mount("/src")
  t.mount("/test")

  Dir["test/functional/*_test.html"].sort.each do |test_file|
    tests = testcases ? { :url = "/#{test_file}", :testcases = testcases } : "/#{test_file}"
    test_filename = test_file[/.*\/(.+?)\.html/, 1]
    t.run(tests) unless tests_to_run && !tests_to_run.include?(test_filename)
  end

  %w( firefox safari ie konqueror ).each do |browser| # opera 
    t.browser(browser.to_sym) unless browsers_to_test && !browsers_to_test.include?(browser)
  end
end


task :clean_package_source do
  rm_rf File.join(APP_PKG_DIR, "#{APP_NAME}-#{APP_VERSION}")
end

Dir['tasks/**/*.rake'].each { |rake| load rake }

end
</content>
		</actual_file>
		<actual_file>
			<filename>README.txt</filename>
			<content>Jsawesome

Description:
    JSAwesome provides a powerful JSON based DSL for creating interactive forms.

Example:
    new JSAwesome('rad', [['cool','neat'], ['^neat',true]], {'cool':{label:'Cool man', validation:'cool'}).to_html()
    =
      label for="rad_cool"Cool man/label
      input type="text" name="rad_cool" value="neat"/
      label for="rad_neat"input type="checkbox" name="rad_neat" checked="checked"/ Neat/label
    
    A detailed overview of the library is now available at
      http://vandev.com/2008/4/22/jsawesome
      
    Also see the functional tests for more examples of what is possible

More information:
    http://github.com/vanpelt/jsawesome/tree/master
    
Author:
    Chris Van Pelt, vanpelt@doloreslabs.com</content>
		</actual_file>
		<actual_file>
			<filename>javascript_test_autotest.yml</filename>
			<content>browsers:
  firefox: '/Applications/Firefox.app/Contents/MacOS/firefox-bin'
  safari: '/Applications/Safari.app/Contents/MacOS/Safari'</content>
		</actual_file>
		<actual_file>
			<filename>jstest.rb</filename>
			<content>require 'rake/tasklib'
require 'thread'
require 'webrick'
require 'fileutils'
include FileUtils

class Browser
  def supported?; true; end
  def setup ; end
  def open(url) ; end
  def teardown ; end

  def host
    require 'rbconfig'
    Config::CONFIG['host']
  end
  
  def macos?
    host.include?('darwin')
  end
  
  def windows?
    host.include?('mswin')
  end
  
  def linux?
    host.include?('linux')
  end
  
  def applescript(script)
    raise "Can't run AppleScript on #{host}" unless macos?
    system "osascript -e '#{script}' 2&1 /dev/null"
  end
end

class FirefoxBrowser  Browser
  def initialize(path=File.join(ENV['ProgramFiles'] || 'c:\Program Files', '\Mozilla Firefox\firefox.exe'))
    @path = path
  end

  def visit(url)
    system("open -a Firefox '#{url}'") if macos?
    system("#{@path} #{url}") if windows? 
    system("firefox #{url}") if linux?
  end

  def to_s
    "Firefox"
  end
end

class SafariBrowser  Browser
  def supported?
    macos?
  end
  
  def setup
    applescript('tell application "Safari" to make new document')
  end
  
  def visit(url)
    applescript('tell application "Safari" to set URL of front document to "' + url + '"')
  end

  def teardown
    #applescript('tell application "Safari" to close front document')
  end

  def to_s
    "Safari"
  end
end

class IEBrowser  Browser
  def setup
    require 'win32ole' if windows?
  end

  def supported?
    windows?
  end
  
  def visit(url)
    if windows?
      ie = WIN32OLE.new('InternetExplorer.Application')
      ie.visible = true
      ie.Navigate(url)
      while ie.ReadyState != 4 do
        sleep(1)
      end
    end
  end

  def to_s
    "Internet Explorer"
  end
end

class KonquerorBrowser  Browser
  @@configDir = File.join((ENV['HOME'] || ''), '.kde', 'share', 'config')
  @@globalConfig = File.join(@@configDir, 'kdeglobals')
  @@konquerorConfig = File.join(@@configDir, 'konquerorrc')

  def supported?
    linux?
  end

  # Forces KDE's default browser to be Konqueror during the tests, and forces
  # Konqueror to open external URL requests in new tabs instead of a new
  # window.
  def setup
    cd @@configDir, :verbose = false do
      copy @@globalConfig, "#{@@globalConfig}.bak", :preserve = true, :verbose = false
      copy @@konquerorConfig, "#{@@konquerorConfig}.bak", :preserve = true, :verbose = false
      # Too lazy to write it in Ruby...  Is sed dependency so bad?
      system "sed -ri /^BrowserApplication=/d  '#{@@globalConfig}'"
      system "sed -ri /^KonquerorTabforExternalURL=/s:false:true: '#{@@konquerorConfig}'"
    end
  end

  def teardown
    cd @@configDir, :verbose = false do
      copy "#{@@globalConfig}.bak", @@globalConfig, :preserve = true, :verbose = false
      copy "#{@@konquerorConfig}.bak", @@konquerorConfig, :preserve = true, :verbose = false
    end
  end
  
  def visit(url)
    system("kfmclient openURL #{url}")
  end
  
  def to_s
    "Konqueror"
  end
end

class OperaBrowser  Browser
  def initialize(path='c:\Program Files\Opera\Opera.exe')
    @path = path
  end
  
  def setup
    if windows?
      puts %{
        MAJOR ANNOYANCE on Windows.
        You have to shut down Opera manually after each test
        for the script to proceed.
        Any suggestions on fixing this is GREATLY appreciated!
        Thank you for your understanding.
      }
    end
  end
  
  def visit(url)
    applescript('tell application "Opera" to GetURL "' + url + '"') if macos? 
    system("#{@path} #{url}") if windows? 
    system("opera #{url}")  if linux?
  end

  def to_s
    "Opera"
  end
end

# shut up, webrick :-)
class ::WEBrick::HTTPServer
  def access_log(config, req, res)
    # nop
  end
end

class ::WEBrick::BasicLog
  def log(level, data)
    # nop
  end
end

class WEBrick::HTTPResponse
  alias send send_response
  def send_response(socket)
    send(socket) unless fail_silently?
  end
  
  def fail_silently?
    @fail_silently
  end
  
  def fail_silently
    @fail_silently = true
  end
end

class WEBrick::HTTPRequest
  def to_json
    headers = []
    each { |k, v| headers.push "#{k.inspect}: #{v.inspect}" }
    headers = "{"  headers.join(', ')  "}"
    %({ "headers": #{headers}, "body": #{body.inspect}, "method": #{request_method.inspect} })
  end
end

class WEBrick::HTTPServlet::AbstractServlet
  def prevent_caching(res)
    res['ETag'] = nil
    res['Last-Modified'] = Time.now + 100**4
    res['Cache-Control'] = 'no-store, no-cache, must-revalidate, post-check=0, pre-check=0'
    res['Pragma'] = 'no-cache'
    res['Expires'] = Time.now - 100**4
  end
end

class BasicServlet  WEBrick::HTTPServlet::AbstractServlet
  def do_GET(req, res)
    prevent_caching(res)
    res['Content-Type'] = "text/plain"
    
    req.query.each do |k, v|
      res[k] = v unless k == 'responseBody'
    end
    res.body = req.query["responseBody"]
    
    raise WEBrick::HTTPStatus::OK
  end
  
  def do_POST(req, res)
    do_GET(req, res)
  end
end

class SlowServlet  BasicServlet
  def do_GET(req, res)
    sleep(2)
    super
  end
end

class DownServlet  BasicServlet
  def do_GET(req, res)
    res.fail_silently
  end
end

class InspectionServlet  BasicServlet
  def do_GET(req, res)
    prevent_caching(res)
    res['Content-Type'] = "application/json"
    res.body = req.to_json
    raise WEBrick::HTTPStatus::OK
  end
end

class NonCachingFileHandler  WEBrick::HTTPServlet::FileHandler
  def do_GET(req, res)
    super
    set_default_content_type(res, req.path)
    prevent_caching(res)
  end
  
  def set_default_content_type(res, path)
    res['Content-Type'] = case path
      when /\.js$/   then 'text/javascript'
      when /\.html$/ then 'text/html'
      when /\.css$/  then 'text/css'
      else 'text/plain'
    end
  end
end

class JavaScriptTestTask  ::Rake::TaskLib

  def initialize(name=:test, port=4711)
    @name = name
    @tests = []
    @browsers = []
    @port = port
    @queue = Queue.new

    @server = WEBrick::HTTPServer.new(:Port = @port) # TODO: make port configurable
    @server.mount_proc("/results") do |req, res|
      @queue.push({
        :tests = req.query['tests'].to_i,
        :assertions = req.query['assertions'].to_i,
        :failures = req.query['failures'].to_i,
        :errors = req.query['errors'].to_i
      })
      res.body = "OK"
    end
    @server.mount("/response", BasicServlet)
    @server.mount("/slow", SlowServlet)
    @server.mount("/down", DownServlet)
    @server.mount("/inspect", InspectionServlet)
    yield self if block_given?
    define
  end

  def define
    task @name do
      trap("INT") { @server.shutdown }
      t = Thread.new { @server.start }
      
      # run all combinations of browsers and tests
      @browsers.each do |browser|
        if browser.supported?
          t0 = Time.now
          results = {:tests = 0, :assertions = 0, :failures = 0, :errors = 0}
          errors = []
          failures = []
          browser.setup
          puts "\nStarted tests in #{browser}"
          @tests.each do |test|
            params = "resultsURL=http://localhost:#{@port}/results&t=" + ("%.6f" % Time.now.to_f)
            if test.is_a?(Hash)
              params  "&tests=#{test[:testcases]}" if test[:testcases]
              test = test[:url]
            end
            browser.visit("http://localhost:#{@port}#{test}?#{params}")
 
            result = @queue.pop
            result.each { |k, v| results[k] += v }
            value = "."
            
            if result[:failures]  0
              value = "F"
              failures.push(test)
            end
            
            if result[:errors]  0
              value = "E"
              errors.push(test)
            end
            
            print value
          end
          
          puts "\nFinished in #{(Time.now - t0).round.to_s} seconds."
          puts "  Failures: #{failures.join(', ')}" unless failures.empty?
          puts "  Errors:   #{errors.join(', ')}" unless errors.empty?
          puts "#{results[:tests]} tests, #{results[:assertions]} assertions, #{results[:failures]} failures, #{results[:errors]} errors"
          browser.teardown
        else
          puts "\nSkipping #{browser}, not supported on this OS"
        end
      end

      @server.shutdown
      t.join
    end
  end

  def mount(path, dir=nil)
    dir = Dir.pwd + path unless dir

    # don't cache anything in our tests
    @server.mount(path, NonCachingFileHandler, dir)
  end

  # test should be specified as a url or as a hash of the form
  # {:url = "url", :testcases = "testFoo,testBar"}
  def run(test)
    @teststest
  end

  def browser(browser)
    browser =
      case(browser)
        when :firefox
          FirefoxBrowser.new
        when :safari
          SafariBrowser.new
        when :ie
          IEBrowser.new
        when :konqueror
          KonquerorBrowser.new
        when :opera
          OperaBrowser.new
        else
          browser
      end

    @browsersbrowser
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>protodoc.rb</filename>
			<content>require 'erb'

class String
  def lines
    split $/
  end
  
  def strip_whitespace_at_line_ends
    lines.map {|line| line.gsub(/\s+$/, '')} * $/
  end
end

module Protodoc
  module Environment
    def include(*filenames)
      filenames.map {|filename| Preprocessor.new(filename).to_s}.join("\n")
    end
  end
  
  class Preprocessor
    include Environment
    
    def initialize(filename)
      @filename = File.expand_path(filename)
      @template = ERB.new(IO.read(@filename), nil, '%')
    end
    
    def to_s
      @template.result(binding).strip_whitespace_at_line_ends
    end
  end  
end

if __FILE__ == $0
  print Protodoc::Preprocessor.new(ARGV.first)
end
</content>
		</actual_file>
		<actual_file>
			<filename>destroy</filename>
			<content>#!/usr/bin/env ruby
APP_ROOT = File.expand_path(File.join(File.dirname(__FILE__), '..'))

begin
  require 'rubigen'
rescue LoadError
  require 'rubygems'
  require 'rubigen'
end
require 'rubigen/scripts/destroy'

ARGV.shift if ['--help', '-h'].include?(ARGV[0])
RubiGen::Base.use_component_sources! [:javascript, :javascript_test, :newjs, :newjs_theme]
RubiGen::Scripts::Destroy.new.run(ARGV)
</content>
		</actual_file>
		<actual_file>
			<filename>generate</filename>
			<content>#!/usr/bin/env ruby
APP_ROOT = File.expand_path(File.join(File.dirname(__FILE__), '..'))

begin
  require 'rubigen'
rescue LoadError
  require 'rubygems'
  require 'rubigen'
end
require 'rubigen/scripts/generate'

ARGV.shift if ['--help', '-h'].include?(ARGV[0])
RubiGen::Base.use_component_sources! [:javascript, :javascript_test, :newjs, :newjs_theme]
RubiGen::Scripts::Generate.new.run(ARGV)
</content>
		</actual_file>
		<actual_file>
			<filename>js_autotest</filename>
			<content>script/rstakeout "rake test:recent:javascript" test/unit/*_test.html src/*.js
</content>
		</actual_file>
		<actual_file>
			<filename>push_js</filename>
			<content>#!/usr/bin/env ruby
ARGV[0] ||= 'jsawesome.js'
compress = ARGV[1] || false
`cat js/base.js js/jsawesome.js  js/#{ARGV[0]}.local`
if compress
  puts "Compressing..."
  `yuicompressor js/#{ARGV[0]}`
  `mv js/#{ARGV[0].sub('.js','-min.js')} js/#{ARGV[0]}.local`
else
  puts "Pushing non compressed"
end
scp = "scp js/#{ARGV[0]}.local deployer@sh2.doloreslabs.com:/var/www/assets/#{ARGV[0]}"
puts `#{scp}`
`rm js/#{ARGV[0]}.local`</content>
		</actual_file>
		<actual_file>
			<filename>rstakeout</filename>
			<content>#!/usr/local/bin/ruby -w


config = File.dirname(__FILE__) + "/../config/javascript_test_autotest.yml"
unless File.exists?(config)
  puts -EOS
Edit config/javascript_test_autotest.yml for the browser(s) to use for autotesting.
See config/javascript_test_autotest.yml.sample for examples.
EOS
  exit
end

##
# Originally by Mike Clark.
#
# From http://www.pragmaticautomation.com/cgi-bin/pragauto.cgi/Monitor/StakingOutFileChanges.rdoc
#
# Runs a user-defined command when files are modified.
#
# Like autotest, but more customizable. This is useful when you want to do
# something other than run tests. For example, generate a PDF book, run
# a single test, or run a legacy Test::Unit suite in an app that also
# has an rSpec suite.
#
# Can use Ruby's Dir[] to get file glob. Quote your args to take advantage of this.
#
#  rstakeout 'rake test:recent' **/*.rb
#  = Only watches Ruby files one directory down (no quotes)
#
#  rstakeout 'rake test:recent' '**/*.rb'
#  = Watches all Ruby files in all directories and subdirectories
#
# Modified (with permission) by Geoffrey Grosenbach to call growlnotify for
# rspec and Test::Unit output.
#
# See the PeepCode screencast on rSpec or other blog articles for instructions on
# setting up growlnotify.

def growl(title, msg, img, pri=0, sticky="")
  system "growlnotify -n autotest --image ~/.autotest_images/#{img} -p #{pri} -m #{msg.inspect} #{title} #{sticky}"
end

def self.growl_fail(output)
  growl "FAIL", "#{output}", "fail.png", 2
end

def self.growl_pass(output)
  growl "Pass", "#{output}", "pass.png"
end

command = ARGV.shift
files = {}

ARGV.each do |arg|
  Dir[arg].each { |file|
    files[file] = File.mtime(file)
  }
end

puts "Watching #{files.keys.join(', ')}\n\nFiles: #{files.keys.length}"

trap('INT') do
  puts "\nQuitting..."
  exit
end


loop do

  sleep 1

  changed_file, last_changed = files.find { |file, last_changed|
    File.mtime(file)  last_changed
  }

  if changed_file
    files[changed_file] = File.mtime(changed_file)
    puts "= #{changed_file} changed, running #{command}"
    results = `#{command}`
    puts results

    if results.include? 'tests'
      output = results.slice(/(\d+)\s+tests?,\s*(\d+)\s+assertions?,\s*(\d+)\s+failures?(,\s*(\d+)\s+errors)?/)
      if output
        $~[3].to_i + $~[5].to_i  0 ? growl_fail(output) : growl_pass(output)
      end
    else
      output = results.slice(/(\d+)\s+examples?,\s*(\d+)\s+failures?(,\s*(\d+)\s+not implemented)?/)
      if output
        $~[2].to_i  0 ? growl_fail(output) : growl_pass(output)
      end
    end
    # TODO Generic growl notification for other actions

    puts "= done"
  end

end
</content>
		</actual_file>
		<actual_file>
			<filename>base.js</filename>
			<content>//Globals...
Scroller = null
delay = 100
window.addEvent('load', function(){
  Scroller = new Fx.Scroll(window, {link:'chain', offset:{x:0,y:-25}})
})
JSAwesome = new Class({
	initialize: function(name, json, labels){
	  this.name = name
		this.json = json
		this.labels = labels || {}
		this.validatables = []
		this.validations = $H(labels).getKeys().filter(function(f){
		  return labels[f]['required'] || labels[f]['validation']
		})
	},
	to_html: function() {
	  var m = []
	  $A(this.json).each(function(p,i){
	    var n = []
	    //Allows you to reference previous selects...
	    if($type(p[1])=="number" && this.json[p[1]])
	      p[1] = this.json[p[1]][1]
	    if($type(p[0])=="array"){
	      n.push(p.map(function(r){
	        r = $splat(r)
	        n.push(this.extra('before', r[0]))
	        return new Element('div', {style:'float:left;margin-right:5px'}).adopt(this._process(r[1],r[0]))
	      }, this))
	      n.push(new Element('br', {style:'clear:left'}))
	      n.push(this.extra('after', $splat(p.getLast())[0]))
	    } else {
	      n.push(this.extra('before', p[0]))
	      n.push(this._process(p[1],p[0]))
	      n.push(this.extra('after', p[0]))
	    }
	    var klass = $type(p[0]) == "string" ? this._clean(p[0]) : "row_"+(i+1)
	    m.push(new Element('div', {'class':'error '+klass}).adopt(n))
	  }, this);
	  var adopted = $(this.name).adopt(m.concat($(this.name).getChildren().dispose()))
	  adopted.getElements('select').each(function(e){
	    e.fireEvent('change', {target:e})
	  })
	 return adopted
	},
	extra: function(where, what) {
	  return this.labels[where+'_'+what] ? new Element('div', {html: this.labels[where+'_'+what]}) : null
	},
	label: function(name, wafor) {
	  var newname = null
	  name = this._clean(name)
	  if($defined(this.labels[name])) {
	    if($defined(this.labels[name]['label']))
	      newname = this.labels[name]['label']
	    else
	      newname = this.labels[name]
	    if($type(newname) == "object")
	      newname = null
	  }
	  if(!$defined(newname))
	    newname = this._capitalize(name.replace(/_/g,' '))
	  return ($type(wafor) == "element" ? wafor.set('html', newname) : new Element('label', {'for':this._id(wafor), 'html':newname}))
	},
	addValidation: function(wha){
	  if(wha) {
	    this.validatables.each(function(v){
	      //There is an undefined element in IE for some sick reason
	      if(v && v.test(wha)) {
	        this.validatables.erase(v)
	        this.validations.push(v)
	      }
	    }, this)
	  } else {
	    this.validater = this.validate.bind(this)
	    $(this.name).getParent('form').addEvent('submit', this.validater)
	  }
	},
	stopValidation: function(wha){
	  if(wha) {
	    this.validations.each(function(v){
	      //There is an undefined element in IE for some sick reason
	      if(v && v.test(wha)) {
	        this.validations.erase(v)
	        this.validatables.push(v)
	      }
	    }, this)
	  } else
	    $(this.name).getParent('form').removeEvent('submit', this.validater)
	},
	validate: function(e) {
	  var valid = this.validations.filter(function(r){
	    var checking = $(this.name).getElement('div .'+this._clean(r))
	    var error = checking.getParent('.error')
	    var invalid = this._check(checking)
	    if(invalid) {
	      this.delay = (delay -= 20)
	      invalid[1].set('style', 'background:#d88b7e')
	      if(error.getChildren().getLast().innerHTML != invalid[0]) {
	        var mes = new Element('span', {
	          style: 'color:red;display:block',
	          html:invalid[0]
	        }).inject(error)
	      }
	      invalid[1].addEvent(invalid[2] || 'blur', function(){
	        var check = this._check(checking)
	        if(!check || invalid[1] != check[1]) {
	          invalid[1].set('style', 'background:')
	          if(mes){
	            mes.dispose()
	            mes = false
	          }
	        }
	      }.bind(this))
	      if(this.delay  0)
	        Scroller.toElement.delay(this.delay, Scroller, checking)
	      else
	        this._reset.delay(500)
	      return true
	    } else 
	      return false
	  }, this).length == 0
	  if(!valid && $type(e) == "event")
      e.stop()
    return valid
	},
	_reset: function() { delay = 100 },
	_check: function(element) {
	  var invalid = false
	  var label = this.labels[element.get('class')]
	  //Validate chained selects
	  if(element.get('tag') == 'select') {
      invalid = element.getParent().getElements("select, .custom").some(function(c){
        element = c
        return c.get('value') === ""
      });
      if(invalid) return ["This is a required field", element, 'change']
    } else if(element.get('type') == "radio" && label['required']) {
      var radios = element.getParent('fieldset').getElements('input[type=radio]')
      if(radios.some(function(r){return r.checked}))
        return false
      else
        return ["You must choose an option", new Elements(radios), 'click']
    } else if(element.get('type') == "checkbox" && label['required']) {
      if(element.checked)
        return false
      else
        return ["You must check this box", element, 'click']
    } else if(label['required'] && element.get('value') === "")
      return ["This is a required field", element]
    else if(label['validation']) {
      var args = $splat(label['validation'][0])
      var regex = new RegExp(args[0], args[1])
      if(!label['required'] && element.get('value').test(/^\s*$/))
        return false
      return (regex.test(element.get('value')) ? false : [label['validation'][1], element])
    }
	},
	_process: function(cur, name, parent) {
	  var select_default = this.labels['{}'] || ["Choose Category", "Choose Subcategory"]
	  switch($type(cur)) {
	    //a select tag or group of radios/checkboxes
	    case 'array':
	      if(name.test(/^[*^]/)) {
	        return new Element('fieldset').adopt(
	          [this.label(this._clean(name), new Element('legend'))].concat(cur.map(function(c){
	            c = $splat(c)
	            return this._process(c[0], name, c.getLast());
	          }, this))
	        );
	      } else {          
          //Sort the options, and make the other / custom field go to the end... if it's a nested select
          if(parent) {
            cur = cur.sort()
            var other = false
            cur.some(function(a){ return a.test(/~/) ? other = a : other})
            if(other)
              cur.erase(other).push(other)
          }
          //Add the default header
          if(cur.length  1)
	          cur = [parent ? select_default[1] : select_default[0]].concat(cur)
	        var level = parent ? parent.getParent().retrieve('level') : null
	        var klass = [name,level].clean().join("_")
	        if(parent && cur.length  0) {
	          parent.store('extra', this._select(name, cur, klass, level))
	          return null
	        } else if(cur.length  0)
	          return [this.label(name, name),this._select(name, cur, klass, level)]
	        else return null
	      }
	    case 'object':
	      cur = $H(cur)
	      var t = [this._process(cur.getKeys(), name, parent)]
	      var root = parent ? parent.retrieve('extra') : t[0][1]
	      t.push(this._process([select_default[1]], name, root.getElement('option')))
	      return t.concat(cur.getValues().map(function(v){
	        var val = cur.keyOf(v).split('|').getLast()
	        var parent = root.getElement('option[value='+val+']')
	        return this._process(v, name, parent)
	      }, this));
	    default:
	      var e = null
        //Ugggggg
	      if($type(cur)=="string") {
	        //There should be a better way to do this
	        var reversed = [].concat(select_default).reverse()
	        var val = cur.split('|').getLast().replace(new RegExp(reversed.join("|")),'')
	        cur = this._clean(cur.split('|')[0])
	      }
	      if($type(parent) == "element") {
	        //Allows for custom values
	        e = new Element('option', {html: cur, value: this._clean(val)})
	        if(val.test(/^~/))
            e.store('extra', this._custom(parent.get('name').replace(/(.+)\[(.+)\]/, '$1[$2_other]'), parent.get('class')))
	      } else {
	        if(name.test(/^#/)) {
	          e = new Element('textarea', {
	            name: this._name(name),
	            id: this._id(name),
	            'class':this._clean(name), 
	            html: cur})
	        } else if(name.test(/^_/)) {
	          e = this._input('hidden', name, cur)
	        } else if(name.test(/^\*/)) {
            e = this.label(cur, name).grab(
              this._input('radio', name, val), 'top')
          } else if(name.test(/^\^/)) {
            //handles both grouped checkboxes and individual ones... Kindof a Mind FFFF
            if($defined(parent))
              var tname = cur
            else {
              parent = cur
              var tname = name
            }
            e = this.label(tname, val || tname).grab(
              this._input('checkbox', (val || tname), parent === true), 'top')
	        } else e = this._input('text', name, cur)
	        //For duplication...
	        if(name.test(/^.?\+/))
	          e = [e, new Element('a', {html:' +', href:'#', events:{click:this.duplicate}, 'class':'plus'})]
	        if(!name.test(/^[_*^]/))
	          e = [this.label(name, name), e]
	      }
	      return e
	  }
	},
	duplicate: function(e) {
	  e.stop()
	  var orig = e.target.getPrevious()
	  var next = ""
	  //Because mechanical turk sucks ass
	  if(!orig.name.test(/\[\d+\]$/)) {
	    next = orig.name+"[1]"
	    orig.name = orig.name+"[0]"
	  } else {
	    var ind = orig.name.match(/\[(\d+)\]$/)[1].toInt() + 1
	    next = orig.name.replace(/\[\d+\]$/, '['+ind+']')
	  }
	  var inp = new Element(orig.get('tag')).set('name', next)
	  if(orig.get('tag') != 'textarea')
	    inp.set('type', orig.get('type'))
	  inp.inject(orig, 'after')
	  new Element('br').inject(orig, 'after')
	},
	_capitalize: function(string){
		return string.replace(/^[a-z]/, function(match){ return match.toUpperCase() });
	},
	_clean: function(name) {
	  return name.replace(/^[_#*^~]?\+?/,'')
	},
	_name: function(name) {
	  return this.name+'['+this._clean(name)+']'
	},
	_id: function(name) {
	  return this.name+'_'+this._clean(name)
	},
	_input: function(type, name, val) {
	  var e = new Element('input', {type: type, 'class': this._clean(name), name: this._name(name), id: (type =='radio' ? '' : this._id(name))})
    if(type == "checkbox") {
      e.set('checked', val ? "checked" : "")
      e.set('value', 'true')
      e = new Element('span').adopt([e, this._input('hidden', name, 'false')])
    } else
      e.set('value', val)
    return e
	},
	_custom: function(name, klass) {
	  var val = this.labels['~'] || "Custom..."
	  return new Element('input', {
      'class':klass+' custom', 
      type: 'text', 
      name: name, 
      value: val,
      events: {
        'focus': function(){
          if(this.value == val)
            this.set('value', "")
        }
      }
    })
	},
	_select: function(name, options, klass, level) {
	  var level = level || 0
	  var leveled = level  0 ? name + '_' + level : name
	  var select = new Element("select", {
      name: this._name(leveled),
      id: this._id(leveled),
      'class': klass,
      events: {
        change: function(event){
          var e = event.target
          var option = e[e.selectedIndex]
          var klass = e.get('class').split(' ')[0]
          var verify = new RegExp("("+name+')_\\d+$')
          var next = klass.test(verify) ? klass.replace(verify, '$1_'+(level+1)) : klass+'_'+(level+1) 
          //Dispose namespaced in a wrapper (Make this better for floated elements...)
          var test = $$('#'+this.name+' .'+klass.replace(verify,'$1'))[0]
          if(test.get('tag') != 'div')
            test = test.getParent('div')
          test.getElements('.custom, select').each(function(i){
            if(i.hasClass('custom') || i.retrieve('level')  level+1)
              i.dispose()
          })
          if(!option.retrieve('extra')) return
          var test = $(this.name).getElement('.'+next)
          //Replace or add the extras
          if(test)
            var made = option.retrieve('extra').replaces(test)
          else
            var made = option.retrieve('extra').inject(e, "after")
          made.fireEvent('change', {target:made})
        }.bind(this)
      }
    })    
    select.store('level', (level || 0) + 1)
    return select.adopt(options.map(
      function(o){
        return this._process(o, klass, select)
      },this)
    )
	}
});</content>
		</actual_file>
		<actual_file>
			<filename>HEADER</filename>
			<content>/*  Jsawesome, version %= APP_VERSION %
 *  (c) 2008 Chris Van Pelt
 *
 *  Jsawesome is freely distributable under 
 *  the terms of an MIT-style license.
 *  For details, see the web site: http://github.com/vanpelt/jsawesome/tree/master
 *
 *--------------------------------------------------------------------------*/</content>
		</actual_file>
		<actual_file>
			<filename>jsawesome.js</filename>
			<content>%= include 'HEADER' %

%= include 'mootools.js' %

%= include 'base.js' %</content>
		</actual_file>
		<actual_file>
			<filename>mootools.js</filename>
			<content>/*
Script: Core.js
	MooTools - My Object Oriented JavaScript Tools.

License:
	MIT-style license.

Copyright:
	Copyright (c) 2006-2007 [Valerio Proietti](http://mad4milk.net/).

Code & Documentation:
	[The MooTools production team](http://mootools.net/developers/).

Inspiration:
	- Class implementation inspired by [Base.js](http://dean.edwards.name/weblog/2006/03/base/) Copyright (c) 2006 Dean Edwards, [GNU Lesser General Public License](http://opensource.org/licenses/lgpl-license.php)
	- Some functionality inspired by [Prototype.js](http://prototypejs.org) Copyright (c) 2005-2007 Sam Stephenson, [MIT License](http://opensource.org/licenses/mit-license.php)
*/

var MooTools = {
	'version': '1.2dev',
	'build': '1543'
};
      
var Native = function(options){
	options = options || {};

	var afterImplement = options.afterImplement || function(){};
	var generics = options.generics;
	generics = (generics !== false);
	var legacy = options.legacy;
	var initialize = options.initialize;
	var protect = options.protect;
	var name = options.name;

	var object = initialize || legacy;

	object.constructor = Native;
	object.$family = {name: 'native'};
	if (legacy && initialize) object.prototype = legacy.prototype;
	object.prototype.constructor = object;

	if (name){
		var family = name.toLowerCase();
		object.prototype.$family = {name: family};
		Native.typize(object, family);
	}

	var add = function(obj, name, method, force){
		if (!protect || force || !obj.prototype[name]) obj.prototype[name] = method;
		if (generics) Native.genericize(obj, name, protect);
		afterImplement.call(obj, name, method);
		return obj;
	};
	
	object.implement = function(a1, a2, a3){
		if (typeof a1 == 'string') return add(this, a1, a2, a3);
		for (var p in a1) add(this, p, a1[p], a2);
		return this;
	};
	
	object.alias = function(a1, a2, a3){
		if (typeof a1 == 'string'){
			a1 = this.prototype[a1];
			if (a1) add(this, a2, a1, a3);
		} else {
			for (var a in a1) this.alias(a, a1[a], a2);
		}
		return this;
	};

	return object;
};

Native.implement = function(objects, properties){
	for (var i = 0, l = objects.length; i  l; i++) objects[i].implement(properties);
};

Native.genericize = function(object, property, check){
	if ((!check || !object[property]) && typeof object.prototype[property] == 'function') object[property] = function(){
		var args = Array.prototype.slice.call(arguments);
		return object.prototype[property].apply(args.shift(), args);
	};
};

Native.typize = function(object, family){
	if (!object.type) object.type = function(item){
		return ($type(item) === family);
	};
};

Native.alias = function(objects, a1, a2, a3){
	for (var i = 0, j = objects.length; i  j; i++) objects[i].alias(a1, a2, a3);
};

(function(objects){
	for (var name in objects) Native.typize(objects[name], name.toLowerCase());
})({'Boolean': Boolean, 'Native': Native, 'Object': Object});

(function(objects){
	for (var name in objects) new Native({name: name, initialize: objects[name], protect: true});
})({'String': String, 'Function': Function, 'Number': Number, 'Array': Array, 'RegExp': RegExp, 'Date': Date});

(function(object, methods){
	for (var i = 0, l = methods.length; i  l; i++) Native.genericize(object, methods[i], true);
	return arguments.callee;
})
(Array, ['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift', 'concat', 'join', 'slice', 'toString', 'valueOf', 'indexOf', 'lastIndexOf'])
(String, ['charAt', 'charCodeAt', 'concat', 'indexOf', 'lastIndexOf', 'match', 'replace', 'search', 'slice', 'split', 'substr', 'substring', 'toLowerCase', 'toUpperCase', 'valueOf']);

function $chk(obj){
	return !!(obj || obj === 0);
};

function $clear(timer){
	clearTimeout(timer);
	clearInterval(timer);
	return null;
};

function $defined(obj){
	return (obj != undefined);
};

function $empty(){};

function $arguments(i){
	return function(){
		return arguments[i];
	};
};

function $lambda(value){
	return (typeof value == 'function') ? value : function(){
		return value;
	};
};

function $extend(original, extended){
	for (var key in (extended || {})) original[key] = extended[key];
	return original;
};

function $unlink(object){
	var unlinked = null;
	
	switch ($type(object)){
		case 'object':
			unlinked = {};
			for (var p in object) unlinked[p] = $unlink(object[p]);
		break;
		case 'hash':
			unlinked = $unlink(object.getClean());
		break;
		case 'array':
			unlinked = [];
			for (var i = 0, l = object.length; i  l; i++) unlinked[i] = $unlink(object[i]);
		break;
		default: return object;
	}
	
	return unlinked;
};

function $merge(){
	var mix = {};
	for (var i = 0, l = arguments.length; i  l; i++){
		var object = arguments[i];
		if ($type(object) != 'object') continue;
		for (var key in object){
			var op = object[key], mp = mix[key];
			mix[key] = (mp && $type(op) == 'object' && $type(mp) == 'object') ? $merge(mp, op) : $unlink(op);
		}
	}
	return mix;
};

function $pick(){
	for (var i = 0, l = arguments.length; i  l; i++){
		if (arguments[i] != undefined) return arguments[i];
	}
	return null;
};

function $random(min, max){
	return Math.floor(Math.random() * (max - min + 1) + min);
};

function $splat(obj){
	var type = $type(obj);
	return (type) ? ((type != 'array' && type != 'arguments') ? [obj] : obj) : [];
};

var $time = Date.now || function(){
	return new Date().getTime();
};

function $try(){
	for (var i = 0, l = arguments.length; i  l; i++){
		try {
			return arguments[i]();
		} catch(e){}
	}
	return null;
};

function $type(obj){
	if (obj == undefined) return false;
	if (obj.$family) return (obj.$family.name == 'number' && !isFinite(obj)) ? false : obj.$family.name;
	if (obj.nodeName){
		switch (obj.nodeType){
			case 1: return 'element';
			case 3: return (/\S/).test(obj.nodeValue) ? 'textnode' : 'whitespace';
		}
	} else if (typeof obj.length == 'number'){
		if (obj.callee) return 'arguments';
		else if (obj.item) return 'collection';
	}
	return typeof obj;
};

var Hash = new Native({

	name: 'Hash',

	initialize: function(object){
		if ($type(object) == 'hash') object = $unlink(object.getClean());
		for (var key in object) this[key] = object[key];
		return this;
	}

});

Hash.implement({
	
	getLength: function(){
		var length = 0;
		for (var key in this){
			if (this.hasOwnProperty(key)) length++;
		}
		return length;
	},

	forEach: function(fn, bind){
		for (var key in this){
			if (this.hasOwnProperty(key)) fn.call(bind, this[key], key, this);
		}
	},
	
	getClean: function(){
		var clean = {};
		for (var key in this){
			if (this.hasOwnProperty(key)) clean[key] = this[key];
		}
		return clean;
	}

});

Hash.alias('forEach', 'each');

function $H(object){
	return new Hash(object);
};

Array.implement({

	forEach: function(fn, bind){
		for (var i = 0, l = this.length; i  l; i++) fn.call(bind, this[i], i, this);
	}

});

Array.alias('forEach', 'each');

function $A(iterable){
	if (iterable.item){
		var array = [];
		for (var i = 0, l = iterable.length; i  l; i++) array[i] = iterable[i];
		return array;
	}
	return Array.prototype.slice.call(iterable);
};

function $each(iterable, fn, bind){
	var type = $type(iterable);
	((type == 'arguments' || type == 'collection' || type == 'array') ? Array : Hash).each(iterable, fn, bind);
};


/*
Script: Browser.js
	The Browser Core. Contains Browser initialization, Window and Document, and the Browser Hash.

License:
	MIT-style license.
*/

var Browser = new Hash({
	Engine: {name: 'unknown', version: ''},
	Platform: {name: (navigator.platform.match(/mac|win|linux/i) || ['other'])[0].toLowerCase()},
	Features: {xpath: !!(document.evaluate), air: !!(window.runtime)},
	Plugins: {}
});

if (window.opera) Browser.Engine = {name: 'presto', version: (document.getElementsByClassName) ? 950 : 925};
else if (window.ActiveXObject) Browser.Engine = {name: 'trident', version: (window.XMLHttpRequest) ? 5 : 4};
else if (!navigator.taintEnabled) Browser.Engine = {name: 'webkit', version: (Browser.Features.xpath) ? 420 : 419};
else if (document.getBoxObjectFor != null) Browser.Engine = {name: 'gecko', version: (document.getElementsByClassName) ? 19 : 18};
Browser.Engine[Browser.Engine.name] = Browser.Engine[Browser.Engine.name + Browser.Engine.version] = true;

if (window.orientation != undefined) Browser.Platform.name = 'ipod';

Browser.Platform[Browser.Platform.name] = true;

Browser.Request = function(){
	return $try(function(){
		return new XMLHttpRequest();
	}, function(){
		return new ActiveXObject('MSXML2.XMLHTTP');
	});
};

Browser.Features.xhr = !!(Browser.Request());

Browser.Plugins.Flash = (function(){
	var version = ($try(function(){
		return navigator.plugins['Shockwave Flash'].description;
	}, function(){
		return new ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version');
	}) || '0 r0').match(/\d+/g);
	return {version: parseInt(version[0] || 0 + '.' + version[1] || 0), build: parseInt(version[2] || 0)};
})();

function $exec(text){
	if (!text) return text;
	if (window.execScript){
		window.execScript(text);
	} else {
		var script = document.createElement('script');
		script.setAttribute('type', 'text/javascript');
		script.text = text;
		document.head.appendChild(script);
		document.head.removeChild(script);
	}
	return text;
};

Native.UID = 1;

var $uid = (Browser.Engine.trident) ? function(item){
	return (item.uid || (item.uid = [Native.UID++]))[0];
} : function(item){
	return item.uid || (item.uid = Native.UID++);
};

var Window = new Native({

	name: 'Window',

	legacy: (Browser.Engine.trident) ? null: window.Window,

	initialize: function(win){
		$uid(win);
		if (!win.Element){
			win.Element = $empty;
			if (Browser.Engine.webkit) win.document.createElement("iframe"); //fixes safari 2
			win.Element.prototype = (Browser.Engine.webkit) ? window["[[DOMElement.prototype]]"] : {};
		}
		return $extend(win, Window.Prototype);
	},

	afterImplement: function(property, value){
		window[property] = Window.Prototype[property] = value;
	}

});

Window.Prototype = {$family: {name: 'window'}};

new Window(window);

var Document = new Native({

	name: 'Document',

	legacy: (Browser.Engine.trident) ? null: window.Document,

	initialize: function(doc){
		$uid(doc);
		doc.head = doc.getElementsByTagName('head')[0];
		doc.html = doc.getElementsByTagName('html')[0];
		doc.window = doc.defaultView || doc.parentWindow;
		if (Browser.Engine.trident4) $try(function(){
			doc.execCommand("BackgroundImageCache", false, true);
		});
		return $extend(doc, Document.Prototype);
	},

	afterImplement: function(property, value){
		document[property] = Document.Prototype[property] = value;
	}

});

Document.Prototype = {$family: {name: 'document'}};

new Document(document);

/*
Script: Array.js
	Contains Array Prototypes like copy, each, contains, and remove.

License:
	MIT-style license.
*/

Array.implement({

	every: function(fn, bind){
		for (var i = 0, l = this.length; i  l; i++){
			if (!fn.call(bind, this[i], i, this)) return false;
		}
		return true;
	},

	filter: function(fn, bind){
		var results = [];
		for (var i = 0, l = this.length; i  l; i++){
			if (fn.call(bind, this[i], i, this)) results.push(this[i]);
		}
		return results;
	},
	
	clean: function() {
		return this.filter($defined);
	},

	indexOf: function(item, from){
		var len = this.length;
		for (var i = (from  0) ? Math.max(0, len + from) : from || 0; i  len; i++){
			if (this[i] === item) return i;
		}
		return -1;
	},

	map: function(fn, bind){
		var results = [];
		for (var i = 0, l = this.length; i  l; i++) results[i] = fn.call(bind, this[i], i, this);
		return results;
	},

	some: function(fn, bind){
		for (var i = 0, l = this.length; i  l; i++){
			if (fn.call(bind, this[i], i, this)) return true;
		}
		return false;
	},

	associate: function(keys){
		var obj = {}, length = Math.min(this.length, keys.length);
		for (var i = 0; i  length; i++) obj[keys[i]] = this[i];
		return obj;
	},

	link: function(object){
		var result = {};
		for (var i = 0, l = this.length; i  l; i++){
			for (var key in object){
				if (object[key](this[i])){
					result[key] = this[i];
					delete object[key];
					break;
				}
			}
		}
		return result;
	},

	contains: function(item, from){
		return this.indexOf(item, from) != -1;
	},

	extend: function(array){
		for (var i = 0, j = array.length; i  j; i++) this.push(array[i]);
		return this;
	},

	getLast: function(){
		return (this.length) ? this[this.length - 1] : null;
	},

	getRandom: function(){
		return (this.length) ? this[$random(0, this.length - 1)] : null;
	},

	include: function(item){
		if (!this.contains(item)) this.push(item);
		return this;
	},

	combine: function(array){
		for (var i = 0, l = array.length; i  l; i++) this.include(array[i]);
		return this;
	},

	erase: function(item){
		for (var i = this.length; i--; i){
			if (this[i] === item) this.splice(i, 1);
		}
		return this;
	},

	empty: function(){
		this.length = 0;
		return this;
	},

	flatten: function(){
		var array = [];
		for (var i = 0, l = this.length; i  l; i++){
			var type = $type(this[i]);
			if (!type) continue;
			array = array.concat((type == 'array' || type == 'collection' || type == 'arguments') ? Array.flatten(this[i]) : this[i]);
		}
		return array;
	},

	hexToRgb: function(array){
		if (this.length != 3) return null;
		var rgb = this.map(function(value){
			if (value.length == 1) value += value;
			return value.toInt(16);
		});
		return (array) ? rgb : 'rgb(' + rgb + ')';
	},

	rgbToHex: function(array){
		if (this.length  3) return null;
		if (this.length == 4 && this[3] == 0 && !array) return 'transparent';
		var hex = [];
		for (var i = 0; i  3; i++){
			var bit = (this[i] - 0).toString(16);
			hex.push((bit.length == 1) ? '0' + bit : bit);
		}
		return (array) ? hex : '#' + hex.join('');
	}

});

/*
Script: Function.js
	Contains Function Prototypes like create, bind, pass, and delay.

License:
	MIT-style license.
*/

Function.implement({

	extend: function(properties){
		for (var property in properties) this[property] = properties[property];
		return this;
	},

	create: function(options){
		var self = this;
		options = options || {};
		return function(event){
			var args = options.arguments;
			args = (args != undefined) ? $splat(args) : Array.slice(arguments, (options.event) ? 1 : 0);
			if (options.event) args = [event || window.event].extend(args);
			var returns = function(){
				return self.apply(options.bind || null, args);
			};
			if (options.delay) return setTimeout(returns, options.delay);
			if (options.periodical) return setInterval(returns, options.periodical);
			if (options.attempt) return $try(returns);
			return returns();
		};
	},

	pass: function(args, bind){
		return this.create({arguments: args, bind: bind});
	},

	attempt: function(args, bind){
		return this.create({arguments: args, bind: bind, attempt: true})();
	},

	bind: function(bind, args){
		return this.create({bind: bind, arguments: args});
	},

	bindWithEvent: function(bind, args){
		return this.create({bind: bind, event: true, arguments: args});
	},

	delay: function(delay, bind, args){
		return this.create({delay: delay, bind: bind, arguments: args})();
	},

	periodical: function(interval, bind, args){
		return this.create({periodical: interval, bind: bind, arguments: args})();
	},

	run: function(args, bind){
		return this.apply(bind, $splat(args));
	}

});

/*
Script: Number.js
	Contains Number Prototypes like limit, round, times, and ceil.

License:
	MIT-style license.
*/

Number.implement({

	limit: function(min, max){
		return Math.min(max, Math.max(min, this));
	},

	round: function(precision){
		precision = Math.pow(10, precision || 0);
		return Math.round(this * precision) / precision;
	},

	times: function(fn, bind){
		for (var i = 0; i  this; i++) fn.call(bind, i, this);
	},

	toFloat: function(){
		return parseFloat(this);
	},

	toInt: function(base){
		return parseInt(this, base || 10);
	}

});

Number.alias('times', 'each');

(function(math){
	var methods = {};
	math.each(function(name){
		if (!Number[name]) methods[name] = function(){
			return Math[name].apply(null, [this].concat($A(arguments)));
		};
	});
	Number.implement(methods);
})(['abs', 'acos', 'asin', 'atan', 'atan2', 'ceil', 'cos', 'exp', 'floor', 'log', 'max', 'min', 'pow', 'sin', 'sqrt', 'tan']);

/*
Script: String.js
	Contains String Prototypes like camelCase, capitalize, test, and toInt.

License:
	MIT-style license.
*/

String.implement({

	test: function(regex, params){
		return ((typeof regex == 'string') ? new RegExp(regex, params) : regex).test(this);
	},

	contains: function(string, separator){
		return (separator) ? (separator + this + separator).indexOf(separator + string + separator)  -1 : this.indexOf(string)  -1;
	},

	trim: function(){
		return this.replace(/^\s+|\s+$/g, '');
	},

	clean: function(){
		return this.replace(/\s+/g, ' ').trim();
	},

	camelCase: function(){
		return this.replace(/-\D/g, function(match){
			return match.charAt(1).toUpperCase();
		});
	},

	hyphenate: function(){
		return this.replace(/[A-Z]/g, function(match){
			return ('-' + match.charAt(0).toLowerCase());
		});
	},

	capitalize: function(){
		return this.replace(/\b[a-z]/g, function(match){
			return match.toUpperCase();
		});
	},

	escapeRegExp: function(){
		return this.replace(/([-.*+?^${}()|[\]\/\\])/g, '\\$1');
	},

	toInt: function(base){
		return parseInt(this, base || 10);
	},

	toFloat: function(){
		return parseFloat(this);
	},

	hexToRgb: function(array){
		var hex = this.match(/^#?(\w{1,2})(\w{1,2})(\w{1,2})$/);
		return (hex) ? hex.slice(1).hexToRgb(array) : null;
	},

	rgbToHex: function(array){
		var rgb = this.match(/\d{1,3}/g);
		return (rgb) ? rgb.rgbToHex(array) : null;
	},

	stripScripts: function(option){
		var scripts = '';
		var text = this.replace(/script[^]*([\s\S]*?)\/script/gi, function(){
			scripts += arguments[1] + '\n';
			return '';
		});
		if (option === true) $exec(scripts);
		else if ($type(option) == 'function') option(scripts, text);
		return text;
	},

	substitute: function(object, regexp){
		return this.replace(regexp || (/\\?\{([^}]+)\}/g), function(match, name){
			if (match.charAt(0) == '\\') return match.slice(1);
			return (object[name] != undefined) ? object[name] : '';
		});
	}

});

/*
Script: Hash.js
	Contains Hash Prototypes. Provides a means for overcoming the JavaScript practical impossibility of extending native Objects.

License:
	MIT-style license.
*/

Hash.implement({

	has: Object.prototype.hasOwnProperty,

	keyOf: function(value){
		for (var key in this){
			if (this.hasOwnProperty(key) && this[key] === value) return key;
		}
		return null;
	},

	hasValue: function(value){
		return (Hash.keyOf(this, value) !== null);
	},

	extend: function(properties){
		Hash.each(properties, function(value, key){
			Hash.set(this, key, value);
		}, this);
		return this;
	},

	combine: function(properties){
		Hash.each(properties, function(value, key){
			Hash.include(this, key, value);
		}, this);
		return this;
	},

	erase: function(key){
		if (this.hasOwnProperty(key)) delete this[key];
		return this;
	},

	get: function(key){
		return (this.hasOwnProperty(key)) ? this[key] : null;
	},

	set: function(key, value){
		if (!this[key] || this.hasOwnProperty(key)) this[key] = value;
		return this;
	},

	empty: function(){
		Hash.each(this, function(value, key){
			delete this[key];
		}, this);
		return this;
	},

	include: function(key, value){
		var k = this[key];
		if (k == undefined) this[key] = value;
		return this;
	},

	map: function(fn, bind){
		var results = new Hash;
		Hash.each(this, function(value, key){
			results.set(key, fn.call(bind, value, key, this));
		}, this);
		return results;
	},

	filter: function(fn, bind){
		var results = new Hash;
		Hash.each(this, function(value, key){
			if (fn.call(bind, value, key, this)) results.set(key, value);
		}, this);
		return results;
	},

	every: function(fn, bind){
		for (var key in this){
			if (this.hasOwnProperty(key) && !fn.call(bind, this[key], key)) return false;
		}
		return true;
	},

	some: function(fn, bind){
		for (var key in this){
			if (this.hasOwnProperty(key) && fn.call(bind, this[key], key)) return true;
		}
		return false;
	},

	getKeys: function(){
		var keys = [];
		Hash.each(this, function(value, key){
			keys.push(key);
		});
		return keys;
	},

	getValues: function(){
		var values = [];
		Hash.each(this, function(value){
			values.push(value);
		});
		return values;
	},
	
	toQueryString: function(base){
		var queryString = [];
		Hash.each(this, function(value, key){
			if (base) key = base + '[' + key + ']';
			var result;
			switch ($type(value)){
				case 'object': result = Hash.toQueryString(value, key); break;
				case 'array':
					var qs = {};
					value.each(function(val, i){
						qs[i] = val;
					});
					result = Hash.toQueryString(qs, key);
				break;
				default: result = key + '=' + encodeURIComponent(value);
			}
			if (value != undefined) queryString.push(result);
		});
		
		return queryString.join('&');
	}

});

Hash.alias({keyOf: 'indexOf', hasValue: 'contains'});

/*
Script: Event.js
	Contains the Event Native, to make the event object completely crossbrowser.

License:
	MIT-style license.
*/

var Event = new Native({

	name: 'Event',

	initialize: function(event, win){
		win = win || window;
		var doc = win.document;
		event = event || win.event;
		if (event.$extended) return event;
		this.$extended = true;
		var type = event.type;
		var target = event.target || event.srcElement;
		while (target && target.nodeType == 3) target = target.parentNode;
		
		if (type.test(/key/)){
			var code = event.which || event.keyCode;
			var key = Event.Keys.keyOf(code);
			if (type == 'keydown'){
				var fKey = code - 111;
				if (fKey  0 && fKey  13) key = 'f' + fKey;
			}
			key = key || String.fromCharCode(code).toLowerCase();
		} else if (type.match(/(click|mouse|menu)/i)){
			doc = (!doc.compatMode || doc.compatMode == 'CSS1Compat') ? doc.html : doc.body;
			var page = {
				x: event.pageX || event.clientX + doc.scrollLeft,
				y: event.pageY || event.clientY + doc.scrollTop
			};
			var client = {
				x: (event.pageX) ? event.pageX - win.pageXOffset : event.clientX,
				y: (event.pageY) ? event.pageY - win.pageYOffset : event.clientY
			};
			if (type.match(/DOMMouseScroll|mousewheel/)){
				var wheel = (event.wheelDelta) ? event.wheelDelta / 120 : -(event.detail || 0) / 3;
			}
			var rightClick = (event.which == 3) || (event.button == 2);
			var related = null;
			if (type.match(/over|out/)){
				switch (type){
					case 'mouseover': related = event.relatedTarget || event.fromElement; break;
					case 'mouseout': related = event.relatedTarget || event.toElement;
				}
				if (!(function(){
					while (related && related.nodeType == 3) related = related.parentNode;
					return true;
				}).create({attempt: Browser.Engine.gecko})()) related = false;
			}
		}

		return $extend(this, {
			event: event,
			type: type,
			
			page: page,
			client: client,
			rightClick: rightClick,
			
			wheel: wheel,
			
			relatedTarget: related,
			target: target,
			
			code: code,
			key: key,
			
			shift: event.shiftKey,
			control: event.ctrlKey,
			alt: event.altKey,
			meta: event.metaKey
		});
	}

});

Event.Keys = new Hash({
	'enter': 13,
	'up': 38,
	'down': 40,
	'left': 37,
	'right': 39,
	'esc': 27,
	'space': 32,
	'backspace': 8,
	'tab': 9,
	'delete': 46
});

Event.implement({

	stop: function(){
		return this.stopPropagation().preventDefault();
	},

	stopPropagation: function(){
		if (this.event.stopPropagation) this.event.stopPropagation();
		else this.event.cancelBubble = true;
		return this;
	},

	preventDefault: function(){
		if (this.event.preventDefault) this.event.preventDefault();
		else this.event.returnValue = false;
		return this;
	}

});

/*
Script: Class.js
	Contains the Class Function for easily creating, extending, and implementing reusable Classes.

License:
	MIT-style license.
*/

var Class = new Native({

	name: 'Class',

	initialize: function(properties){

		properties = properties || {};

		var klass = function(empty){
						
			for (var key in this) this[key] = $unlink(this[key]);

			for (var mutator in Class.Mutators){
				if (!this[mutator]) continue;
				Class.Mutators[mutator](this, this[mutator]);
				delete this[mutator];
			}

			this.constructor = klass;
			
			if (empty === $empty) return this;
			
			var self = (this.initialize) ? this.initialize.apply(this, arguments) : this;
			if (this.options && this.options.initialize) this.options.initialize.call(this);

			return self;
		};

		$extend(klass, this);
		klass.constructor = Class;
		klass.prototype = properties;
		return klass;
	}

});

Class.implement({

	implement: function(){
		Class.Mutators.Implements(this.prototype, Array.slice(arguments));
		return this;
	}

});

Class.Mutators = {};

Class.Mutators.Implements = function(self, klasses){
	$splat(klasses).each(function(klass){
		$extend(self, ($type(klass) == 'class') ? new klass($empty) : klass);
	});
};

Class.Mutators.Extends = function(self, klass){
	
	var instance = new klass($empty);
	
	delete instance.parent;
	delete instance.parentOf;
	
	for (var key in instance){

		var current = self[key], previous = instance[key];
		
		if (current == undefined){
			self[key] = previous;
			continue;
		}

		var ctype = $type(current), ptype = $type(previous);
		
		if (ctype != ptype) continue;
		
		switch (ctype){
			case 'function': 
			
				// opera does not support function.caller, so we replace the function code with brute force. Not pretty, but its just for opera.
				// if future opera versions will support function.caller, this code wont be executed anymore.
				// this code will be only executed if the current browser does not support function.caller (only opera).
				// there is also a fix for an opera bug where in the function string, parentheses around numbers are ignored, and an error is thrown.
				
				if (!arguments.callee.caller) self[key] = eval('(' + String(current).replace(/\bthis\.parent\(\s*(\))?/g, function(full, close){
					return 'arguments.callee._parent_.call(this' + (close || ', ');
				}).replace(/(\d+)\.([A-Za-z_])/g, '($1).$2') + ')');
				
				// end "opera" code
			
				self[key]._parent_ = previous;
			break;
			case 'object': self[key] = $merge(previous, current);
		}
		
	}
	
	self.parent = function(){
		return arguments.callee.caller._parent_.apply(this, arguments);
	};
	
	self.parentOf = function(descendant){
		return descendant._parent_.apply(this, Array.slice(arguments, 1));
	};

};

/*
Script: Class.Extras.js
	Contains Utility Classes that can be implemented into your own Classes to ease the execution of many common tasks.

License:
	MIT-style license.
*/

var Chain = new Class({

	chain: function(){
		this.$chain = (this.$chain || []).extend(arguments);
		return this;
	},

	callChain: function(){
		return (this.$chain && this.$chain.length) ? this.$chain.shift().apply(this, arguments) : false;
	},

	clearChain: function(){
		if (this.$chain) this.$chain.empty();
		return this;
	}

});

var Events = new Class({

	addEvent: function(type, fn, internal){
		if (fn != $empty){
			this.$events = this.$events || {};
			this.$events[type] = this.$events[type] || [];
			this.$events[type].include(fn);
			if (internal) fn.internal = true;
		}
		return this;
	},

	addEvents: function(events){
		for (var type in events) this.addEvent(type, events[type]);
		return this;
	},

	fireEvent: function(type, args, delay){
		if (!this.$events || !this.$events[type]) return this;
		this.$events[type].each(function(fn){
			fn.create({'bind': this, 'delay': delay, 'arguments': args})();
		}, this);
		return this;
	},

	removeEvent: function(type, fn){
		if (!this.$events || !this.$events[type]) return this;
		if (!fn.internal) this.$events[type].erase(fn);
		return this;
	},

	removeEvents: function(type){
		for (var e in this.$events){
			if (type && type != e) continue;
			var fns = this.$events[e];
			for (var i = fns.length; i--; i) this.removeEvent(e, fns[i]);
		}
		return this;
	}

});

var Options = new Class({

	setOptions: function(){
		this.options = $merge.run([this.options].extend(arguments));
		if (!this.addEvent) return this;
		for (var option in this.options){
			if ($type(this.options[option]) != 'function' || !(/^on[A-Z]/).test(option)) continue;
			this.addEvent(option, this.options[option]);
			delete this.options[option];
		}
		return this;
	}

});

/*
Script: Element.js
	One of the most important items in MooTools. Contains the dollar function, the dollars function, and an handful of cross-browser,
	time-saver methods to let you easily work with HTML Elements.

License:
	MIT-style license.
*/

Document.implement({

	newElement: function(tag, props){
		if (Browser.Engine.trident && props){
			['name', 'type', 'checked'].each(function(attribute){
				if (!props[attribute]) return;
				tag += ' ' + attribute + '="' + props[attribute] + '"';
				if (attribute != 'checked') delete props[attribute];
			});
			tag = '' + tag + '';
		}
		return $.element(this.createElement(tag)).set(props);
	},

	newTextNode: function(text){
		return this.createTextNode(text);
	},

	getDocument: function(){
		return this;
	},

	getWindow: function(){
		return this.defaultView || this.parentWindow;
	},

	purge: function(){
		var elements = this.getElementsByTagName('*');
		for (var i = 0, l = elements.length; i  l; i++) Browser.freeMem(elements[i]);
	}

});

var Element = new Native({

	name: 'Element',

	legacy: window.Element,

	initialize: function(tag, props){
		var konstructor = Element.Constructors.get(tag);
		if (konstructor) return konstructor(props);
		if (typeof tag == 'string') return document.newElement(tag, props);
		return $(tag).set(props);
	},

	afterImplement: function(key, value){
		if (!Array[key]) Elements.implement(key, Elements.multi(key));
		Element.Prototype[key] = value;
	}

});

Element.Prototype = {$family: {name: 'element'}};

Element.Constructors = new Hash;

var IFrame = new Native({

	name: 'IFrame',

	generics: false,

	initialize: function(){
		var params = Array.link(arguments, {properties: Object.type, iframe: $defined});
		var props = params.properties || {};
		var iframe = $(params.iframe) || false;
		var onload = props.onload || $empty;
		delete props.onload;
		props.id = props.name = $pick(props.id, props.name, iframe.id, iframe.name, 'IFrame_' + $time());
		iframe = new Element(iframe || 'iframe', props);
		var onFrameLoad = function(){
			var host = $try(function(){
				return iframe.contentWindow.location.host;
			});
			if (host && host == window.location.host){
				var win = new Window(iframe.contentWindow);
				var doc = new Document(iframe.contentWindow.document);
				$extend(win.Element.prototype, Element.Prototype);
			}
			onload.call(iframe.contentWindow, iframe.contentWindow.document);
		};
		(!window.frames[props.id]) ? iframe.addListener('load', onFrameLoad) : onFrameLoad();
		return iframe;
	}

});

var Elements = new Native({

	initialize: function(elements, options){
		options = $extend({ddup: true, cash: true}, options);
		elements = elements || [];
		if (options.ddup || options.cash){
			var uniques = {}, returned = [];
			for (var i = 0, l = elements.length; i  l; i++){
				var el = $.element(elements[i], !options.cash);
				if (options.ddup){
					if (uniques[el.uid]) continue;
					uniques[el.uid] = true;
				}
				returned.push(el);
			}
			elements = returned;
		}
		return (options.cash) ? $extend(elements, this) : elements;
	}

});

Elements.implement({

	filter: function(filter, bind){
		if (!filter) return this;
		return new Elements(Array.filter(this, (typeof filter == 'string') ? function(item){
			return item.match(filter);
		} : filter, bind));
	}

});

Elements.multi = function(property){
	return function(){
		var items = [];
		var elements = true;
		for (var i = 0, j = this.length; i  j; i++){
			var returns = this[i][property].apply(this[i], arguments);
			items.push(returns);
			if (elements) elements = ($type(returns) == 'element');
		}
		return (elements) ? new Elements(items) : items;
	};
};

Window.implement({

	$: function(el, nocash){
		if (el && el.$family && el.uid) return el;
		var type = $type(el);
		return ($[type]) ? $[type](el, nocash, this.document) : null;
	},

	$$: function(selector){
		if (arguments.length == 1 && typeof selector == 'string') return this.document.getElements(selector);
		var elements = [];
		var args = Array.flatten(arguments);
		for (var i = 0, l = args.length; i  l; i++){
			var item = args[i];
			switch ($type(item)){
				case 'element': item = [item]; break;
				case 'string': item = this.document.getElements(item, true); break;
				default: item = false;
			}
			if (item) elements.extend(item);
		}
		return new Elements(elements);
	},

	getDocument: function(){
		return this.document;
	},

	getWindow: function(){
		return this;
	}

});

$.string = function(id, nocash, doc){
	id = doc.getElementById(id);
	return (id) ? $.element(id, nocash) : null;
};

$.element = function(el, nocash){
	$uid(el);
	if (!nocash && !el.$family && !(/^object|embed$/i).test(el.tagName)){
		var proto = Element.Prototype;
		for (var p in proto) el[p] = proto[p];
	};
	return el;
};

$.object = function(obj, nocash, doc){
	if (obj.toElement) return $.element(obj.toElement(doc), nocash);
	return null;
};

$.textnode = $.whitespace = $.window = $.document = $arguments(0);

Native.implement([Element, Document], {

	getElement: function(selector, nocash){
		return $(this.getElements(selector, true)[0] || null, nocash);
	},

	getElements: function(tags, nocash){
		tags = tags.split(',');
		var elements = [];
		var ddup = (tags.length  1);
		tags.each(function(tag){
			var partial = this.getElementsByTagName(tag.trim());
			(ddup) ? elements.extend(partial) : elements = partial;
		}, this);
		return new Elements(elements, {ddup: ddup, cash: !nocash});
	}

});

Element.Storage = {

	get: function(uid){
		return (this[uid] || (this[uid] = {}));
	}

};

Element.Inserters = new Hash({

	before: function(context, element){
		if (element.parentNode) element.parentNode.insertBefore(context, element);
	},

	after: function(context, element){
		if (!element.parentNode) return;
		var next = element.nextSibling;
		(next) ? element.parentNode.insertBefore(context, next) : element.parentNode.appendChild(context);
	},

	bottom: function(context, element){
		element.appendChild(context);
	},

	top: function(context, element){
		var first = element.firstChild;
		(first) ? element.insertBefore(context, first) : element.appendChild(context);
	}

});

Element.Inserters.inside = Element.Inserters.bottom;

Element.Inserters.each(function(value, key){

	var Key = key.capitalize();

	Element.implement('inject' + Key, function(el){
		value(this, $(el, true));
		return this;
	});

	Element.implement('grab' + Key, function(el){
		value($(el, true), this);
		return this;
	});

});

Element.implement({

	getDocument: function(){
		return this.ownerDocument;
	},

	getWindow: function(){
		return this.ownerDocument.getWindow();
	},

	getElementById: function(id, nocash){
		var el = this.ownerDocument.getElementById(id);
		if (!el) return null;
		for (var parent = el.parentNode; parent != this; parent = parent.parentNode){
			if (!parent) return null;
		}
		return $.element(el, nocash);
	},

	set: function(prop, value){
		switch ($type(prop)){
			case 'object':
				for (var p in prop) this.set(p, prop[p]);
				break;
			case 'string':
				var property = Element.Properties.get(prop);
				(property && property.set) ? property.set.apply(this, Array.slice(arguments, 1)) : this.setProperty(prop, value);
		}
		return this;
	},

	get: function(prop){
		var property = Element.Properties.get(prop);
		return (property && property.get) ? property.get.apply(this, Array.slice(arguments, 1)) : this.getProperty(prop);
	},

	erase: function(prop){
		var property = Element.Properties.get(prop);
		(property && property.erase) ? property.erase.apply(this, Array.slice(arguments, 1)) : this.removeProperty(prop);
		return this;
	},

	match: function(tag){
		return (!tag || Element.get(this, 'tag') == tag);
	},

	inject: function(el, where){
		Element.Inserters.get(where || 'bottom')(this, $(el, true));
		return this;
	},

	wraps: function(el, where){
		el = $(el, true);
		return this.replaces(el).grab(el, where);
	},

	grab: function(el, where){
		Element.Inserters.get(where || 'bottom')($(el, true), this);
		return this;
	},

	appendText: function(text, where){
		return this.grab(this.getDocument().newTextNode(text), where);
	},

	adopt: function(){
		Array.flatten(arguments).each(function(element){
			element = $(element, true);
			if (element) this.appendChild(element);
		}, this);
		return this;
	},

	dispose: function(){
		return (this.parentNode) ? this.parentNode.removeChild(this) : this;
	},

	clone: function(contents, keepid){
		switch ($type(this)){
			case 'element':
				var attributes = {};
				for (var j = 0, l = this.attributes.length; j  l; j++){
					var attribute = this.attributes[j], key = attribute.nodeName.toLowerCase();
					var value = (key == 'style' && this.style) ? this.style.cssText : attribute.nodeValue;
					if (!$chk(value) || key == 'uid' || (key == 'id' && !keepid)) continue;
					if (value != 'inherit' && ['string', 'number'].contains($type(value))) attributes[key] = value;
				}
				var element = new Element(this.nodeName.toLowerCase(), attributes);
				if (contents !== false){
					for (var i = 0, k = this.childNodes.length; i  k; i++){
						var child = Element.clone(this.childNodes[i], true, keepid);
						if (child) element.grab(child);
					}
				}
				return element;
			case 'textnode': return document.newTextNode(this.nodeValue);
		}
		return null;
	},

	replaces: function(el){
		el = $(el, true);
		el.parentNode.replaceChild(this, el);
		return this;
	},

	hasClass: function(className){
		return this.className.contains(className, ' ');
	},

	addClass: function(className){
		if (!this.hasClass(className)) this.className = (this.className + ' ' + className).clean();
		return this;
	},

	removeClass: function(className){
		this.className = this.className.replace(new RegExp('(^|\\s)' + className + '(?:\\s|$)'), '$1').clean();
		return this;
	},

	toggleClass: function(className){
		return this.hasClass(className) ? this.removeClass(className) : this.addClass(className);
	},

	getComputedStyle: function(property){
		if (this.currentStyle) return this.currentStyle[property.camelCase()];
		var computed = this.getWindow().getComputedStyle(this, null);
		return (computed) ? computed.getPropertyValue([property.hyphenate()]) : null;
	},

	empty: function(){
		$A(this.childNodes).each(function(node){
			Browser.freeMem(node);
			Element.empty(node);
			Element.dispose(node);
		}, this);
		return this;
	},

	destroy: function(){
		Browser.freeMem(this.empty().dispose());
		return null;
	},

	getSelected: function(){
		return new Elements($A(this.options).filter(function(option){
			return option.selected;
		}));
	},

	toQueryString: function(){
		var queryString = [];
		this.getElements('input, select, textarea').each(function(el){
			if (!el.name || el.disabled) return;
			var value = (el.tagName.toLowerCase() == 'select') ? Element.getSelected(el).map(function(opt){
				return opt.value;
			}) : ((el.type == 'radio' || el.type == 'checkbox') && !el.checked) ? null : el.value;
			$splat(value).each(function(val){
				if (val) queryString.push(el.name + '=' + encodeURIComponent(val));
			});
		});
		return queryString.join('&');
	},

	getProperty: function(attribute){
		var EA = Element.Attributes, key = EA.Props[attribute];
		var value = (key) ? this[key] : this.getAttribute(attribute, 2);
		return (EA.Bools[attribute]) ? !!value : (key) ? value : value || null;
	},

	getProperties: function(){
		var args = $A(arguments);
		return args.map(function(attr){
			return this.getProperty(attr);
		}, this).associate(args);
	},

	setProperty: function(attribute, value){
		var EA = Element.Attributes, key = EA.Props[attribute], hasValue = $defined(value);
		if (key && EA.Bools[attribute]) value = (value || !hasValue) ? true : false;
		else if (!hasValue) return this.removeProperty(attribute);
		(key) ? this[key] = value : this.setAttribute(attribute, value);
		return this;
	},

	setProperties: function(attributes){
		for (var attribute in attributes) this.setProperty(attribute, attributes[attribute]);
		return this;
	},

	removeProperty: function(attribute){
		var EA = Element.Attributes, key = EA.Props[attribute], isBool = (key && EA.Bools[attribute]);
		(key) ? this[key] = (isBool) ? false : '' : this.removeAttribute(attribute);
		return this;
	},

	removeProperties: function(){
		Array.each(arguments, this.removeProperty, this);
		return this;
	}

});

(function(){

var walk = function(element, walk, start, match, all, nocash){
	var el = element[start || walk];
	var elements = [];
	while (el){
		if (el.nodeType == 1 && (!match || Element.match(el, match))){
			elements.push(el);
			if (!all) break;
		}
		el = el[walk];
	}
	return (all) ? new Elements(elements, {ddup: false, cash: !nocash}) : $(elements[0], nocash);
};

Element.implement({

	getPrevious: function(match, nocash){
		return walk(this, 'previousSibling', null, match, false, nocash);
	},

	getAllPrevious: function(match, nocash){
		return walk(this, 'previousSibling', null, match, true, nocash);
	},

	getNext: function(match, nocash){
		return walk(this, 'nextSibling', null, match, false, nocash);
	},

	getAllNext: function(match, nocash){
		return walk(this, 'nextSibling', null, match, true, nocash);
	},

	getFirst: function(match, nocash){
		return walk(this, 'nextSibling', 'firstChild', match, false, nocash);
	},

	getLast: function(match, nocash){
		return walk(this, 'previousSibling', 'lastChild', match, false, nocash);
	},

	getParent: function(match, nocash){
		return walk(this, 'parentNode', null, match, false, nocash);
	},

	getParents: function(match, nocash){
		return walk(this, 'parentNode', null, match, true, nocash);
	},

	getChildren: function(match, nocash){
		return walk(this, 'nextSibling', 'firstChild', match, true, nocash);
	},

	hasChild: function(el){
		el = $(el, true);
		return (!!el && $A(this.getElementsByTagName(el.tagName)).contains(el));
	}

});

})();

Element.Properties = new Hash;

Element.Properties.style = {

	set: function(style){
		this.style.cssText = style;
	},

	get: function(){
		return this.style.cssText;
	},

	erase: function(){
		this.style.cssText = '';
	}

};

Element.Properties.tag = {get: function(){
	return this.tagName.toLowerCase();
}};

Element.Properties.href = {get: function(){
	return (!this.href) ? null : this.href.replace(new RegExp('^' + document.location.protocol + '\/\/' + document.location.host), '');
}};

Element.Properties.html = {set: function(){
	return this.innerHTML = Array.flatten(arguments).join('');
}};

Native.implement([Element, Window, Document], {

	addListener: function(type, fn){
		if (this.addEventListener) this.addEventListener(type, fn, false);
		else this.attachEvent('on' + type, fn);
		return this;
	},

	removeListener: function(type, fn){
		if (this.removeEventListener) this.removeEventListener(type, fn, false);
		else this.detachEvent('on' + type, fn);
		return this;
	},

	retrieve: function(property, dflt){
		var storage = Element.Storage.get(this.uid);
		var prop = storage[property];
		if ($defined(dflt) && !$defined(prop)) prop = storage[property] = dflt;
		return $pick(prop);
	},

	store: function(property, value){
		var storage = Element.Storage.get(this.uid);
		storage[property] = value;
		return this;
	},

	eliminate: function(property){
		var storage = Element.Storage.get(this.uid);
		delete storage[property];
		return this;
	}

});

Element.Attributes = new Hash({
	Props: {'html': 'innerHTML', 'class': 'className', 'for': 'htmlFor', 'text': (Browser.Engine.trident) ? 'innerText' : 'textContent'},
	Bools: ['compact', 'nowrap', 'ismap', 'declare', 'noshade', 'checked', 'disabled', 'readonly', 'multiple', 'selected', 'noresize', 'defer'],
	Camels: ['value', 'accessKey', 'cellPadding', 'cellSpacing', 'colSpan', 'frameBorder', 'maxLength', 'readOnly', 'rowSpan', 'tabIndex', 'useMap']
});

Browser.freeMem = function(item){
	if (!item) return;
	if (Browser.Engine.trident && (/object/i).test(item.tagName)){
		for (var p in item){
			if (typeof item[p] == 'function') item[p] = $empty;
		}
		Element.dispose(item);
	}
	if (item.uid && item.removeEvents) item.removeEvents();
};

(function(EA){

	var EAB = EA.Bools, EAC = EA.Camels;
	EA.Bools = EAB = EAB.associate(EAB);
	Hash.extend(Hash.combine(EA.Props, EAB), EAC.associate(EAC.map(function(v){
		return v.toLowerCase();
	})));
	EA.erase('Camels');

})(Element.Attributes);

window.addListener('unload', function(){
	window.removeListener('unload', arguments.callee);
	document.purge();
	if (Browser.Engine.trident) CollectGarbage();
});

/*
Script: Element.Event.js
	Contains Element methods for dealing with events, and custom Events.

License:
	MIT-style license.
*/

Element.Properties.events = {set: function(events){
	this.addEvents(events);
}};

Native.implement([Element, Window, Document], {

	addEvent: function(type, fn){
		var events = this.retrieve('events', {});
		events[type] = events[type] || {'keys': [], 'values': []};
		if (events[type].keys.contains(fn)) return this;
		events[type].keys.push(fn);
		var realType = type, custom = Element.Events.get(type), condition = fn, self = this;
		if (custom){
			if (custom.onAdd) custom.onAdd.call(this, fn);
			if (custom.condition){
				condition = function(event){
					if (custom.condition.call(this, event)) return fn.call(this, event);
					return false;
				};
			}
			realType = custom.base || realType;
		}
		var defn = function(){
			return fn.call(self);
		};
		var nativeEvent = Element.NativeEvents[realType] || 0;
		if (nativeEvent){
			if (nativeEvent == 2){
				defn = function(event){
					event = new Event(event, self.getWindow());
					if (condition.call(self, event) === false) event.stop();
				};
			}
			this.addListener(realType, defn);
		}
		events[type].values.push(defn);
		return this;
	},

	removeEvent: function(type, fn){
		var events = this.retrieve('events');
		if (!events || !events[type]) return this;
		var pos = events[type].keys.indexOf(fn);
		if (pos == -1) return this;
		var key = events[type].keys.splice(pos, 1)[0];
		var value = events[type].values.splice(pos, 1)[0];
		var custom = Element.Events.get(type);
		if (custom){
			if (custom.onRemove) custom.onRemove.call(this, fn);
			type = custom.base || type;
		}
		return (Element.NativeEvents[type]) ? this.removeListener(type, value) : this;
	},

	addEvents: function(events){
		for (var event in events) this.addEvent(event, events[event]);
		return this;
	},

	removeEvents: function(type){
		var events = this.retrieve('events');
		if (!events) return this;
		if (!type){
			for (var evType in events) this.removeEvents(evType);
			events = null;
		} else if (events[type]){
			while (events[type].keys[0]) this.removeEvent(type, events[type].keys[0]);
			events[type] = null;
		}
		return this;
	},

	fireEvent: function(type, args, delay){
		var events = this.retrieve('events');
		if (!events || !events[type]) return this;
		events[type].keys.each(function(fn){
			fn.create({'bind': this, 'delay': delay, 'arguments': args})();
		}, this);
		return this;
	},

	cloneEvents: function(from, type){
		from = $(from);
		var fevents = from.retrieve('events');
		if (!fevents) return this;
		if (!type){
			for (var evType in fevents) this.cloneEvents(from, evType);
		} else if (fevents[type]){
			fevents[type].keys.each(function(fn){
				this.addEvent(type, fn);
			}, this);
		}
		return this;
	}

});

Element.NativeEvents = {
	click: 2, dblclick: 2, mouseup: 2, mousedown: 2, contextmenu: 2, //mouse buttons
	mousewheel: 2, DOMMouseScroll: 2, //mouse wheel
	mouseover: 2, mouseout: 2, mousemove: 2, selectstart: 2, selectend: 2, //mouse movement
	keydown: 2, keypress: 2, keyup: 2, //keyboard
	focus: 2, blur: 2, change: 2, reset: 2, select: 2, submit: 2, //form elements
	load: 1, unload: 1, beforeunload: 2, resize: 1, move: 1, DOMContentLoaded: 1, readystatechange: 1, //window
	error: 1, abort: 1, scroll: 1 //misc
};

(function(){

var $check = function(event){
	var related = event.relatedTarget;
	if (related == undefined) return true;
	if (related === false) return false;
	return ($type(this) != 'document' && related != this && related.prefix != 'xul' && !this.hasChild(related));
};

Element.Events = new Hash({

	mouseenter: {
		base: 'mouseover',
		condition: $check
	},

	mouseleave: {
		base: 'mouseout',
		condition: $check
	},

	mousewheel: {
		base: (Browser.Engine.gecko) ? 'DOMMouseScroll' : 'mousewheel'
	}

});

})();

/* EVERYTHING BELOW HERE COULD BE ELIMINATED IF I DIDNT DO CUSTOM VALIDATION EFFECTS */

/*
Script: Element.Style.js
	Contains methods for interacting with the styles of Elements in a fashionable way.

License:
	MIT-style license.
*/

Element.Properties.styles = {set: function(styles){
	this.setStyles(styles);
}};

Element.Properties.opacity = {

	set: function(opacity, novisibility){
		if (!novisibility){
			if (opacity == 0){
				if (this.style.visibility != 'hidden') this.style.visibility = 'hidden';
			} else {
				if (this.style.visibility != 'visible') this.style.visibility = 'visible';
			}
		}
		if (!this.currentStyle || !this.currentStyle.hasLayout) this.style.zoom = 1;
		if (Browser.Engine.trident) this.style.filter = (opacity == 1) ? '' : 'alpha(opacity=' + opacity * 100 + ')';
		this.style.opacity = opacity;
		this.store('opacity', opacity);
	},

	get: function(){
		return this.retrieve('opacity', 1);
	}

};

Element.implement({
	
	setOpacity: function(value){
		return this.set('opacity', value, true);
	},
	
	getOpacity: function(){
		return this.get('opacity');
	},

	setStyle: function(property, value){
		switch (property){
			case 'opacity': return this.set('opacity', parseFloat(value));
			case 'float': property = (Browser.Engine.trident) ? 'styleFloat' : 'cssFloat';
		}
		property = property.camelCase();
		if ($type(value) != 'string'){
			var map = (Element.Styles.get(property) || '@').split(' ');
			value = $splat(value).map(function(val, i){
				if (!map[i]) return '';
				return ($type(val) == 'number') ? map[i].replace('@', Math.round(val)) : val;
			}).join(' ');
		} else if (value == String(Number(value))){
			value = Math.round(value);
		}
		this.style[property] = value;
		return this;
	},

	getStyle: function(property){
		switch (property){
			case 'opacity': return this.get('opacity');
			case 'float': property = (Browser.Engine.trident) ? 'styleFloat' : 'cssFloat';
		}
		property = property.camelCase();
		var result = this.style[property];
		if (!$chk(result)){
			result = [];
			for (var style in Element.ShortStyles){
				if (property != style) continue;
				for (var s in Element.ShortStyles[style]) result.push(this.getStyle(s));
				return result.join(' ');
			}
			result = this.getComputedStyle(property);
		}
		if (result){
			result = String(result);
			var color = result.match(/rgba?\([\d\s,]+\)/);
			if (color) result = result.replace(color[0], color[0].rgbToHex());
		}
		if (Browser.Engine.presto || (Browser.Engine.trident && !$chk(parseInt(result)))){
			if (property.test(/^(height|width)$/)){
				var values = (property == 'width') ? ['left', 'right'] : ['top', 'bottom'], size = 0;
				values.each(function(value){
					size += this.getStyle('border-' + value + '-width').toInt() + this.getStyle('padding-' + value).toInt();
				}, this);
				return this['offset' + property.capitalize()] - size + 'px';
			}
			if (Browser.Engine.presto && String(result).test('px')) return result;
			if (property.test(/(border(.+)Width|margin|padding)/)) return '0px';
		}
		return result;
	},

	setStyles: function(styles){
		for (var style in styles) this.setStyle(style, styles[style]);
		return this;
	},

	getStyles: function(){
		var result = {};
		Array.each(arguments, function(key){
			result[key] = this.getStyle(key);
		}, this);
		return result;
	}

});

Element.Styles = new Hash({
	left: '@px', top: '@px', bottom: '@px', right: '@px',
	width: '@px', height: '@px', maxWidth: '@px', maxHeight: '@px', minWidth: '@px', minHeight: '@px',
	backgroundColor: 'rgb(@, @, @)', backgroundPosition: '@px @px', color: 'rgb(@, @, @)',
	fontSize: '@px', letterSpacing: '@px', lineHeight: '@px', clip: 'rect(@px @px @px @px)',
	margin: '@px @px @px @px', padding: '@px @px @px @px', border: '@px @ rgb(@, @, @) @px @ rgb(@, @, @) @px @ rgb(@, @, @)',
	borderWidth: '@px @px @px @px', borderStyle: '@ @ @ @', borderColor: 'rgb(@, @, @) rgb(@, @, @) rgb(@, @, @) rgb(@, @, @)',
	zIndex: '@', 'zoom': '@', fontWeight: '@', textIndent: '@px', opacity: '@'
});

Element.ShortStyles = {margin: {}, padding: {}, border: {}, borderWidth: {}, borderStyle: {}, borderColor: {}};

['Top', 'Right', 'Bottom', 'Left'].each(function(direction){
	var Short = Element.ShortStyles;
	var All = Element.Styles;
	['margin', 'padding'].each(function(style){
		var sd = style + direction;
		Short[style][sd] = All[sd] = '@px';
	});
	var bd = 'border' + direction;
	Short.border[bd] = All[bd] = '@px @ rgb(@, @, @)';
	var bdw = bd + 'Width', bds = bd + 'Style', bdc = bd + 'Color';
	Short[bd] = {};
	Short.borderWidth[bdw] = Short[bd][bdw] = All[bdw] = '@px';
	Short.borderStyle[bds] = Short[bd][bds] = All[bds] = '@';
	Short.borderColor[bdc] = Short[bd][bdc] = All[bdc] = 'rgb(@, @, @)';
});


/*
Script: Element.Dimensions.js
	Contains methods to work with size, scroll, or positioning of Elements and the window object.

License:
	MIT-style license.

Credits:
	- Element positioning based on the [qooxdoo](http://qooxdoo.org/) code and smart browser fixes, [LGPL License](http://www.gnu.org/licenses/lgpl.html).
	- Viewport dimensions based on [YUI](http://developer.yahoo.com/yui/) code, [BSD License](http://developer.yahoo.com/yui/license.html).
*/

(function(){

Element.implement({

	scrollTo: function(x, y){
		if (isBody(this)){
			this.getWindow().scrollTo(x, y);
		} else {
			this.scrollLeft = x;
			this.scrollTop = y;
		}
		return this;
	},

	getSize: function(){
		if (isBody(this)) return this.getWindow().getSize();
		return {x: this.offsetWidth, y: this.offsetHeight};
	},

	getScrollSize: function(){
		if (isBody(this)) return this.getWindow().getScrollSize();
		return {x: this.scrollWidth, y: this.scrollHeight};
	},

	getScroll: function(){
		if (isBody(this)) return this.getWindow().getScroll();
		return {x: this.scrollLeft, y: this.scrollTop};
	},

	getScrolls: function(){
		var element = this, position = {x: 0, y: 0};
		while (element && !isBody(element)){
			position.x += element.scrollLeft;
			position.y += element.scrollTop;
			element = element.parentNode;
		}
		return position;
	},

	getOffsets: function(){
		var element = this, position = {x: 0, y: 0};
		if (isBody(this)) return position;

		while (element && !isBody(element)){
			position.x += element.offsetLeft;
			position.y += element.offsetTop;

			if (Browser.Engine.gecko){
				if (!borderBox(element)){
					position.x += leftBorder(element);
					position.y += topBorder(element);
				}
				var parent = element.parentNode;
				if (parent && styleString(parent, 'overflow') != 'visible'){
					position.x += leftBorder(parent);
					position.y += topBorder(parent);
				}
			} else if (element != this && (Browser.Engine.trident || Browser.Engine.webkit)){
				position.x += leftBorder(element);
				position.y += topBorder(element);
			}

			element = element.offsetParent;
			if (Browser.Engine.trident){
				while (element && !element.currentStyle.hasLayout) element = element.offsetParent;
			}
		}
		if (Browser.Engine.gecko && !borderBox(this)){
			position.x -= leftBorder(this);
			position.y -= topBorder(this);
		}
		return position;
	},

	getPosition: function(relative){
		if (isBody(this)) return {x: 0, y: 0};
		var offset = this.getOffsets(), scroll = this.getScrolls();
		var position = {x: offset.x - scroll.x, y: offset.y - scroll.y};
		var relativePosition = (relative && (relative = $(relative))) ? relative.getPosition() : {x: 0, y: 0};
		return {x: position.x - relativePosition.x, y: position.y - relativePosition.y};
	},

	getCoordinates: function(element){
		if (isBody(this)) return this.getWindow().getCoordinates();
		var position = this.getPosition(element), size = this.getSize();
		var obj = {left: position.x, top: position.y, width: size.x, height: size.y};
		obj.right = obj.left + obj.width;
		obj.bottom = obj.top + obj.height;
		return obj;
	},

	computePosition: function(obj){
		return {left: obj.x - styleNumber(this, 'margin-left'), top: obj.y - styleNumber(this, 'margin-top')};
	},

	position: function(obj){
		return this.setStyles(this.computePosition(obj));
	}

});

Native.implement([Document, Window], {

	getSize: function(){
		var win = this.getWindow();
		if (Browser.Engine.presto || Browser.Engine.webkit) return {x: win.innerWidth, y: win.innerHeight};
		var doc = getCompatElement(this);
		return {x: doc.clientWidth, y: doc.clientHeight};
	},

	getScroll: function(){
		var win = this.getWindow();
		var doc = getCompatElement(this);
		return {x: win.pageXOffset || doc.scrollLeft, y: win.pageYOffset || doc.scrollTop};
	},

	getScrollSize: function(){
		var doc = getCompatElement(this);
		var min = this.getSize();
		return {x: Math.max(doc.scrollWidth, min.x), y: Math.max(doc.scrollHeight, min.y)};
	},

	getPosition: function(){
		return {x: 0, y: 0};
	},

	getCoordinates: function(){
		var size = this.getSize();
		return {top: 0, left: 0, bottom: size.y, right: size.x, height: size.y, width: size.x};
	}

});

// private methods

var styleString = Element.getComputedStyle;

function styleNumber(element, style){
	return styleString(element, style).toInt() || 0;
};

function borderBox(element){
	return styleString(element, '-moz-box-sizing') == 'border-box';
};

function topBorder(element){
	return styleNumber(element, 'border-top-width');
};

function leftBorder(element){
	return styleNumber(element, 'border-left-width');
};

function isBody(element){
	return (/^(?:body|html)$/i).test(element.tagName);
};

function getCompatElement(element){
	var doc = element.getDocument();
	return (!doc.compatMode || doc.compatMode == 'CSS1Compat') ? doc.html : doc.body;
};

})();

//aliases

Native.implement([Window, Document, Element], {

	getHeight: function(){
		return this.getSize().y;
	},

	getWidth: function(){
		return this.getSize().x;
	},

	getScrollTop: function(){
		return this.getScroll().y;
	},

	getScrollLeft: function(){
		return this.getScroll().x;
	},

	getScrollHeight: function(){
		return this.getScrollSize().y;
	},

	getScrollWidth: function(){
		return this.getScrollSize().x;
	},

	getTop: function(){
		return this.getPosition().y;
	},

	getLeft: function(){
		return this.getPosition().x;
	}

});

/*
Script: Selectors.js
	Adds advanced CSS Querying capabilities for targeting elements. Also includes pseudoselectors support.

License:
	MIT-style license.
*/

Native.implement([Document, Element], {
	
	getElements: function(expression, nocash){
		expression = expression.split(',');
		var items, local = {};
		for (var i = 0, l = expression.length; i  l; i++){
			var selector = expression[i], elements = Selectors.Utils.search(this, selector, local);
			if (i != 0 && elements.item) elements = $A(elements);
			items = (i == 0) ? elements : (items.item) ? $A(items).concat(elements) : items.concat(elements);
		}
		return new Elements(items, {ddup: (expression.length  1), cash: !nocash});
	}
	
});

Element.implement({
	
	match: function(selector){
		if (!selector) return true;
		var tagid = Selectors.Utils.parseTagAndID(selector);
		var tag = tagid[0], id = tagid[1];
		if (!Selectors.Filters.byID(this, id) || !Selectors.Filters.byTag(this, tag)) return false;
		var parsed = Selectors.Utils.parseSelector(selector);
		return (parsed) ? Selectors.Utils.filter(this, parsed, {}) : true;
	}
	
});

var Selectors = {Cache: {nth: {}, parsed: {}}};

Selectors.RegExps = {
	id: (/#([\w-]+)/),
	tag: (/^(\w+|\*)/),
	quick: (/^(\w+|\*)$/),
	splitter: (/\s*([+~\s])\s*([a-zA-Z#.*:\[])/g),
	combined: (/\.([\w-]+)|\[(\w+)(?:([!*^$~|]?=)["']?(.*?)["']?)?\]|:([\w-]+)(?:\(["']?(.*?)?["']?\)|$)/g)
};

Selectors.Utils = {
	
	chk: function(item, uniques){
		if (!uniques) return true;
		var uid = $uid(item);
		if (!uniques[uid]) return uniques[uid] = true;
		return false;
	},
	
	parseNthArgument: function(argument){
		if (Selectors.Cache.nth[argument]) return Selectors.Cache.nth[argument];
		var parsed = argument.match(/^([+-]?\d*)?([a-z]+)?([+-]?\d*)?$/);
		if (!parsed) return false;
		var inta = parseInt(parsed[1]);
		var a = (inta || inta === 0) ? inta : 1;
		var special = parsed[2] || false;
		var b = parseInt(parsed[3]) || 0;
		if (a != 0){
			b--;
			while (b  1) b += a;
			while (b = a) b -= a;
		} else {
			a = b;
			special = 'index';
		}
		switch (special){
			case 'n': parsed = {a: a, b: b, special: 'n'}; break;
			case 'odd': parsed = {a: 2, b: 0, special: 'n'}; break;
			case 'even': parsed =  {a: 2, b: 1, special: 'n'}; break;
			case 'first': parsed = {a: 0, special: 'index'}; break;
			case 'last': parsed = {special: 'last-child'}; break;
			case 'only': parsed = {special: 'only-child'}; break;
			default: parsed = {a: (a - 1), special: 'index'};
		}
		
		return Selectors.Cache.nth[argument] = parsed;
	},
	
	parseSelector: function(selector){
		if (Selectors.Cache.parsed[selector]) return Selectors.Cache.parsed[selector];
		var m, parsed = {classes: [], pseudos: [], attributes: []};
		while ((m = Selectors.RegExps.combined.exec(selector))){
			var cn = m[1], an = m[2], ao = m[3], av = m[4], pn = m[5], pa = m[6];
			if (cn){
				parsed.classes.push(cn);
			} else if (pn){
				var parser = Selectors.Pseudo.get(pn);
				if (parser) parsed.pseudos.push({parser: parser, argument: pa});
				else parsed.attributes.push({name: pn, operator: '=', value: pa});
			} else if (an){
				parsed.attributes.push({name: an, operator: ao, value: av});
			}
		}
		if (!parsed.classes.length) delete parsed.classes;
		if (!parsed.attributes.length) delete parsed.attributes;
		if (!parsed.pseudos.length) delete parsed.pseudos;
		if (!parsed.classes && !parsed.attributes && !parsed.pseudos) parsed = null;
		return Selectors.Cache.parsed[selector] = parsed;
	},
	
	parseTagAndID: function(selector){
		var tag = selector.match(Selectors.RegExps.tag);
		var id = selector.match(Selectors.RegExps.id);
		return [(tag) ? tag[1] : '*', (id) ? id[1] : false];
	},
	
	filter: function(item, parsed, local){
		var i;
		if (parsed.classes){
			for (i = parsed.classes.length; i--; i){
				var cn = parsed.classes[i];
				if (!Selectors.Filters.byClass(item, cn)) return false;
			}
		}
		if (parsed.attributes){
			for (i = parsed.attributes.length; i--; i){
				var att = parsed.attributes[i];
				if (!Selectors.Filters.byAttribute(item, att.name, att.operator, att.value)) return false;
			}
		}
		if (parsed.pseudos){
			for (i = parsed.pseudos.length; i--; i){
				var psd = parsed.pseudos[i];
				if (!Selectors.Filters.byPseudo(item, psd.parser, psd.argument, local)) return false;
			}
		}
		return true;
	},
	
	getByTagAndID: function(ctx, tag, id){
		if (id){
			var item = ctx.getElementById(id, true);
			return (item && Selectors.Filters.byTag(item, tag)) ? [item] : [];
		} else {
			return ctx.getElementsByTagName(tag);
		}
	},
	
	search: function(self, expression, local){
		var splitters = [];
		
		var selectors = expression.trim().replace(Selectors.RegExps.splitter, function(m0, m1, m2){
			splitters.push(m1);
			return ':)' + m2;
		}).split(':)');
		
		var items, match, filtered, item;
		
		for (var i = 0, l = selectors.length; i  l; i++){
			
			var selector = selectors[i];
			
			if (i == 0 && Selectors.RegExps.quick.test(selector)){
				items = self.getElementsByTagName(selector);
				continue;
			}
			
			var splitter = splitters[i - 1];
			
			var tagid = Selectors.Utils.parseTagAndID(selector);
			var tag = tagid[0], id = tagid[1];

			if (i == 0){
				items = Selectors.Utils.getByTagAndID(self, tag, id);
			} else {
				var uniques = {}, found = [];
				for (var j = 0, k = items.length; j  k; j++) found = Selectors.Getters[splitter](found, items[j], tag, id, uniques);
				items = found;
			}
			
			var parsed = Selectors.Utils.parseSelector(selector);
			
			if (parsed){
				filtered = [];
				for (var m = 0, n = items.length; m  n; m++){
					item = items[m];
					if (Selectors.Utils.filter(item, parsed, local)) filtered.push(item);
				}
				items = filtered;
			}
			
		}
		
		return items;
		
	}
	
};

Selectors.Getters = {
	
	' ': function(found, self, tag, id, uniques){
		var items = Selectors.Utils.getByTagAndID(self, tag, id);
		for (var i = 0, l = items.length; i  l; i++){
			var item = items[i];
			if (Selectors.Utils.chk(item, uniques)) found.push(item);
		}
		return found;
	},
	
	'': function(found, self, tag, id, uniques){
		var children = Selectors.Utils.getByTagAndID(self, tag, id);
		for (var i = 0, l = children.length; i  l; i++){
			var child = children[i];
			if (child.parentNode == self && Selectors.Utils.chk(child, uniques)) found.push(child);
		}
		return found;
	},
	
	'+': function(found, self, tag, id, uniques){
		while ((self = self.nextSibling)){
			if (self.nodeType == 1){
				if (Selectors.Utils.chk(self, uniques) && Selectors.Filters.byTag(self, tag) && Selectors.Filters.byID(self, id)) found.push(self);
				break;
			}
		}
		return found;
	},
	
	'~': function(found, self, tag, id, uniques){
		
		while ((self = self.nextSibling)){
			if (self.nodeType == 1){
				if (!Selectors.Utils.chk(self, uniques)) break;
				if (Selectors.Filters.byTag(self, tag) && Selectors.Filters.byID(self, id)) found.push(self);
			} 
		}
		return found;
	}
	
};

Selectors.Filters = {
	
	byTag: function(self, tag){
		return (tag == '*' || (self.tagName && self.tagName.toLowerCase() == tag));
	},
	
	byID: function(self, id){
		return (!id || (self.id && self.id == id));
	},
	
	byClass: function(self, klass){
		return (self.className && self.className.contains(klass, ' '));
	},
	
	byPseudo: function(self, parser, argument, local){
		return parser.call(self, argument, local);
	},
	
	byAttribute: function(self, name, operator, value){
		var result = Element.prototype.getProperty.call(self, name);
		if (!result) return false;
		if (!operator || value == undefined) return true;
		switch (operator){
			case '=': return (result == value);
			case '*=': return (result.contains(value));
			case '^=': return (result.substr(0, value.length) == value);
			case '$=': return (result.substr(result.length - value.length) == value);
			case '!=': return (result != value);
			case '~=': return result.contains(value, ' ');
			case '|=': return result.contains(value, '-');
		}
		return false;
	}
	
};

Selectors.Pseudo = new Hash({
	
	// w3c pseudo selectors
	
	empty: function(){
		return !(this.innerText || this.textContent || '').length;
	},
	
	not: function(selector){
		return !Element.match(this, selector);
	},
	
	contains: function(text){
		return (this.innerText || this.textContent || '').contains(text);
	},
	
	'first-child': function(){
		return Selectors.Pseudo.index.call(this, 0);
	},
	
	'last-child': function(){
		var element = this;
		while ((element = element.nextSibling)){
			if (element.nodeType == 1) return false;
		}
		return true;
	},
	
	'only-child': function(){
		var prev = this;
		while ((prev = prev.previousSibling)){
			if (prev.nodeType == 1) return false;
		}
		var next = this;
		while ((next = next.nextSibling)){
			if (next.nodeType == 1) return false;
		}
		return true;
	},
	
	'nth-child': function(argument, local){
		argument = (argument == undefined) ? 'n' : argument;
		var parsed = Selectors.Utils.parseNthArgument(argument);
		if (parsed.special != 'n') return Selectors.Pseudo[parsed.special].call(this, parsed.a, local);
		var count = 0;
		local.positions = local.positions || {};
		var uid = $uid(this);
		if (!local.positions[uid]){
			var self = this;
			while ((self = self.previousSibling)){
				if (self.nodeType != 1) continue;
				count ++;
				var position = local.positions[$uid(self)];
				if (position != undefined){
					count = position + count;
					break;
				}
			}
			local.positions[uid] = count;
		}
		return (local.positions[uid] % parsed.a == parsed.b);
	},
	
	// custom pseudo selectors
	
	index: function(index){
		var element = this, count = 0;
		while ((element = element.previousSibling)){
			if (element.nodeType == 1 && ++count  index) return false;
		}
		return (count == index);
	},
	
	even: function(argument, local){
		return Selectors.Pseudo['nth-child'].call(this, '2n+1', local);
	},

	odd: function(argument, local){
		return Selectors.Pseudo['nth-child'].call(this, '2n', local);
	}
	
});

/*
Script: Fx.js
	Contains the basic animation logic to be extended by all other Fx Classes.

License:
	MIT-style license.
*/

var Fx = new Class({

	Implements: [Chain, Events, Options],

	options: {
		/*
		onStart: $empty,
		onCancel: $empty,
		onComplete: $empty,
		*/
		fps: 50,
		unit: false,
		duration: 500,
		link: 'ignore',
		transition: function(p){
			return -(Math.cos(Math.PI * p) - 1) / 2;
		}
	},

	initialize: function(options){
		this.subject = this.subject || this;
		this.setOptions(options);
		this.options.duration = Fx.Durations[this.options.duration] || this.options.duration.toInt();
		var wait = this.options.wait;
		if (wait === false) this.options.link = 'cancel';
	},

	step: function(){
		var time = $time();
		if (time  this.time + this.options.duration){
			var delta = this.options.transition((time - this.time) / this.options.duration);
			this.set(this.compute(this.from, this.to, delta));
		} else {
			this.set(this.compute(this.from, this.to, 1));
			this.complete();
		}
	},

	set: function(now){
		return now;
	},

	compute: function(from, to, delta){
		return Fx.compute(from, to, delta);
	},

	check: function(caller){
		if (!this.timer) return true;
		switch (this.options.link){
			case 'cancel': this.cancel(); return true;
			case 'chain': this.chain(caller.bind(this, Array.slice(arguments, 1))); return false;
		}
		return false;
	},

	start: function(from, to){
		if (!this.check(arguments.callee, from, to)) return this;
		this.from = from;
		this.to = to;
		this.time = 0;
		this.startTimer();
		this.onStart();
		return this;
	},

	complete: function(){
		if (this.stopTimer()) this.onComplete();
		return this;
	},

	cancel: function(){
		if (this.stopTimer()) this.onCancel();
		return this;
	},

	onStart: function(){
		this.fireEvent('onStart', this.subject);
	},

	onComplete: function(){
		this.fireEvent('onComplete', this.subject);
		if (!this.callChain()) this.fireEvent('onChainComplete', this.subject);
	},

	onCancel: function(){
		this.fireEvent('onCancel', this.subject).clearChain();
	},

	pause: function(){
		this.stopTimer();
		return this;
	},

	resume: function(){
		this.startTimer();
		return this;
	},

	stopTimer: function(){
		if (!this.timer) return false;
		this.time = $time() - this.time;
		this.timer = $clear(this.timer);
		return true;
	},

	startTimer: function(){
		if (this.timer) return false;
		this.time = $time() - this.time;
		this.timer = this.step.periodical(Math.round(1000 / this.options.fps), this);
		return true;
	}

});

Fx.compute = function(from, to, delta){
	return (to - from) * delta + from;
};

Fx.Durations = {'short': 250, 'normal': 500, 'long': 1000};


/*
Script: Fx.CSS.js
	Contains the CSS animation logic. Used by Fx.Tween, Fx.Morph, Fx.Elements.

License:
	MIT-style license.
*/

Fx.CSS = new Class({

	Extends: Fx,

	//prepares the base from/to object

	prepare: function(element, property, values){
		values = $splat(values);
		var values1 = values[1];
		if (!$chk(values1)){
			values[1] = values[0];
			values[0] = element.getStyle(property);
		}
		var parsed = values.map(this.parse);
		return {from: parsed[0], to: parsed[1]};
	},

	//parses a value into an array

	parse: function(value){
		value = $lambda(value)();
		value = (typeof value == 'string') ? value.split(' ') : $splat(value);
		return value.map(function(val){
			val = String(val);
			var found = false;
			Fx.CSS.Parsers.each(function(parser, key){
				if (found) return;
				var parsed = parser.parse(val);
				if ($chk(parsed)) found = {value: parsed, parser: parser};
			});
			found = found || {value: val, parser: Fx.CSS.Parsers.String};
			return found;
		});
	},

	//computes by a from and to prepared objects, using their parsers.

	compute: function(from, to, delta){
		var computed = [];
		(Math.min(from.length, to.length)).times(function(i){
			computed.push({value: from[i].parser.compute(from[i].value, to[i].value, delta), parser: from[i].parser});
		});
		computed.$family = {name: 'fx:css:value'};
		return computed;
	},

	//serves the value as settable

	serve: function(value, unit){
		if ($type(value) != 'fx:css:value') value = this.parse(value);
		var returned = [];
		value.each(function(bit){
			returned = returned.concat(bit.parser.serve(bit.value, unit));
		});
		return returned;
	},

	//renders the change to an element

	render: function(element, property, value, unit){
		element.setStyle(property, this.serve(value, unit));
	},

	//searches inside the page css to find the values for a selector

	search: function(selector){
		if (Fx.CSS.Cache[selector]) return Fx.CSS.Cache[selector];
		var to = {};
		Array.each(document.styleSheets, function(sheet, j){
			var href = sheet.href;
			if (href && href.contains('://') && !href.contains(document.domain)) return;
			var rules = sheet.rules || sheet.cssRules;
			Array.each(rules, function(rule, i){
				if (!rule.style) return;
				var selectorText = (rule.selectorText) ? rule.selectorText.replace(/^\w+/, function(m){
					return m.toLowerCase();
				}) : null;
				if (!selectorText || !selectorText.test('^' + selector + '$')) return;
				Element.Styles.each(function(value, style){
					if (!rule.style[style] || Element.ShortStyles[style]) return;
					value = String(rule.style[style]);
					to[style] = (value.test(/^rgb/)) ? value.rgbToHex() : value;
				});
			});
		});
		return Fx.CSS.Cache[selector] = to;
	}

});

Fx.CSS.Cache = {};

Fx.CSS.Parsers = new Hash({

	Color: {
		parse: function(value){
			if (value.match(/^#[0-9a-f]{3,6}$/i)) return value.hexToRgb(true);
			return ((value = value.match(/(\d+),\s*(\d+),\s*(\d+)/))) ? [value[1], value[2], value[3]] : false;
		},
		compute: function(from, to, delta){
			return from.map(function(value, i){
				return Math.round(Fx.compute(from[i], to[i], delta));
			});
		},
		serve: function(value){
			return value.map(Number);
		}
	},

	Number: {
		parse: parseFloat,
		compute: Fx.compute,
		serve: function(value, unit){
			return (unit) ? value + unit : value;
		}
	},

	String: {
		parse: $lambda(false),
		compute: $arguments(1),
		serve: $arguments(0)
	}

});

/*
Script: Fx.Scroll.js
	Effect to smoothly scroll any element, including the window.

License:
	MIT-style license.
*/

Fx.Scroll = new Class({

	Extends: Fx,

	options: {
		offset: {'x': 0, 'y': 0},
		wheelStops: true
	},

	initialize: function(element, options){
		this.element = this.subject = $(element);
		this.parent(options);
		var cancel = this.cancel.bind(this, false);

		if ($type(this.element) != 'element') this.element = $(this.element.getDocument().body);

		var stopper = this.element;

		if (this.options.wheelStops){
			this.addEvent('onStart', function(){
				stopper.addEvent('mousewheel', cancel);
			}, true);
			this.addEvent('onComplete', function(){
				stopper.removeEvent('mousewheel', cancel);
			}, true);
		}
	},

	set: function(){
		var now = Array.flatten(arguments);
		this.element.scrollTo(now[0], now[1]);
	},

	compute: function(from, to, delta){
		var now = [];
		(2).times(function(i){
			now.push(Fx.compute(from[i], to[i], delta));
		});
		return now;
	},

	start: function(x, y){
		if (!this.check(arguments.callee, x, y)) return this;
		var offsetSize = this.element.getSize(), scrollSize = this.element.getScrollSize();
		var scroll = this.element.getScroll(), values = {x: x, y: y};
		for (var z in values){
			var max = scrollSize[z] - offsetSize[z];
			if ($chk(values[z])) values[z] = ($type(values[z]) == 'number') ? values[z].limit(0, max) : max;
			else values[z] = scroll[z];
			values[z] += this.options.offset[z];
		}
		return this.parent([scroll.x, scroll.y], [values.x, values.y]);
	},

	toTop: function(){
		return this.start(false, 0);
	},

	toLeft: function(){
		return this.start(0, false);
	},

	toRight: function(){
		return this.start('right', false);
	},

	toBottom: function(){
		return this.start(false, 'bottom');
	},

	toElement: function(el){
		var position = $(el).getPosition(this.element);
		return this.start(position.x, position.y);
	}

});

/*
Script: Swiff.js
	Wrapper for embedding SWF movies. Supports (and fixes) External Interface Communication.

License:
	MIT-style license.

Credits:
	Flash detection & Internet Explorer + Flash Player 9 fix inspired by SWFObject.
*/

var Swiff = new Class({

	Implements: [Options],

	options: {
		id: null,
		height: 1,
		width: 1,
		container: null,
		properties: {},
		params: {
			quality: 'high',
			allowScriptAccess: 'always',
			wMode: 'transparent',
			swLiveConnect: true
		},
		callBacks: {},
		vars: {}
	},

	toElement: function(){
		return this.object;
	},

	initialize: function(path, options){
		this.instance = 'Swiff_' + $time();

		this.setOptions(options);
		options = this.options;
		var id = this.id = options.id || this.instance;
		var container = $(options.container);

		Swiff.CallBacks[this.instance] = {};

		var params = options.params, vars = options.vars, callBacks = options.callBacks;
		var properties = $extend({height: options.height, width: options.width}, options.properties);

		var self = this;

		for (var callBack in callBacks){
			Swiff.CallBacks[this.instance][callBack] = (function(option){
				return function(){
					return option.apply(self.object, arguments);
				};
			})(callBacks[callBack]);
			vars[callBack] = 'Swiff.CallBacks.' + this.instance + '.' + callBack;
		}

		params.flashVars = Hash.toQueryString(vars);
		if (Browser.Engine.trident){
			properties.classid = 'clsid:D27CDB6E-AE6D-11cf-96B8-444553540000';
			params.movie = path;
		} else {
			properties.type = 'application/x-shockwave-flash';
			properties.data = path;
		}
		var build = 'object id="' + id + '"';
		for (var property in properties) build += ' ' + property + '="' + properties[property] + '"';
		build += '';
		for (var param in params){
			if (params[param]) build += 'param name="' + param + '" value="' + params[param] + '" /';
		}
		build += '/object';
		this.object =  ((container) ? container.empty() : new Element('div')).set('html', build).firstChild;
	},

	replaces: function(element){
		element = $(element, true);
		element.parentNode.replaceChild(this.toElement(), element);
		return this;
	},

	inject: function(element){
		$(element, true).appendChild(this.toElement());
		return this;
	},

	remote: function(){
		return Swiff.remote.apply(Swiff, [this.toElement()].extend(arguments));
	}

});

Swiff.CallBacks = {};

Swiff.remote = function(obj, fn){
	var rs = obj.CallFunction('invoke name="' + fn + '" returntype="javascript"' + __flash__argumentsToXML(arguments, 2) + '/invoke');
	return eval(rs);
};
</content>
		</actual_file>
		<actual_file>
			<filename>deploy.rake</filename>
			<content>desc 'Package and upload the release to rubyforge.'
task :release = [:clean, :dist, :package] do |t|
  require 'rubyforge'
  version = APP_VERSION
  name    = APP_NAME
  rubyforge_name = RUBYFORGE_PROJECT
  v = ENV["VERSION"] or abort "Must supply VERSION=x.y.z"
  abort "Versions don't match #{v} vs #{version}" if v != version
  pkg = "pkg/#{name}-#{version}"

  if $DEBUG then
    puts "release_id = rf.add_release #{rubyforge_name.inspect}, #{name.inspect}, #{version.inspect}, \"#{pkg}.tgz\""
    puts "rf.add_file #{rubyforge_name.inspect}, #{name.inspect}, release_id, \"#{pkg}.gem\""
  end

  rf = RubyForge.new
  puts "Logging in"
  rf.login

  c = rf.userconfig
  c["release_notes"] = APP_DESCRIPTION if Object.const_defined?("APP_DESCRIPTION")
  c["release_changes"] = APP_CHANGES   if Object.const_defined?("APP_CHANGES")
  c["preformatted"] = true

  files = ["#{pkg}.tar.gz", "dist/#{name}-#{version}.js"].compact

  puts "Releasing #{name} v. #{version}"
  rf.add_release rubyforge_name, name, version, *files
end
</content>
		</actual_file>
		<actual_file>
			<filename>environment.rake</filename>
			<content>task :ruby_env do
  RUBY_APP = if RUBY_PLATFORM =~ /java/
    "jruby"
  else
    "ruby"
  end unless defined? RUBY_APP
end
</content>
		</actual_file>
		<actual_file>
			<filename>javascript_test_autotest_tasks.rake</filename>
			<content>TEST_CHANGES_SINCE = Time.now - 600

namespace :test do
  namespace :recent do
    desc "Open recently modified files into browser"
    task :javascript do
      require 'rubygems'
      gem 'activesupport'
      require 'active_support'

      since = TEST_CHANGES_SINCE
      touched = FileList[
        'test/unit/*_test.html', 
        'src/*.js'].select { |path| File.mtime(path)  since }
      next if touched.blank?
      
      gem 'newjs'
      require 'newjs'
      require 'newjs/autotest'
      
      touched.each do |file|
        if file =~ /\/([^\/]+)\.js$/
          file = "test/unit/#{$1}_test.html"
        end
        file = "#{APP_ROOT}/#{file}"
        unless File.exists?(file)
          # puts "Notice: Test file does not exist: #{file}"
          next
        end
        puts "Launching test: #{file}"
        browsers = JavascriptTestAutotest::Config.get :browsers
        if browsers.blank?
          puts "WARNING: No browsers setup in config/javascript_test_autotest.yml"
          next
        end
        browsers.each_pair do |name, path|
          browser = JavascriptTestAutotest::Browser.browser(name, path)
          browser.setup
          browser.visit(file)
          browser.teardown          
        end
      end
    end
  end
end
</content>
		</actual_file>
		<actual_file>
			<filename>jsunittest.js</filename>
			<content>/*  Jsunittest, version 0.6.1
 *  (c) 2008 Dr Nic Williams
 *
 *  Jsunittest is freely distributable under
 *  the terms of an MIT-style license.
 *  For details, see the web site: http://jsunittest.rubyforge.org
 *
 *--------------------------------------------------------------------------*/

var JsUnitTest = {
  Version: '0.6.1',
};

var DrNicTest = {
  Unit: {},
  inspect: function(object) {
    try {
      if (typeof object == "undefined") return 'undefined';
      if (object === null) return 'null';
      if (typeof object == "string") {
        var useDoubleQuotes = arguments[1];
        var escapedString = this.gsub(object, /[\x00-\x1f\\]/, function(match) {
          var character = String.specialChar[match[0]];
          return character ? character : '\\u00' + match[0].charCodeAt().toPaddedString(2, 16);
        });
        if (useDoubleQuotes) return '"' + escapedString.replace(/"/g, '\\"') + '"';
        return "'" + escapedString.replace(/'/g, '\\\'') + "'";
      };
      return String(object);
    } catch (e) {
      if (e instanceof RangeError) return '...';
      throw e;
    }
  },
  $: function(element) {
    if (arguments.length  1) {
      for (var i = 0, elements = [], length = arguments.length; i  length; i++)
        elements.push(this.$(arguments[i]));
      return elements;
    }
    if (typeof element == "string")
      element = document.getElementById(element);
    return element;
  },
  gsub: function(source, pattern, replacement) {
    var result = '', match;
    replacement = arguments.callee.prepareReplacement(replacement);

    while (source.length  0) {
      if (match = source.match(pattern)) {
        result += source.slice(0, match.index);
        result += DrNicTest.String.interpret(replacement(match));
        source  = source.slice(match.index + match[0].length);
      } else {
        result += source, source = '';
      }
    }
    return result;
  },
  scan: function(source, pattern, iterator) {
    this.gsub(source, pattern, iterator);
    return String(source);
  },
  escapeHTML: function(data) {
    return data.replace(/&/g,'&amp;').replace(//g,'&lt;').replace(//g,'&gt;');
  },
  arrayfromargs: function(args) {
  	var myarray = new Array();
  	var i;

  	for (i=0;iargs.length;i++)
  		myarray[i] = args[i];

  	return myarray;
  },
  hashToSortedArray: function(hash) {
    var results = [];
    for (key in hash) {
      results.push([key, hash[key]]);
    }
    return results.sort();
  },
  flattenArray: function(array) {
    var results = arguments[1] || [];
    for (var i=0; i  array.length; i++) {
      var object = array[i];
      if (object != null && typeof object == "object" &&
        'splice' in object && 'join' in object) {
          this.flattenArray(object, results);
      } else {
        results.push(object);
      }
    };
    return results;
  },
  selectorMatch: function(expression, element) {
    var tokens = [];
    var patterns = {
      // combinators must be listed first
      // (and descendant needs to be last combinator)
      laterSibling: /^\s*~\s*/,
      child:        /^\s*\s*/,
      adjacent:     /^\s*\+\s*/,
      descendant:   /^\s/,

      // selectors follow
      tagName:      /^\s*(\*|[\w\-]+)(\b|$)?/,
      id:           /^#([\w\-\*]+)(\b|$)/,
      className:    /^\.([\w\-\*]+)(\b|$)/,
      pseudo:
  /^:((first|last|nth|nth-last|only)(-child|-of-type)|empty|checked|(en|dis)abled|not)(\((.*?)\))?(\b|$|(?=\s|[:+~]))/,
      attrPresence: /^\[((?:[\w]+:)?[\w]+)\]/,
      attr:         /\[((?:[\w-]*:)?[\w-]+)\s*(?:([!^$*~|]?=)\s*((['"])([^\4]*?)\4|([^'"][^\]]*?)))?\]/
    };

    var assertions = {
      tagName: function(element, matches) {
        return matches[1].toUpperCase() == element.tagName.toUpperCase();
      },

      className: function(element, matches) {
        return Element.hasClassName(element, matches[1]);
      },

      id: function(element, matches) {
        return element.id === matches[1];
      },

      attrPresence: function(element, matches) {
        return Element.hasAttribute(element, matches[1]);
      },

      attr: function(element, matches) {
        var nodeValue = Element.readAttribute(element, matches[1]);
        return nodeValue && operators[matches[2]](nodeValue, matches[5] || matches[6]);
      }
    };
    var e = this.expression, ps = patterns, as = assertions;
    var le, p, m;

    while (e && le !== e && (/\S/).test(e)) {
      le = e;
      for (var i in ps) {
        p = ps[i];
        if (m = e.match(p)) {
          // use the Selector.assertions methods unless the selector
          // is too complex.
          if (as[i]) {
            tokens.push([i, Object.clone(m)]);
            e = e.replace(m[0], '');
          }
        }
      }
    }

    var match = true, name, matches;
    for (var i = 0, token; token = tokens[i]; i++) {
      name = token[0], matches = token[1];
      if (!assertions[name](element, matches)) {
        match = false; break;
      }
    }

    return match;
  },
  toQueryParams: function(query, separator) {
    var query = query || window.location.search;
    var match = query.replace(/^\s+/, '').replace(/\s+$/, '').match(/([^?#]*)(#.*)?$/);
    if (!match) return { };

    var hash = {};
    var parts = match[1].split(separator || '&');
    for (var i=0; i  parts.length; i++) {
      var pair = parts[i].split('=');
      if (pair[0]) {
        var key = decodeURIComponent(pair.shift());
        var value = pair.length  1 ? pair.join('=') : pair[0];
        if (value != undefined) value = decodeURIComponent(value);

        if (key in hash) {
          var object = hash[key];
          var isArray = object != null && typeof object == "object" &&
            'splice' in object && 'join' in object
          if (!isArray) hash[key] = [hash[key]];
          hash[key].push(value);
        }
        else hash[key] = value;
      }
    };
    return hash;
  },

  String: {
    interpret: function(value) {
      return value == null ? '' : String(value);
    }
  }
};

DrNicTest.gsub.prepareReplacement = function(replacement) {
  if (typeof replacement == "function") return replacement;
  var template = new Template(replacement);
  return function(match) { return template.evaluate(match) };
};

DrNicTest.Template = function(template, pattern) {
  this.template = template; //template.toString();
  this.pattern = pattern || DrNicTest.Template.Pattern;
};

DrNicTest.Template.prototype.evaluate = function(object) {
  if (typeof object.toTemplateReplacements == "function")
    object = object.toTemplateReplacements();

  return DrNicTest.gsub(this.template, this.pattern, function(match) {
    if (object == null) return '';

    var before = match[1] || '';
    if (before == '\\') return match[2];

    var ctx = object, expr = match[3];
    var pattern = /^([^.[]+|\[((?:.*?[^\\])?)\])(\.|\[|$)/;
    match = pattern.exec(expr);
    if (match == null) return before;

    while (match != null) {
      var comp = (match[1].indexOf('[]') === 0) ? match[2].gsub('\\\\]', ']') : match[1];
      ctx = ctx[comp];
      if (null == ctx || '' == match[3]) break;
      expr = expr.substring('[' == match[3] ? match[1].length : match[0].length);
      match = pattern.exec(expr);
    }

    return before + DrNicTest.String.interpret(ctx);
  });
}

DrNicTest.Template.Pattern = /(^|.|\r|\n)(#\{(.*?)\})/;
DrNicTest.Event = {};
// written by Dean Edwards, 2005
// with input from Tino Zijdel, Matthias Miller, Diego Perini
// namespaced by Dr Nic Williams 2008

// http://dean.edwards.name/weblog/2005/10/add-event/
// http://dean.edwards.name/weblog/2005/10/add-event2/
DrNicTest.Event.addEvent = function(element, type, handler) {
	if (element.addEventListener) {
		element.addEventListener(type, handler, false);
	} else {
		// assign each event handler a unique ID
		if (!handler.$$guid) handler.$$guid = addEvent.guid++;
		// create a hash table of event types for the element
		if (!element.events) element.events = {};
		// create a hash table of event handlers for each element/event pair
		var handlers = element.events[type];
		if (!handlers) {
			handlers = element.events[type] = {};
			// store the existing event handler (if there is one)
			if (element["on" + type]) {
				handlers[0] = element["on" + type];
			}
		}
		// store the event handler in the hash table
		handlers[handler.$$guid] = handler;
		// assign a global event handler to do all the work
		element["on" + type] = handleEvent;
	}
};
// a counter used to create unique IDs
DrNicTest.Event.addEvent.guid = 1;

DrNicTest.Event.removeEvent = function(element, type, handler) {
	if (element.removeEventListener) {
		element.removeEventListener(type, handler, false);
	} else {
		// delete the event handler from the hash table
		if (element.events && element.events[type]) {
			delete element.events[type][handler.$$guid];
		}
	}
};

DrNicTest.Event.handleEvent = function(event) {
	var returnValue = true;
	// grab the event object (IE uses a global event object)
	event = event || fixEvent(((this.ownerDocument || this.document || this).parentWindow || window).event);
	// get a reference to the hash table of event handlers
	var handlers = this.events[event.type];
	// execute each event handler
	for (var i in handlers) {
		this.$$handleEvent = handlers[i];
		if (this.$$handleEvent(event) === false) {
			returnValue = false;
		}
	}
	return returnValue;
};

DrNicTest.Event.fixEvent = function(event) {
	// add W3C standard event methods
	event.preventDefault = fixEvent.preventDefault;
	event.stopPropagation = fixEvent.stopPropagation;
	return event;
};
DrNicTest.Event.fixEvent.preventDefault = function() {
	this.returnValue = false;
};
DrNicTest.Event.fixEvent.stopPropagation = function() {
	this.cancelBubble = true;
};

DrNicTest.Unit.Logger = function(element) {
  this.element = DrNicTest.$(element);
  if (this.element) this._createLogTable();
};

DrNicTest.Unit.Logger.prototype.start = function(testName) {
  if (!this.element) return;
  var tbody = this.element.getElementsByTagName('tbody')[0];
  tbody.innerHTML = tbody.innerHTML + 'trtd' + testName + '/tdtd/tdtd/td/tr';
};

DrNicTest.Unit.Logger.prototype.setStatus = function(status) {
  var logline = this.getLastLogLine();
  logline.className = status;
  var statusCell = logline.getElementsByTagName('td')[1];
  statusCell.innerHTML = status;
};

DrNicTest.Unit.Logger.prototype.finish = function(status, summary) {
  if (!this.element) return;
  this.setStatus(status);
  this.message(summary);
};

DrNicTest.Unit.Logger.prototype.message = function(message) {
  if (!this.element) return;
  var cell = this.getMessageCell();
  cell.innerHTML = this._toHTML(message);
};

DrNicTest.Unit.Logger.prototype.summary = function(summary) {
  if (!this.element) return;
  var div = this.element.getElementsByTagName('div')[0];
  div.innerHTML = this._toHTML(summary);
};

DrNicTest.Unit.Logger.prototype.getLastLogLine = function() {
  var tbody = this.element.getElementsByTagName('tbody')[0];
  var loglines = tbody.getElementsByTagName('tr');
  return loglines[loglines.length - 1];
};

DrNicTest.Unit.Logger.prototype.getMessageCell = function() {
  var logline = this.getLastLogLine();
  return logline.getElementsByTagName('td')[2];
};

DrNicTest.Unit.Logger.prototype._createLogTable = function() {
  var html = 'div class="logsummary"running.../div' +
  'table class="logtable"' +
  'theadtrthStatus/ththTest/ththMessage/th/tr/thead' +
  'tbody class="loglines"/tbody' +
  '/table';
  this.element.innerHTML = html;
};

DrNicTest.Unit.Logger.prototype.appendActionButtons = function(actions) {
  // actions = $H(actions);
  // if (!actions.any()) return;
  // var div = new Element("div", {className: 'action_buttons'});
  // actions.inject(div, function(container, action) {
  //   var button = new Element("input").setValue(action.key).observe("click", action.value);
  //   button.type = "button";
  //   return container.insert(button);
  // });
  // this.getMessageCell().insert(div);
};

DrNicTest.Unit.Logger.prototype._toHTML = function(txt) {
  return DrNicTest.escapeHTML(txt).replace(/\n/g,"br/");
};
DrNicTest.Unit.MessageTemplate = function(string) {
  var parts = [];
  var str = DrNicTest.scan((string || ''), /(?=[^\\])\?|(?:\\\?|[^\?])+/, function(part) {
    parts.push(part[0]);
  });
  this.parts = parts;
};

DrNicTest.Unit.MessageTemplate.prototype.evaluate = function(params) {
  var results = [];
  for (var i=0; i  this.parts.length; i++) {
    var part = this.parts[i];
    var result = (part == '?') ? DrNicTest.inspect(params.shift()) : part.replace(/\\\?/, '?');
    results.push(result);
  };
  return results.join('');
};
// A generic function for performming AJAX requests
// It takes one argument, which is an object that contains a set of options
// All of which are outline in the comments, below
// From John Resig's book Pro JavaScript Techniques
// published by Apress, 2006-8
DrNicTest.ajax = function( options ) {

    // Load the options object with defaults, if no
    // values were provided by the user
    options = {
        // The type of HTTP Request
        type: options.type || "POST",

        // The URL the request will be made to
        url: options.url || "",

        // How long to wait before considering the request to be a timeout
        timeout: options.timeout || 5000,

        // Functions to call when the request fails, succeeds,
        // or completes (either fail or succeed)
        onComplete: options.onComplete || function(){},
        onError: options.onError || function(){},
        onSuccess: options.onSuccess || function(){},

        // The data type that'll be returned from the server
        // the default is simply to determine what data was returned from the
        // and act accordingly.
        data: options.data || ""
    };

    // Create the request object
    var xml = new XMLHttpRequest();

    // Open the asynchronous POST request
    xml.open(options.type, options.url, true);

    // We're going to wait for a request for 5 seconds, before giving up
    var timeoutLength = 5000;

    // Keep track of when the request has been succesfully completed
    var requestDone = false;

    // Initalize a callback which will fire 5 seconds from now, cancelling
    // the request (if it has not already occurred).
    setTimeout(function(){
         requestDone = true;
    }, timeoutLength);

    // Watch for when the state of the document gets updated
    xml.onreadystatechange = function(){
        // Wait until the data is fully loaded,
        // and make sure that the request hasn't already timed out
        if ( xml.readyState == 4 && !requestDone ) {

            // Check to see if the request was successful
            if ( httpSuccess( xml ) ) {

                // Execute the success callback with the data returned from the server
                options.onSuccess( httpData( xml, options.type ) );

            // Otherwise, an error occurred, so execute the error callback
            } else {
                options.onError();
            }

            // Call the completion callback
            options.onComplete();

            // Clean up after ourselves, to avoid memory leaks
            xml = null;
        }
    };

    // Establish the connection to the server
    xml.send(null);

    // Determine the success of the HTTP response
    function httpSuccess(r) {
        try {
            // If no server status is provided, and we're actually
            // requesting a local file, then it was successful
            return !r.status && location.protocol == "file:" ||

                // Any status in the 200 range is good
                ( r.status = 200 && r.status  300 ) ||

                // Successful if the document has not been modified
                r.status == 304 ||

                // Safari returns an empty status if the file has not been modified
                navigator.userAgent.indexOf("Safari") = 0 && typeof r.status == "undefined";
        } catch(e){}

        // If checking the status failed, then assume that the request failed too
        return false;
    }

    // Extract the correct data from the HTTP response
    function httpData(r,type) {
        // Get the content-type header
        var ct = r.getResponseHeader("content-type");

        // If no default type was provided, determine if some
        // form of XML was returned from the server
        var data = !type && ct && ct.indexOf("xml") = 0;

        // Get the XML Document object if XML was returned from
        // the server, otherwise return the text contents returned by the server
        data = type == "xml" || data ? r.responseXML : r.responseText;

        // If the specified type is "script", execute the returned text
        // response as if it was JavaScript
        if ( type == "script" )
            eval.call( window, data );

        // Return the response data (either an XML Document or a text string)
        return data;
    }

}
DrNicTest.Unit.Assertions = {
  buildMessage: function(message, template) {
    var args = DrNicTest.arrayfromargs(arguments).slice(2);
    return (message ? message + '\n' : '') +
      new DrNicTest.Unit.MessageTemplate(template).evaluate(args);
  },

  flunk: function(message) {
    this.assertBlock(message || 'Flunked', function() { return false });
  },

  assertBlock: function(message, block) {
    try {
      block.call(this) ? this.pass() : this.fail(message);
    } catch(e) { this.error(e) }
  },

  assert: function(expression, message) {
    message = this.buildMessage(message || 'assert', 'got ?', expression);
    this.assertBlock(message, function() { return expression });
  },

  assertEqual: function(expected, actual, message) {
    message = this.buildMessage(message || 'assertEqual', 'expected ?, actual: ?', expected, actual);
    this.assertBlock(message, function() { return expected == actual });
  },

  assertNotEqual: function(expected, actual, message) {
    message = this.buildMessage(message || 'assertNotEqual', 'expected ?, actual: ?', expected, actual);
    this.assertBlock(message, function() { return expected != actual });
  },

  assertEnumEqual: function(expected, actual, message) {
    message = this.buildMessage(message || 'assertEnumEqual', 'expected ?, actual: ?', expected, actual);
    var expected_array = DrNicTest.flattenArray(expected);
    var actual_array   = DrNicTest.flattenArray(actual);
    this.assertBlock(message, function() {
      if (expected_array.length == actual_array.length) {
        for (var i=0; i  expected_array.length; i++) {
          if (expected_array[i] != actual_array[i]) return false;
        };
        return true;
      }
      return false;
    });
  },

  assertEnumNotEqual: function(expected, actual, message) {
    message = this.buildMessage(message || 'assertEnumNotEqual', '? was the same as ?', expected, actual);
    var expected_array = DrNicTest.flattenArray(expected);
    var actual_array   = DrNicTest.flattenArray(actual);
    this.assertBlock(message, function() {
      if (expected_array.length == actual_array.length) {
        for (var i=0; i  expected_array.length; i++) {
          if (expected_array[i] != actual_array[i]) return true;
        };
        return false;
      }
      return true;
    });
  },

  assertHashEqual: function(expected, actual, message) {
    message = this.buildMessage(message || 'assertHashEqual', 'expected ?, actual: ?', expected, actual);
    var expected_array = DrNicTest.flattenArray(DrNicTest.hashToSortedArray(expected));
    var actual_array   = DrNicTest.flattenArray(DrNicTest.hashToSortedArray(actual));
    var block = function() {
      if (expected_array.length == actual_array.length) {
        for (var i=0; i  expected_array.length; i++) {
          if (expected_array[i] != actual_array[i]) return false;
        };
        return true;
      }
      return false;
    };
    this.assertBlock(message, block);
  },

  assertHashNotEqual: function(expected, actual, message) {
    message = this.buildMessage(message || 'assertHashNotEqual', '? was the same as ?', expected, actual);
    var expected_array = DrNicTest.flattenArray(DrNicTest.hashToSortedArray(expected));
    var actual_array   = DrNicTest.flattenArray(DrNicTest.hashToSortedArray(actual));
    // from now we recursively zip & compare nested arrays
    var block = function() {
      if (expected_array.length == actual_array.length) {
        for (var i=0; i  expected_array.length; i++) {
          if (expected_array[i] != actual_array[i]) return true;
        };
        return false;
      }
      return true;
    };
    this.assertBlock(message, block);
  },

  assertIdentical: function(expected, actual, message) {
    message = this.buildMessage(message || 'assertIdentical', 'expected ?, actual: ?', expected, actual);
    this.assertBlock(message, function() { return expected === actual });
  },

  assertNotIdentical: function(expected, actual, message) {
    message = this.buildMessage(message || 'assertNotIdentical', 'expected ?, actual: ?', expected, actual);
    this.assertBlock(message, function() { return expected !== actual });
  },

  assertNull: function(obj, message) {
    message = this.buildMessage(message || 'assertNull', 'got ?', obj);
    this.assertBlock(message, function() { return obj === null });
  },

  assertNotNull: function(obj, message) {
    message = this.buildMessage(message || 'assertNotNull', 'got ?', obj);
    this.assertBlock(message, function() { return obj !== null });
  },

  assertUndefined: function(obj, message) {
    message = this.buildMessage(message || 'assertUndefined', 'got ?', obj);
    this.assertBlock(message, function() { return typeof obj == "undefined" });
  },

  assertNotUndefined: function(obj, message) {
    message = this.buildMessage(message || 'assertNotUndefined', 'got ?', obj);
    this.assertBlock(message, function() { return typeof obj != "undefined" });
  },

  assertNullOrUndefined: function(obj, message) {
    message = this.buildMessage(message || 'assertNullOrUndefined', 'got ?', obj);
    this.assertBlock(message, function() { return obj == null });
  },

  assertNotNullOrUndefined: function(obj, message) {
    message = this.buildMessage(message || 'assertNotNullOrUndefined', 'got ?', obj);
    this.assertBlock(message, function() { return obj != null });
  },

  assertMatch: function(expected, actual, message) {
    message = this.buildMessage(message || 'assertMatch', 'regex ? did not match ?', expected, actual);
    this.assertBlock(message, function() { return new RegExp(expected).exec(actual) });
  },

  assertNoMatch: function(expected, actual, message) {
    message = this.buildMessage(message || 'assertNoMatch', 'regex ? matched ?', expected, actual);
    this.assertBlock(message, function() { return !(new RegExp(expected).exec(actual)) });
  },

  assertHidden: function(element, message) {
    message = this.buildMessage(message || 'assertHidden', '? isn\'t hidden.', element);
    this.assertBlock(message, function() { return element.style.display == 'none' });
  },

  assertInstanceOf: function(expected, actual, message) {
    message = this.buildMessage(message || 'assertInstanceOf', '? was not an instance of the expected type', actual);
    this.assertBlock(message, function() { return actual instanceof expected });
  },

  assertNotInstanceOf: function(expected, actual, message) {
    message = this.buildMessage(message || 'assertNotInstanceOf', '? was an instance of the expected type', actual);
    this.assertBlock(message, function() { return !(actual instanceof expected) });
  },

  assertRespondsTo: function(method, obj, message) {
    message = this.buildMessage(message || 'assertRespondsTo', 'object doesn\'t respond to ?', method);
    this.assertBlock(message, function() { return (method in obj && typeof obj[method] == 'function') });
  },

  assertRaise: function(exceptionName, method, message) {
    message = this.buildMessage(message || 'assertRaise', '? exception expected but none was raised', exceptionName);
    var block = function() {
      try {
        method();
        return false;
      } catch(e) {
        if (e.name == exceptionName) return true;
        else throw e;
      }
    };
    this.assertBlock(message, block);
  },

  assertNothingRaised: function(method, message) {
    try {
      method();
      this.assert(true, "Expected nothing to be thrown");
    } catch(e) {
      message = this.buildMessage(message || 'assertNothingRaised', '? was thrown when nothing was expected.', e);
      this.flunk(message);
    }
  },

  _isVisible: function(element) {
    element = DrNicTest.$(element);
    if(!element.parentNode) return true;
    this.assertNotNull(element);
    if(element.style && element.style.display == 'none')
      return false;

    return arguments.callee.call(this, element.parentNode);
  },

  assertVisible: function(element, message) {
    message = this.buildMessage(message, '? was not visible.', element);
    this.assertBlock(message, function() { return this._isVisible(element) });
  },

  assertNotVisible: function(element, message) {
    message = this.buildMessage(message, '? was not hidden and didn\'t have a hidden parent either.', element);
    this.assertBlock(message, function() { return !this._isVisible(element) });
  },

  assertElementsMatch: function() {
    var pass = true, expressions = DrNicTest.arrayfromargs(arguments);
    var elements = expressions.shift();
    if (elements.length != expressions.length) {
      message = this.buildMessage('assertElementsMatch', 'size mismatch: ? elements, ? expressions (?).', elements.length, expressions.length, expressions);
      this.flunk(message);
      pass = false;
    }
    for (var i=0; i  expressions.length; i++) {
      var expression = expressions[i];
      var element    = DrNicTest.$(elements[i]);
      if (DrNicTest.selectorMatch(expression, element)) {
        pass = true;
        break;
      }
      message = this.buildMessage('assertElementsMatch', 'In index ?: expected ? but got ?', index, expression, element);
      this.flunk(message);
      pass = false;
    };
    this.assert(pass, "Expected all elements to match.");
  },

  assertElementMatches: function(element, expression, message) {
    this.assertElementsMatch([element], expression);
  }
};
DrNicTest.Unit.Runner = function(testcases) {
  var argumentOptions = arguments[1] || {};
  var options = this.options = {};
  options.testLog = ('testLog' in argumentOptions) ? argumentOptions.testLog : 'testlog';
  options.resultsURL = this.queryParams.resultsURL;
  options.testLog = DrNicTest.$(options.testLog);

  this.tests = this.getTests(testcases);
  this.currentTest = 0;
  this.logger = new DrNicTest.Unit.Logger(options.testLog);

  var self = this;
  DrNicTest.Event.addEvent(window, "load", function() {
    setTimeout(function() {
      self.runTests();
    }, 0.1);
  });
};

DrNicTest.Unit.Runner.prototype.queryParams = DrNicTest.toQueryParams();

DrNicTest.Unit.Runner.prototype.portNumber = function() {
  if (window.location.search.length  0) {
    var matches = window.location.search.match(/\:(\d{3,5})\//);
    if (matches) {
      return parseInt(matches[1]);
    }
  }
  return null;
};

DrNicTest.Unit.Runner.prototype.getTests = function(testcases) {
  var tests = [], options = this.options;
  if (this.queryParams.tests) tests = this.queryParams.tests.split(',');
  else if (options.tests) tests = options.tests;
  else if (options.test) tests = [option.test];
  else {
    for (testname in testcases) {
      if (testname.match(/^test/)) tests.push(testname);
    }
  }
  var results = [];
  for (var i=0; i  tests.length; i++) {
    var test = tests[i];
    if (testcases[test])
      results.push(
        new DrNicTest.Unit.Testcase(test, testcases[test], testcases.setup, testcases.teardown)
      );
  };
  return results;
};

DrNicTest.Unit.Runner.prototype.getResult = function() {
  var results = {
    tests: this.tests.length,
    assertions: 0,
    failures: 0,
    errors: 0
  };

  for (var i=0; i  this.tests.length; i++) {
    var test = this.tests[i];
    results.assertions += test.assertions;
    results.failures   += test.failures;
    results.errors     += test.errors;
  };
  return results;
};

DrNicTest.Unit.Runner.prototype.postResults = function() {
  if (this.options.resultsURL) {
    // new Ajax.Request(this.options.resultsURL,
    //   { method: 'get', parameters: this.getResult(), asynchronous: false });
    var results = this.getResult();
    var url = this.options.resultsURL + "?";
    url += "assertions="+ results.assertions + "&";
    url += "failures="  + results.failures + "&";
    url += "errors="    + results.errors;
    DrNicTest.ajax({
      url: url,
      type: 'GET'
    })
  }
};

DrNicTest.Unit.Runner.prototype.runTests = function() {
  var test = this.tests[this.currentTest], actions;

  if (!test) return this.finish();
  if (!test.isWaiting) this.logger.start(test.name);
  test.run();
  var self = this;
  if(test.isWaiting) {
    this.logger.message("Waiting for " + test.timeToWait + "ms");
    // setTimeout(this.runTests.bind(this), test.timeToWait || 1000);
    setTimeout(function() {
      self.runTests();
    }, test.timeToWait || 1000);
    return;
  }

  this.logger.finish(test.status(), test.summary());
  if (actions = test.actions) this.logger.appendActionButtons(actions);
  this.currentTest++;
  // tail recursive, hopefully the browser will skip the stackframe
  this.runTests();
};

DrNicTest.Unit.Runner.prototype.finish = function() {
  this.postResults();
  this.logger.summary(this.summary());
};

DrNicTest.Unit.Runner.prototype.summary = function() {
  return new DrNicTest.Template('#{tests} tests, #{assertions} assertions, #{failures} failures, #{errors} errors').evaluate(this.getResult());
};
DrNicTest.Unit.Testcase = function(name, test, setup, teardown) {
  this.name           = name;
  this.test           = test     || function() {};
  this.setup          = setup    || function() {};
  this.teardown       = teardown || function() {};
  this.messages       = [];
  this.actions        = {};
};
// import DrNicTest.Unit.Assertions

for (method in DrNicTest.Unit.Assertions) {
  DrNicTest.Unit.Testcase.prototype[method] = DrNicTest.Unit.Assertions[method];
}

DrNicTest.Unit.Testcase.prototype.isWaiting  = false;
DrNicTest.Unit.Testcase.prototype.timeToWait = 1000;
DrNicTest.Unit.Testcase.prototype.assertions = 0;
DrNicTest.Unit.Testcase.prototype.failures   = 0;
DrNicTest.Unit.Testcase.prototype.errors     = 0;
// DrNicTest.Unit.Testcase.prototype.isRunningFromRake = window.location.port == 4711;
DrNicTest.Unit.Testcase.prototype.isRunningFromRake = window.location.port;

DrNicTest.Unit.Testcase.prototype.wait = function(time, nextPart) {
  this.isWaiting = true;
  this.test = nextPart;
  this.timeToWait = time;
};

DrNicTest.Unit.Testcase.prototype.run = function(rethrow) {
  try {
    try {
      if (!this.isWaiting) this.setup();
      this.isWaiting = false;
      this.test();
    } finally {
      if(!this.isWaiting) {
        this.teardown();
      }
    }
  }
  catch(e) {
    if (rethrow) throw e;
    this.error(e, this);
  }
};

DrNicTest.Unit.Testcase.prototype.summary = function() {
  var msg = '#{assertions} assertions, #{failures} failures, #{errors} errors\n';
  return new DrNicTest.Template(msg).evaluate(this) +
    this.messages.join("\n");
};

DrNicTest.Unit.Testcase.prototype.pass = function() {
  this.assertions++;
};

DrNicTest.Unit.Testcase.prototype.fail = function(message) {
  this.failures++;
  var line = "";
  try {
    throw new Error("stack");
  } catch(e){
    line = (/\.html:(\d+)/.exec(e.stack || '') || ['',''])[1];
  }
  this.messages.push("Failure: " + message + (line ? " Line #" + line : ""));
};

DrNicTest.Unit.Testcase.prototype.info = function(message) {
  this.messages.push("Info: " + message);
};

DrNicTest.Unit.Testcase.prototype.error = function(error, test) {
  this.errors++;
  this.actions['retry with throw'] = function() { test.run(true) };
  this.messages.push(error.name + ": "+ error.message + "(" + DrNicTest.inspect(error) + ")");
};

DrNicTest.Unit.Testcase.prototype.status = function() {
  if (this.failures  0) return 'failed';
  if (this.errors  0) return 'error';
  return 'passed';
};

DrNicTest.Unit.Testcase.prototype.benchmark = function(operation, iterations) {
  var startAt = new Date();
  (iterations || 1).times(operation);
  var timeTaken = ((new Date())-startAt);
  this.info((arguments[2] || 'Operation') + ' finished ' +
     iterations + ' iterations in ' + (timeTaken/1000)+'s' );
  return timeTaken;
};

Test = DrNicTest</content>
		</actual_file>
		<actual_file>
			<filename>nested.html</filename>
			<content>!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"

html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
head
	meta http-equiv="Content-Type" content="text/html; charset=utf-8"/

	titleJSAwesome!/title
	script src="../../src/mootools.js" type="text/javascript" charset="utf-8"/script
	script src="../../src/base.js" type="text/javascript" charset="utf-8"/script
	style type="text/css" media="screen"
		label{
			display:block;
		}
		div {
		  margin-bottom:10px;
		}
	/style
/head

body
	form method="post" id="form" action="http://www.doloreslabs.com"
		div id="test"
		/div
		input type="submit"/
	/form
script type="text/javascript" charset="utf-8"
  var json = [["category_1",{
    "Other|~11":[],
    "Performing Arts|8":["Ballet|39","Cabaret &amp; Review|40","Comedy|41","Literary Arts|42","Musicals|43","Opera|44","Poetry|45","Puppetry|46","Street Performance|47","Symphony|48","Theater|49","Other|~0"],
    "Music|7":["Alternative|34","Jazz|35","R&amp;B|36","Rock|37","Techno &amp; Dance|38","Country|72","Classical|80","Folk|1044","World Music|1045","Gospel|1046","Pop|1047","Blues|1048","Rap\/Hip-Hop|1087","Other|~0"],
    "Fairs &amp; Festivals|5":[],
    "Community|2":["Activism|15","Charity &amp; Volunteer|16","Ethnic &amp; Cultural|17","Libraries|18","Parades|19","Religion|20","Talks &amp; Lectures|21","Workshops &amp; Classes|22","Antiques &amp; Collectibles|68","Home &amp; Garden|69","Pets|81","History|1052","Health|1053","Science|1054","Other|~0"],
    "Visual Arts|10": ["Animation|61","Film|62","Galleries|63","Museums|64", "Painting|65","Photography|66","Other|~0"],
    "Dance|4":["Ballet|25","Ballroom|26","Waltz|27","Salsa|28","Swing|29","Tango|30","Other|~0"],
    "Arts &amp; Crafts|1": ["Ceramics|12","Knitting|13","Quilting|14","Bazaar|1057","Other|~0"],
    "Shopping|1049":["Retail|1050","Fashion|1051"],
    "Sports &amp; Outdoors|9": ["Auto Racing|50","Baseball|51","Basketball|52","Boating|53", "Camping|54","Cycling|55","Football|56","Hiking|57","Hockey|58","Running|59","Soccer|60","Swimming|73","Nature|74","Amateur|75","Volleyball|76","Tennis|77","Wrestling|78","Track &amp; Field|79","Golf|1042","Surf &amp; Beach|1043","Yoga|1055","Aviation|1056","Other|~0"],
    "Food &amp; Dining|6":["Farmers' Markets|32","Wine|33","Other|~0"],
    "Business &amp; Tech|3":["Real Estate|23","Gaming &amp; Technology|24","Conferences &amp; Trade Shows|67","Cars|71","Other|~0"]
  }],["category_2",0],["category_3",0],["_id",null]]
	var labels = {
    category_1: {required:true},
  }
	var js = new JSAwesome('test', json, labels)
	js.to_html()
	js.addValidation()
/script
/body
/html</content>
		</actual_file>
		<actual_file>
			<filename>sample.html</filename>
			<content>!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"

html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
head
	meta http-equiv="Content-Type" content="text/html; charset=utf-8"/

	titleJSAwesome!/title
	script src="../../src/mootools.js" type="text/javascript" charset="utf-8"/script
	script src="../../src/base.js" type="text/javascript" charset="utf-8"/script
	style type="text/css" media="screen"
		label{
			display:block;
		}
		div {
		  margin-bottom:10px;
		}
	/style
/head

body
	form method="post" id="form" action="http://www.doloreslabs.com"
		div id="test"
		/div
		input type="submit"/
	/form
script type="text/javascript" charset="utf-8"
  var json = [
	  ['drop', ['~single', 'dude|~custom']],
	  [['text',''], ['more_text','Oh yeah'], ['cool','Booyah']],
	  ['text_again',''],
	  ['#textarea','Default text'],
	  ['_hidden','invisible'],
	  ['*radios', ['so|nice', 'many', 'radio|yeah', 'boxes']],
	  [['^real_cool', true], '^not'],
	  ['^choices', ['Choice 1|one', 'Choice 2|two', ['Choice 3|three', true]]],
	  ['sub_cats', 
	    {'rad': ['cool', 'neat'], 
	     'awesome':
	       {'crazy': ['Indeed|~really', 'man'],
	        'way': ['oh', 'yeah']}
	    }],
	  ['sub_cats2', 8]
	  ]
	var labels = {
    cool:'Um Thats right',
    '~':'Suggest something...',
    '{}':['Something', 'Something else'],
    'not':'Not Cool',
    'choices':'Many Choices',
    'real_cool':{label:'Nice', required:true},
    'radios':{required:true, label:'So many choices'},
    sub_cats:{required:true, label:"Sub Categories"},
    textarea:{validation:["cool", "Text area must contain cool"]}
  }
	var test = new JSAwesome('test', json, labels)
	test.to_html()
	test.addValidation()
	window.addEvent('load', function(){
    $$('input.not').each(function(i){
      i.addEvent('click', function(){
        var id = this.getParent('div.error').getParent().get('id')
        var awesome = eval(id)
        if(this.checked)
           awesome.stopValidation(/radio/)
        else
           awesome.addValidation(/radio/)
      })
    })
  })
/script
/body
/html</content>
		</actual_file>
		<actual_file>
			<filename>test_helper.js</filename>
			<content>//I assume mootools was already required
String.implement('sexify', function(){
  return this.replace('test','').replace(/[A-Z]/g, function(match){
    return ' ' + match.charAt(0);
  })
})

DrNicTest.Unit.Testcase.prototype.$N = function(selector){
  return $$('#'+this.name+' '+selector)
}

var JSON = new Hash({

	encode: function(obj){
		switch ($type(obj)){
			case 'string':
				return '"' + obj.replace(/[\x00-\x1f\\"]/g, JSON.$replaceChars) + '"';
			case 'array':
				return '[' + String(obj.map(JSON.encode).filter($defined)) + ']';
			case 'object': case 'hash':
				var string = [];
				Hash.each(obj, function(value, key){
					var json = JSON.encode(value);
					if (json) string.push(JSON.encode(key) + ':' + json);
				});
				return '{' + String(string) + '}';
			case 'number': case 'boolean': return String(obj);
			case false: return 'null';
		}
		return null;
	},

	$specialChars: {'\b': '\\b', '\t': '\\t', '\n': '\\n', '\f': '\\f', '\r': '\\r', '"' : '\\"', '\\': '\\\\'},

	$replaceChars: function(chr){
		return JSON.$specialChars[chr] || '\\u00' + Math.floor(chr.charCodeAt() / 16).toString(16) + (chr.charCodeAt() % 16).toString(16);
	},

	decode: function(string, secure){
		if ($type(string) != 'string' || !string.length) return null;
		if (secure && !(/^[,:{}\[\]0-9.\-+Eaeflnr-u \n\r\t]*$/).test(string.replace(/\\./g, '@').replace(/"[^"\\\n\r]*"/g, ''))) return null;
		return eval('(' + string + ')');
	}

});

Native.implement([Hash, Array, String, Number], {

	toJSON: function(){
		return JSON.encode(this);
	}

});</content>
		</actual_file>
		<actual_file>
			<filename>unittest.css</filename>
			<content>body, div, p, h1, h2, h3, ul, ol, span, a, table, td, form, img, li {
  font-family: sans-serif;
}

body {
  font-size:0.8em;
}

#log {
  padding-bottom: 1em;
  border-bottom: 2px solid #000;
  margin-bottom: 2em;
}

.logsummary {
  margin-top: 1em;
  margin-bottom: 1em;
  padding: 1ex;
  border: 1px solid #000;
  font-weight: bold;
}

.logtable {
  width:100%;
  border-collapse: collapse;
  border: 1px dotted #666;
}

.logtable td, .logtable th {
  text-align: left;
  padding: 3px 8px;
  border: 1px dotted #666;
}

.logtable .passed {
  background-color: #cfc;
}

.logtable .failed, .logtable .error {
  background-color: #fcc;
}

.logtable td div.action_buttons {
  display: inline;
}

.logtable td div.action_buttons input {
  margin: 0 5px;
  font-size: 10px;
}
</content>
		</actual_file>
		<actual_file>
			<filename>select_test.html</filename>
			<content>!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
head
  titleJavaScript unit test file/title
  meta http-equiv="content-type" content="text/html; charset=utf-8" /
  script src="../assets/jsunittest.js" type="text/javascript"/script
  
  script src="../../dist/jsawesome.js" type="text/javascript"/script
  
  script src="../assets/test_helper.js" type="text/javascript"/script
  
  
  link rel="stylesheet" href="../assets/unittest.css" type="text/css" /
  style type="text/css" media="screen"
		label{
			display:block;
		}
		div.error {
		  margin-top:10px;
		}
	/style
/head
body

div id="content"

  div id="header"
    h1JSAwesome select functional tests/h1
    p
      Functional tests for demonstrating single and nested select menus.
    /p
  /div
  pre[["cool","nice"]]/pre

  !-- Log output (one per Runner, via {testLog: "testlog"} option)--
  h2Single selects/h2
  div id="singlelog"/div
  div id="single"/div
  
  
  h2Nested selects/h2
  div id="nestedlog"/div
  div id="nested"/div
  
  !-- Put sample/test html here --
/div

script type="text/javascript"
// ![CDATA[

  new Test.Unit.Runner({
    // replace this with your real tests
    setup: function() {
      $('single').grab(new Element('div', {
        id:this.name
      }).grab(new Element('h3', {
        html:this.name.sexify()
      })))
    },
    
    teardown: function() {
      $('single').adopt([new Element('pre', {
        text:tb.json.toJSON()
      }), new Element('pre', {
        text:$H(tb.labels).toJSON()
      })])
    },
    
    testSimpleSelect: function() { with(this) {
      tb = new JSAwesome(name, [['select',['1','2','3','4']]])
      tb.to_html()
      var select = $N('select.select')[0]
      assertEqual(name+"[select]", select.name)
      assertEqual(5,select.getElements('option').length)
      assertEqual("", select.value)
      var label = $N('label')
      assertEqual("Select", label.get("html"))
    }},
    
    testRequiredSelectWithCustomLabel: function() { with(this){
      tb = new JSAwesome(name, [['select',['1','2','3','4']]],{
        select:{label:'Cool select', required:true}
      })
      tb.to_html()
      var select = $N('select.select')[0]
      assertEqual(name+"[select]", select.name)
      assertEqual(5,select.getElements('option').length)
      assertEqual("", select.value)
      var label = $N('label')
      assertEqual("Cool select", label.get("html"))
      assert(!tb.validate())
      var warning = $N('span')[0]
      assertEqual("This is a required field", warning.get("html"))
    }}
      
  }, {testLog: "singlelog"}); 
  
  new Test.Unit.Runner({
    // replace this with your real tests
    setup: function() {
      $('multi').grab(new Element('div', {
        id:this.name
      }).grab(new Element('h3', {
        html:this.name.sexify()
      })))
    },
    
    teardown: function() {
      //$('basic').set("html", "")
    },
    
    testNestedSelect: function() { with(this) {
      assert(true)
    }}
  }, {testLog: "nestedlog"}); 
  // For each Test.UnitRunner instance, specify the element id where results will be
  // published; e.g. div id="testlog"/ above.
  // That is, you can have multiple "new Test.Unit.Runner() { ... }" on this page, just
  // create more div id="testlog2"/div etc, and pass the element id to the hash above:
  // e.g. {testLog: "testlog2"}
// ]]
/script
/body
/html</content>
		</actual_file>
		<actual_file>
			<filename>text_box_test.html</filename>
			<content>!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
head
  titleJavaScript unit test file/title
  meta http-equiv="content-type" content="text/html; charset=utf-8" /
  script src="../assets/jsunittest.js" type="text/javascript"/script
  
  script src="../../dist/jsawesome.js" type="text/javascript"/script
  
  script src="../assets/test_helper.js" type="text/javascript"/script
  
  link rel="stylesheet" href="../assets/unittest.css" type="text/css" /
  style type="text/css" media="screen"
		label{
			display:block;
		}
		div.error {
		  margin-top:10px;
		}
	/style
/head
body

div id="content"

  div id="header"
    h1JSAwesome text box functional tests/h1
    p
      Functional tests for demonstrating basic text box usage.
    /p
  /div
  !-- Log output (one per Runner, via {testLog: "testlog"} option)--
  h2Single text boxes/h2
  div id="singlelog"/div
  div id="single"/div
  
  
  h2Multiple text boxes/h2
  div id="multilog"/div
  div id="multi"/div
  
  !-- Put sample/test html here --
/div

script type="text/javascript"
// ![CDATA[

  new Test.Unit.Runner({
    // replace this with your real tests
    setup: function() {
      $('single').grab(new Element('div', {
        id:this.name
      }).grab(new Element('h3', {
        html:this.name.sexify()
      })))
    },
    
    teardown: function() {
      //$('basic').set("html", "")
    },
    
    testSingleEmptyTextBox: function() { with(this) {
      var tb = new JSAwesome(name, [['text_box','']])
      tb.to_html()
      var box = $N('input.text_box')[0]
      assertEqual(name+"[text_box]", box.name)
      assertEqual("", box.value)
      var label = $N('label')[0]
      assertEqual("Text Box", label.get("html"))
    }},
    
    testSingleCustomTextBox: function() { with(this) {
      var tb = new JSAwesome(name, [['text_box','Default value']], {text_box:"Custom"})
      tb.to_html()
      var box = $N('input.text_box')[0]
      assertEqual(name+"[text_box]", box.name)
      assertEqual("Default value", box.value)
      var label = $N('label')[0]
      assertEqual("Custom", label.get("html"))
    }},
    
    testSingleValidatedTextBox: function() { with(this) {
      var tb = new JSAwesome(name, [['text_box', 'invalid']], {text_box: {validation:["^valid", "Is invalid"]}})
      tb.to_html()
      var box = $N('input.text_box')[0]
      assertEqual(name+"[text_box]", box.name)
      assertEqual("invalid", box.value)
      var label = $N('label')[0]
      assertEqual("Text Box", label.get("html"))
      assert(!tb.validate())
      var warning = $E('div.error span')
      assertEqual("Is invalid", warning.get("html"))
    }},
    
    testSingleRequiredTextBox: function() { with(this) {
      var tb = new JSAwesome(name, [['text_box', null]], {text_box: {required:true}})
      tb.to_html()
      var box = $N('input.text_box')[0]
      assertEqual(name+"[text_box]", box.name)
      assertEqual("", box.value)
      assert(!tb.validate())
      var warning = $N('div.error span')[0]
      assertEqual("This is a required field", warning.get("html"))
    }}
      
  }, {testLog: "singlelog"}); 
  
  new Test.Unit.Runner({
    // replace this with your real tests
    setup: function() {
      $('multi').grab(new Element('div', {
        id:this.name
      }).grab(new Element('h3', {
        html:this.name.sexify()
      })))
    },
    
    teardown: function() {
      //$('basic').set("html", "")
    },
    
    testMultipleEmptyTextBox: function() { with(this) {
      var tb = new JSAwesome(name, [[['text_box1',''], ['text_box2', '']]])
      tb.to_html()
      var boxes = $$('div.row_1 input')
      assertEqual(2, boxes.length)
      assertEqual(name+"[text_box1]", boxes[0].name)
      assertEqual(name+"[text_box2]", boxes[1].name)
      assertEqual("", boxes[0].value)
      assertEqual("", boxes[1].value)
      assertEqual("Text Box1", $E('label[for='+name+'_text_box1]').get("html"))
      assertEqual("Text Box2", $E('label[for='+name+'_text_box2]').get("html"))
    }},
    
    testMultipleCustomTextBox: function() { with(this) {
      var tb = new JSAwesome(name, [[['text_box1','default'], ['text_box2', '']]], {text_box2:"Custom label"})
      tb.to_html()
      var boxes = $N('input')
      var labels = $N('label')
      assertEqual(2, boxes.length)
      assertEqual(2, labels.length)
      assertEqual(name+"[text_box1]", boxes[0].name)      
      assertEqual("default", boxes[0].value)
      assertEqual("", boxes[1].value)
      assertEqual("Text Box1", labels[0].get("html"))
      assertEqual("Custom label", labels[1].get("html"))
    }},
    
    testMultipleValidatedTextBox: function() { with(this) {
      var tb = new JSAwesome(name, [
        [['text_box1','default'], ['text_box2', '']], 
        ['text_box3','']], {
          text_box2: {label:"custom", validation:[".{10}","Must be 10 chars long"]},
          text_box1: {vaidation:[".{7}","Must be 7 chars long"]}
      })
      tb.to_html()
      var boxes = $N('input')
      var labels = $N('label')
      assertEqual(3, boxes.length)
      assertEqual(3, labels.length)
      assertEqual(3, boxes.getElements('div').length)
      assertEqual("", boxes[1].value)
      assert(!tb.validate())
      var warning = $N('div.error span').getLast()
      assertEqual("Must be 10 chars long", warning.get("html"))
      assertEqual("custom", labels[1].get("html"))
    }},
    
    testMultipleRequiredTextBox: function() { with(this) {
      var tb = new JSAwesome(name, [
        [['text_box1','default'], ['text_box2', '']], 
        [['text_box3',''],['text_box4',''],['text_box5', '']]], {
          text_box2: {label:"custom", required:true},
          text_box1: {required:true},
          text_box5: {required:true}
      })
      tb.to_html()
      var boxes = $N('input')
      var labels = $N('label')
      assertEqual(5, boxes.length)
      assertEqual(5, labels.length)
      assertEqual(5, boxes.getElements('div').length)
      assertEqual("", boxes[1].value)
      assert(!tb.validate())
      var warnings = $N('div.error span')
      assertEqual("This is a required field", warnings.getLast().get("html"))
      assertEqual("This is a required field", warnings[0].get("html"))
      assertEqual("custom", labels[1].get("html"))
      assertMatch(/background/, boxes[1].get('style'))
      assertNoMatch(/background/, boxes[0].get('style'))
      assertMatch(/background/, boxes[4].get('style'))
    }},
  
  }, {testLog: "multilog"}); 
  // For each Test.UnitRunner instance, specify the element id where results will be
  // published; e.g. div id="testlog"/ above.
  // That is, you can have multiple "new Test.Unit.Runner() { ... }" on this page, just
  // create more div id="testlog2"/div etc, and pass the element id to the hash above:
  // e.g. {testLog: "testlog2"}
// ]]
/script
/body
/html</content>
		</actual_file>
		<actual_file>
			<filename>jsawesome_test.html</filename>
			<content>!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
head
  titleJavaScript unit test file/title
  meta http-equiv="content-type" content="text/html; charset=utf-8" /
  script src="../assets/jsunittest.js" type="text/javascript"/script
  
  script src="../../src/mootools.js" type="text/javascript"/script
  script src="../../src/base.js" type="text/javascript"/script
  
  link rel="stylesheet" href="../assets/unittest.css" type="text/css" /
/head
body

div id="content"

  div id="header"
    h1JavaScript unit test file/h1
    p
      This file tests strongjsawesome.js/strong.
    /p
  /div

  !-- Log output (one per Runner, via {testLog: "testlog"} option)--
  div id="testlog"/div
  
  !-- Put sample/test html here --
  div id="sample"/div
/div

script type="text/javascript"
// ![CDATA[

  new Test.Unit.Runner({
    // replace this with your real tests
    setup: function() {
      
    },
    
    teardown: function() {
      
    },
    
    testSimpleInstantiation: function() { with(this) {
      var js = new JSAwesome('sample', [['cool','']])
      assert(js)
      assertEqual('sample', js.name)
      assertEnumEqual([['cool','']], js.json)
      assertEnumEqual({}, js.labels)
    }}
      
  }, {testLog: "testlog"}); 
  // For each Test.UnitRunner instance, specify the element id where results will be
  // published; e.g. div id="testlog"/ above.
  // That is, you can have multiple "new Test.Unit.Runner() { ... }" on this page, just
  // create more div id="testlog2"/div etc, and pass the element id to the hash above:
  // e.g. {testLog: "testlog2"}
// ]]
/script
/body
/html</content>
		</actual_file>
	</actual_files>
</repo>
<repo>
	<id>31</id>
	<name>jspec</name>
	<description>A JavaScript BDD Testing Library</description>n	<owner>wycats</owner>
	<main_language>JavaScript</main_language>
	<created_at>2008-01-13T15:50:31Z</created_at>
	<updated_at>2014-01-02T14:49:05Z</updated_at>
	<clone_url>https://github.com/wycats/jspec.git</clone_url>
	<languages>
		<language>JavaScript</language>
	</languages>
	<branches>
		<branch>master</branch>
	</branches>
	<contributors>
		<contributor>wycats</contributor>
	</contributors>
	<commits>
		<commit>
			<sha>163aeb2c126c6a140f292cf1a4849a168ab5ef27</sha>
			<message>cleaning up files</message>
			<author_name>Phil Hagelberg</author_name>
			<author_date>2008-02-05T23:41:03Z</author_date>
			<author_email>phil@evri.com</author_email>
			<committer_name>Phil Hagelberg</committer_name>
			<committer_date>2008-02-05T23:41:03Z</committer_date>
			<committer_email>phil@evri.com</committer_email>
			<files>
				<file>
					<file_name>core.js</file_name>
					<diff>@@ -1,3 +1,4 @@
+// specs for jquery core
 module("core");
 
 test("Basic requirements", function() {</diff>
				</file>
				<file>
					<file_name>jspec.zip</file_name>
					<diff></diff>
				</file>
				<file>
					<file_name>jspec/index.html</file_name>
					<diff>@@ -1,63 +0,0 @@
-!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
-   "http://www.w3.org/TR/html4/strict.dtd"
-
-html lang="en"
-head
-	meta http-equiv="Content-Type" content="text/html; charset=utf-8"
-	titletester2/title
-	meta name="generator" content="TextMate http://macromates.com/"
-	meta name="author" content="Yehuda Katz"
-	script src="jspec.js"/script
-	script
-		window.onload = function() {
-			jspec.describe("JSpec", function() {
-				it("should support ==", function() {
-					(1).should("==", 1);
-					var arr = [];
-					arr.should("==", arr);
-					var obj = new Object;
-					obj.should("==", obj);
-					document.should("==", document);
-				});
-			
-				it("should support include", function() {
-					[1,2,3,4,5].should("include", 3);
-					[1,2,3,4,5].should_not("include", 3);
-					document.getElementsByTagName("div").should("include", document.getElementById("hello"))
-				});
-				
-				it("should support exists", function() {
-					document.should("exist");
-				});
-				
-				jspec.matchers["have_tag_name"] = {
-					describe: function(target, not) {
-						return jspec.compress_lines(this) + " should " + (not ? "not " : "") + "have " + target + " as its tag name."
-					},
-					matches: function(target) {
-						return (this.tagName && this.tagName == target) ? true : false;
-					},
-					failure_message: function(target, not) {
-						return "Expected " + this.toString() + (not ? " not " : " ") + "to have " + target + " as its tag name," +
-							" but was " + this.tagName;
-					}
-				};
-				
-				it("should support custom matchers", function() {
-					document.getElementById("wrapper").should("have_tag_name", "DIV");
-					document.getElementById("wrapper").should_not("have_tag_name", "SPAN");
-					document.getElementById("wrapper").should("have_tag_name", "SPAN");					
-				});
-			});
-		};
-	/script	
-	style type="text/css"
-		div#wrapper { display: none ;}
-	/style
-/head
-body
-
-	div id="wrapper"div id="hello"Hello/div/div
-
-/body
-/html</diff>
				</file>
				<file>
					<file_name>jspec/jspec.js</file_name>
					<diff>@@ -1,110 +0,0 @@
-jspec = {
-	fn_contents: function(fn) {
-		return fn.toString().match(/^[^\{]*{((.*\n*)*)}/m)[1];
-	},
-	DESCRIBE: 0,
-	IT_SHOULD: 1,
-	FAILURE: 2,
-	logger: function(state, message) {
-		switch(state) {
-			case jspec.DESCRIBE:
-				console.log("- " + message);
-				break;
-			case jspec.IT_SHOULD:
-				console.log("  - " + message);
-				break;
-			case jspec.FAILURE:
-				console.log("    " + message);
-				break;
-		}
-		
-	},
-	describe: function(str, desc) {
-		console.log(str);
-		var it = function(str, fn) {
-			jspec.logger(jspec.DESCRIBE, str)
-			fn.call();
-		};
-		Object.prototype.should = function(fn_str, to_compare, not) {
-		  try {
-			  var pass = jspec.matchers[fn_str].matches.call(this, to_compare);
-				if(not) var pass = !pass;
-			} catch(e) {
-			  var pass = null;
-			}
-			var should_string = (jspec.matchers[fn_str].describe && 
-			  jspec.matchers[fn_str].describe.call(this, to_compare, not)) || 
-			  this.toString() + " should " + (not ? "not " : "") + fn_str + " " + to_compare;
-			if(pass) {
-				jspec.logger(jspec.IT_SHOULD, should_string + " (PASS)");
-			}	else {
-				jspec.logger(jspec.IT_SHOULD, should_string + (pass == false ? " (FAIL)" : " (ERROR)"));
-				jspec.logger(jspec.FAILURE, jspec.matchers[fn_str].failure_message.call(this, to_compare, not))
-			}
-		};
-		Object.prototype.should_not = function(fn_str, to_compare) {
-			this.should(fn_str, to_compare, true);
-		};
-		x = desc.toString()
-		var fn_body = this.fn_contents(desc);
-		var fn = new Function("it", fn_body);
-		fn.call(this, it);
-		delete Object.prototype.should
-		delete Object.prototype.should_not
-	}
-}
-
-jspec.compress_lines = function(obj) {
-  if(obj instanceof Function) {
-    console.log(obj)
-    return obj.toString().match(/^([^\{]*) {/)[1];
-	} else if(obj instanceof Array) {
-		return "[" + obj.toString() + "]";
-  } else {
-    return obj.toString().replace(/\n\s*/g, "");
-  }
-}
-
-jspec.matchers = {};
-
-jspec.matchers["=="] = {
-  describe: function(target, not) {
-    return jspec.compress_lines(this) + " should " + (not ? "not " : "") + "equal " + jspec.compress_lines(target)
-  },
-	matches: function(target) {
-		return this == target;
-	},
-	failure_message: function(target, not) {
-		if (not)
-			return "Expected " + jspec.compress_lines(this) + " not to equal " + jspec.compress_lines(target);
-		else
-			return "Expected " + jspec.compress_lines(this) + ". Got " + jspec.compress_lines(target);
-	}
-}
-
-jspec.matchers["include"] = {
-	matches: function(target) {
-		if(Array.prototype.indexOf) return Array.prototype.indexOf.call(this, target) != -1;
-		else {
-			for(i=0,j=this.length;ij;i++) {
-				if(target == this[i]) return true;
-			}
-			return false;
-		}
-	},
-	failure_message: function(target, not) {
-		return "Expected [" + jspec.compress_lines(this) + "] " + (not ? "not " : "") + "to include " + target;
-	}  
-}
-
-jspec.matchers["exist"] = {
-  describe: function(target, not) {
-    return jspec.compress_lines(this) + " should " + (not ? "not " : "")  + "exist."
-  },
-  matches: function(target) {
-    return !!this;
-  },
-  failure_message: function(target, not) {
-    return "Expected " + (not ? "not " : "") + "to exist, but was " + jspec.compress_lines(this);
-  }
-}
\ No newline at end of file</diff>
				</file>
				<file>
					<file_name>tester2.html</file_name>
					<diff>@@ -29,6 +29,8 @@
         it("should support exists", function() {
          expect(document).to("exist");
         });
+
+				it("should support pending specs");
         
         jspec.matchers["have_tag_name"] = {
          describe: function(self, target, not) {</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>2c34a20fe1699ecdefb07b3bde51906da00ffc0b</sha>
			<message>added license file</message>
			<author_name>Phil Hagelberg</author_name>
			<author_date>2008-02-05T23:37:03Z</author_date>
			<author_email>phil@evri.com</author_email>
			<committer_name>Phil Hagelberg</committer_name>
			<committer_date>2008-02-05T23:37:03Z</committer_date>
			<committer_email>phil@evri.com</committer_email>
			<files>
				<file>
					<file_name>LICENSE</file_name>
					<diff>@@ -0,0 +1,25 @@
+Copyright (c) 2007-2008, Yehuda Katz and contributors
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without 
+modification, are permitted provided that the following conditions are met:
+
+* Redistributions of source code must retain the above copyright notice, thi
+  list of conditions and the following disclaimer.
+* Redistributions in binary form must reproduce the above copyright notice
+  this list of conditions and the following disclaimer in the documentatio
+  and/or other materials provided with the distribution.
+* Neither the name of the Evan Phoenix nor the names of its contributors 
+  may be used to endorse or promote products derived from this software 
+  without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE 
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>e3cffb960dfe24c1831522d22afc12d237dae302</sha>
			<message>added support for pending specs</message>
			<author_name>Phil Hagelberg</author_name>
			<author_date>2008-02-05T23:36:52Z</author_date>
			<author_email>phil@evri.com</author_email>
			<committer_name>Phil Hagelberg</committer_name>
			<committer_date>2008-02-05T23:36:52Z</committer_date>
			<committer_email>phil@evri.com</committer_email>
			<files>
				<file>
					<file_name>jspec.js</file_name>
					<diff>@@ -3,7 +3,7 @@ jspec = {
 		return fn.toString().match(/^[^\{]*{((.*\n*)*)}/m)[1];
 	},
 	TOP_LEVEL: 0, DESCRIBE: 1, IT_SHOULD_PASS: 2, IT_SHOULD_FAIL: 3, 
-	FAILURE: 4, DONE_EXAMPLE: 5, DONE_GROUP: 6,
+	FAILURE: 4, DONE_EXAMPLE: 5, DONE_GROUP: 6, PENDING: 7,
 	logger: function(state, message) {
 		switch(state) {
 			case jspec.TOP_LEVEL:
@@ -27,15 +27,23 @@ jspec = {
 				break;
 			case jspec.DONE_GROUP:
 				console.groupEnd();
+  			break;
+  		case jspec.PENDING:
+    		console.warn("Pending: " + message);
+  			break;
 		}
 		
 	},
 	describe: function(str, desc) {
 		jspec.logger(jspec.TOP_LEVEL, str);
 		var it = function(str, fn) {
-			jspec.logger(jspec.DESCRIBE, str);
-			fn();
-			jspec.logger(jspec.DONE_EXAMPLE);			
+			if(fn) {
+				jspec.logger(jspec.DESCRIBE, str);
+				fn();
+				jspec.logger(jspec.DONE_EXAMPLE);
+			} else {
+				jspec.logger(jspec.PENDING, str);
+			};
 		};
 		var Expectation = function(p) { this.expectation = p; };
 		Expectation.prototype.to = function(fn_str, to_compare, not) {</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>798da3d0aa19f5456efcbe8b5ba1df4628c5207b</sha>
			<message>Prettier console.logs</message>
			<author_name>Yehuda Katz</author_name>
			<author_date>2008-01-17T09:06:01Z</author_date>
			<author_email>wycats@gmail.com</author_email>
			<committer_name>Yehuda Katz</committer_name>
			<committer_date>2008-01-17T09:06:01Z</committer_date>
			<committer_email>wycats@gmail.com</committer_email>
			<files>
				<file>
					<file_name>jspec.js</file_name>
					<diff>@@ -2,24 +2,31 @@ jspec = {
 	fn_contents: function(fn) {
 		return fn.toString().match(/^[^\{]*{((.*\n*)*)}/m)[1];
 	},
-	TOP_LEVEL: 0,
-	DESCRIBE: 1,
-	IT_SHOULD: 2,
-	FAILURE: 3,
+	TOP_LEVEL: 0, DESCRIBE: 1, IT_SHOULD_PASS: 2, IT_SHOULD_FAIL: 3, 
+	FAILURE: 4, DONE_EXAMPLE: 5, DONE_GROUP: 6,
 	logger: function(state, message) {
 		switch(state) {
 			case jspec.TOP_LEVEL:
-				console.log(message);
+				console.group(message);
 				break;
 			case jspec.DESCRIBE:
-				console.log("- " + message);
+				console.group(message);
 				break;
-			case jspec.IT_SHOULD:
-				console.log("  - " + message);
+			case jspec.IT_SHOULD_PASS:
+				console.info(message);
+				break;
+			case jspec.IT_SHOULD_FAIL:
+				console.group(message);
 				break;
 			case jspec.FAILURE:
-				console.log("    " + message);
+				console.error(message);
+				console.groupEnd();
+				break;
+			case jspec.DONE_EXAMPLE:
+				console.groupEnd();
 				break;
+			case jspec.DONE_GROUP:
+				console.groupEnd();
 		}
 		
 	},
@@ -28,6 +35,7 @@ jspec = {
 		var it = function(str, fn) {
 			jspec.logger(jspec.DESCRIBE, str);
 			fn();
+			jspec.logger(jspec.DONE_EXAMPLE);			
 		};
 		var Expectation = function(p) { this.expectation = p; };
 		Expectation.prototype.to = function(fn_str, to_compare, not) {
@@ -41,9 +49,9 @@ jspec = {
 			  jspec.matchers[fn_str].describe(this.expectation, to_compare, not)) || 
 			  this.toString() + " should " + (not ? "not " : "") + fn_str + " " + to_compare;
 			if(pass) {
-				jspec.logger(jspec.IT_SHOULD, should_string + " (PASS)");
+				jspec.logger(jspec.IT_SHOULD_PASS, should_string + " (PASS)");
 			}	else {
-				jspec.logger(jspec.IT_SHOULD, should_string + (pass == false ? " (FAIL)" : " (ERROR)"));
+				jspec.logger(jspec.IT_SHOULD_FAIL, should_string + (pass == false ? " (FAIL)" : " (ERROR)"));
 				jspec.logger(jspec.FAILURE, jspec.matchers[fn_str].failure_message(this.expectation, to_compare, not))
 			}
 		}
@@ -53,6 +61,7 @@ jspec = {
 		var fn_body = this.fn_contents(desc);
 		var fn = new Function("it", "expect", fn_body);
 		fn.call(this, it, expect);
+		jspec.logger(jspec.DONE_GROUP);
 	}
 }
 </diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>7860e59d803f330f3c3955eae7cde9e7994bfda9</sha>
			<message>Boooo... some necessary changes.</message>
			<author_name>Yehuda Katz</author_name>
			<author_date>2008-01-17T08:51:01Z</author_date>
			<author_email>wycats@gmail.com</author_email>
			<committer_name>Yehuda Katz</committer_name>
			<committer_date>2008-01-17T08:51:01Z</committer_date>
			<committer_email>wycats@gmail.com</committer_email>
			<files>
				<file>
					<file_name>jspec.js</file_name>
					<diff>@@ -27,34 +27,32 @@ jspec = {
 		jspec.logger(jspec.TOP_LEVEL, str);
 		var it = function(str, fn) {
 			jspec.logger(jspec.DESCRIBE, str);
-			fn.call();
+			fn();
 		};
-		Object.prototype.should = function(fn_str, to_compare, not) {
+		var Expectation = function(p) { this.expectation = p; };
+		Expectation.prototype.to = function(fn_str, to_compare, not) {
 		  try {
-			  var pass = jspec.matchers[fn_str].matches.call(this, to_compare);
+			  var pass = jspec.matchers[fn_str].matches(this.expectation, to_compare);
 				if(not) var pass = !pass;
 			} catch(e) {
 			  var pass = null;
 			}
 			var should_string = (jspec.matchers[fn_str].describe && 
-			  jspec.matchers[fn_str].describe.call(this, to_compare, not)) || 
+			  jspec.matchers[fn_str].describe(this.expectation, to_compare, not)) || 
 			  this.toString() + " should " + (not ? "not " : "") + fn_str + " " + to_compare;
 			if(pass) {
 				jspec.logger(jspec.IT_SHOULD, should_string + " (PASS)");
 			}	else {
 				jspec.logger(jspec.IT_SHOULD, should_string + (pass == false ? " (FAIL)" : " (ERROR)"));
-				jspec.logger(jspec.FAILURE, jspec.matchers[fn_str].failure_message.call(this, to_compare, not))
+				jspec.logger(jspec.FAILURE, jspec.matchers[fn_str].failure_message(this.expectation, to_compare, not))
 			}
-		};
-		Object.prototype.should_not = function(fn_str, to_compare) {
-			this.should(fn_str, to_compare, true);
-		};
+		}
+		Expectation.prototype.not_to = function(fn_str, to_compare) { this.to(fn_str, to_compare, true) }
+		var expect = function(p) { return new Expectation(p) };
 		x = desc.toString()
 		var fn_body = this.fn_contents(desc);
-		var fn = new Function("it", fn_body);
-		fn.call(this, it);
-		delete Object.prototype.should
-		delete Object.prototype.should_not
+		var fn = new Function("it", "expect", fn_body);
+		fn.call(this, it, expect);
 	}
 }
 
@@ -65,6 +63,9 @@ jspec.print_object = function(obj) {
     return obj.toString().match(/^([^\{]*) {/)[1];
 	} else if(obj instanceof Array) {
 		return "[" + obj.toString() + "]";
+	} else if(obj instanceof HTMLElement) {
+		return "" + obj.tagName + " " + (obj.className != "" ? "class='" + obj.className + "'" : "") + 
+			(obj.id != "" ? "id='" + obj.id + "'" : "") + "";
   } else {
     return obj.toString().replace(/\n\s*/g, "");
   }
@@ -75,43 +76,43 @@ jspec.print_object = function(obj) {
 jspec.matchers = {};
 
 jspec.matchers["=="] = {
-  describe: function(target, not) {
-    return jspec.print_object(this) + " should " + (not ? "not " : "") + "equal " + jspec.print_object(target)
+  describe: function(self, target, not) {
+    return jspec.print_object(self) + " should " + (not ? "not " : "") + "equal " + jspec.print_object(target)
   },
-	matches: function(target) {
-		return this == target;
+	matches: function(self, target) {
+		return self == target;
 	},
-	failure_message: function(target, not) {
+	failure_message: function(self, target, not) {
 		if (not)
-			return "Expected " + jspec.print_object(this) + " not to equal " + jspec.print_object(target);
+			return "Expected " + jspec.print_object(self) + " not to equal " + jspec.print_object(target);
 		else
-			return "Expected " + jspec.print_object(this) + ". Got " + jspec.print_object(target);
+			return "Expected " + jspec.print_object(self) + ". Got " + jspec.print_object(target);
 	}
 }
 
 jspec.matchers["include"] = {
-	matches: function(target) {
-		if(Array.prototype.indexOf) return Array.prototype.indexOf.call(this, target) != -1;
+	matches: function(self, target) {
+		if(Array.prototype.indexOf) return Array.prototype.indexOf.call(self, target) != -1;
 		else {
-			for(i=0,j=this.length;ij;i++) {
-				if(target == this[i]) return true;
+			for(i=0,j=self.length;ij;i++) {
+				if(target == self[i]) return true;
 			}
 			return false;
 		}
 	},
-	failure_message: function(target, not) {
-		return "Expected [" + jspec.print_object(this) + "] " + (not ? "not " : "") + "to include " + target;
+	failure_message: function(self, target, not) {
+		return "Expected [" + jspec.print_object(self) + "] " + (not ? "not " : "") + "to include " + target;
 	}  
 }
 
 jspec.matchers["exist"] = {
-  describe: function(target, not) {
-    return jspec.print_object(this) + " should " + (not ? "not " : "")  + "exist."
+  describe: function(self, target, not) {
+    return jspec.print_object(self) + " should " + (not ? "not " : "")  + "exist."
   },
-  matches: function(target) {
+  matches: function(self, target) {
     return !!this;
   },
-  failure_message: function(target, not) {
-    return "Expected " + (not ? "not " : "") + "to exist, but was " + jspec.print_object(this);
+  failure_message: function(self, target, not) {
+    return "Expected " + (not ? "not " : "") + "to exist, but was " + jspec.print_object(self);
   }
 }
\ No newline at end of file</diff>
				</file>
				<file>
					<file_name>tester2.html</file_name>
					<diff>@@ -12,42 +12,42 @@
 		window.onload = function() {
 			jspec.describe("JSpec", function() {
 				it("should support ==", function() {
-					(1).should("==", 1);
+					expect(1).to("==", 1);
 					var arr = [];
-					arr.should("==", arr);
+					expect(arr).to("==", arr);
 					var obj = new Object;
-					obj.should("==", obj);
-					document.should("==", document);
+					expect(obj).to("==", obj);
+					expect(document).to("==", document);
 				});
 			
-				it("should support include", function() {
-					[1,2,3,4,5].should("include", 3);
-					[1,2,3,4,5].should_not("include", 3);
-					document.getElementsByTagName("div").should("include", document.getElementById("hello"))
-				});
-				
-				it("should support exists", function() {
-					document.should("exist");
-				});
-				
-				jspec.matchers["have_tag_name"] = {
-					describe: function(target, not) {
-						return jspec.print_object(this) + " should " + (not ? "not " : "") + "have " + target + " as its tag name."
-					},
-					matches: function(target) {
-						return (this.tagName && this.tagName == target) ? true : false;
-					},
-					failure_message: function(target, not) {
-						return "Expected " + this.toString() + (not ? " not " : " ") + "to have " + target + " as its tag name," +
-							" but was " + this.tagName;
-					}
-				};
-				
-				it("should support custom matchers", function() {
-					document.getElementById("wrapper").should("have_tag_name", "DIV");
-					document.getElementById("wrapper").should_not("have_tag_name", "SPAN");
-					document.getElementById("wrapper").should("have_tag_name", "SPAN");					
-				});
+        it("should support include", function() {
+         expect([1,2,3,4,5]).to("include", 3);
+         expect([1,2,3,4,5]).not_to("include", 3);
+         expect(document.getElementsByTagName("div")).to("include", document.getElementById("hello"))
+        });
+        
+        it("should support exists", function() {
+         expect(document).to("exist");
+        });
+        
+        jspec.matchers["have_tag_name"] = {
+         describe: function(self, target, not) {
+           return jspec.print_object(self) + " should " + (not ? "not " : "") + "have " + target + " as its tag name."
+         },
+         matches: function(self, target) {
+           return (self.tagName && self.tagName == target) ? true : false;
+         },
+         failure_message: function(self, target, not) {
+           return "Expected " + jspec.print_object(self) + (not ? " not " : " ") + "to have " + target + " as its tag name," +
+             " but was " + self.tagName;
+         }
+        };
+        
+        it("should support custom matchers", function() {
+         expect(document.getElementById("wrapper")).to("have_tag_name", "DIV");
+         expect(document.getElementById("wrapper")).to("have_tag_name", "SPAN");
+         expect(document.getElementById("wrapper")).not_to("have_tag_name", "SPAN");         
+        });
 			});
 		};
 	/script	</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>faaae412902604f844dc18fc52b0ff17727aabaf</sha>
			<message>Initial checkin</message>
			<author_name>Yehuda Katz</author_name>
			<author_date>2008-01-13T08:01:19Z</author_date>
			<author_email>wycats@gmail.com</author_email>
			<committer_name>Yehuda Katz</committer_name>
			<committer_date>2008-01-13T08:01:19Z</committer_date>
			<committer_email>wycats@gmail.com</committer_email>
			<files>
			</files>
		</commit>
	</commits>
	<actual_files>
		<actual_file>
			<filename>core.js</filename>
			<content>// specs for jquery core
module("core");

test("Basic requirements", function() {
	expect(7);
	ok( Array.prototype.push, "Array.push()" );
	ok( Function.prototype.apply, "Function.apply()" );
	ok( document.getElementById, "getElementById" );
	ok( document.getElementsByTagName, "getElementsByTagName" );
	ok( RegExp, "RegExp" );
	ok( jQuery, "jQuery" );
	ok( $, "$()" );
});

test("$()", function() {
	expect(5);
	
	var main = $("#main");
	isSet( $("div p", main).get(), q("sndp", "en", "sap"), "Basic selector with jQuery object as context" );
	
	// make sure this is handled
	$('p\r\n/p');
	ok( true, "Check for \\r and \\n in jQuery()" );
	
	/* // Disabled until we add this functionality in
	var pass = true;
	try {
		$("divTesting/div").appendTo(document.getElementById("iframe").contentDocument.body);
	} catch(e){
		pass = false;
	}
	ok( pass, "$('&lt;tag&gt;') needs optional document parameter to ease cross-frame DOM wrangling, see #968" );*/

	var code = $("code/");
	equals( code.length, 1, "Correct number of elements generated for code" );
	var img = $("img/");
	equals( img.length, 1, "Correct number of elements generated for img" );
	var div = $("div/hr/code/b/");
	equals( div.length, 4, "Correct number of elements generated for div hr code b" );
});


test("noConflict", function() {
	expect(6);
	
	var old = jQuery;
	var newjQuery = jQuery.noConflict();

	ok( newjQuery == old, "noConflict returned the jQuery object" );
	ok( jQuery == old, "Make sure jQuery wasn't touched." );
	ok( $ == "$", "Make sure $ was reverted." );

	jQuery = $ = old;

	newjQuery = jQuery.noConflict(true);

	ok( newjQuery == old, "noConflict returned the jQuery object" );
	ok( jQuery == "jQuery", "Make sure jQuery was reverted." );
	ok( $ == "$", "Make sure $ was reverted." );

	jQuery = $ = old;
});

test("isFunction", function() {
	expect(21);

	// Make sure that false values return false
	ok( !jQuery.isFunction(), "No Value" );
	ok( !jQuery.isFunction( null ), "null Value" );
	ok( !jQuery.isFunction( undefined ), "undefined Value" );
	ok( !jQuery.isFunction( "" ), "Empty String Value" );
	ok( !jQuery.isFunction( 0 ), "0 Value" );

	// Check built-ins
	// Safari uses "(Internal Function)"
	ok( jQuery.isFunction(String), "String Function" );
	ok( jQuery.isFunction(Array), "Array Function" );
	ok( jQuery.isFunction(Object), "Object Function" );
	ok( jQuery.isFunction(Function), "Function Function" );

	// When stringified, this could be misinterpreted
	var mystr = "function";
	ok( !jQuery.isFunction(mystr), "Function String" );

	// When stringified, this could be misinterpreted
	var myarr = [ "function" ];
	ok( !jQuery.isFunction(myarr), "Function Array" );

	// When stringified, this could be misinterpreted
	var myfunction = { "function": "test" };
	ok( !jQuery.isFunction(myfunction), "Function Object" );

	// Make sure normal functions still work
	var fn = function(){};
	ok( jQuery.isFunction(fn), "Normal Function" );

	var obj = document.createElement("object");

	// Firefox says this is a function
	ok( !jQuery.isFunction(obj), "Object Element" );

	// IE says this is an object
	ok( jQuery.isFunction(obj.getAttribute), "getAttribute Function" );

	var nodes = document.body.childNodes;

	// Safari says this is a function
	ok( !jQuery.isFunction(nodes), "childNodes Property" );

	var first = document.body.firstChild;
	
	// Normal elements are reported ok everywhere
	ok( !jQuery.isFunction(first), "A normal DOM Element" );

	var input = document.createElement("input");
	input.type = "text";
	document.body.appendChild( input );

	// IE says this is an object
	ok( jQuery.isFunction(input.focus), "A default function property" );

	document.body.removeChild( input );

	var a = document.createElement("a");
	a.href = "some-function";
	document.body.appendChild( a );

	// This serializes with the word 'function' in it
	ok( !jQuery.isFunction(a), "Anchor Element" );

	document.body.removeChild( a );

	// Recursive function calls have lengths and array-like properties
	function callme(callback){
		function fn(response){
			callback(response);
		}

		ok( jQuery.isFunction(fn), "Recursive Function Call" );

    	fn({ some: "data" });
	};

	callme(function(){
    	callme(function(){});
	});
});

var foo = false;

test("$('html')", function() {
	expect(4);
	
	reset();
	foo = false;
	var s = $("scriptvar foo='test';/script")[0];
	ok( s, "Creating a script" );
	ok( !foo, "Make sure the script wasn't executed prematurely" );
	$("body").append(s);
	ok( foo, "Executing a scripts contents in the right context" );
	
	reset();
	ok( $("link rel='stylesheet'/")[0], "Creating a link" );
	
	reset();
});

test("length", function() {
	expect(1);
	ok( $("p").length == 6, "Get Number of Elements Found" );
});

test("size()", function() {
	expect(1);
	ok( $("p").size() == 6, "Get Number of Elements Found" );
});

test("get()", function() {
	expect(1);
	isSet( $("p").get(), q("firstp","ap","sndp","en","sap","first"), "Get All Elements" );
});

test("get(Number)", function() {
	expect(1);
	ok( $("p").get(0) == document.getElementById("firstp"), "Get A Single Element" );
});

test("add(String|Element|Array)", function() {
	expect(7);
	isSet( $("#sndp").add("#en").add("#sap").get(), q("sndp", "en", "sap"), "Check elements from document" );
	isSet( $("#sndp").add( $("#en")[0] ).add( $("#sap") ).get(), q("sndp", "en", "sap"), "Check elements from document" );
	ok( $([]).add($("#form")[0].elements).length = 13, "Check elements from array" );
	
	var x = $([]).add($("p id='x1'xxx/p")).add($("p id='x2'xxx/p"));
	ok( x[0].id == "x1", "Check on-the-fly element1" );
	ok( x[1].id == "x2", "Check on-the-fly element2" );
	
	var x = $([]).add("p id='x1'xxx/p").add("p id='x2'xxx/p");
	ok( x[0].id == "x1", "Check on-the-fly element1" );
	ok( x[1].id == "x2", "Check on-the-fly element2" );
});

test("each(Function)", function() {
	expect(1);
	var div = $("div");
	div.each(function(){this.foo = 'zoo';});
	var pass = true;
	for ( var i = 0; i  div.size(); i++ ) {
	  if ( div.get(i).foo != "zoo" ) pass = false;
	}
	ok( pass, "Execute a function, Relative" );
});

test("index(Object)", function() {
	expect(8);
	ok( $([window, document]).index(window) == 0, "Check for index of elements" );
	ok( $([window, document]).index(document) == 1, "Check for index of elements" );
	var inputElements = $('#radio1,#radio2,#check1,#check2');
	ok( inputElements.index(document.getElementById('radio1')) == 0, "Check for index of elements" );
	ok( inputElements.index(document.getElementById('radio2')) == 1, "Check for index of elements" );
	ok( inputElements.index(document.getElementById('check1')) == 2, "Check for index of elements" );
	ok( inputElements.index(document.getElementById('check2')) == 3, "Check for index of elements" );
	ok( inputElements.index(window) == -1, "Check for not found index" );
	ok( inputElements.index(document) == -1, "Check for not found index" );
});

test("attr(String)", function() {
	expect(13);
	ok( $('#text1').attr('value') == "Test", 'Check for value attribute' );
	ok( $('#text1').attr('type') == "text", 'Check for type attribute' );
	ok( $('#radio1').attr('type') == "radio", 'Check for type attribute' );
	ok( $('#check1').attr('type') == "checkbox", 'Check for type attribute' );
	ok( $('#simon1').attr('rel') == "bookmark", 'Check for rel attribute' );
	ok( $('#google').attr('title') == "Google!", 'Check for title attribute' );
	ok( $('#mark').attr('hreflang') == "en", 'Check for hreflang attribute' );
	ok( $('#en').attr('lang') == "en", 'Check for lang attribute' );
	ok( $('#simon').attr('class') == "blog link", 'Check for class attribute' );
	ok( $('#name').attr('name') == "name", 'Check for name attribute' );
	ok( $('#text1').attr('name') == "action", 'Check for name attribute' );
	ok( $('#form').attr('action').indexOf("formaction") = 0, 'Check for action attribute' );
	
	$('a id="tAnchor5"/a').attr('href', '#5').appendTo('#main'); // using innerHTML in IE causes href attribute to be serialized to the full path
	ok( $('#tAnchor5').attr('href') == "#5", 'Check for non-absolute href (an anchor)' );
});

if ( !isLocal ) {
    test("attr(String) in XML Files", function() {
        expect(2);
        stop();
        $.get("data/dashboard.xml", function(xml) {
            ok( $("locations", xml).attr("class") == "foo", "Check class attribute in XML document" );
            ok( $("location", xml).attr("for") == "bar", "Check for attribute in XML document" );
            start();
        });
    });
}

test("attr(String, Function)", function() {
	expect(2);
	ok( $('#text1').attr('value', function() { return this.id })[0].value == "text1", "Set value from id" );
	ok( $('#text1').attr('title', function(i) { return i }).attr('title') == "0", "Set value with an index");
});

test("attr(Hash)", function() {
	expect(1);
	var pass = true;
	$("div").attr({foo: 'baz', zoo: 'ping'}).each(function(){
	  if ( this.getAttribute('foo') != "baz" && this.getAttribute('zoo') != "ping" ) pass = false;
	});
	ok( pass, "Set Multiple Attributes" );
});

test("attr(String, Object)", function() {
	expect(12);
	var div = $("div");
	div.attr("foo", "bar");
	var pass = true;
	for ( var i = 0; i  div.size(); i++ ) {
	  if ( div.get(i).getAttribute('foo') != "bar" ) pass = false;
	}
	ok( pass, "Set Attribute" );

	ok( $("#foo").attr({"width": null}), "Try to set an attribute to nothing" );	
	
	$("#name").attr('name', 'something');
	ok( $("#name").attr('name') == 'something', 'Set name attribute' );
	$("#check2").attr('checked', true);
	ok( document.getElementById('check2').checked == true, 'Set checked attribute' );
	$("#check2").attr('checked', false);
	ok( document.getElementById('check2').checked == false, 'Set checked attribute' );
	$("#text1").attr('readonly', true);
	ok( document.getElementById('text1').readOnly == true, 'Set readonly attribute' );
	$("#text1").attr('readonly', false);
	ok( document.getElementById('text1').readOnly == false, 'Set readonly attribute' );
	$("#name").attr('maxlength', '5');
	ok( document.getElementById('name').maxLength == '5', 'Set maxlength attribute' );

	reset();

	var type = $("#check2").attr('type');
	var thrown = false;
	try {
		$("#check2").attr('type','hidden');
	} catch(e) {
		thrown = true;
	}
	ok( thrown, "Exception thrown when trying to change type property" );
	equals( type, $("#check2").attr('type'), "Verify that you can't change the type of an input element" );

	var check = document.createElement("input");
	var thrown = true;
	try {
		$(check).attr('type','checkbox');
	} catch(e) {
		thrown = false;
	}
	ok( thrown, "Exception thrown when trying to change type property" );
	equals( "checkbox", $(check).attr('type'), "Verify that you can change the type of an input element that isn't in the DOM" );
});

if ( !isLocal ) {
    test("attr(String, Object) - Loaded via XML document", function() {
        expect(2);
        stop();
        $.get('data/dashboard.xml', function(xml) { 
              var titles = [];
              $('tab', xml).each(function() {
                    titles.push($(this).attr('title'));
              });
              ok( titles[0] == 'Location', 'attr() in XML context: Check first title' );
              ok( titles[1] == 'Users', 'attr() in XML context: Check second title' );
              start();
        });
    });
}

test("css(String|Hash)", function() {
	expect(19);
	
	ok( $('#main').css("display") == 'none', 'Check for css property "display"');
	
	ok( $('#foo').is(':visible'), 'Modifying CSS display: Assert element is visible');
	$('#foo').css({display: 'none'});
	ok( !$('#foo').is(':visible'), 'Modified CSS display: Assert element is hidden');
	$('#foo').css({display: 'block'});
	ok( $('#foo').is(':visible'), 'Modified CSS display: Assert element is visible');
	
	$('#floatTest').css({styleFloat: 'right'});
	ok( $('#floatTest').css('styleFloat') == 'right', 'Modified CSS float using "styleFloat": Assert float is right');
	$('#floatTest').css({cssFloat: 'left'});
	ok( $('#floatTest').css('cssFloat') == 'left', 'Modified CSS float using "cssFloat": Assert float is left');
	$('#floatTest').css({'float': 'right'});
	ok( $('#floatTest').css('float') == 'right', 'Modified CSS float using "float": Assert float is right');
	$('#floatTest').css({'font-size': '30px'});
	ok( $('#floatTest').css('font-size') == '30px', 'Modified CSS font-size: Assert font-size is 30px');
	
	$.each("0,0.25,0.5,0.75,1".split(','), function(i, n) {
		$('#foo').css({opacity: n});
		ok( $('#foo').css('opacity') == parseFloat(n), "Assert opacity is " + parseFloat(n) + " as a String" );
		$('#foo').css({opacity: parseFloat(n)});
		ok( $('#foo').css('opacity') == parseFloat(n), "Assert opacity is " + parseFloat(n) + " as a Number" );
	});	
	$('#foo').css({opacity: ''});
	ok( $('#foo').css('opacity') == '1', "Assert opacity is 1 when set to an empty String" );
});

test("css(String, Object)", function() {
	expect(18);
	ok( $('#foo').is(':visible'), 'Modifying CSS display: Assert element is visible');
	$('#foo').css('display', 'none');
	ok( !$('#foo').is(':visible'), 'Modified CSS display: Assert element is hidden');
	$('#foo').css('display', 'block');
	ok( $('#foo').is(':visible'), 'Modified CSS display: Assert element is visible');
	
	$('#floatTest').css('styleFloat', 'left');
	ok( $('#floatTest').css('styleFloat') == 'left', 'Modified CSS float using "styleFloat": Assert float is left');
	$('#floatTest').css('cssFloat', 'right');
	ok( $('#floatTest').css('cssFloat') == 'right', 'Modified CSS float using "cssFloat": Assert float is right');
	$('#floatTest').css('float', 'left');
	ok( $('#floatTest').css('float') == 'left', 'Modified CSS float using "float": Assert float is left');
	$('#floatTest').css('font-size', '20px');
	ok( $('#floatTest').css('font-size') == '20px', 'Modified CSS font-size: Assert font-size is 20px');
	
	$.each("0,0.25,0.5,0.75,1".split(','), function(i, n) {
		$('#foo').css('opacity', n);
		ok( $('#foo').css('opacity') == parseFloat(n), "Assert opacity is " + parseFloat(n) + " as a String" );
		$('#foo').css('opacity', parseFloat(n));
		ok( $('#foo').css('opacity') == parseFloat(n), "Assert opacity is " + parseFloat(n) + " as a Number" );
	});
	$('#foo').css('opacity', '');
	ok( $('#foo').css('opacity') == '1', "Assert opacity is 1 when set to an empty String" );
});

test("text()", function() {
	expect(1);
	var expected = "This link has class=\"blog\": Simon Willison's Weblog";
	ok( $('#sap').text() == expected, 'Check for merged text of more then one element.' );
});

test("wrap(String|Element)", function() {
	expect(6);
	var defaultText = 'Try them out:'
	var result = $('#first').wrap('div class="red"span/span/div').text();
	ok( defaultText == result, 'Check for wrapping of on-the-fly html' );
	ok( $('#first').parent().parent().is('.red'), 'Check if wrapper has class "red"' );

	reset();
	var defaultText = 'Try them out:'
	var result = $('#first').wrap(document.getElementById('empty')).parent();
	ok( result.is('ol'), 'Check for element wrapping' );
	ok( result.text() == defaultText, 'Check for element wrapping' );
	
	reset();
	$('#check1').click(function() {		
		var checkbox = this;		
		ok( checkbox.checked, "Checkbox's state is erased after wrap() action, see #769" );
		$(checkbox).wrap( 'div id="c1" style="display:none;"/div' );
		ok( checkbox.checked, "Checkbox's state is erased after wrap() action, see #769" );
	}).click();
});

test("wrapAll(String|Element)", function() {
	expect(8);
	var prev = $("#first")[0].previousSibling;
	var p = $("#first")[0].parentNode;
	var result = $('#first,#firstp').wrapAll('div class="red"div id="tmp"/div/div');
	equals( result.parent().length, 1, 'Check for wrapping of on-the-fly html' );
	ok( $('#first').parent().parent().is('.red'), 'Check if wrapper has class "red"' );
	ok( $('#firstp').parent().parent().is('.red'), 'Check if wrapper has class "red"' );
	equals( $("#first").parent().parent()[0].previousSibling, prev, "Correct Previous Sibling" );
	equals( $("#first").parent().parent()[0].parentNode, p, "Correct Parent" );

	reset();
	var prev = $("#first")[0].previousSibling;
	var p = $("#first")[0].parentNode;
	var result = $('#first,#firstp').wrapAll(document.getElementById('empty'));
	equals( $("#first").parent()[0], $("#firstp").parent()[0], "Same Parent" );
	equals( $("#first").parent()[0].previousSibling, prev, "Correct Previous Sibling" );
	equals( $("#first").parent()[0].parentNode, p, "Correct Parent" );
});

test("wrapInner(String|Element)", function() {
	expect(6);
	var num = $("#first").children().length;
	var result = $('#first').wrapInner('div class="red"div id="tmp"/div/div');
	equals( $("#first").children().length, 1, "Only one child" );
	ok( $("#first").children().is(".red"), "Verify Right Element" );
	equals( $("#first").children().children().children().length, num, "Verify Elements Intact" );

	reset();
	var num = $("#first").children().length;
	var result = $('#first').wrapInner(document.getElementById('empty'));
	equals( $("#first").children().length, 1, "Only one child" );
	ok( $("#first").children().is("#empty"), "Verify Right Element" );
	equals( $("#first").children().children().length, num, "Verify Elements Intact" );
});

test("append(String|Element|Array&lt;Element&gt;|jQuery)", function() {
	expect(18);
	var defaultText = 'Try them out:'
	var result = $('#first').append('bbuga/b');
	ok( result.text() == defaultText + 'buga', 'Check if text appending works' );
	ok( $('#select3').append('option value="appendTest"Append Test/option').find('option:last-child').attr('value') == 'appendTest', 'Appending html options to select element');
	
	reset();
	var expected = "This link has class=\"blog\": Simon Willison's WeblogTry them out:";
	$('#sap').append(document.getElementById('first'));
	ok( expected == $('#sap').text(), "Check for appending of element" );
	
	reset();
	expected = "This link has class=\"blog\": Simon Willison's WeblogTry them out:Yahoo";
	$('#sap').append([document.getElementById('first'), document.getElementById('yahoo')]);
	ok( expected == $('#sap').text(), "Check for appending of array of elements" );
	
	reset();
	expected = "This link has class=\"blog\": Simon Willison's WeblogTry them out:Yahoo";
	$('#sap').append($("#first, #yahoo"));
	ok( expected == $('#sap').text(), "Check for appending of jQuery object" );

	reset();
	$("#sap").append( 5 );
	ok( $("#sap")[0].innerHTML.match( /5$/ ), "Check for appending a number" );

	reset();
	$("#sap").append( " text with spaces " );
	ok( $("#sap")[0].innerHTML.match(/ text with spaces $/), "Check for appending text with spaces" );

	reset();
	ok( $("#sap").append([]), "Check for appending an empty array." );
	ok( $("#sap").append(""), "Check for appending an empty string." );
	ok( $("#sap").append(document.getElementsByTagName("foo")), "Check for appending an empty nodelist." );
	
	reset();
	$("#sap").append(document.getElementById('form'));
	ok( $("#sapform").size() == 1, "Check for appending a form" );  // Bug #910

	reset();
	var pass = true;
	try {
		$( $("iframe")[0].contentWindow.document.body ).append("divtest/div");
	} catch(e) {
		pass = false;
	}

	ok( pass, "Test for appending a DOM node to the contents of an IFrame" );
	
	reset();
	$('fieldset/').appendTo('#form').append('legend id="legend"test/legend');
	t( 'Append legend', '#legend', ['legend'] );
	
	reset();
	$('#select1').append('OPTIONTest/OPTION');
	ok( $('#select1 option:last').text() == "Test", "Appending &lt;OPTION&gt; (all caps)" );
	
	$('#table').append('colgroup/colgroup');
	ok( $('#table colgroup').length, "Append colgroup" );
	
	$('#table colgroup').append('col/');
	ok( $('#table colgroup col').length, "Append col" );
	
	reset();
	$('#table').append('caption/caption');
	ok( $('#table caption').length, "Append caption" );

	reset();
	$('form:last')
		.append('select id="appendSelect1"/select')
		.append('select id="appendSelect2"optionTest/option/select');
	
	t( "Append Select", "#appendSelect1, #appendSelect2", ["appendSelect1", "appendSelect2"] );
});

test("appendTo(String|Element|Array&lt;Element&gt;|jQuery)", function() {
	expect(6);
	var defaultText = 'Try them out:'
	$('bbuga/b').appendTo('#first');
	ok( $("#first").text() == defaultText + 'buga', 'Check if text appending works' );
	ok( $('option value="appendTest"Append Test/option').appendTo('#select3').parent().find('option:last-child').attr('value') == 'appendTest', 'Appending html options to select element');
	
	reset();
	var expected = "This link has class=\"blog\": Simon Willison's WeblogTry them out:";
	$(document.getElementById('first')).appendTo('#sap');
	ok( expected == $('#sap').text(), "Check for appending of element" );
	
	reset();
	expected = "This link has class=\"blog\": Simon Willison's WeblogTry them out:Yahoo";
	$([document.getElementById('first'), document.getElementById('yahoo')]).appendTo('#sap');
	ok( expected == $('#sap').text(), "Check for appending of array of elements" );
	
	reset();
	expected = "This link has class=\"blog\": Simon Willison's WeblogTry them out:Yahoo";
	$("#first, #yahoo").appendTo('#sap');
	ok( expected == $('#sap').text(), "Check for appending of jQuery object" );
	
	reset();
	$('#select1').appendTo('#foo');
	t( 'Append select', '#foo select', ['select1'] );
});

test("prepend(String|Element|Array&lt;Element&gt;|jQuery)", function() {
	expect(5);
	var defaultText = 'Try them out:'
	var result = $('#first').prepend('bbuga/b');
	ok( result.text() == 'buga' + defaultText, 'Check if text prepending works' );
	ok( $('#select3').prepend('option value="prependTest"Prepend Test/option').find('option:first-child').attr('value') == 'prependTest', 'Prepending html options to select element');
	
	reset();
	var expected = "Try them out:This link has class=\"blog\": Simon Willison's Weblog";
	$('#sap').prepend(document.getElementById('first'));
	ok( expected == $('#sap').text(), "Check for prepending of element" );

	reset();
	expected = "Try them out:YahooThis link has class=\"blog\": Simon Willison's Weblog";
	$('#sap').prepend([document.getElementById('first'), document.getElementById('yahoo')]);
	ok( expected == $('#sap').text(), "Check for prepending of array of elements" );
	
	reset();
	expected = "Try them out:YahooThis link has class=\"blog\": Simon Willison's Weblog";
	$('#sap').prepend($("#first, #yahoo"));
	ok( expected == $('#sap').text(), "Check for prepending of jQuery object" );
});

test("prependTo(String|Element|Array&lt;Element&gt;|jQuery)", function() {
	expect(6);
	var defaultText = 'Try them out:'
	$('bbuga/b').prependTo('#first');
	ok( $('#first').text() == 'buga' + defaultText, 'Check if text prepending works' );
	ok( $('option value="prependTest"Prepend Test/option').prependTo('#select3').parent().find('option:first-child').attr('value') == 'prependTest', 'Prepending html options to select element');
	
	reset();
	var expected = "Try them out:This link has class=\"blog\": Simon Willison's Weblog";
	$(document.getElementById('first')).prependTo('#sap');
	ok( expected == $('#sap').text(), "Check for prepending of element" );

	reset();
	expected = "Try them out:YahooThis link has class=\"blog\": Simon Willison's Weblog";
	$([document.getElementById('yahoo'), document.getElementById('first')]).prependTo('#sap');
	ok( expected == $('#sap').text(), "Check for prepending of array of elements" );
	
	reset();
	expected = "Try them out:YahooThis link has class=\"blog\": Simon Willison's Weblog";
	$("#yahoo, #first").prependTo('#sap');
	ok( expected == $('#sap').text(), "Check for prepending of jQuery object" );
	
	reset();
	$('select id="prependSelect1"/select').prependTo('form:last');
	$('select id="prependSelect2"optionTest/option/select').prependTo('form:last');
	
	t( "Prepend Select", "#prependSelect1, #prependSelect2", ["prependSelect1", "prependSelect2"] );
});

test("before(String|Element|Array&lt;Element&gt;|jQuery)", function() {
	expect(4);
	var expected = 'This is a normal link: bugaYahoo';
	$('#yahoo').before('bbuga/b');
	ok( expected == $('#en').text(), 'Insert String before' );
	
	reset();
	expected = "This is a normal link: Try them out:Yahoo";
	$('#yahoo').before(document.getElementById('first'));
	ok( expected == $('#en').text(), "Insert element before" );
	
	reset();
	expected = "This is a normal link: Try them out:diveintomarkYahoo";
	$('#yahoo').before([document.getElementById('first'), document.getElementById('mark')]);
	ok( expected == $('#en').text(), "Insert array of elements before" );
	
	reset();
	expected = "This is a normal link: Try them out:diveintomarkYahoo";
	$('#yahoo').before($("#first, #mark"));
	ok( expected == $('#en').text(), "Insert jQuery before" );
});

test("insertBefore(String|Element|Array&lt;Element&gt;|jQuery)", function() {
	expect(4);
	var expected = 'This is a normal link: bugaYahoo';
	$('bbuga/b').insertBefore('#yahoo');
	ok( expected == $('#en').text(), 'Insert String before' );
	
	reset();
	expected = "This is a normal link: Try them out:Yahoo";
	$(document.getElementById('first')).insertBefore('#yahoo');
	ok( expected == $('#en').text(), "Insert element before" );
	
	reset();
	expected = "This is a normal link: Try them out:diveintomarkYahoo";
	$([document.getElementById('first'), document.getElementById('mark')]).insertBefore('#yahoo');
	ok( expected == $('#en').text(), "Insert array of elements before" );
	
	reset();
	expected = "This is a normal link: Try them out:diveintomarkYahoo";
	$("#first, #mark").insertBefore('#yahoo');
	ok( expected == $('#en').text(), "Insert jQuery before" );
});

test("after(String|Element|Array&lt;Element&gt;|jQuery)", function() {
	expect(4);
	var expected = 'This is a normal link: Yahoobuga';
	$('#yahoo').after('bbuga/b');
	ok( expected == $('#en').text(), 'Insert String after' );
	
	reset();
	expected = "This is a normal link: YahooTry them out:";
	$('#yahoo').after(document.getElementById('first'));
	ok( expected == $('#en').text(), "Insert element after" );

	reset();
	expected = "This is a normal link: YahooTry them out:diveintomark";
	$('#yahoo').after([document.getElementById('first'), document.getElementById('mark')]);
	ok( expected == $('#en').text(), "Insert array of elements after" );
	
	reset();
	expected = "This is a normal link: YahooTry them out:diveintomark";
	$('#yahoo').after($("#first, #mark"));
	ok( expected == $('#en').text(), "Insert jQuery after" );
});

test("insertAfter(String|Element|Array&lt;Element&gt;|jQuery)", function() {
	expect(4);
	var expected = 'This is a normal link: Yahoobuga';
	$('bbuga/b').insertAfter('#yahoo');
	ok( expected == $('#en').text(), 'Insert String after' );
	
	reset();
	expected = "This is a normal link: YahooTry them out:";
	$(document.getElementById('first')).insertAfter('#yahoo');
	ok( expected == $('#en').text(), "Insert element after" );

	reset();
	expected = "This is a normal link: YahooTry them out:diveintomark";
	$([document.getElementById('mark'), document.getElementById('first')]).insertAfter('#yahoo');
	ok( expected == $('#en').text(), "Insert array of elements after" );
	
	reset();
	expected = "This is a normal link: YahooTry them out:diveintomark";
	$("#mark, #first").insertAfter('#yahoo');
	ok( expected == $('#en').text(), "Insert jQuery after" );
});

test("replaceWith(String|Element|Array&lt;Element&gt;|jQuery)", function() {
	expect(10);
	$('#yahoo').replaceWith('b id="replace"buga/b');
	ok( $("#replace")[0], 'Replace element with string' );
	ok( !$("#yahoo")[0], 'Verify that original element is gone, after string' );
	
	reset();
	$('#yahoo').replaceWith(document.getElementById('first'));
	ok( $("#first")[0], 'Replace element with element' );
	ok( !$("#yahoo")[0], 'Verify that original element is gone, after element' );

	reset();
	$('#yahoo').replaceWith([document.getElementById('first'), document.getElementById('mark')]);
	ok( $("#first")[0], 'Replace element with array of elements' );
	ok( $("#mark")[0], 'Replace element with array of elements' );
	ok( !$("#yahoo")[0], 'Verify that original element is gone, after array of elements' );
	
	reset();
	$('#yahoo').replaceWith($("#first, #mark"));
	ok( $("#first")[0], 'Replace element with set of elements' );
	ok( $("#mark")[0], 'Replace element with set of elements' );
	ok( !$("#yahoo")[0], 'Verify that original element is gone, after set of elements' );
});

test("replaceAll(String|Element|Array&lt;Element&gt;|jQuery)", function() {
	expect(10);
	$('b id="replace"buga/b').replaceAll("#yahoo");
	ok( $("#replace")[0], 'Replace element with string' );
	ok( !$("#yahoo")[0], 'Verify that original element is gone, after string' );
	
	reset();
	$(document.getElementById('first')).replaceAll("#yahoo");
	ok( $("#first")[0], 'Replace element with element' );
	ok( !$("#yahoo")[0], 'Verify that original element is gone, after element' );

	reset();
	$([document.getElementById('first'), document.getElementById('mark')]).replaceAll("#yahoo");
	ok( $("#first")[0], 'Replace element with array of elements' );
	ok( $("#mark")[0], 'Replace element with array of elements' );
	ok( !$("#yahoo")[0], 'Verify that original element is gone, after array of elements' );
	
	reset();
	$("#first, #mark").replaceAll("#yahoo");
	ok( $("#first")[0], 'Replace element with set of elements' );
	ok( $("#mark")[0], 'Replace element with set of elements' );
	ok( !$("#yahoo")[0], 'Verify that original element is gone, after set of elements' );
});

test("end()", function() {
	expect(3);
	ok( 'Yahoo' == $('#yahoo').parent().end().text(), 'Check for end' );
	ok( $('#yahoo').end(), 'Check for end with nothing to end' );
	
	var x = $('#yahoo');
	x.parent();
	ok( 'Yahoo' == $('#yahoo').text(), 'Check for non-destructive behaviour' );
});

test("find(String)", function() {
	expect(1);
	ok( 'Yahoo' == $('#foo').find('.blogTest').text(), 'Check for find' );
});

test("clone()", function() {
	expect(3);
	ok( 'This is a normal link: Yahoo' == $('#en').text(), 'Assert text for #en' );
	var clone = $('#yahoo').clone();
	ok( 'Try them out:Yahoo' == $('#first').append(clone).text(), 'Check for clone' );
	ok( 'This is a normal link: Yahoo' == $('#en').text(), 'Reassert text for #en' );
});

test("is(String)", function() {
	expect(26);
	ok( $('#form').is('form'), 'Check for element: A form must be a form' );
	ok( !$('#form').is('div'), 'Check for element: A form is not a div' );
	ok( $('#mark').is('.blog'), 'Check for class: Expected class "blog"' );
	ok( !$('#mark').is('.link'), 'Check for class: Did not expect class "link"' );
	ok( $('#simon').is('.blog.link'), 'Check for multiple classes: Expected classes "blog" and "link"' );
	ok( !$('#simon').is('.blogTest'), 'Check for multiple classes: Expected classes "blog" and "link", but not "blogTest"' );
	ok( $('#en').is('[lang="en"]'), 'Check for attribute: Expected attribute lang to be "en"' );
	ok( !$('#en').is('[lang="de"]'), 'Check for attribute: Expected attribute lang to be "en", not "de"' );
	ok( $('#text1').is('[type="text"]'), 'Check for attribute: Expected attribute type to be "text"' );
	ok( !$('#text1').is('[type="radio"]'), 'Check for attribute: Expected attribute type to be "text", not "radio"' );
	ok( $('#text2').is(':disabled'), 'Check for pseudoclass: Expected to be disabled' );
	ok( !$('#text1').is(':disabled'), 'Check for pseudoclass: Expected not disabled' );
	ok( $('#radio2').is(':checked'), 'Check for pseudoclass: Expected to be checked' );
	ok( !$('#radio1').is(':checked'), 'Check for pseudoclass: Expected not checked' );
	ok( $('#foo').is(':has(p)'), 'Check for child: Expected a child "p" element' );
	ok( !$('#foo').is(':has(ul)'), 'Check for child: Did not expect "ul" element' );
	ok( $('#foo').is(':has(p):has(a):has(code)'), 'Check for childs: Expected "p", "a" and "code" child elements' );
	ok( !$('#foo').is(':has(p):has(a):has(code):has(ol)'), 'Check for childs: Expected "p", "a" and "code" child elements, but no "ol"' );
	ok( !$('#foo').is(0), 'Expected false for an invalid expression - 0' );
	ok( !$('#foo').is(null), 'Expected false for an invalid expression - null' );
	ok( !$('#foo').is(''), 'Expected false for an invalid expression - ""' );
	ok( !$('#foo').is(undefined), 'Expected false for an invalid expression - undefined' );
	
	// test is() with comma-seperated expressions
	ok( $('#en').is('[lang="en"],[lang="de"]'), 'Comma-seperated; Check for lang attribute: Expect en or de' );
	ok( $('#en').is('[lang="de"],[lang="en"]'), 'Comma-seperated; Check for lang attribute: Expect en or de' );
	ok( $('#en').is('[lang="en"] , [lang="de"]'), 'Comma-seperated; Check for lang attribute: Expect en or de' );
	ok( $('#en').is('[lang="de"] , [lang="en"]'), 'Comma-seperated; Check for lang attribute: Expect en or de' );
});

test("$.extend(Object, Object)", function() {
	expect(11);

	var settings = { xnumber1: 5, xnumber2: 7, xstring1: "peter", xstring2: "pan" },
		options =     { xnumber2: 1, xstring2: "x", xxx: "newstring" },
		optionsCopy = { xnumber2: 1, xstring2: "x", xxx: "newstring" },
		merged = { xnumber1: 5, xnumber2: 1, xstring1: "peter", xstring2: "x", xxx: "newstring" },
		deep1 = { foo: { bar: true } },
		deep1copy = { foo: { bar: true } },
		deep2 = { foo: { baz: true }, foo2: document },
		deep2copy = { foo: { baz: true }, foo2: document },
		deepmerged = { foo: { bar: true, baz: true }, foo2: document };

	jQuery.extend(settings, options);
	isObj( settings, merged, "Check if extended: settings must be extended" );
	isObj( options, optionsCopy, "Check if not modified: options must not be modified" );

	jQuery.extend(settings, null, options);
	isObj( settings, merged, "Check if extended: settings must be extended" );
	isObj( options, optionsCopy, "Check if not modified: options must not be modified" );

	jQuery.extend(true, deep1, deep2);
	isObj( deep1.foo, deepmerged.foo, "Check if foo: settings must be extended" );
	isObj( deep2.foo, deep2copy.foo, "Check if not deep2: options must not be modified" );
	equals( deep1.foo2, document, "Make sure that a deep clone was not attempted on the document" );

	var defaults = { xnumber1: 5, xnumber2: 7, xstring1: "peter", xstring2: "pan" },
		defaultsCopy = { xnumber1: 5, xnumber2: 7, xstring1: "peter", xstring2: "pan" },
		options1 =     { xnumber2: 1, xstring2: "x" },
		options1Copy = { xnumber2: 1, xstring2: "x" },
		options2 =     { xstring2: "xx", xxx: "newstringx" },
		options2Copy = { xstring2: "xx", xxx: "newstringx" },
		merged2 = { xnumber1: 5, xnumber2: 1, xstring1: "peter", xstring2: "xx", xxx: "newstringx" };

	var settings = jQuery.extend({}, defaults, options1, options2);
	isObj( settings, merged2, "Check if extended: settings must be extended" );
	isObj( defaults, defaultsCopy, "Check if not modified: options1 must not be modified" );
	isObj( options1, options1Copy, "Check if not modified: options1 must not be modified" );
	isObj( options2, options2Copy, "Check if not modified: options2 must not be modified" );
});

test("val()", function() {
	expect(2);
	ok( $("#text1").val() == "Test", "Check for value of input element" );
	ok( !$("#text1").val() == "", "Check for value of input element" );
});

test("val(String)", function() {
	expect(3);
	document.getElementById('text1').value = "bla";
	ok( $("#text1").val() == "bla", "Check for modified value of input element" );
	$("#text1").val('test');
	ok ( document.getElementById('text1').value == "test", "Check for modified (via val(String)) value of input element" );
	
	$("#select1").val("3");
	ok( $("#select1").val() == "3", "Check for modified (via val(String)) value of select element" );
});

var scriptorder = 0;

test("html(String)", function() {
	expect(9);
	var div = $("div");
	div.html("btest/b");
	var pass = true;
	for ( var i = 0; i  div.size(); i++ ) {
	  if ( div.get(i).childNodes.length == 0 ) pass = false;
	}
	ok( pass, "Set HTML" );

	stop();

	$("#main").html('script type="text/javascript"ok( true, "$().html().evalScripts() Evals Scripts Twice in Firefox, see #975" );/script');

	$("#main").html('foo formscript type="text/javascript"ok( true, "$().html().evalScripts() Evals Scripts Twice in Firefox, see #975" );/script/form');

	$("#main").html("scriptok(scriptorder++ == 0, 'Script is executed in order');ok($('#scriptorder').length == 0,'Execute before html')\/scriptspan id='scriptorder'scriptok(scriptorder++ == 1, 'Script is executed in order');ok($('#scriptorder').length == 1,'Execute after html')\/script/spanscriptok(scriptorder++ == 2, 'Script is executed in order');ok($('#scriptorder').length == 1,'Execute after html')\/script");

	setTimeout( start, 100 );
});

test("filter()", function() {
	expect(4);
	isSet( $("#form input").filter(":checked").get(), q("radio2", "check1"), "filter(String)" );
	isSet( $("p").filter("#ap, #sndp").get(), q("ap", "sndp"), "filter('String, String')" );
	isSet( $("p").filter("#ap,#sndp").get(), q("ap", "sndp"), "filter('String,String')" );
	isSet( $("p").filter(function() { return !$("a", this).length }).get(), q("sndp", "first"), "filter(Function)" );
});

test("not()", function() {
	expect(3);
	ok( $("#main  p#ap  a").not("#google").length == 2, "not('selector')" );
	isSet( $("p").not("#ap, #sndp, .result").get(), q("firstp", "en", "sap", "first"), "not('selector, selector')" );
	isSet( $("p").not($("#ap, #sndp, .result")).get(), q("firstp", "en", "sap", "first"), "not(jQuery)" );
});

test("andSelf()", function() {
	expect(4);
	isSet( $("#en").siblings().andSelf().get(), q("sndp", "sap","en"), "Check for siblings and self" );
	isSet( $("#foo").children().andSelf().get(), q("sndp", "en", "sap", "foo"), "Check for children and self" );
	isSet( $("#en, #sndp").parent().andSelf().get(), q("foo","en","sndp"), "Check for parent and self" );
	isSet( $("#groups").parents("p, div").andSelf().get(), q("ap", "main", "groups"), "Check for parents and self" );
});

test("siblings([String])", function() {
	expect(5);
	isSet( $("#en").siblings().get(), q("sndp", "sap"), "Check for siblings" );
	isSet( $("#sndp").siblings(":has(code)").get(), q("sap"), "Check for filtered siblings (has code child element)" ); 
	isSet( $("#sndp").siblings(":has(a)").get(), q("en", "sap"), "Check for filtered siblings (has anchor child element)" );
	isSet( $("#foo").siblings("form, b").get(), q("form", "lengthtest", "testForm", "floatTest"), "Check for multiple filters" );
	isSet( $("#en, #sndp").siblings().get(), q("sndp", "sap", "en"), "Check for unique results from siblings" );
});

test("children([String])", function() {
	expect(3);
	isSet( $("#foo").children().get(), q("sndp", "en", "sap"), "Check for children" );
	isSet( $("#foo").children(":has(code)").get(), q("sndp", "sap"), "Check for filtered children" );
	isSet( $("#foo").children("#en, #sap").get(), q("en", "sap"), "Check for multiple filters" );
});

test("parent([String])", function() {
	expect(5);
	ok( $("#groups").parent()[0].id == "ap", "Simple parent check" );
	ok( $("#groups").parent("p")[0].id == "ap", "Filtered parent check" );
	ok( $("#groups").parent("div").length == 0, "Filtered parent check, no match" );
	ok( $("#groups").parent("div, p")[0].id == "ap", "Check for multiple filters" );
	isSet( $("#en, #sndp").parent().get(), q("foo"), "Check for unique results from parent" );
});
	
test("parents([String])", function() {
	expect(5);
	ok( $("#groups").parents()[0].id == "ap", "Simple parents check" );
	ok( $("#groups").parents("p")[0].id == "ap", "Filtered parents check" );
	ok( $("#groups").parents("div")[0].id == "main", "Filtered parents check2" );
	isSet( $("#groups").parents("p, div").get(), q("ap", "main"), "Check for multiple filters" );
	isSet( $("#en, #sndp").parents().get(), q("foo", "main", "dl", "body", "html"), "Check for unique results from parents" );
});

test("next([String])", function() {
	expect(4);
	ok( $("#ap").next()[0].id == "foo", "Simple next check" );
	ok( $("#ap").next("div")[0].id == "foo", "Filtered next check" );
	ok( $("#ap").next("p").length == 0, "Filtered next check, no match" );
	ok( $("#ap").next("div, p")[0].id == "foo", "Multiple filters" );
});
	
test("prev([String])", function() {
	expect(4);
	ok( $("#foo").prev()[0].id == "ap", "Simple prev check" );
	ok( $("#foo").prev("p")[0].id == "ap", "Filtered prev check" );
	ok( $("#foo").prev("div").length == 0, "Filtered prev check, no match" );
	ok( $("#foo").prev("p, div")[0].id == "ap", "Multiple filters" );
});

test("show()", function() {
	expect(1);
	var pass = true, div = $("div");
	div.show().each(function(){
	  if ( this.style.display == "none" ) pass = false;
	});
	ok( pass, "Show" );
});

test("addClass(String)", function() {
	expect(1);
	var div = $("div");
	div.addClass("test");
	var pass = true;
	for ( var i = 0; i  div.size(); i++ ) {
	 if ( div.get(i).className.indexOf("test") == -1 ) pass = false;
	}
	ok( pass, "Add Class" );
});

test("removeClass(String) - simple", function() {
	expect(3);
	var div = $("div").addClass("test").removeClass("test"),
		pass = true;
	for ( var i = 0; i  div.size(); i++ ) {
		if ( div.get(i).className.indexOf("test") != -1 ) pass = false;
	}
	ok( pass, "Remove Class" );
	
	reset();
	var div = $("div").addClass("test").addClass("foo").addClass("bar");
	div.removeClass("test").removeClass("bar").removeClass("foo");
	var pass = true;
	for ( var i = 0; i  div.size(); i++ ) {
	 if ( div.get(i).className.match(/test|bar|foo/) ) pass = false;
	}
	ok( pass, "Remove multiple classes" );
	
	reset();
	var div = $("div:eq(0)").addClass("test").removeClass("");
	ok( div.is('.test'), "Empty string passed to removeClass" );
	
});

test("toggleClass(String)", function() {
	expect(3);
	var e = $("#firstp");
	ok( !e.is(".test"), "Assert class not present" );
	e.toggleClass("test");
	ok( e.is(".test"), "Assert class present" ); 
	e.toggleClass("test");
	ok( !e.is(".test"), "Assert class not present" );
});

test("removeAttr(String", function() {
	expect(1);
	ok( $('#mark').removeAttr("class")[0].className == "", "remove class" );
});

test("text(String)", function() {
	expect(1);
	ok( $("#foo").text("divbHello/b cruel world!/div")[0].innerHTML == "&lt;div&gt;&lt;b&gt;Hello&lt;/b&gt; cruel world!&lt;/div&gt;", "Check escaped text" );
});

test("$.each(Object,Function)", function() {
	expect(8);
	$.each( [0,1,2], function(i, n){
		ok( i == n, "Check array iteration" );
	});
	
	$.each( [5,6,7], function(i, n){
		ok( i == n - 5, "Check array iteration" );
	});
	 
	$.each( { name: "name", lang: "lang" }, function(i, n){
		ok( i == n, "Check object iteration" );
	});
});

test("$.prop", function() {
	expect(2);
	var handle = function() { return this.id };
	ok( $.prop($("#ap")[0], handle) == "ap", "Check with Function argument" );
	ok( $.prop($("#ap")[0], "value") == "value", "Check with value argument" );
});

test("$.className", function() {
	expect(6);
	var x = $("pHi/p")[0];
	var c = $.className;
	c.add(x, "hi");
	ok( x.className == "hi", "Check single added class" );
	c.add(x, "foo bar");
	ok( x.className == "hi foo bar", "Check more added classes" );
	c.remove(x);
	ok( x.className == "", "Remove all classes" );
	c.add(x, "hi foo bar");
	c.remove(x, "foo");
	ok( x.className == "hi bar", "Check removal of one class" );
	ok( c.has(x, "hi"), "Check has1" );
	ok( c.has(x, "bar"), "Check has2" );
});

test("remove()", function() {
	expect(4);
	$("#ap").children().remove();
	ok( $("#ap").text().length  10, "Check text is not removed" );
	ok( $("#ap").children().length == 0, "Check remove" );
	
	reset();
	$("#ap").children().remove("a");
	ok( $("#ap").text().length  10, "Check text is not removed" );
	ok( $("#ap").children().length == 1, "Check filtered remove" );
});

test("empty()", function() {
	expect(2);
	ok( $("#ap").children().empty().text().length == 0, "Check text is removed" );
	ok( $("#ap").children().length == 4, "Check elements are not removed" );
});

test("slice()", function() {
	expect(5);
	isSet( $("#ap a").slice(1,2), q("groups"), "slice(1,2)" );
	isSet( $("#ap a").slice(1), q("groups", "anchor1", "mark"), "slice(1)" );
	isSet( $("#ap a").slice(0,3), q("google", "groups", "anchor1"), "slice(0,3)" );
	isSet( $("#ap a").slice(-1), q("mark"), "slice(-1)" );

	isSet( $("#ap a").eq(1), q("groups"), "eq(1)" );
});

test("map()", function() {
	expect(2);

	isSet(
		$("#ap").map(function(){
			return $(this).find("a").get();
		}),
		q("google", "groups", "anchor1", "mark"),
		"Array Map"
	);

	isSet(
		$("#ap  a").map(function(){
			return this.parentNode;
		}),
		q("ap","ap","ap"),
		"Single Map"
	);
});

test("contents()", function() {
	expect(2);
	equals( $("#ap").contents().length, 9, "Check element contents" );
	ok( $("#iframe").contents()[0], "Check existance of IFrame document" );
	// Disabled, randomly fails
	//ok( $("#iframe").contents()[0].body, "Check existance of IFrame body" );
});
</content>
		</actual_file>
		<actual_file>
			<filename>jquery.js</filename>
			<content>(function(){
/*
 * jQuery 1.2.1 - New Wave Javascript
 *
 * Copyright (c) 2007 John Resig (jquery.com)
 * Dual licensed under the MIT (MIT-LICENSE.txt)
 * and GPL (GPL-LICENSE.txt) licenses.
 *
 * $Date: 2007-10-20T22:04:06.909452Z $
 * $Rev: 19095 $
 */

// Map over jQuery in case of overwrite
if ( window.jQuery )
	var _jQuery = window.jQuery;

var jQuery = window.jQuery = function( selector, context ) {
	// If the context is a namespace object, return a new object
	return this instanceof jQuery ?
		this.init( selector, context ) :
		new jQuery( selector, context );
};

// Map over the $ in case of overwrite
if ( window.$ )
	var _$ = window.$;
	
// Map the jQuery namespace to the '$' one
window.$ = jQuery;

// A simple way to check for HTML strings or ID strings
// (both of which we optimize for)
var quickExpr = /^[^]*((.|\s)+)[^]*$|^#(\w+)$/;

jQuery.fn = jQuery.prototype = {
	init: function( selector, context ) {
		// Make sure that a selection was provided
		selector = selector || document;

		// Handle HTML strings
		if ( typeof selector  == "string" ) {
			// Are we dealing with HTML string or an ID?
			var match = quickExpr.exec( selector );

			// Verify a match, and that no context was specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) - $(array)
				if ( match[1] )
					selector = jQuery.clean( [ match[1] ], context );

				// HANDLE: $("#id")
				else {
					var elem = document.getElementById( match[3] );

					// Make sure an element was located
					if ( elem )
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id != match[3] )
							return jQuery().find( selector );

						// Otherwise, we inject the element directly into the jQuery object
						else {
							this[0] = elem;
							this.length = 1;
							return this;
						}

					else
						selector = [];
				}

			// HANDLE: $(expr, [context])
			// (which is just equivalent to: $(content).find(expr)
			} else
				return new jQuery( context ).find( selector );

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) )
			return new jQuery( document )[ jQuery.fn.ready ? "ready" : "load" ]( selector );

		return this.setArray(
			// HANDLE: $(array)
			selector.constructor == Array && selector ||

			// HANDLE: $(arraylike)
			// Watch for when an array-like object, contains DOM nodes, is passed in as the selector
			(selector.jquery || selector.length && selector != window && !selector.nodeType && selector[0] != undefined && selector[0].nodeType) && jQuery.makeArray( selector ) ||

			// HANDLE: $(*)
			[ selector ] );
	},
	
	// The current version of jQuery being used
	jquery: "1.2.1",

	// The number of elements contained in the matched element set
	size: function() {
		return this.length;
	},
	
	// The number of elements contained in the matched element set
	length: 0,

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num == undefined ?

			// Return a 'clean' array
			jQuery.makeArray( this ) :

			// Return just the object
			this[ num ];
	},
	
	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {
		// Build a new jQuery matched element set
		var ret = jQuery( elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},
	
	// Force the current matched set of elements to become
	// the specified array of elements (destroying the stack in the process)
	// You should use pushStack() in order to do this, but maintain the stack
	setArray: function( elems ) {
		// Resetting the length to 0, then using the native Array push
		// is a super-fast way to populate an object with array-like properties
		this.length = 0;
		Array.prototype.push.apply( this, elems );
		
		return this;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	// Determine the position of an element within 
	// the matched set of elements
	index: function( elem ) {
		var ret = -1;

		// Locate the position of the desired element
		this.each(function(i){
			if ( this == elem )
				ret = i;
		});

		return ret;
	},

	attr: function( name, value, type ) {
		var options = name;
		
		// Look for the case where we're accessing a style value
		if ( name.constructor == String )
			if ( value == undefined )
				return this.length && jQuery[ type || "attr" ]( this[0], name ) || undefined;

			else {
				options = {};
				options[ name ] = value;
			}
		
		// Check to see if we're setting style values
		return this.each(function(i){
			// Set all the styles
			for ( name in options )
				jQuery.attr(
					type ?
						this.style :
						this,
					name, jQuery.prop( this, options[ name ], type, i, name )
				);
		});
	},

	css: function( key, value ) {
		return this.attr( key, value, "curCSS" );
	},

	text: function( text ) {
		if ( typeof text != "object" && text != null )
			return this.empty().append( document.createTextNode( text ) );

		var ret = "";

		jQuery.each( text || this, function(){
			jQuery.each( this.childNodes, function(){
				if ( this.nodeType != 8 )
					ret += this.nodeType != 1 ?
						this.nodeValue :
						jQuery.fn.text( [ this ] );
			});
		});

		return ret;
	},

	wrapAll: function( html ) {
		if ( this[0] )
			// The elements to wrap the target around
			jQuery( html, this[0].ownerDocument )
				.clone()
				.insertBefore( this[0] )
				.map(function(){
					var elem = this;

					while ( elem.firstChild )
						elem = elem.firstChild;

					return elem;
				})
				.append(this);

		return this;
	},

	wrapInner: function( html ) {
		return this.each(function(){
			jQuery( this ).contents().wrapAll( html );
		});
	},

	wrap: function( html ) {
		return this.each(function(){
			jQuery( this ).wrapAll( html );
		});
	},

	append: function() {
		return this.domManip(arguments, true, false, function(elem){
			this.appendChild( elem );
		});
	},

	prepend: function() {
		return this.domManip(arguments, true, true, function(elem){
			this.insertBefore( elem, this.firstChild );
		});
	},
	
	before: function() {
		return this.domManip(arguments, false, false, function(elem){
			this.parentNode.insertBefore( elem, this );
		});
	},

	after: function() {
		return this.domManip(arguments, false, true, function(elem){
			this.parentNode.insertBefore( elem, this.nextSibling );
		});
	},

	end: function() {
		return this.prevObject || jQuery( [] );
	},

	find: function( selector ) {
		var elems = jQuery.map(this, function(elem){
			return jQuery.find( selector, elem );
		});

		return this.pushStack( /[^+] [^+]/.test( selector ) || selector.indexOf("..")  -1 ?
			jQuery.unique( elems ) :
			elems );
	},

	clone: function( events ) {
		// Do the clone
		var ret = this.map(function(){
			return this.outerHTML ?
				jQuery( this.outerHTML )[0] :
				this.cloneNode( true );
		});

		// Need to set the expando to null on the cloned set if it exists
		// removeData doesn't work here, IE removes it from the original as well
		// this is primarily for IE but the data expando shouldn't be copied over in any browser
		var clone = ret.find("*").andSelf().each(function(){
			if ( this[ expando ] != undefined )
				this[ expando ] = null;
		});
		
		// Copy the events from the original to the clone
		if ( events === true )
			this.find("*").andSelf().each(function(i){
				var events = jQuery.data( this, "events" );

				for ( var type in events )
					for ( var handler in events[ type ] )
						jQuery.event.add( clone[ i ], type, events[ type ][ handler ], events[ type ][ handler ].data );
			});

		// Return the cloned set
		return ret;
	},

	filter: function( selector ) {
		return this.pushStack(
			jQuery.isFunction( selector ) &&
			jQuery.grep(this, function(elem, i){
				return selector.call( elem, i );
			}) ||

			jQuery.multiFilter( selector, this ) );
	},

	not: function( selector ) {
		return this.pushStack(
			selector.constructor == String &&
			jQuery.multiFilter( selector, this, true ) ||

			jQuery.grep(this, function(elem) {
				return selector.constructor == Array || selector.jquery ?
					jQuery.inArray( elem, selector )  0 :
					elem != selector;
			}) );
	},

	add: function( selector ) {
		return this.pushStack( jQuery.merge( 
			this.get(),
			selector.constructor == String ? 
				jQuery( selector ).get() :
				selector.length != undefined && (!selector.nodeName || jQuery.nodeName(selector, "form")) ?
					selector : [selector] ) );
	},

	is: function( selector ) {
		return selector ?
			jQuery.multiFilter( selector, this ).length  0 :
			false;
	},

	hasClass: function( selector ) {
		return this.is( "." + selector );
	},
	
	val: function( value ) {
		if ( value == undefined ) {

			if ( this.length ) {
				var elem = this[0];
		    	
				// We need to handle select boxes special
				if ( jQuery.nodeName( elem, "select" ) ) {
					var index = elem.selectedIndex,
						values = [],
						options = elem.options,
						one = elem.type == "select-one";
					
					// Nothing was selected
					if ( index  0 )
						return null;

					// Loop through all the selected options
					for ( var i = one ? index : 0, max = one ? index + 1 : options.length; i  max; i++ ) {
						var option = options[ i ];

						if ( option.selected ) {
							// Get the specifc value for the option
							value = jQuery.browser.msie && !option.attributes.value.specified ? option.text : option.value;
							
							// We don't need an array for one selects
							if ( one )
								return value;
							
							// Multi-Selects return an array
							values.push( value );
						}
					}
					
					return values;
					
				// Everything else, we just grab the value
				} else
					return this[0].value.replace(/\r/g, "");

			}

		} else
			return this.each(function(){
				if ( value.constructor == Array && /radio|checkbox/.test( this.type ) )
					this.checked = (jQuery.inArray(this.value, value) = 0 ||
						jQuery.inArray(this.name, value) = 0);

				else if ( jQuery.nodeName( this, "select" ) ) {
					var values = value.constructor == Array ?
						value :
						[ value ];

					jQuery( "option", this ).each(function(){
						this.selected = (jQuery.inArray( this.value, values ) = 0 ||
							jQuery.inArray( this.text, values ) = 0);
					});

					if ( !values.length )
						this.selectedIndex = -1;

				} else
					this.value = value;
			});
	},
	
	html: function( value ) {
		return value == undefined ?
			(this.length ?
				this[0].innerHTML :
				null) :
			this.empty().append( value );
	},

	replaceWith: function( value ) {
		return this.after( value ).remove();
	},

	eq: function( i ) {
		return this.slice( i, i + 1 );
	},

	slice: function() {
		return this.pushStack( Array.prototype.slice.apply( this, arguments ) );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function(elem, i){
			return callback.call( elem, i, elem );
		}));
	},

	andSelf: function() {
		return this.add( this.prevObject );
	},
	
	domManip: function( args, table, reverse, callback ) {
		var clone = this.length  1, elems; 

		return this.each(function(){
			if ( !elems ) {
				elems = jQuery.clean( args, this.ownerDocument );

				if ( reverse )
					elems.reverse();
			}

			var obj = this;

			if ( table && jQuery.nodeName( this, "table" ) && jQuery.nodeName( elems[0], "tr" ) )
				obj = this.getElementsByTagName("tbody")[0] || this.appendChild( document.createElement("tbody") );

			var scripts = jQuery( [] );

			jQuery.each(elems, function(){
				var elem = clone ?
					this.cloneNode( true ) :
					this;

				if ( jQuery.nodeName( elem, "script" ) ) {

					// If scripts are waiting to be executed, wait on this script as well
					if ( scripts.length )
						scripts = scripts.add( elem );

					// If nothing is waiting to be executed, run immediately
					else
						evalScript( 0, elem );

				} else {
					// Remove any inner scripts for later evaluation
					if ( elem.nodeType == 1 )
						scripts = scripts.add( jQuery( "script", elem ).remove() );

					// Inject the elements into the document
					callback.call( obj, elem );
				}
			});

			scripts.each( evalScript );
		});
	}
};

function evalScript( i, elem ) {
	if ( elem.src )
		jQuery.ajax({
			url: elem.src,
			async: false,
			dataType: "script"
		});

	else
		jQuery.globalEval( elem.text || elem.textContent || elem.innerHTML || "" );

	if ( elem.parentNode )
		elem.parentNode.removeChild( elem );
}

jQuery.extend = jQuery.fn.extend = function() {
	// copy reference to target object
	var target = arguments[0] || {}, i = 1, length = arguments.length, deep = false, options;

	// Handle a deep copy situation
	if ( target.constructor == Boolean ) {
		deep = target;
		target = arguments[1] || {};
	}

	// extend jQuery itself if only one argument is passed
	if ( length == 1 ) {
		target = this;
		i = 0;
	}

	for ( ; i  length; i++ )
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null )
			// Extend the base object
			for ( var name in options ) {
				// Prevent never-ending loop
				if ( target == options[ name ] )
					continue;

				// Recurse if we're merging object values
				if ( deep && typeof options[ name ] == "object" && target[ name ] && !options[ name ].nodeType )
					jQuery.extend( target[ name ], options[ name ] );

				// Don't bring in undefined values
				else if ( options[ name ] != undefined )
					target[ name ] = options[ name ];

			}

	// Return the modified object
	return target;
};

var expando = "jQuery" + (new Date()).getTime(), uuid = 0, windowData = {};

// exclude the following css properties to add px
var exclude = /z-?index|font-?weight|opacity|zoom|line-?height/i;

jQuery.extend({
	noConflict: function( deep ) {
		window.$ = _$;

		if ( deep )
			window.jQuery = _jQuery;

		return jQuery;
	},

	// This may seem like some crazy code, but trust me when I say that this
	// is the only cross-browser way to do this. --John
	isFunction: function( fn ) {
		return !!fn && typeof fn != "string" && !fn.nodeName && 
			fn.constructor != Array && /function/i.test( fn + "" );
	},
	
	// check if an element is in a (or is an) XML document
	isXMLDoc: function( elem ) {
		return elem.documentElement && !elem.body ||
			elem.tagName && elem.ownerDocument && !elem.ownerDocument.body;
	},

	// Evalulates a script in a global context
	// Evaluates Async. in Safari 2 :-(
	globalEval: function( data ) {
		data = jQuery.trim( data );

		if ( data ) {
			// Inspired by code by Andrea Giammarchi
			// http://webreflection.blogspot.com/2007/08/global-scope-evaluation-and-dom.html
			var head = document.getElementsByTagName("head")[0] || document.documentElement,
				script = document.createElement("script");

			script.type = "text/javascript";
			if ( jQuery.browser.msie )
				script.text = data;
			else
				script.appendChild( document.createTextNode( data ) );

			head.appendChild( script );
			head.removeChild( script );
		}
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toUpperCase() == name.toUpperCase();
	},
	
	cache: {},
	
	data: function( elem, name, data ) {
		elem = elem == window ?
			windowData :
			elem;

		var id = elem[ expando ];

		// Compute a unique ID for the element
		if ( !id ) 
			id = elem[ expando ] = ++uuid;

		// Only generate the data cache if we're
		// trying to access or manipulate it
		if ( name && !jQuery.cache[ id ] )
			jQuery.cache[ id ] = {};
		
		// Prevent overriding the named cache with undefined values
		if ( data != undefined )
			jQuery.cache[ id ][ name ] = data;
		
		// Return the named cache data, or the ID for the element	
		return name ?
			jQuery.cache[ id ][ name ] :
			id;
	},
	
	removeData: function( elem, name ) {
		elem = elem == window ?
			windowData :
			elem;

		var id = elem[ expando ];

		// If we want to remove a specific section of the element's data
		if ( name ) {
			if ( jQuery.cache[ id ] ) {
				// Remove the section of cache data
				delete jQuery.cache[ id ][ name ];

				// If we've removed all the data, remove the element's cache
				name = "";

				for ( name in jQuery.cache[ id ] )
					break;

				if ( !name )
					jQuery.removeData( elem );
			}

		// Otherwise, we want to remove all of the element's data
		} else {
			// Clean up the element expando
			try {
				delete elem[ expando ];
			} catch(e){
				// IE has trouble directly removing the expando
				// but it's ok with using removeAttribute
				if ( elem.removeAttribute )
					elem.removeAttribute( expando );
			}

			// Completely remove the data cache
			delete jQuery.cache[ id ];
		}
	},

	// args is for internal usage only
	each: function( object, callback, args ) {
		if ( args ) {
			if ( object.length == undefined )
				for ( var name in object )
					callback.apply( object[ name ], args );
			else
				for ( var i = 0, length = object.length; i  length; i++ )
					if ( callback.apply( object[ i ], args ) === false )
						break;

		// A special, fast, case for the most common use of each
		} else {
			if ( object.length == undefined )
				for ( var name in object )
					callback.call( object[ name ], name, object[ name ] );
			else
				for ( var i = 0, length = object.length, value = object[0]; 
					i  length && callback.call( value, i, value ) !== false; value = object[++i] ){}
		}

		return object;
	},
	
	prop: function( elem, value, type, i, name ) {
			// Handle executable functions
			if ( jQuery.isFunction( value ) )
				value = value.call( elem, i );
				
			// Handle passing in a number to a CSS property
			return value && value.constructor == Number && type == "curCSS" && !exclude.test( name ) ?
				value + "px" :
				value;
	},

	className: {
		// internal only, use addClass("class")
		add: function( elem, classNames ) {
			jQuery.each((classNames || "").split(/\s+/), function(i, className){
				if ( !jQuery.className.has( elem.className, className ) )
					elem.className += (elem.className ? " " : "") + className;
			});
		},

		// internal only, use removeClass("class")
		remove: function( elem, classNames ) {
			elem.className = classNames != undefined ?
				jQuery.grep(elem.className.split(/\s+/), function(className){
					return !jQuery.className.has( classNames, className );	
				}).join(" ") :
				"";
		},

		// internal only, use is(".class")
		has: function( elem, className ) {
			return jQuery.inArray( className, (elem.className || elem).toString().split(/\s+/) )  -1;
		}
	},

	// A method for quickly swapping in/out CSS properties to get correct calculations
	swap: function( elem, options, callback ) {
		// Remember the old values, and insert the new ones
		for ( var name in options ) {
			elem.style[ "old" + name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		callback.call( elem );

		// Revert the old values
		for ( var name in options )
			elem.style[ name ] = elem.style[ "old" + name ];
	},

	css: function( elem, name ) {
		if ( name == "height" || name == "width" ) {
			var old = {}, height, width;

			// Revert the padding and border widths to get the
			// correct height/width values
			jQuery.each([ "Top", "Bottom", "Right", "Left" ], function(){
				old[ "padding" + this ] = 0;
				old[ "border" + this + "Width" ] = 0;
			});

			// Swap out the padding/border values temporarily
			jQuery.swap( elem, old, function() {

				// If the element is visible, then the calculation is easy
				if ( jQuery( elem ).is(":visible") ) {
					height = elem.offsetHeight;
					width = elem.offsetWidth;

				// Otherwise, we need to flip out more values
				} else {
					elem = jQuery( elem.cloneNode(true) )
						.find(":radio").removeAttr("checked").end()
						.css({
							visibility: "hidden",
							position: "absolute",
							display: "block",
							right: "0",
							left: "0"
						}).appendTo( elem.parentNode )[0];

					var position = jQuery.css( elem.parentNode, "position" ) || "static";
					if ( position == "static" )
						elem.parentNode.style.position = "relative";

					height = elem.clientHeight;
					width = elem.clientWidth;

					if ( position == "static" )
						elem.parentNode.style.position = "static";

					elem.parentNode.removeChild( elem );
				}
			});

			return name == "height" ?
				height :
				width;
		}

		return jQuery.curCSS( elem, name );
	},

	curCSS: function( elem, name, force ) {
		var ret;

		// A helper method for determining if an element's values are broken
		function color( elem ) {
			if ( !jQuery.browser.safari )
				return false;

			var ret = document.defaultView.getComputedStyle( elem, null );
			return !ret || ret.getPropertyValue("color") == "";
		}

		// We need to handle opacity special in IE
		if ( name == "opacity" && jQuery.browser.msie ) {
			ret = jQuery.attr( elem.style, "opacity" );

			return ret == "" ?
				"1" :
				ret;
		}
		
		// Make sure we're using the right name for getting the float value
		if ( name.match( /float/i ) )
			name = styleFloat;

		if ( !force && elem.style[ name ] )
			ret = elem.style[ name ];

		else if ( document.defaultView && document.defaultView.getComputedStyle ) {

			// Only "float" is needed here
			if ( name.match( /float/i ) )
				name = "float";

			name = name.replace( /([A-Z])/g, "-$1" ).toLowerCase();

			var getComputedStyle = document.defaultView.getComputedStyle( elem, null );

			if ( getComputedStyle && !color( elem ) )
				ret = getComputedStyle.getPropertyValue( name );

			// If the element isn't reporting its values properly in Safari
			// then some display: none elements are involved
			else {
				var swap = [], stack = [];

				// Locate all of the parent display: none elements
				for ( var a = elem; a && color(a); a = a.parentNode )
					stack.unshift(a);

				// Go through and make them visible, but in reverse
				// (It would be better if we knew the exact display type that they had)
				for ( var i = 0; i  stack.length; i++ )
					if ( color( stack[ i ] ) ) {
						swap[ i ] = stack[ i ].style.display;
						stack[ i ].style.display = "block";
					}

				// Since we flip the display style, we have to handle that
				// one special, otherwise get the value
				ret = name == "display" && swap[ stack.length - 1 ] != null ?
					"none" :
					( getComputedStyle && getComputedStyle.getPropertyValue( name ) ) || "";

				// Finally, revert the display styles back
				for ( var i = 0; i  swap.length; i++ )
					if ( swap[ i ] != null )
						stack[ i ].style.display = swap[ i ];
			}

			// We should always get a number back from opacity
			if ( name == "opacity" && ret == "" )
				ret = "1";

		} else if ( elem.currentStyle ) {
			var camelCase = name.replace(/\-(\w)/g, function(all, letter){
				return letter.toUpperCase();
			});

			ret = elem.currentStyle[ name ] || elem.currentStyle[ camelCase ];

			// From the awesome hack by Dean Edwards
			// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

			// If we're not dealing with a regular pixel number
			// but a number that has a weird ending, we need to convert it to pixels
			if ( !/^\d+(px)?$/i.test( ret ) && /^\d/.test( ret ) ) {
				// Remember the original values
				var style = elem.style.left, runtimeStyle = elem.runtimeStyle.left;

				// Put in the new values to get a computed value out
				elem.runtimeStyle.left = elem.currentStyle.left;
				elem.style.left = ret || 0;
				ret = elem.style.pixelLeft + "px";

				// Revert the changed values
				elem.style.left = style;
				elem.runtimeStyle.left = runtimeStyle;
			}
		}

		return ret;
	},
	
	clean: function( elems, context ) {
		var ret = [];
		context = context || document;

		jQuery.each(elems, function(i, elem){
			if ( !elem )
				return;

			if ( elem.constructor == Number )
				elem = elem.toString();
			
			// Convert html string into DOM nodes
			if ( typeof elem == "string" ) {
				// Fix "XHTML"-style tags in all browsers
				elem = elem.replace(/((\w+)[^]*?)\//g, function(all, front, tag){
					return tag.match(/^(abbr|br|col|img|input|link|meta|param|hr|area)$/i) ?
						all :
						front + "/" + tag + "";
				});

				// Trim whitespace, otherwise indexOf won't work as expected
				var tags = jQuery.trim( elem ).toLowerCase(), div = context.createElement("div");

				var wrap =
					// option or optgroup
					!tags.indexOf("opt") &&
					[ 1, "select", "/select" ] ||
					
					!tags.indexOf("leg") &&
					[ 1, "fieldset", "/fieldset" ] ||
					
					tags.match(/^(thead|tbody|tfoot|colg|cap)/) &&
					[ 1, "table", "/table" ] ||
					
					!tags.indexOf("tr") &&
					[ 2, "tabletbody", "/tbody/table" ] ||
					
				 	// thead matched above
					(!tags.indexOf("td") || !tags.indexOf("th")) &&
					[ 3, "tabletbodytr", "/tr/tbody/table" ] ||
					
					!tags.indexOf("col") &&
					[ 2, "tabletbody/tbodycolgroup", "/colgroup/table" ] ||

					// IE can't serialize link and script tags normally
					jQuery.browser.msie &&
					[ 1, "divdiv", "/div" ] ||
					
					[ 0, "", "" ];

				// Go to html and back, then peel off extra wrappers
				div.innerHTML = wrap[1] + elem + wrap[2];
				
				// Move to the right depth
				while ( wrap[0]-- )
					div = div.lastChild;
				
				// Remove IE's autoinserted tbody from table fragments
				if ( jQuery.browser.msie ) {
					
					// String was a table, *may* have spurious tbody
					var tbody = !tags.indexOf("table") && tags.indexOf("tbody")  0 ?
						div.firstChild && div.firstChild.childNodes :
						
						// String was a bare thead or tfoot
						wrap[1] == "table" && tags.indexOf("tbody")  0 ?
							div.childNodes :
							[];
				
					for ( var i = tbody.length - 1; i = 0 ; --i )
						if ( jQuery.nodeName( tbody[ i ], "tbody" ) && !tbody[ i ].childNodes.length )
							tbody[ i ].parentNode.removeChild( tbody[ i ] );
					
					// IE completely kills leading whitespace when innerHTML is used	
					if ( /^\s/.test( elem ) )	
						div.insertBefore( context.createTextNode( elem.match(/^\s*/)[0] ), div.firstChild );
				
				}
				
				elem = jQuery.makeArray( div.childNodes );
			}

			if ( elem.length === 0 && (!jQuery.nodeName( elem, "form" ) && !jQuery.nodeName( elem, "select" )) )
				return;

			if ( elem[0] == undefined || jQuery.nodeName( elem, "form" ) || elem.options )
				ret.push( elem );

			else
				ret = jQuery.merge( ret, elem );

		});

		return ret;
	},
	
	attr: function( elem, name, value ) {
		var fix = jQuery.isXMLDoc( elem ) ?
			{} :
			jQuery.props;

		// Safari mis-reports the default selected property of a hidden option
		// Accessing the parent's selectedIndex property fixes it
		if ( name == "selected" && jQuery.browser.safari )
			elem.parentNode.selectedIndex;
		
		// Certain attributes only work when accessed via the old DOM 0 way
		if ( fix[ name ] ) {
			if ( value != undefined )
				elem[ fix[ name ] ] = value;

			return elem[ fix[ name ] ];

		} else if ( jQuery.browser.msie && name == "style" )
			return jQuery.attr( elem.style, "cssText", value );

		else if ( value == undefined && jQuery.browser.msie && jQuery.nodeName( elem, "form" ) && (name == "action" || name == "method") )
			return elem.getAttributeNode( name ).nodeValue;

		// IE elem.getAttribute passes even for style
		else if ( elem.tagName ) {

			if ( value != undefined ) {
				// We can't allow the type property to be changed (since it causes problems in IE)
				if ( name == "type" && jQuery.nodeName( elem, "input" ) && elem.parentNode )
					throw "type property can't be changed";

				elem.setAttribute( name, value );
			}

			if ( jQuery.browser.msie && /href|src/.test( name ) && !jQuery.isXMLDoc( elem ) ) 
				return elem.getAttribute( name, 2 );

			return elem.getAttribute( name );

		// elem is actually elem.style ... set the style
		} else {
			// IE actually uses filters for opacity
			if ( name == "opacity" && jQuery.browser.msie ) {
				if ( value != undefined ) {
					// IE has trouble with opacity if it does not have layout
					// Force it by setting the zoom level
					elem.zoom = 1; 
	
					// Set the alpha filter to set the opacity
					elem.filter = (elem.filter || "").replace( /alpha\([^)]*\)/, "" ) +
						(parseFloat( value ).toString() == "NaN" ? "" : "alpha(opacity=" + value * 100 + ")");
				}
	
				return elem.filter ? 
					(parseFloat( elem.filter.match(/opacity=([^)]*)/)[1] ) / 100).toString() :
					"";
			}

			name = name.replace(/-([a-z])/ig, function(all, letter){
				return letter.toUpperCase();
			});

			if ( value != undefined )
				elem[ name ] = value;

			return elem[ name ];
		}
	},
	
	trim: function( text ) {
		return (text || "").replace( /^\s+|\s+$/g, "" );
	},

	makeArray: function( array ) {
		var ret = [];

		// Need to use typeof to fight Safari childNodes crashes
		if ( typeof array != "array" )
			for ( var i = 0, length = array.length; i  length; i++ )
				ret.push( array[ i ] );
		else
			ret = array.slice( 0 );

		return ret;
	},

	inArray: function( elem, array ) {
		for ( var i = 0, length = array.length; i  length; i++ )
			if ( array[ i ] == elem )
				return i;

		return -1;
	},

	merge: function( first, second ) {
		// We have to loop this way because IE & Opera overwrite the length
		// expando of getElementsByTagName

		// Also, we need to make sure that the correct elements are being returned
		// (IE returns comment nodes in a '*' query)
		if ( jQuery.browser.msie ) {
			for ( var i = 0; second[ i ]; i++ )
				if ( second[ i ].nodeType != 8 )
					first.push( second[ i ] );

		} else
			for ( var i = 0; second[ i ]; i++ )
				first.push( second[ i ] );

		return first;
	},

	unique: function( array ) {
		var ret = [], done = {};

		try {

			for ( var i = 0, length = array.length; i  length; i++ ) {
				var id = jQuery.data( array[ i ] );

				if ( !done[ id ] ) {
					done[ id ] = true;
					ret.push( array[ i ] );
				}
			}

		} catch( e ) {
			ret = array;
		}

		return ret;
	},

	grep: function( elems, callback, inv ) {
		// If a string is passed in for the function, make a function
		// for it (a handy shortcut)
		if ( typeof callback == "string" )
			callback = eval("false||function(a,i){return " + callback + "}");

		var ret = [];

		// Go through the array, only saving the items
		// that pass the validator function
		for ( var i = 0, length = elems.length; i  length; i++ )
			if ( !inv && callback( elems[ i ], i ) || inv && !callback( elems[ i ], i ) )
				ret.push( elems[ i ] );

		return ret;
	},

	map: function( elems, callback ) {
		var ret = [];

		// Go through the array, translating each of the items to their
		// new value (or values).
		for ( var i = 0, length = elems.length; i  length; i++ ) {
			var value = callback( elems[ i ], i );

			if ( value !== null && value != undefined ) {
				if ( value.constructor != Array )
					value = [ value ];

				ret = ret.concat( value );
			}
		}

		return ret;
	}
});

var userAgent = navigator.userAgent.toLowerCase();

// Figure out what browser is being used
jQuery.browser = {
	version: (userAgent.match( /.+(?:rv|it|ra|ie)[\/: ]([\d.]+)/ ) || [])[1],
	safari: /webkit/.test( userAgent ),
	opera: /opera/.test( userAgent ),
	msie: /msie/.test( userAgent ) && !/opera/.test( userAgent ),
	mozilla: /mozilla/.test( userAgent ) && !/(compatible|webkit)/.test( userAgent )
};

var styleFloat = jQuery.browser.msie ?
	"styleFloat" :
	"cssFloat";
	
jQuery.extend({
	// Check to see if the W3C box model is being used
	boxModel: !jQuery.browser.msie || document.compatMode == "CSS1Compat",
	
	props: {
		"for": "htmlFor",
		"class": "className",
		"float": styleFloat,
		cssFloat: styleFloat,
		styleFloat: styleFloat,
		innerHTML: "innerHTML",
		className: "className",
		value: "value",
		disabled: "disabled",
		checked: "checked",
		readonly: "readOnly",
		selected: "selected",
		maxlength: "maxLength",
		selectedIndex: "selectedIndex"
	}
});

jQuery.each({
	parent: "elem.parentNode",
	parents: "jQuery.dir(elem,'parentNode')",
	next: "jQuery.nth(elem,2,'nextSibling')",
	prev: "jQuery.nth(elem,2,'previousSibling')",
	nextAll: "jQuery.dir(elem,'nextSibling')",
	prevAll: "jQuery.dir(elem,'previousSibling')",
	siblings: "jQuery.sibling(elem.parentNode.firstChild,elem)",
	children: "jQuery.sibling(elem.firstChild)",
	contents: "jQuery.nodeName(elem,'iframe')?elem.contentDocument||elem.contentWindow.document:jQuery.makeArray(elem.childNodes)"
}, function(name, fn){
	fn = eval("false||function(elem){return " + fn + "}");

	jQuery.fn[ name ] = function( selector ) {
		var ret = jQuery.map( this, fn );

		if ( selector && typeof selector == "string" )
			ret = jQuery.multiFilter( selector, ret );

		return this.pushStack( jQuery.unique( ret ) );
	};
});

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function(name, original){
	jQuery.fn[ name ] = function() {
		var args = arguments;

		return this.each(function(){
			for ( var i = 0, length = args.length; i  length; i++ )
				jQuery( args[ i ] )[ original ]( this );
		});
	};
});

jQuery.each({
	removeAttr: function( name ) {
		jQuery.attr( this, name, "" );
		this.removeAttribute( name );
	},

	addClass: function( classNames ) {
		jQuery.className.add( this, classNames );
	},

	removeClass: function( classNames ) {
		jQuery.className.remove( this, classNames );
	},

	toggleClass: function( classNames ) {
		jQuery.className[ jQuery.className.has( this, classNames ) ? "remove" : "add" ]( this, classNames );
	},

	remove: function( selector ) {
		if ( !selector || jQuery.filter( selector, [ this ] ).r.length ) {
			// Prevent memory leaks
			jQuery( "*", this ).add(this).each(function(){
				jQuery.event.remove(this);
				jQuery.removeData(this);
			});
			this.parentNode.removeChild( this );
		}
	},

	empty: function() {
		// Remove element nodes and prevent memory leaks
		jQuery( "*", this ).remove();
		
		// Remove any remaining nodes
		while ( this.firstChild )
			this.removeChild( this.firstChild );
	}
}, function(name, fn){
	jQuery.fn[ name ] = function(){
		return this.each( fn, arguments );
	};
});

jQuery.each([ "Height", "Width" ], function(i, name){
	var type = name.toLowerCase();
	
	jQuery.fn[ type ] = function( size ) {
		// Get window width or height
		return this[0] == window ?
			// Opera reports document.body.client[Width/Height] properly in both quirks and standards
			jQuery.browser.opera && document.body[ "client" + name ] || 
			
			// Safari reports inner[Width/Height] just fine (Mozilla and Opera include scroll bar widths)
			jQuery.browser.safari && window[ "inner" + name ] ||
			
			// Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode
			document.compatMode == "CSS1Compat" && document.documentElement[ "client" + name ] || document.body[ "client" + name ] :
		
			// Get document width or height
			this[0] == document ?
				// Either scroll[Width/Height] or offset[Width/Height], whichever is greater (Mozilla reports scrollWidth the same as offsetWidth)
				Math.max( document.body[ "scroll" + name ], document.body[ "offset" + name ] ) :
        
				// Get or set width or height on the element
				size == undefined ?
					// Get width or height on the element
					(this.length ? jQuery.css( this[0], type ) : null) :

					// Set the width or height on the element (default to pixels if value is unitless)
					this.css( type, size.constructor == String ? size : size + "px" );
	};
});

var chars = jQuery.browser.safari && parseInt(jQuery.browser.version)  417 ?
		"(?:[\\w*_-]|\\\\.)" :
		"(?:[\\w\u0128-\uFFFF*_-]|\\\\.)",
	quickChild = new RegExp("^\\s*(" + chars + "+)"),
	quickID = new RegExp("^(" + chars + "+)(#)(" + chars + "+)"),
	quickClass = new RegExp("^([#.]?)(" + chars + "*)");

jQuery.extend({
	expr: {
		"": "m[2]=='*'||jQuery.nodeName(a,m[2])",
		"#": "a.getAttribute('id')==m[2]",
		":": {
			// Position Checks
			lt: "im[3]-0",
			gt: "im[3]-0",
			nth: "m[3]-0==i",
			eq: "m[3]-0==i",
			first: "i==0",
			last: "i==r.length-1",
			even: "i%2==0",
			odd: "i%2",

			// Child Checks
			"first-child": "a.parentNode.getElementsByTagName('*')[0]==a",
			"last-child": "jQuery.nth(a.parentNode.lastChild,1,'previousSibling')==a",
			"only-child": "!jQuery.nth(a.parentNode.lastChild,2,'previousSibling')",

			// Parent Checks
			parent: "a.firstChild",
			empty: "!a.firstChild",

			// Text Check
			contains: "(a.textContent||a.innerText||jQuery(a).text()||'').indexOf(m[3])=0",

			// Visibility
			visible: '"hidden"!=a.type&&jQuery.css(a,"display")!="none"&&jQuery.css(a,"visibility")!="hidden"',
			hidden: '"hidden"==a.type||jQuery.css(a,"display")=="none"||jQuery.css(a,"visibility")=="hidden"',

			// Form attributes
			enabled: "!a.disabled",
			disabled: "a.disabled",
			checked: "a.checked",
			selected: "a.selected||jQuery.attr(a,'selected')",

			// Form elements
			text: "'text'==a.type",
			radio: "'radio'==a.type",
			checkbox: "'checkbox'==a.type",
			file: "'file'==a.type",
			password: "'password'==a.type",
			submit: "'submit'==a.type",
			image: "'image'==a.type",
			reset: "'reset'==a.type",
			button: '"button"==a.type||jQuery.nodeName(a,"button")',
			input: "/input|select|textarea|button/i.test(a.nodeName)",

			// :has()
			has: "jQuery.find(m[3],a).length",

			// :header
			header: "/h\\d/i.test(a.nodeName)",

			// :animated
			animated: "jQuery.grep(jQuery.timers,function(fn){return a==fn.elem;}).length"
		}
	},
	
	// The regular expressions that power the parsing engine
	parse: [
		// Match: [@value='test'], [@foo]
		/^(\[) *@?([\w-]+) *([!*$^~=]*) *('?"?)(.*?)\4 *\]/,

		// Match: :contains('foo')
		/^(:)([\w-]+)\("?'?(.*?(\(.*?\))?[^(]*?)"?'?\)/,

		// Match: :even, :last-chlid, #id, .class
		new RegExp("^([:.#]*)(" + chars + "+)")
	],

	multiFilter: function( expr, elems, not ) {
		var old, cur = [];

		while ( expr && expr != old ) {
			old = expr;
			var f = jQuery.filter( expr, elems, not );
			expr = f.t.replace(/^\s*,\s*/, "" );
			cur = not ? elems = f.r : jQuery.merge( cur, f.r );
		}

		return cur;
	},

	find: function( t, context ) {
		// Quickly handle non-string expressions
		if ( typeof t != "string" )
			return [ t ];

		// Make sure that the context is a DOM Element
		if ( context && !context.nodeType )
			context = null;

		// Set the correct context (if none is provided)
		context = context || document;

		// Initialize the search
		var ret = [context], done = [], last;

		// Continue while a selector expression exists, and while
		// we're no longer looping upon ourselves
		while ( t && last != t ) {
			var r = [];
			last = t;

			t = jQuery.trim(t);

			var foundToken = false;

			// An attempt at speeding up child selectors that
			// point to a specific element tag
			var re = quickChild;
			var m = re.exec(t);

			if ( m ) {
				var nodeName = m[1].toUpperCase();

				// Perform our own iteration and filter
				for ( var i = 0; ret[i]; i++ )
					for ( var c = ret[i].firstChild; c; c = c.nextSibling )
						if ( c.nodeType == 1 && (nodeName == "*" || c.nodeName.toUpperCase() == nodeName.toUpperCase()) )
							r.push( c );

				ret = r;
				t = t.replace( re, "" );
				if ( t.indexOf(" ") == 0 ) continue;
				foundToken = true;
			} else {
				re = /^([+~])\s*(\w*)/i;

				if ( (m = re.exec(t)) != null ) {
					r = [];

					var nodeName = m[2], merge = {};
					m = m[1];

					for ( var j = 0, rl = ret.length; j  rl; j++ ) {
						var n = m == "~" || m == "+" ? ret[j].nextSibling : ret[j].firstChild;
						for ( ; n; n = n.nextSibling )
							if ( n.nodeType == 1 ) {
								var id = jQuery.data(n);

								if ( m == "~" && merge[id] ) break;
								
								if (!nodeName || n.nodeName.toUpperCase() == nodeName.toUpperCase() ) {
									if ( m == "~" ) merge[id] = true;
									r.push( n );
								}
								
								if ( m == "+" ) break;
							}
					}

					ret = r;

					// And remove the token
					t = jQuery.trim( t.replace( re, "" ) );
					foundToken = true;
				}
			}

			// See if there's still an expression, and that we haven't already
			// matched a token
			if ( t && !foundToken ) {
				// Handle multiple expressions
				if ( !t.indexOf(",") ) {
					// Clean the result set
					if ( context == ret[0] ) ret.shift();

					// Merge the result sets
					done = jQuery.merge( done, ret );

					// Reset the context
					r = ret = [context];

					// Touch up the selector string
					t = " " + t.substr(1,t.length);

				} else {
					// Optimize for the case nodeName#idName
					var re2 = quickID;
					var m = re2.exec(t);
					
					// Re-organize the results, so that they're consistent
					if ( m ) {
					   m = [ 0, m[2], m[3], m[1] ];

					} else {
						// Otherwise, do a traditional filter check for
						// ID, class, and element selectors
						re2 = quickClass;
						m = re2.exec(t);
					}

					m[2] = m[2].replace(/\\/g, "");

					var elem = ret[ret.length-1];

					// Try to do a global search by ID, where we can
					if ( m[1] == "#" && elem && elem.getElementById && !jQuery.isXMLDoc(elem) ) {
						// Optimization for HTML document case
						var oid = elem.getElementById(m[2]);
						
						// Do a quick check for the existence of the actual ID attribute
						// to avoid selecting by the name attribute in IE
						// also check to insure id is a string to avoid selecting an element with the name of 'id' inside a form
						if ( (jQuery.browser.msie||jQuery.browser.opera) && oid && typeof oid.id == "string" && oid.id != m[2] )
							oid = jQuery('[@id="'+m[2]+'"]', elem)[0];

						// Do a quick check for node name (where applicable) so
						// that div#foo searches will be really fast
						ret = r = oid && (!m[3] || jQuery.nodeName(oid, m[3])) ? [oid] : [];
					} else {
						// We need to find all descendant elements
						for ( var i = 0; ret[i]; i++ ) {
							// Grab the tag name being searched for
							var tag = m[1] == "#" && m[3] ? m[3] : m[1] != "" || m[0] == "" ? "*" : m[2];

							// Handle IE7 being really dumb about objects
							if ( tag == "*" && ret[i].nodeName.toLowerCase() == "object" )
								tag = "param";

							r = jQuery.merge( r, ret[i].getElementsByTagName( tag ));
						}

						// It's faster to filter by class and be done with it
						if ( m[1] == "." )
							r = jQuery.classFilter( r, m[2] );

						// Same with ID filtering
						if ( m[1] == "#" ) {
							var tmp = [];

							// Try to find the element with the ID
							for ( var i = 0; r[i]; i++ )
								if ( r[i].getAttribute("id") == m[2] ) {
									tmp = [ r[i] ];
									break;
								}

							r = tmp;
						}

						ret = r;
					}

					t = t.replace( re2, "" );
				}

			}

			// If a selector string still exists
			if ( t ) {
				// Attempt to filter it
				var val = jQuery.filter(t,r);
				ret = r = val.r;
				t = jQuery.trim(val.t);
			}
		}

		// An error occurred with the selector;
		// just return an empty set instead
		if ( t )
			ret = [];

		// Remove the root context
		if ( ret && context == ret[0] )
			ret.shift();

		// And combine the results
		done = jQuery.merge( done, ret );

		return done;
	},

	classFilter: function(r,m,not){
		m = " " + m + " ";
		var tmp = [];
		for ( var i = 0; r[i]; i++ ) {
			var pass = (" " + r[i].className + " ").indexOf( m ) = 0;
			if ( !not && pass || not && !pass )
				tmp.push( r[i] );
		}
		return tmp;
	},

	filter: function(t,r,not) {
		var last;

		// Look for common filter expressions
		while ( t  && t != last ) {
			last = t;

			var p = jQuery.parse, m;

			for ( var i = 0; p[i]; i++ ) {
				m = p[i].exec( t );

				if ( m ) {
					// Remove what we just matched
					t = t.substring( m[0].length );

					m[2] = m[2].replace(/\\/g, "");
					break;
				}
			}

			if ( !m )
				break;

			// :not() is a special case that can be optimized by
			// keeping it out of the expression list
			if ( m[1] == ":" && m[2] == "not" )
				r = jQuery.filter(m[3], r, true).r;

			// We can get a big speed boost by filtering by class here
			else if ( m[1] == "." )
				r = jQuery.classFilter(r, m[2], not);

			else if ( m[1] == "[" ) {
				var tmp = [], type = m[3];
				
				for ( var i = 0, rl = r.length; i  rl; i++ ) {
					var a = r[i], z = a[ jQuery.props[m[2]] || m[2] ];
					
					if ( z == null || /href|src|selected/.test(m[2]) )
						z = jQuery.attr(a,m[2]) || '';

					if ( (type == "" && !!z ||
						 type == "=" && z == m[5] ||
						 type == "!=" && z != m[5] ||
						 type == "^=" && z && !z.indexOf(m[5]) ||
						 type == "$=" && z.substr(z.length - m[5].length) == m[5] ||
						 (type == "*=" || type == "~=") && z.indexOf(m[5]) = 0) ^ not )
							tmp.push( a );
				}
				
				r = tmp;

			// We can get a speed boost by handling nth-child here
			} else if ( m[1] == ":" && m[2] == "nth-child" ) {
				var merge = {}, tmp = [],
					test = /(\d*)n\+?(\d*)/.exec(
						m[3] == "even" && "2n" || m[3] == "odd" && "2n+1" ||
						!/\D/.test(m[3]) && "n+" + m[3] || m[3]),
					first = (test[1] || 1) - 0, last = test[2] - 0;

				for ( var i = 0, rl = r.length; i  rl; i++ ) {
					var node = r[i], parentNode = node.parentNode, id = jQuery.data(parentNode);

					if ( !merge[id] ) {
						var c = 1;

						for ( var n = parentNode.firstChild; n; n = n.nextSibling )
							if ( n.nodeType == 1 )
								n.nodeIndex = c++;

						merge[id] = true;
					}

					var add = false;

					if ( first == 1 ) {
						if ( last == 0 || node.nodeIndex == last )
							add = true;
					} else if ( (node.nodeIndex + last) % first == 0 )
						add = true;

					if ( add ^ not )
						tmp.push( node );
				}

				r = tmp;

			// Otherwise, find the expression to execute
			} else {
				var f = jQuery.expr[m[1]];
				if ( typeof f != "string" )
					f = jQuery.expr[m[1]][m[2]];

				// Build a custom macro to enclose it
				f = eval("false||function(a,i){return " + f + "}");

				// Execute it against the current filter
				r = jQuery.grep( r, f, not );
			}
		}

		// Return an array of filtered elements (r)
		// and the modified expression string (t)
		return { r: r, t: t };
	},

	dir: function( elem, dir ){
		var matched = [];
		var cur = elem[dir];
		while ( cur && cur != document ) {
			if ( cur.nodeType == 1 )
				matched.push( cur );
			cur = cur[dir];
		}
		return matched;
	},
	
	nth: function(cur,result,dir,elem){
		result = result || 1;
		var num = 0;

		for ( ; cur; cur = cur[dir] )
			if ( cur.nodeType == 1 && ++num == result )
				break;

		return cur;
	},
	
	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType == 1 && (!elem || n != elem) )
				r.push( n );
		}

		return r;
	}
});
/*
 * A number of helper functions used for managing events.
 * Many of the ideas behind this code orignated from 
 * Dean Edwards' addEvent library.
 */
jQuery.event = {

	// Bind an event to an element
	// Original by Dean Edwards
	add: function(element, type, handler, data) {
		// For whatever reason, IE has trouble passing the window object
		// around, causing it to be cloned in the process
		if ( jQuery.browser.msie && element.setInterval != undefined )
			element = window;

		// Make sure that the function being executed has a unique ID
		if ( !handler.guid )
			handler.guid = this.guid++;
			
		// if data is passed, bind to handler 
		if( data != undefined ) { 
        		// Create temporary function pointer to original handler 
			var fn = handler; 

			// Create unique handler function, wrapped around original handler 
			handler = function() { 
				// Pass arguments and context to original handler 
				return fn.apply(this, arguments); 
			};

			// Store data in unique handler 
			handler.data = data;

			// Set the guid of unique handler to the same of original handler, so it can be removed 
			handler.guid = fn.guid;
		}

		// Namespaced event handlers
		var parts = type.split(".");
		type = parts[0];
		handler.type = parts[1];

		// Init the element's event structure
		var events = jQuery.data(element, "events") || jQuery.data(element, "events", {});
		
		var handle = jQuery.data(element, "handle") || jQuery.data(element, "handle", function(){
			// returned undefined or false
			var val;

			// Handle the second event of a trigger and when
			// an event is called after a page has unloaded
			if ( typeof jQuery == "undefined" || jQuery.event.triggered )
				return val;
			
			val = jQuery.event.handle.apply(element, arguments);
			
			return val;
		});

		// Get the current list of functions bound to this event
		var handlers = events[type];

		// Init the event handler queue
		if (!handlers) {
			handlers = events[type] = {};	
			
			// And bind the global event handler to the element
			if (element.addEventListener)
				element.addEventListener(type, handle, false);
			else
				element.attachEvent("on" + type, handle);
		}

		// Add the function to the element's handler list
		handlers[handler.guid] = handler;

		// Keep track of which events have been used, for global triggering
		this.global[type] = true;
	},

	guid: 1,
	global: {},

	// Detach an event or set of events from an element
	remove: function(element, type, handler) {
		var events = jQuery.data(element, "events"), ret, index;

		// Namespaced event handlers
		if ( typeof type == "string" ) {
			var parts = type.split(".");
			type = parts[0];
		}

		if ( events ) {
			// type is actually an event object here
			if ( type && type.type ) {
				handler = type.handler;
				type = type.type;
			}
			
			if ( !type ) {
				for ( type in events )
					this.remove( element, type );

			} else if ( events[type] ) {
				// remove the given handler for the given type
				if ( handler )
					delete events[type][handler.guid];
				
				// remove all handlers for the given type
				else
					for ( handler in events[type] )
						// Handle the removal of namespaced events
						if ( !parts[1] || events[type][handler].type == parts[1] )
							delete events[type][handler];

				// remove generic event handler if no more handlers exist
				for ( ret in events[type] ) break;
				if ( !ret ) {
					if (element.removeEventListener)
						element.removeEventListener(type, jQuery.data(element, "handle"), false);
					else
						element.detachEvent("on" + type, jQuery.data(element, "handle"));
					ret = null;
					delete events[type];
				}
			}

			// Remove the expando if it's no longer used
			for ( ret in events ) break;
			if ( !ret ) {
				jQuery.removeData( element, "events" );
				jQuery.removeData( element, "handle" );
			}
		}
	},

	trigger: function(type, data, element, donative, extra) {
		// Clone the incoming data, if any
		data = jQuery.makeArray(data || []);

		// Handle a global trigger
		if ( !element ) {
			// Only trigger if we've ever bound an event for it
			if ( this.global[type] )
				jQuery("*").add([window, document]).trigger(type, data);

		// Handle triggering a single element
		} else {
			var val, ret, fn = jQuery.isFunction( element[ type ] || null ),
				// Check to see if we need to provide a fake event, or not
				event = !data[0] || !data[0].preventDefault;
			
			// Pass along a fake event
			if ( event )
				data.unshift( this.fix({ type: type, target: element }) );

			// Enforce the right trigger type
			data[0].type = type;

			// Trigger the event
			if ( jQuery.isFunction( jQuery.data(element, "handle") ) )
				val = jQuery.data(element, "handle").apply( element, data );

			// Handle triggering native .onfoo handlers
			if ( !fn && element["on"+type] && element["on"+type].apply( element, data ) === false )
				val = false;

			// Extra functions don't get the custom event object
			if ( event )
				data.shift();

			// Handle triggering of extra function
			if ( extra && extra.apply( element, data ) === false )
				val = false;

			// Trigger the native events (except for clicks on links)
			if ( fn && donative !== false && val !== false && !(jQuery.nodeName(element, 'a') && type == "click") ) {
				this.triggered = true;
				element[ type ]();
			}

			this.triggered = false;
		}

		return val;
	},

	handle: function(event) {
		// returned undefined or false
		var val;

		// Empty object is for triggered events with no data
		event = jQuery.event.fix( event || window.event || {} ); 

		// Namespaced event handlers
		var parts = event.type.split(".");
		event.type = parts[0];

		var handlers = jQuery.data(this, "events") && jQuery.data(this, "events")[event.type], args = Array.prototype.slice.call( arguments, 1 );
		args.unshift( event );

		for ( var j in handlers ) {
			var handler = handlers[j];
			// Pass in a reference to the handler function itself
			// So that we can later remove it
			args[0].handler = handler;
			args[0].data = handler.data;

			// Filter the functions by class
			if ( !parts[1] || handler.type == parts[1] ) {
				var ret = handler.apply( this, args );

				if ( val !== false )
					val = ret;

				if ( ret === false ) {
					event.preventDefault();
					event.stopPropagation();
				}
			}
		}

		// Clean up added properties in IE to prevent memory leak
		if (jQuery.browser.msie)
			event.target = event.preventDefault = event.stopPropagation =
				event.handler = event.data = null;

		return val;
	},

	fix: function(event) {
		// store a copy of the original event object 
		// and clone to set read-only properties
		var originalEvent = event;
		event = jQuery.extend({}, originalEvent);
		
		// add preventDefault and stopPropagation since 
		// they will not work on the clone
		event.preventDefault = function() {
			// if preventDefault exists run it on the original event
			if (originalEvent.preventDefault)
				originalEvent.preventDefault();
			// otherwise set the returnValue property of the original event to false (IE)
			originalEvent.returnValue = false;
		};
		event.stopPropagation = function() {
			// if stopPropagation exists run it on the original event
			if (originalEvent.stopPropagation)
				originalEvent.stopPropagation();
			// otherwise set the cancelBubble property of the original event to true (IE)
			originalEvent.cancelBubble = true;
		};
		
		// Fix target property, if necessary
		if ( !event.target && event.srcElement )
			event.target = event.srcElement;
				
		// check if target is a textnode (safari)
		if (jQuery.browser.safari && event.target.nodeType == 3)
			event.target = originalEvent.target.parentNode;

		// Add relatedTarget, if necessary
		if ( !event.relatedTarget && event.fromElement )
			event.relatedTarget = event.fromElement == event.target ? event.toElement : event.fromElement;

		// Calculate pageX/Y if missing and clientX/Y available
		if ( event.pageX == null && event.clientX != null ) {
			var doc = document.documentElement, body = document.body;
			event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc.clientLeft || 0);
			event.pageY = event.clientY + (doc && doc.scrollTop  || body && body.scrollTop  || 0) - (doc.clientLeft || 0);
		}
			
		// Add which for key events
		if ( !event.which && (event.charCode || event.keyCode) )
			event.which = event.charCode || event.keyCode;
		
		// Add metaKey to non-Mac browsers (use ctrl for PC's and Meta for Macs)
		if ( !event.metaKey && event.ctrlKey )
			event.metaKey = event.ctrlKey;

		// Add which for click: 1 == left; 2 == middle; 3 == right
		// Note: button is not normalized, so don't use it
		if ( !event.which && event.button )
			event.which = (event.button & 1 ? 1 : ( event.button & 2 ? 3 : ( event.button & 4 ? 2 : 0 ) ));
			
		return event;
	}
};

jQuery.fn.extend({
	bind: function( type, data, fn ) {
		return type == "unload" ? this.one(type, data, fn) : this.each(function(){
			jQuery.event.add( this, type, fn || data, fn && data );
		});
	},
	
	one: function( type, data, fn ) {
		return this.each(function(){
			jQuery.event.add( this, type, function(event) {
				jQuery(this).unbind(event);
				return (fn || data).apply( this, arguments);
			}, fn && data);
		});
	},

	unbind: function( type, fn ) {
		return this.each(function(){
			jQuery.event.remove( this, type, fn );
		});
	},

	trigger: function( type, data, fn ) {
		return this.each(function(){
			jQuery.event.trigger( type, data, this, true, fn );
		});
	},

	triggerHandler: function( type, data, fn ) {
		if ( this[0] )
			return jQuery.event.trigger( type, data, this[0], false, fn );
	},

	toggle: function() {
		// Save reference to arguments for access in closure
		var args = arguments;

		return this.click(function(event) {
			// Figure out which function to execute
			this.lastToggle = 0 == this.lastToggle ? 1 : 0;
			
			// Make sure that clicks stop
			event.preventDefault();
			
			// and execute the function
			return args[this.lastToggle].apply( this, [event] ) || false;
		});
	},

	hover: function(fnOver, fnOut) {
		
		// A private function for handling mouse 'hovering'
		function handleHover(event) {
			// Check if mouse(over|out) are still within the same parent element
			var parent = event.relatedTarget;
	
			// Traverse up the tree
			while ( parent && parent != this ) try { parent = parent.parentNode; } catch(error) { parent = this; };
			
			// If we actually just moused on to a sub-element, ignore it
			if ( parent == this ) return false;
			
			// Execute the right function
			return (event.type == "mouseover" ? fnOver : fnOut).apply(this, [event]);
		}
		
		// Bind the function to the two event listeners
		return this.mouseover(handleHover).mouseout(handleHover);
	},
	
	ready: function(fn) {
		// Attach the listeners
		bindReady();

		// If the DOM is already ready
		if ( jQuery.isReady )
			// Execute the function immediately
			fn.apply( document, [jQuery] );
			
		// Otherwise, remember the function for later
		else
			// Add the function to the wait list
			jQuery.readyList.push( function() { return fn.apply(this, [jQuery]); } );
	
		return this;
	}
});

jQuery.extend({
	/*
	 * All the code that makes DOM Ready work nicely.
	 */
	isReady: false,
	readyList: [],
	
	// Handle when the DOM is ready
	ready: function() {
		// Make sure that the DOM is not already loaded
		if ( !jQuery.isReady ) {
			// Remember that the DOM is ready
			jQuery.isReady = true;
			
			// If there are functions bound, to execute
			if ( jQuery.readyList ) {
				// Execute all of them
				jQuery.each( jQuery.readyList, function(){
					this.apply( document );
				});
				
				// Reset the list of functions
				jQuery.readyList = null;
			}
			// Remove event listener to avoid memory leak
			if ( jQuery.browser.mozilla || jQuery.browser.opera )
				document.removeEventListener( "DOMContentLoaded", jQuery.ready, false );
		}
	}
});


jQuery.each( ("blur,focus,load,resize,scroll,unload,click,dblclick," +
	"mousedown,mouseup,mousemove,mouseover,mouseout,change,select," + 
	"submit,keydown,keypress,keyup,error").split(","), function(i, name){
	
	// Handle event binding
	jQuery.fn[name] = function(fn){
		return fn ? this.bind(name, fn) : this.trigger(name);
	};
});

var readyBound = false;

function bindReady(){
	if ( readyBound ) return;
	readyBound = true;

	// If Mozilla is used
	if ( jQuery.browser.mozilla || jQuery.browser.opera )
		// Use the handy event callback
		document.addEventListener( "DOMContentLoaded", jQuery.ready, false );
	
	// If Safari or IE is used
	// Continually check to see if the document is ready
	else (function(){
		try {
			// If IE is used, use the trick by Diego Perini
			// http://javascript.nwbox.com/IEContentLoaded/
			if ( jQuery.browser.msie || document.readyState != "loaded" && document.readyState != "complete" )
				document.documentElement.doScroll("left");
		} catch( error ) {
			return setTimeout( arguments.callee, 0 );
		}

		// and execute any waiting functions
		jQuery.ready();
	})();

	// A fallback to window.onload, that will always work
	jQuery.event.add( window, "load", jQuery.ready );
}

// Prevent memory leaks in IE
if ( jQuery.browser.msie )
	jQuery(window).bind("unload", function() {
		$("*").add([document, window]).unbind();
	});
jQuery.fn.extend({
	load: function( url, params, callback ) {
		if ( jQuery.isFunction( url ) )
			return this.bind("load", url);

		var off = url.indexOf(" ");
		if ( off = 0 ) {
			var selector = url.slice(off, url.length);
			url = url.slice(0, off);
		}

		callback = callback || function(){};

		// Default to a GET request
		var type = "GET";

		// If the second parameter was provided
		if ( params )
			// If it's a function
			if ( jQuery.isFunction( params ) ) {
				// We assume that it's the callback
				callback = params;
				params = null;

			// Otherwise, build a param string
			} else {
				params = jQuery.param( params );
				type = "POST";
			}

		var self = this;

		// Request the remote document
		jQuery.ajax({
			url: url,
			type: type,
			data: params,
			complete: function(res, status){
				// If successful, inject the HTML into all the matched elements
				if ( status == "success" || status == "notmodified" )
					// See if a selector was specified
					self.html( selector ?
						// Create a dummy div to hold the results
						jQuery("div/")
							// inject the contents of the document in, removing the scripts
							// to avoid any 'Permission Denied' errors in IE
							.append(res.responseText.replace(/script(.|\s)*?\/script/g, ""))

							// Locate the specified elements
							.find(selector) :

						// If not, just inject the full result
						res.responseText );

				// Add delay to account for Safari's delay in globalEval
				setTimeout(function(){
					self.each( callback, [res.responseText, status, res] );
				}, 13);
			}
		});
		return this;
	},

	serialize: function() {
		return jQuery.param(this.serializeArray());
	},
	serializeArray: function() {
		return this.map(function(){
			return jQuery.nodeName(this, "form") ?
				jQuery.makeArray(this.elements) : this;
		})
		.filter(function(){
			return this.name && !this.disabled && 
				(this.checked || /select|textarea/i.test(this.nodeName) || 
					/text|hidden|password/i.test(this.type));
		})
		.map(function(i, elem){
			var val = jQuery(this).val();
			return val == null ? null :
				val.constructor == Array ?
					jQuery.map( val, function(val, i){
						return {name: elem.name, value: val};
					}) :
					{name: elem.name, value: val};
		}).get();
	}
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( "ajaxStart,ajaxStop,ajaxComplete,ajaxError,ajaxSuccess,ajaxSend".split(","), function(i,o){
	jQuery.fn[o] = function(f){
		return this.bind(o, f);
	};
});

var jsc = (new Date).getTime();

jQuery.extend({
	get: function( url, data, callback, type ) {
		// shift arguments if data argument was ommited
		if ( jQuery.isFunction( data ) ) {
			callback = data;
			data = null;
		}
		
		return jQuery.ajax({
			type: "GET",
			url: url,
			data: data,
			success: callback,
			dataType: type
		});
	},

	getScript: function( url, callback ) {
		return jQuery.get(url, null, callback, "script");
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get(url, data, callback, "json");
	},

	post: function( url, data, callback, type ) {
		if ( jQuery.isFunction( data ) ) {
			callback = data;
			data = {};
		}

		return jQuery.ajax({
			type: "POST",
			url: url,
			data: data,
			success: callback,
			dataType: type
		});
	},

	ajaxSetup: function( settings ) {
		jQuery.extend( jQuery.ajaxSettings, settings );
	},

	ajaxSettings: {
		global: true,
		type: "GET",
		timeout: 0,
		contentType: "application/x-www-form-urlencoded",
		processData: true,
		async: true,
		data: null
	},
	
	// Last-Modified header cache for next request
	lastModified: {},

	ajax: function( s ) {
		var jsonp, jsre = /=(\?|%3F)/g, status, data;

		// Extend the settings, but re-extend 's' so that it can be
		// checked again later (in the test suite, specifically)
		s = jQuery.extend(true, s, jQuery.extend(true, {}, jQuery.ajaxSettings, s));

		// convert data if not already a string
		if ( s.data && s.processData && typeof s.data != "string" )
			s.data = jQuery.param(s.data);

		// Handle JSONP Parameter Callbacks
		if ( s.dataType == "jsonp" ) {
			if ( s.type.toLowerCase() == "get" ) {
				if ( !s.url.match(jsre) )
					s.url += (s.url.match(/\?/) ? "&" : "?") + (s.jsonp || "callback") + "=?";
			} else if ( !s.data || !s.data.match(jsre) )
				s.data = (s.data ? s.data + "&" : "") + (s.jsonp || "callback") + "=?";
			s.dataType = "json";
		}

		// Build temporary JSONP function
		if ( s.dataType == "json" && (s.data && jsre.test( s.data ) || s.url.match(jsre)) ) {
			jsonp = "jsonp" + jsc++;

			// Replace the =? sequence both in the query string and the data
			if ( s.data )
				s.data = (s.data + "").replace(jsre, "=" + jsonp);
			s.url = s.url.replace(jsre, "=" + jsonp);

			// We need to make sure
			// that a JSONP style response is executed properly
			s.dataType = "script";

			// Handle JSONP-style loading
			window[ jsonp ] = function(tmp){
				data = tmp;
				success();
				complete();
				// Garbage collect
				window[ jsonp ] = undefined;
				try{ delete window[ jsonp ]; } catch(e){}
			};
		}

		if ( s.dataType == "script" && s.cache == null )
			s.cache = false;

		if ( s.cache === false && s.type.toLowerCase() == "get" )
			s.url += (s.url.match(/\?/) ? "&" : "?") + "_=" + (new Date()).getTime();

		// If data is available, append data to url for get requests
		if ( s.data && s.type.toLowerCase() == "get" ) {
			s.url += (s.url.match(/\?/) ? "&" : "?") + s.data;

			// IE likes to send both get and post data, prevent this
			s.data = null;
		}

		// Watch for a new set of requests
		if ( s.global && ! jQuery.active++ )
			jQuery.event.trigger( "ajaxStart" );

		// If we're requesting a remote document
		// and trying to load JSON or Script
		if ( !s.url.indexOf("http") && s.dataType == "script" ) {
			var head = document.getElementsByTagName("head")[0];
			var script = document.createElement("script");
			script.src = s.url;

			// Handle Script loading
			if ( !jsonp ) {
				var done = false;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function(){
					if ( !done && (!this.readyState || 
							this.readyState == "loaded" || this.readyState == "complete") ) {
						done = true;
						success();
						complete();
						head.removeChild( script );
					}
				};
			}

			head.appendChild(script);

			// We handle everything using the script element injection
			return;
		}

		var requestDone = false;

		// Create the request object; Microsoft failed to properly
		// implement the XMLHttpRequest in IE7, so we use the ActiveXObject when it is available
		var xml = window.ActiveXObject ? new ActiveXObject("Microsoft.XMLHTTP") : new XMLHttpRequest();

		// Open the socket
		xml.open(s.type, s.url, s.async);

		// Set the correct header, if data is being sent
		if ( s.data )
			xml.setRequestHeader("Content-Type", s.contentType);

		// Set the If-Modified-Since header, if ifModified mode.
		if ( s.ifModified )
			xml.setRequestHeader("If-Modified-Since",
				jQuery.lastModified[s.url] || "Thu, 01 Jan 1970 00:00:00 GMT" );

		// Set header so the called script knows that it's an XMLHttpRequest
		xml.setRequestHeader("X-Requested-With", "XMLHttpRequest");

		// Allow custom headers/mimetypes
		if ( s.beforeSend )
			s.beforeSend(xml);
			
		if ( s.global )
		    jQuery.event.trigger("ajaxSend", [xml, s]);

		// Wait for a response to come back
		var onreadystatechange = function(isTimeout){
			// The transfer is complete and the data is available, or the request timed out
			if ( !requestDone && xml && (xml.readyState == 4 || isTimeout == "timeout") ) {
				requestDone = true;
				
				// clear poll interval
				if (ival) {
					clearInterval(ival);
					ival = null;
				}
				
				status = isTimeout == "timeout" && "timeout" ||
					!jQuery.httpSuccess( xml ) && "error" ||
					s.ifModified && jQuery.httpNotModified( xml, s.url ) && "notmodified" ||
					"success";

				if ( status == "success" ) {
					// Watch for, and catch, XML document parse errors
					try {
						// process the data (runs the xml through httpData regardless of callback)
						data = jQuery.httpData( xml, s.dataType );
					} catch(e) {
						status = "parsererror";
					}
				}

				// Make sure that the request was successful or notmodified
				if ( status == "success" ) {
					// Cache Last-Modified header, if ifModified mode.
					var modRes;
					try {
						modRes = xml.getResponseHeader("Last-Modified");
					} catch(e) {} // swallow exception thrown by FF if header is not available
	
					if ( s.ifModified && modRes )
						jQuery.lastModified[s.url] = modRes;

					// JSONP handles its own success callback
					if ( !jsonp )
						success();	
				} else
					jQuery.handleError(s, xml, status);

				// Fire the complete handlers
				complete();

				// Stop memory leaks
				if ( s.async )
					xml = null;
			}
		};
		
		if ( s.async ) {
			// don't attach the handler to the request, just poll it instead
			var ival = setInterval(onreadystatechange, 13); 

			// Timeout checker
			if ( s.timeout  0 )
				setTimeout(function(){
					// Check to see if the request is still happening
					if ( xml ) {
						// Cancel the request
						xml.abort();
	
						if( !requestDone )
							onreadystatechange( "timeout" );
					}
				}, s.timeout);
		}
			
		// Send the data
		try {
			xml.send(s.data);
		} catch(e) {
			jQuery.handleError(s, xml, null, e);
		}
		
		// firefox 1.5 doesn't fire statechange for sync requests
		if ( !s.async )
			onreadystatechange();
		
		// return XMLHttpRequest to allow aborting the request etc.
		return xml;

		function success(){
			// If a local callback was specified, fire it and pass it the data
			if ( s.success )
				s.success( data, status );

			// Fire the global callback
			if ( s.global )
				jQuery.event.trigger( "ajaxSuccess", [xml, s] );
		}

		function complete(){
			// Process result
			if ( s.complete )
				s.complete(xml, status);

			// The request was completed
			if ( s.global )
				jQuery.event.trigger( "ajaxComplete", [xml, s] );

			// Handle the global AJAX counter
			if ( s.global && ! --jQuery.active )
				jQuery.event.trigger( "ajaxStop" );
		}
	},

	handleError: function( s, xml, status, e ) {
		// If a local callback was specified, fire it
		if ( s.error ) s.error( xml, status, e );

		// Fire the global callback
		if ( s.global )
			jQuery.event.trigger( "ajaxError", [xml, s, e] );
	},

	// Counter for holding the number of active queries
	active: 0,

	// Determines if an XMLHttpRequest was successful or not
	httpSuccess: function( r ) {
		try {
			return !r.status && location.protocol == "file:" ||
				( r.status = 200 && r.status  300 ) || r.status == 304 ||
				jQuery.browser.safari && r.status == undefined;
		} catch(e){}
		return false;
	},

	// Determines if an XMLHttpRequest returns NotModified
	httpNotModified: function( xml, url ) {
		try {
			var xmlRes = xml.getResponseHeader("Last-Modified");

			// Firefox always returns 200. check Last-Modified date
			return xml.status == 304 || xmlRes == jQuery.lastModified[url] ||
				jQuery.browser.safari && xml.status == undefined;
		} catch(e){}
		return false;
	},

	httpData: function( r, type ) {
		var ct = r.getResponseHeader("content-type");
		var xml = type == "xml" || !type && ct && ct.indexOf("xml") = 0;
		var data = xml ? r.responseXML : r.responseText;

		if ( xml && data.documentElement.tagName == "parsererror" )
			throw "parsererror";

		// If the type is "script", eval it in global context
		if ( type == "script" )
			jQuery.globalEval( data );

		// Get the JavaScript object, if JSON is used.
		if ( type == "json" )
			data = eval("(" + data + ")");

		return data;
	},

	// Serialize an array of form elements or a set of
	// key/values into a query string
	param: function( a ) {
		var s = [];

		// If an array was passed in, assume that it is an array
		// of form elements
		if ( a.constructor == Array || a.jquery )
			// Serialize the form elements
			jQuery.each( a, function(){
				s.push( encodeURIComponent(this.name) + "=" + encodeURIComponent( this.value ) );
			});

		// Otherwise, assume that it's an object of key/value pairs
		else
			// Serialize the key/values
			for ( var j in a )
				// If the value is an array then the key names need to be repeated
				if ( a[j] && a[j].constructor == Array )
					jQuery.each( a[j], function(){
						s.push( encodeURIComponent(j) + "=" + encodeURIComponent( this ) );
					});
				else
					s.push( encodeURIComponent(j) + "=" + encodeURIComponent( a[j] ) );

		// Return the resulting serialization
		return s.join("&").replace(/%20/g, "+");
	}

});
jQuery.fn.extend({
	show: function(speed,callback){
		return speed ?
			this.animate({
				height: "show", width: "show", opacity: "show"
			}, speed, callback) :
			
			this.filter(":hidden").each(function(){
				this.style.display = this.oldblock ? this.oldblock : "";
				if ( jQuery.css(this,"display") == "none" )
					this.style.display = "block";
			}).end();
	},
	
	hide: function(speed,callback){
		return speed ?
			this.animate({
				height: "hide", width: "hide", opacity: "hide"
			}, speed, callback) :
			
			this.filter(":visible").each(function(){
				this.oldblock = this.oldblock || jQuery.css(this,"display");
				if ( this.oldblock == "none" )
					this.oldblock = "block";
				this.style.display = "none";
			}).end();
	},

	// Save the old toggle function
	_toggle: jQuery.fn.toggle,
	
	toggle: function( fn, fn2 ){
		return jQuery.isFunction(fn) && jQuery.isFunction(fn2) ?
			this._toggle( fn, fn2 ) :
			fn ?
				this.animate({
					height: "toggle", width: "toggle", opacity: "toggle"
				}, fn, fn2) :
				this.each(function(){
					jQuery(this)[ jQuery(this).is(":hidden") ? "show" : "hide" ]();
				});
	},
	
	slideDown: function(speed,callback){
		return this.animate({height: "show"}, speed, callback);
	},
	
	slideUp: function(speed,callback){
		return this.animate({height: "hide"}, speed, callback);
	},

	slideToggle: function(speed, callback){
		return this.animate({height: "toggle"}, speed, callback);
	},
	
	fadeIn: function(speed, callback){
		return this.animate({opacity: "show"}, speed, callback);
	},
	
	fadeOut: function(speed, callback){
		return this.animate({opacity: "hide"}, speed, callback);
	},
	
	fadeTo: function(speed,to,callback){
		return this.animate({opacity: to}, speed, callback);
	},
	
	animate: function( prop, speed, easing, callback ) {
		var optall = jQuery.speed(speed, easing, callback);

		return this[ optall.queue === false ? "each" : "queue" ](function(){
			var opt = jQuery.extend({}, optall);
			var hidden = jQuery(this).is(":hidden"), self = this;
			
			for ( var p in prop ) {
				if ( prop[p] == "hide" && hidden || prop[p] == "show" && !hidden )
					return jQuery.isFunction(opt.complete) && opt.complete.apply(this);

				if ( p == "height" || p == "width" ) {
					// Store display property
					opt.display = jQuery.css(this, "display");

					// Make sure that nothing sneaks out
					opt.overflow = this.style.overflow;
				}
			}

			if ( opt.overflow != null )
				this.style.overflow = "hidden";

			opt.curAnim = jQuery.extend({}, prop);
			
			jQuery.each( prop, function(name, val){
				var e = new jQuery.fx( self, opt, name );

				if ( /toggle|show|hide/.test(val) )
					e[ val == "toggle" ? hidden ? "show" : "hide" : val ]( prop );
				else {
					var parts = val.toString().match(/^([+-]=)?([\d+-.]+)(.*)$/),
						start = e.cur(true) || 0;

					if ( parts ) {
						var end = parseFloat(parts[2]),
							unit = parts[3] || "px";

						// We need to compute starting value
						if ( unit != "px" ) {
							self.style[ name ] = (end || 1) + unit;
							start = ((end || 1) / e.cur(true)) * start;
							self.style[ name ] = start + unit;
						}

						// If a +=/-= token was provided, we're doing a relative animation
						if ( parts[1] )
							end = ((parts[1] == "-=" ? -1 : 1) * end) + start;

						e.custom( start, end, unit );
					} else
						e.custom( start, val, "" );
				}
			});

			// For JS strict compliance
			return true;
		});
	},
	
	queue: function(type, fn){
		if ( jQuery.isFunction(type) ) {
			fn = type;
			type = "fx";
		}

		if ( !type || (typeof type == "string" && !fn) )
			return queue( this[0], type );

		return this.each(function(){
			if ( fn.constructor == Array )
				queue(this, type, fn);
			else {
				queue(this, type).push( fn );
			
				if ( queue(this, type).length == 1 )
					fn.apply(this);
			}
		});
	},

	stop: function(){
		var timers = jQuery.timers;

		return this.each(function(){
			for ( var i = 0; i  timers.length; i++ )
				if ( timers[i].elem == this )
					timers.splice(i--, 1);
		}).dequeue();
	}

});

var queue = function( elem, type, array ) {
	if ( !elem )
		return;

	var q = jQuery.data( elem, type + "queue" );

	if ( !q || array )
		q = jQuery.data( elem, type + "queue", 
			array ? jQuery.makeArray(array) : [] );

	return q;
};

jQuery.fn.dequeue = function(type){
	type = type || "fx";

	return this.each(function(){
		var q = queue(this, type);

		q.shift();

		if ( q.length )
			q[0].apply( this );
	});
};

jQuery.extend({
	
	speed: function(speed, easing, fn) {
		var opt = speed && speed.constructor == Object ? speed : {
			complete: fn || !fn && easing || 
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && easing.constructor != Function && easing
		};

		opt.duration = (opt.duration && opt.duration.constructor == Number ? 
			opt.duration : 
			{ slow: 600, fast: 200 }[opt.duration]) || 400;
	
		// Queueing
		opt.old = opt.complete;
		opt.complete = function(){
			jQuery(this).dequeue();
			if ( jQuery.isFunction( opt.old ) )
				opt.old.apply( this );
		};
	
		return opt;
	},
	
	easing: {
		linear: function( p, n, firstNum, diff ) {
			return firstNum + diff * p;
		},
		swing: function( p, n, firstNum, diff ) {
			return ((-Math.cos(p*Math.PI)/2) + 0.5) * diff + firstNum;
		}
	},
	
	timers: [],

	fx: function( elem, options, prop ){
		this.options = options;
		this.elem = elem;
		this.prop = prop;

		if ( !options.orig )
			options.orig = {};
	}

});

jQuery.fx.prototype = {

	// Simple function for setting a style value
	update: function(){
		if ( this.options.step )
			this.options.step.apply( this.elem, [ this.now, this ] );

		(jQuery.fx.step[this.prop] || jQuery.fx.step._default)( this );

		// Set display property to block for height/width animations
		if ( this.prop == "height" || this.prop == "width" )
			this.elem.style.display = "block";
	},

	// Get the current size
	cur: function(force){
		if ( this.elem[this.prop] != null && this.elem.style[this.prop] == null )
			return this.elem[ this.prop ];

		var r = parseFloat(jQuery.curCSS(this.elem, this.prop, force));
		return r && r  -10000 ? r : parseFloat(jQuery.css(this.elem, this.prop)) || 0;
	},

	// Start an animation from one number to another
	custom: function(from, to, unit){
		this.startTime = (new Date()).getTime();
		this.start = from;
		this.end = to;
		this.unit = unit || this.unit || "px";
		this.now = this.start;
		this.pos = this.state = 0;
		this.update();

		var self = this;
		function t(){
			return self.step();
		}

		t.elem = this.elem;

		jQuery.timers.push(t);

		if ( jQuery.timers.length == 1 ) {
			var timer = setInterval(function(){
				var timers = jQuery.timers;
				
				for ( var i = 0; i  timers.length; i++ )
					if ( !timers[i]() )
						timers.splice(i--, 1);

				if ( !timers.length )
					clearInterval( timer );
			}, 13);
		}
	},

	// Simple 'show' function
	show: function(){
		// Remember where we started, so that we can go back to it later
		this.options.orig[this.prop] = jQuery.attr( this.elem.style, this.prop );
		this.options.show = true;

		// Begin the animation
		this.custom(0, this.cur());

		// Make sure that we start at a small width/height to avoid any
		// flash of content
		if ( this.prop == "width" || this.prop == "height" )
			this.elem.style[this.prop] = "1px";
		
		// Start by showing the element
		jQuery(this.elem).show();
	},

	// Simple 'hide' function
	hide: function(){
		// Remember where we started, so that we can go back to it later
		this.options.orig[this.prop] = jQuery.attr( this.elem.style, this.prop );
		this.options.hide = true;

		// Begin the animation
		this.custom(this.cur(), 0);
	},

	// Each step of an animation
	step: function(){
		var t = (new Date()).getTime();

		if ( t  this.options.duration + this.startTime ) {
			this.now = this.end;
			this.pos = this.state = 1;
			this.update();

			this.options.curAnim[ this.prop ] = true;

			var done = true;
			for ( var i in this.options.curAnim )
				if ( this.options.curAnim[i] !== true )
					done = false;

			if ( done ) {
				if ( this.options.display != null ) {
					// Reset the overflow
					this.elem.style.overflow = this.options.overflow;
				
					// Reset the display
					this.elem.style.display = this.options.display;
					if ( jQuery.css(this.elem, "display") == "none" )
						this.elem.style.display = "block";
				}

				// Hide the element if the "hide" operation was done
				if ( this.options.hide )
					this.elem.style.display = "none";

				// Reset the properties, if the item has been hidden or shown
				if ( this.options.hide || this.options.show )
					for ( var p in this.options.curAnim )
						jQuery.attr(this.elem.style, p, this.options.orig[p]);
			}

			// If a callback was provided, execute it
			if ( done && jQuery.isFunction( this.options.complete ) )
				// Execute the complete function
				this.options.complete.apply( this.elem );

			return false;
		} else {
			var n = t - this.startTime;
			this.state = n / this.options.duration;

			// Perform the easing function, defaults to swing
			this.pos = jQuery.easing[this.options.easing || (jQuery.easing.swing ? "swing" : "linear")](this.state, n, 0, 1, this.options.duration);
			this.now = this.start + ((this.end - this.start) * this.pos);

			// Perform the next step of the animation
			this.update();
		}

		return true;
	}

};

jQuery.fx.step = {
	scrollLeft: function(fx){
		fx.elem.scrollLeft = fx.now;
	},

	scrollTop: function(fx){
		fx.elem.scrollTop = fx.now;
	},

	opacity: function(fx){
		jQuery.attr(fx.elem.style, "opacity", fx.now);
	},

	_default: function(fx){
		fx.elem.style[ fx.prop ] = fx.now + fx.unit;
	}
};
// The Offset Method
// Originally By Brandon Aaron, part of the Dimension Plugin
// http://jquery.com/plugins/project/dimensions
jQuery.fn.offset = function() {
	var left = 0, top = 0, elem = this[0], results;
	
	if ( elem ) with ( jQuery.browser ) {
		var	parent       = elem.parentNode, 
		    offsetChild  = elem,
		    offsetParent = elem.offsetParent, 
		    doc          = elem.ownerDocument,
		    safari2      = safari && parseInt(version)  522,
		    fixed        = jQuery.css(elem, "position") == "fixed";
	
		// Use getBoundingClientRect if available
		if ( elem.getBoundingClientRect ) {
			var box = elem.getBoundingClientRect();
		
			// Add the document scroll offsets
			add(
				box.left + Math.max(doc.documentElement.scrollLeft, doc.body.scrollLeft),
				box.top  + Math.max(doc.documentElement.scrollTop,  doc.body.scrollTop)
			);
		
			// IE adds the HTML element's border, by default it is medium which is 2px
			// IE 6 and IE 7 quirks mode the border width is overwritable by the following css html { border: 0; }
			// IE 7 standards mode, the border is always 2px
			if ( msie ) {
				var border = jQuery("html").css("borderWidth");
				border = (border == "medium" || jQuery.boxModel && parseInt(version) = 7) && 2 || border;
				add( -border, -border );
			}
	
		// Otherwise loop through the offsetParents and parentNodes
		} else {
		
			// Initial element offsets
			add( elem.offsetLeft, elem.offsetTop );
		
			// Get parent offsets
			while ( offsetParent ) {
				// Add offsetParent offsets
				add( offsetParent.offsetLeft, offsetParent.offsetTop );
			
				// Mozilla and Safari  2 does not include the border on offset parents
				// However Mozilla adds the border for table or table cells
				if ( mozilla && !/^t(able|d|h)$/i.test(offsetParent.tagName) || safari && !safari2 )
					border( offsetParent );
					
				// Add the document scroll offsets if position is fixed on any offsetParent
				if ( !fixed && jQuery.css(offsetParent, "position") == "fixed" )
					fixed = true;
			
				// Set offsetChild to previous offsetParent unless it is the body element
				offsetChild  = /^body$/i.test(offsetParent.tagName) ? offsetChild : offsetParent;
				// Get next offsetParent
				offsetParent = offsetParent.offsetParent;
			}
		
			// Get parent scroll offsets
			while ( parent.tagName && !/^body|html$/i.test(parent.tagName) ) {
				// Remove parent scroll UNLESS that parent is inline or a table-row to work around Opera inline/table scrollLeft/Top bug
				if ( !/^inline|table-row.*$/i.test(jQuery.css(parent, "display")) )
					// Subtract parent scroll offsets
					add( -parent.scrollLeft, -parent.scrollTop );
			
				// Mozilla does not add the border for a parent that has overflow != visible
				if ( mozilla && jQuery.css(parent, "overflow") != "visible" )
					border( parent );
			
				// Get next parent
				parent = parent.parentNode;
			}
		
			// Safari = 2 doubles body offsets with a fixed position element/offsetParent or absolutely positioned offsetChild
			// Mozilla doubles body offsets with a non-absolutely positioned offsetChild
			if ( (safari2 && (fixed || jQuery.css(offsetChild, "position") == "absolute")) || 
				(mozilla && jQuery.css(offsetChild, "position") != "absoltue") )
					add( -doc.body.offsetLeft, -doc.body.offsetTop );
			
			// Add the document scroll offsets if position is fixed
			if ( fixed )
				add(
					Math.max(doc.documentElement.scrollLeft, doc.body.scrollLeft),
					Math.max(doc.documentElement.scrollTop,  doc.body.scrollTop)
				);
		}

		// Return an object with top and left properties
		results = { top: top, left: left };
	}

	return results;

	function border(elem) {
		add( jQuery.css(elem, "borderLeftWidth"), jQuery.css(elem, "borderTopWidth") );
	}

	function add(l, t) {
		left += parseInt(l) || 0;
		top += parseInt(t) || 0;
	}
};
})();
</content>
		</actual_file>
		<actual_file>
			<filename>jspec.js</filename>
			<content>jspec = {
	fn_contents: function(fn) {
		return fn.toString().match(/^[^\{]*{((.*\n*)*)}/m)[1];
	},
	TOP_LEVEL: 0, DESCRIBE: 1, IT_SHOULD_PASS: 2, IT_SHOULD_FAIL: 3, 
	FAILURE: 4, DONE_EXAMPLE: 5, DONE_GROUP: 6, PENDING: 7,
	logger: function(state, message) {
		switch(state) {
			case jspec.TOP_LEVEL:
				console.group(message);
				break;
			case jspec.DESCRIBE:
				console.group(message);
				break;
			case jspec.IT_SHOULD_PASS:
				console.info(message);
				break;
			case jspec.IT_SHOULD_FAIL:
				console.group(message);
				break;
			case jspec.FAILURE:
				console.error(message);
				console.groupEnd();
				break;
			case jspec.DONE_EXAMPLE:
				console.groupEnd();
				break;
			case jspec.DONE_GROUP:
				console.groupEnd();
  			break;
  		case jspec.PENDING:
    		console.warn("Pending: " + message);
  			break;
		}
		
	},
	describe: function(str, desc) {
		jspec.logger(jspec.TOP_LEVEL, str);
		var it = function(str, fn) {
			if(fn) {
				jspec.logger(jspec.DESCRIBE, str);
				fn();
				jspec.logger(jspec.DONE_EXAMPLE);
			} else {
				jspec.logger(jspec.PENDING, str);
			};
		};
		var Expectation = function(p) { this.expectation = p; };
		Expectation.prototype.to = function(fn_str, to_compare, not) {
		  try {
			  var pass = jspec.matchers[fn_str].matches(this.expectation, to_compare);
				if(not) var pass = !pass;
			} catch(e) {
			  var pass = null;
			}
			var should_string = (jspec.matchers[fn_str].describe && 
			  jspec.matchers[fn_str].describe(this.expectation, to_compare, not)) || 
			  this.toString() + " should " + (not ? "not " : "") + fn_str + " " + to_compare;
			if(pass) {
				jspec.logger(jspec.IT_SHOULD_PASS, should_string + " (PASS)");
			}	else {
				jspec.logger(jspec.IT_SHOULD_FAIL, should_string + (pass == false ? " (FAIL)" : " (ERROR)"));
				jspec.logger(jspec.FAILURE, jspec.matchers[fn_str].failure_message(this.expectation, to_compare, not))
			}
		}
		Expectation.prototype.not_to = function(fn_str, to_compare) { this.to(fn_str, to_compare, true) }
		var expect = function(p) { return new Expectation(p) };
		x = desc.toString()
		var fn_body = this.fn_contents(desc);
		var fn = new Function("it", "expect", fn_body);
		fn.call(this, it, expect);
		jspec.logger(jspec.DONE_GROUP);
	}
}

// Helper for 

jspec.print_object = function(obj) {
  if(obj instanceof Function) {
    return obj.toString().match(/^([^\{]*) {/)[1];
	} else if(obj instanceof Array) {
		return "[" + obj.toString() + "]";
	} else if(obj instanceof HTMLElement) {
		return "" + obj.tagName + " " + (obj.className != "" ? "class='" + obj.className + "'" : "") + 
			(obj.id != "" ? "id='" + obj.id + "'" : "") + "";
  } else {
    return obj.toString().replace(/\n\s*/g, "");
  }
}

// Matchers begin here

jspec.matchers = {};

jspec.matchers["=="] = {
  describe: function(self, target, not) {
    return jspec.print_object(self) + " should " + (not ? "not " : "") + "equal " + jspec.print_object(target)
  },
	matches: function(self, target) {
		return self == target;
	},
	failure_message: function(self, target, not) {
		if (not)
			return "Expected " + jspec.print_object(self) + " not to equal " + jspec.print_object(target);
		else
			return "Expected " + jspec.print_object(self) + ". Got " + jspec.print_object(target);
	}
}

jspec.matchers["include"] = {
	matches: function(self, target) {
		if(Array.prototype.indexOf) return Array.prototype.indexOf.call(self, target) != -1;
		else {
			for(i=0,j=self.length;ij;i++) {
				if(target == self[i]) return true;
			}
			return false;
		}
	},
	failure_message: function(self, target, not) {
		return "Expected [" + jspec.print_object(self) + "] " + (not ? "not " : "") + "to include " + target;
	}  
}

jspec.matchers["exist"] = {
  describe: function(self, target, not) {
    return jspec.print_object(self) + " should " + (not ? "not " : "")  + "exist."
  },
  matches: function(self, target) {
    return !!this;
  },
  failure_message: function(self, target, not) {
    return "Expected " + (not ? "not " : "") + "to exist, but was " + jspec.print_object(self);
  }
}</content>
		</actual_file>
		<actual_file>
			<filename>LICENSE</filename>
			<content>Copyright (c) 2007-2008, Yehuda Katz and contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, thi
  list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice
  this list of conditions and the following disclaimer in the documentatio
  and/or other materials provided with the distribution.
* Neither the name of the Evan Phoenix nor the names of its contributors 
  may be used to endorse or promote products derived from this software 
  without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE 
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</content>
		</actual_file>
		<actual_file>
			<filename>tester.html</filename>
			<content>!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd"

html lang="en"
head
	meta http-equiv="Content-Type" content="text/html; charset=utf-8"
	titletester/title
	meta name="generator" content="TextMate http://macromates.com/"
	meta name="author" content="Yehuda Katz"
	script src="jspec.js"/script
	script$ = "$"/script
	script src="jquery.js"/script
	script
	  jspec.describe("The browser environment", function() {
	    it("should have Array.prototype.push", function() {
	      Array.prototype.push.should("exist");
	    });

	    it("should have Function.prototype.apply", function() {
	      Function.prototype.apply.should("exist");
	    });

	    it("should have document.getElementById", function() {
        document.getElementById.should("exist");
	    });	    

      it("should have document.getElementsByTagName", function() {
        document.getElementsByTagName.should("exist");
      });
      
      it("should have RegExp", function() {
        RegExp.should("exist");
      });
      
      it("should have jQuery", function() {
        jQuery.should("exist");
      });
	  })
	  
	  jspec.describe("$()", function() {
	    it("should generate the correct number of elements for code", function() {
	      $("code/").length.should("==", 1);
	    });
	    
	    it("should generate the correct number of elements for img", function() {
	      $("img/").length.should("==", 1);
	    });
	    
	    it("should generate the correct number of elements for div/hr/code/b/", function() {
	      $("div/hr/code/b/").length.should("==", 4);
	    });
	  })
	  
	  jspec.describe("jQuery.noConflict()", function() {
	    var old = jQuery;
	    var newjQuery = jQuery.noConflict();
	    
	    it("should return the jQuery object", function() {
	      newjQuery.should("==", old);
	    });
	    
	    it("should not have harmed the original jQuery", function() {
	      jQuery.should("==", old)
	    });
	    
	    it("should revert $", function() {
	      $.should("==", "$");
	    });
	    
	    jQuery = $ = old;
	    newjQuery = jQuery.noConflict(true);
	    
	    
	  })
	  
    // var old = jQuery;
    // var newjQuery = jQuery.noConflict();
    // 
    // ok( newjQuery == old, "noConflict returned the jQuery object" );
    // ok( jQuery == old, "Make sure jQuery wasn't touched." );
    // ok( $ == "$", "Make sure $ was reverted." );
    // 
    // jQuery = $ = old;
    // 
    // newjQuery = jQuery.noConflict(true);
    // 
    // ok( newjQuery == old, "noConflict returned the jQuery object" );
    // ok( jQuery == "jQuery", "Make sure jQuery was reverted." );
    // ok( $ == "$", "Make sure $ was reverted." );
    // 
    // jQuery = $ = old;
  	
	
	/script
	!-- Date: 2007-10-28 --
/head
body

/body
/html
</content>
		</actual_file>
		<actual_file>
			<filename>tester2.html</filename>
			<content>!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd"

html lang="en"
head
	meta http-equiv="Content-Type" content="text/html; charset=utf-8"
	titletester2/title
	meta name="generator" content="TextMate http://macromates.com/"
	meta name="author" content="Yehuda Katz"
	script src="jspec.js"/script
	script
		window.onload = function() {
			jspec.describe("JSpec", function() {
				it("should support ==", function() {
					expect(1).to("==", 1);
					var arr = [];
					expect(arr).to("==", arr);
					var obj = new Object;
					expect(obj).to("==", obj);
					expect(document).to("==", document);
				});
			
        it("should support include", function() {
         expect([1,2,3,4,5]).to("include", 3);
         expect([1,2,3,4,5]).not_to("include", 3);
         expect(document.getElementsByTagName("div")).to("include", document.getElementById("hello"))
        });
        
        it("should support exists", function() {
         expect(document).to("exist");
        });

				it("should support pending specs");
        
        jspec.matchers["have_tag_name"] = {
         describe: function(self, target, not) {
           return jspec.print_object(self) + " should " + (not ? "not " : "") + "have " + target + " as its tag name."
         },
         matches: function(self, target) {
           return (self.tagName && self.tagName == target) ? true : false;
         },
         failure_message: function(self, target, not) {
           return "Expected " + jspec.print_object(self) + (not ? " not " : " ") + "to have " + target + " as its tag name," +
             " but was " + self.tagName;
         }
        };
        
        it("should support custom matchers", function() {
         expect(document.getElementById("wrapper")).to("have_tag_name", "DIV");
         expect(document.getElementById("wrapper")).to("have_tag_name", "SPAN");
         expect(document.getElementById("wrapper")).not_to("have_tag_name", "SPAN");         
        });
			});
		};
	/script	
	style type="text/css"
		div#wrapper { display: none ;}
	/style
/head
body

	div id="wrapper"div id="hello"Hello/div/div

/body
/html
</content>
		</actual_file>
	</actual_files>
</repo>
<repo>
	<id>36</id>
	<name>ambition</name>
	<description>include Enumerable — Unmaintained</description>n	<owner>defunkt</owner>
	<main_language>Ruby</main_language>
	<created_at>2008-01-14T06:28:56Z</created_at>
	<updated_at>2013-12-28T13:45:22Z</updated_at>
	<clone_url>https://github.com/defunkt/ambition.git</clone_url>
	<languages>
		<language>Ruby</language>
		<language>JavaScript</language>
	</languages>
	<branches>
		<branch>gh-pages</branch>
		<branch>master</branch>
	</branches>
	<contributors>
		<contributor>defunkt</contributor>
		<contributor>automatthew</contributor>
		<contributor>technicalpickles</contributor>
	</contributors>
	<commits>
		<commit>
			<sha>b24b87b2d11d75fdb35f63ac9cfc0977cb1b9c39</sha>
			<message>add deps.rip</message>
			<author_name>Chris Wanstrath</author_name>
			<author_date>2009-06-11T17:26:55Z</author_date>
			<author_email>chris@ozmm.org</author_email>
			<committer_name>Chris Wanstrath</committer_name>
			<committer_date>2009-06-11T17:26:55Z</committer_date>
			<committer_email>chris@ozmm.org</committer_email>
			<files>
				<file>
					<file_name>deps.rip</file_name>
					<diff>@@ -0,0 +1,3 @@
+git://github.com/drnic/rubigen.git REL-1.3.0
+git://github.com/seattlerb/ruby2ruby.git e3cf57559 # 1.1.8
+git://github.com/seattlerb/parsetree.git 480ede9d9 # 2.1.1</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>3e4ba211ea5dae8c99ccca1979fd2a77027154f2</sha>
			<message>github pages urls</message>
			<author_name>Chris Wanstrath</author_name>
			<author_date>2008-12-17T21:40:22Z</author_date>
			<author_email>chris@ozmm.org</author_email>
			<committer_name>Chris Wanstrath</committer_name>
			<committer_date>2008-12-17T21:40:22Z</committer_date>
			<committer_email>chris@ozmm.org</committer_email>
			<files>
				<file>
					<file_name>site/src/layout.textile</file_name>
					<diff>@@ -5,9 +5,9 @@
 head
   meta http-equiv="Content-Type" content="text/html; charset=utf-8"/
   titleRuby's Ambition/title
-  link href="/static/hubris.css" media="screen" rel="Stylesheet" type="text/css" /
-  script src="/static/code_highlighter.js" type="text/javascript"/script
-  script src="/static/ruby.js" type="text/javascript"/script  
+  link href="http://defunkt.github.com/ambition/static/hubris.css" media="screen" rel="Stylesheet" type="text/css" /
+  script src="http://defunkt.github.com/ambition/static/code_highlighter.js" type="text/javascript"/script
+  script src="http://defunkt.github.com/ambition/static/ruby.js" type="text/javascript"/script  
 /head
 
 body
@@ -15,9 +15,9 @@
     div id="header"
       h1span class="a"A/spanmbition/h1
       div id="nav"
-        a href="/"span class="a"o/spanverview/a
-        &#183; a href="/adapters.html"span class="a"a/spandapters/a
-        &#183; a href="/api.html"span class="a"a/spanpi/a
+        a href="http://defunkt.github.com/ambition/"span class="a"o/spanverview/a
+        &#183; a href="http://defunkt.github.com/ambition/adapters.html"span class="a"a/spandapters/a
+        &#183; a href="http://defunkt.github.com/ambition/api.html"span class="a"a/spanpi/a
       /div
     /div
 </diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>0016ea559f202b3e593a4808bfe94a48aecb0600</sha>
			<message>dependencies</message>
			<author_name>Chris Wanstrath</author_name>
			<author_date>2008-04-26T09:18:16Z</author_date>
			<author_email>chris@ozmm.org</author_email>
			<committer_name>Chris Wanstrath</committer_name>
			<committer_date>2008-04-26T09:18:16Z</committer_date>
			<committer_email>chris@ozmm.org</committer_email>
			<files>
				<file>
					<file_name>Rakefile</file_name>
					<diff>@@ -2,7 +2,7 @@ require 'rake'
 require 'rake/testtask'
 require 'rake/rdoctask'
 
-Version = '0.5.3'
+Version = '0.5.4'
 
 module Rake::TaskManager
   def delete_task(task_class, *args, &block)
@@ -31,8 +31,8 @@ begin
     p.ruby_version   = '= 1.8.6'
     p.ignore_pattern = /^(\.git|site|adapters).+/
     p.test_pattern   = 'test/*_test.rb'
-    p.dependencies   'ParseTree =2.0.1'
-    p.dependencies   'ruby2ruby =1.1.7'
+    p.dependencies   'ParseTree =2.1.1'
+    p.dependencies   'ruby2ruby =1.1.8'
     p.dependencies   'rubigen =1.1.1'
   end
 </diff>
				</file>
				<file>
					<file_name>ambition.gemspec</file_name>
					<diff>@@ -1,10 +1,10 @@
 
-# Gem::Specification for Ambition-0.5.3
+# Gem::Specification for Ambition-0.5.4
 # Originally generated by Echoe
 
 Gem::Specification.new do |s|
   s.name = %q{ambition}
-  s.version = "0.5.3"
+  s.version = "0.5.4"
 
   s.specification_version = 2 if s.respond_to? :specification_version=
 
@@ -26,8 +26,8 @@ Gem::Specification.new do |s|
   s.rubygems_version = %q{1.0.1}
   s.summary = %q{Ambition builds yer API calls from plain jane Ruby.}
 
-  s.add_dependency(%qParseTree, ["= 2.0.1"])
-  s.add_dependency(%qruby2ruby, ["= 1.1.7"])
+  s.add_dependency(%qParseTree, ["= 2.1.1"])
+  s.add_dependency(%qruby2ruby, ["= 1.1.8"])
   s.add_dependency(%qrubigen, ["= 1.1.1"])
 end
 
@@ -38,7 +38,7 @@ end
 # require 'rake/testtask'
 # require 'rake/rdoctask'
 # 
-# Version = '0.5.3'
+# Version = '0.5.4'
 # 
 # module Rake::TaskManager
 #   def delete_task(task_class, *args, &block)
@@ -67,8 +67,8 @@ end
 #     p.ruby_version   = '= 1.8.6'
 #     p.ignore_pattern = /^(\.git|site|adapters).+/
 #     p.test_pattern   = 'test/*_test.rb'
-#     p.dependencies   'ParseTree =2.0.1'
-#     p.dependencies   'ruby2ruby =1.1.7'
+#     p.dependencies   'ParseTree =2.1.1'
+#     p.dependencies   'ruby2ruby =1.1.8'
 #     p.dependencies   'rubigen =1.1.1'
 #   end
 # </diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>ce730e25e0b980d99afe76be9658c9742c9464ab</sha>
			<message>gemspec</message>
			<author_name>Chris Wanstrath</author_name>
			<author_date>2008-04-26T09:11:58Z</author_date>
			<author_email>chris@ozmm.org</author_email>
			<committer_name>Chris Wanstrath</committer_name>
			<committer_date>2008-04-26T09:11:58Z</committer_date>
			<committer_email>chris@ozmm.org</committer_email>
			<files>
				<file>
					<file_name>ambition.gemspec</file_name>
					<diff>@@ -0,0 +1,120 @@
+
+# Gem::Specification for Ambition-0.5.3
+# Originally generated by Echoe
+
+Gem::Specification.new do |s|
+  s.name = %q{ambition}
+  s.version = "0.5.3"
+
+  s.specification_version = 2 if s.respond_to? :specification_version=
+
+  s.required_rubygems_version = Gem::Requirement.new("= 0") if s.respond_to? :required_rubygems_version=
+  s.authors = ["Chris Wanstrath"]
+  s.date = %q{2008-04-26}
+  s.default_executable = %q{ambition_adapter}
+  s.description = %q{Ambition builds yer API calls from plain jane Ruby.}
+  s.email = %q{chris@ozmm.org}
+  s.executables = ["ambition_adapter"]
+  s.extra_rdoc_files = ["bin/ambition_adapter", "lib/ambition/api.rb", "lib/ambition/context.rb", "lib/ambition/core_ext.rb", "lib/ambition/enumerable.rb", "lib/ambition/processors/base.rb", "lib/ambition/processors/ruby.rb", "lib/ambition/processors/select.rb", "lib/ambition/processors/slice.rb", "lib/ambition/processors/sort.rb", "lib/ambition/sexp_translator.rb", "lib/ambition.rb", "LICENSE", "README"]
+  s.files = ["app_generators/ambition_adapter/ambition_adapter_generator.rb", "app_generators/ambition_adapter/templates/lib/adapter/base.rb.erb", "app_generators/ambition_adapter/templates/lib/adapter/query.rb.erb", "app_generators/ambition_adapter/templates/lib/adapter/select.rb.erb", "app_generators/ambition_adapter/templates/lib/adapter/slice.rb.erb", "app_generators/ambition_adapter/templates/lib/adapter/sort.rb.erb", "app_generators/ambition_adapter/templates/lib/init.rb.erb", "app_generators/ambition_adapter/templates/LICENSE", "app_generators/ambition_adapter/templates/Rakefile", "app_generators/ambition_adapter/templates/README", "app_generators/ambition_adapter/templates/test/helper.rb.erb", "app_generators/ambition_adapter/templates/test/select_test.rb.erb", "app_generators/ambition_adapter/templates/test/slice_test.rb.erb", "app_generators/ambition_adapter/templates/test/sort_test.rb.erb", "app_generators/ambition_adapter/USAGE", "bin/ambition_adapter", "lib/ambition/api.rb", "lib/ambition/context.rb", "lib/ambition/core_ext.rb", "lib/ambition/enumerable.rb", "lib/ambition/processors/base.rb", "lib/ambition/processors/ruby.rb", "lib/ambition/processors/select.rb", "lib/ambition/processors/slice.rb", "lib/ambition/processors/sort.rb", "lib/ambition/sexp_translator.rb", "lib/ambition.rb", "LICENSE", "Manifest", "README", "test/adapters/exemplar/association_test.rb", "test/adapters/exemplar/count_test.rb", "test/adapters/exemplar/detect_test.rb", "test/adapters/exemplar/enumerable_test.rb", "test/adapters/exemplar/helper.rb", "test/adapters/exemplar/index_operator.rb", "test/adapters/exemplar/reject_test.rb", "test/adapters/exemplar/select_test.rb", "test/adapters/exemplar/slice_test.rb", "test/adapters/exemplar/sort_test.rb", "test/debug", "test/helper.rb", "ambition.gemspec"]
+  s.has_rdoc = true
+  s.homepage = %q{http://errtheblog.com/}
+  s.rdoc_options = ["--line-numbers", "--inline-source", "--title", "Ambition", "--main", "README"]
+  s.require_paths = ["lib"]
+  s.required_ruby_version = Gem::Requirement.new("= 1.8.6")
+  s.rubyforge_project = %q{err}
+  s.rubygems_version = %q{1.0.1}
+  s.summary = %q{Ambition builds yer API calls from plain jane Ruby.}
+
+  s.add_dependency(%qParseTree, ["= 2.0.1"])
+  s.add_dependency(%qruby2ruby, ["= 1.1.7"])
+  s.add_dependency(%qrubigen, ["= 1.1.1"])
+end
+
+
+# # Original Rakefile source (requires the Echoe gem):
+# 
+# require 'rake'
+# require 'rake/testtask'
+# require 'rake/rdoctask'
+# 
+# Version = '0.5.3'
+# 
+# module Rake::TaskManager
+#   def delete_task(task_class, *args, &block)
+#     task_name, deps = resolve_args(args)
+#     @tasks.delete(task_class.scope_name(@scope, task_name).to_s)
+#   end
+# end
+# class Rake::Task
+#   def self.delete_task(args, &block) Rake.application.delete_task(self, args, &block) end
+# end
+# def delete_task(args, &block) Rake::Task.delete_task(args, &block) end
+# 
+# begin
+#   require 'rubygems'
+#   gem 'echoe', '=2.7'
+#   ENV['RUBY_FLAGS'] = ""
+#   require 'echoe'
+# 
+#   Echoe.new('ambition', Version) do |p|
+#     p.project        = 'err'
+#     p.summary        = "Ambition builds yer API calls from plain jane Ruby."
+#     p.description    = "Ambition builds yer API calls from plain jane Ruby."
+#     p.url            = "http://errtheblog.com/"
+#     p.author         = 'Chris Wanstrath'
+#     p.email          = "chris@ozmm.org"
+#     p.ruby_version   = '= 1.8.6'
+#     p.ignore_pattern = /^(\.git|site|adapters).+/
+#     p.test_pattern   = 'test/*_test.rb'
+#     p.dependencies   'ParseTree =2.0.1'
+#     p.dependencies   'ruby2ruby =1.1.7'
+#     p.dependencies   'rubigen =1.1.1'
+#   end
+# 
+# rescue LoadError 
+#   puts "Not doing any of the Echoe gemmy stuff, because you don't have the specified gem versions"
+# end
+# 
+# delete_task :test
+# delete_task :install_gem
+# 
+# Rake::TestTask.new('test') do |t|
+#   t.pattern = 'test/*_test.rb'
+# end
+# 
+# Rake::TestTask.new('test:adapters') do |t|
+#   t.pattern = 'adapters/*/test/*_test.rb'
+# end
+# 
+# Dir['adapters/*'].each do |adapter|
+#   adapter = adapter.split('/').last
+#   Rake::TestTask.new("test:adapters:#{adapter.sub('ambitious_','')}") do |t|
+#     t.pattern = "adapters/#{adapter}/test/*_test.rb"
+#   end
+# end
+# 
+# desc 'Default: run unit tests.'
+# task :default = :test
+# 
+# desc 'Generate RDoc documentation'
+# Rake::RDocTask.new(:rdoc) do |rdoc|
+#   files = ['README', 'LICENSE', 'lib/**/*.rb']
+#   rdoc.rdoc_files.add(files)
+#   rdoc.main     = "README" 
+#   rdoc.title    = "ambition"
+#   # rdoc.template = File.exists?(t="/Users/chris/ruby/projects/err/rock/template.rb") ? t : "/var/www/rock/template.rb"
+#   rdoc.rdoc_dir = 'doc' 
+#   rdoc.options  '--inline-source'
+# end
+# 
+# desc 'Generate coverage reports'
+# task :rcov do
+#   `rcov -e gems test/*_test.rb`
+#   puts 'Generated coverage reports.'
+# end
+# 
+# desc 'Install as a gem'
+# task :install_gem do
+#   puts `rake manifest package && gem install pkg/ambition-#{Version}.gem`
+# end</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>5e94044e4647d94f9846791290e88cc37b175125</sha>
			<message>remove adapters from main repo</message>
			<author_name>Chris Wanstrath</author_name>
			<author_date>2008-04-26T09:11:48Z</author_date>
			<author_email>chris@ozmm.org</author_email>
			<committer_name>Chris Wanstrath</committer_name>
			<committer_date>2008-04-26T09:11:48Z</committer_date>
			<committer_email>chris@ozmm.org</committer_email>
			<files>
				<file>
					<file_name>adapters/ambitious_activeldap/Manifest</file_name>
					<diff>@@ -1,8 +0,0 @@
-lib/ambition/adapters/active_ldap/base.rb
-lib/ambition/adapters/active_ldap/query.rb
-lib/ambition/adapters/active_ldap/select.rb
-test/enumerable_test.rb
-test/helper.rb
-test/integration_test.rb
-test/select_test.rb
-Manifest</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activeldap/Rakefile</file_name>
					<diff>@@ -1,31 +0,0 @@
-require 'rake'
-
-Version = '0.1.0'
-
-begin
-  require 'rubygems'
-  gem 'echoe', '=2.7'
-  ENV['RUBY_FLAGS'] = ""
-  require 'echoe'
-
-  Echoe.new('ambitious-activeldap') do |p|
-    p.dependencies   'ruby-activeldap =0.8.3.1'
-    p.summary        = "An ambitious adapter for ActiveLDAP"
-    p.author         = 'Chris Wanstrath'
-    p.email          = "chris@ozmm.org"
-
-    p.project        = 'ambition'
-    p.url            = "http://ambition.rubyforge.org/"
-    p.test_pattern   = 'test/*_test.rb'
-    p.version        = Version
-    p.dependencies   'ambition =0.5.0'
-  end
-
-rescue LoadError 
-  puts "Not doing any of the Echoe gemmy stuff, because you don't have the specified gem versions"
-end
-
-desc 'Install as a gem'
-task :install_gem do
-  puts `rake manifest package && gem install pkg/ambitious-activeldap-#{Version}.gem`
-end</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activeldap/lib/ambition/adapters/active_ldap.rb</file_name>
					<diff>@@ -1,8 +0,0 @@
-require 'ambition'
-require 'active_ldap'
-require 'ambition/adapters/active_ldap/query'
-require 'ambition/adapters/active_ldap/base'
-require 'ambition/adapters/active_ldap/select'
-
-ActiveLdap::Base.extend Ambition::API
-ActiveLdap::Base.ambition_adapter = Ambition::Adapters::ActiveLdap</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activeldap/lib/ambition/adapters/active_ldap/base.rb</file_name>
					<diff>@@ -1,15 +0,0 @@
-module Ambition
-  module Adapters
-    module ActiveLdap
-      class Base
-        def sanitize(object)
-          case object
-          when true  then 'TRUE'
-          when false then 'FALSE'
-          else object.to_s
-          end
-        end
-      end
-    end
-  end
-end</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activeldap/lib/ambition/adapters/active_ldap/query.rb</file_name>
					<diff>@@ -1,27 +0,0 @@
-module Ambition
-  module Adapters
-    module ActiveLdap
-      class Query
-
-        def kick
-          owner.find(:all, to_hash)
-        end
-
-        def size
-          raise "Not Implemented"
-        end
-
-        def to_hash
-          hash = {}
-          hash[:filter] = to_s unless to_s.empty?
-          hash
-        end
-
-        def to_s
-          Array(clauses[:select]).join
-          clauses[:select].first.to_s
-        end
-      end
-    end
-  end
-end</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activeldap/lib/ambition/adapters/active_ldap/select.rb</file_name>
					<diff>@@ -1,65 +0,0 @@
-module Ambition
-  module Adapters
-    module ActiveLdap
-      class Select  Base
-        def call(*methods)
-          method = methods.first.to_s
-          if method[-1] == ??
-            "(#{method[0...-1]}=#{sanitize true})"
-          else
-            method
-          end
-        end
-
-        def chained_call(*methods)
-          call(*methods)
-        end
-
-        def both(left, right)
-          "(&#{left}#{sanitize right})"
-        end
-
-        def either(left, right)
-          "(|#{left}#{sanitize right})"
-        end
-
-        def ==(left, right)
-          "(#{left}=#{sanitize right})"
-        end
-
-        # !=
-        def not_equal(left, right)
-          "(!(#{left}=#{sanitize right}))"
-        end
-
-        def =~(left, right)
-        end
-
-        # !~
-        def not_regexp(left, right)
-        end
-
-        def (left, right)
-          self.=(left, right)
-        end
-
-        def (left, right)
-          self.=(left, right)
-        end
-
-        def =(left, right)
-          "(#{left}=#{sanitize right})"
-        end
-
-        def =(left, right)
-          "(#{left}=#{sanitize right})"
-        end
-
-        def include?(left, right)
-          bits = left.map { |item| "(#{right}=#{item})" }
-          "(|#{bits})"
-        end
-      end
-    end
-  end
-end</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activeldap/test/enumerable_test.rb</file_name>
					<diff>@@ -1,95 +0,0 @@
-require File.dirname(__FILE__) + '/helper'
-
-context "Each" do
-  specify "simple ==" do
-    hash = { :filter = "(uid=mking)" }
-    LDAPUser.expects(:find).with(:all, hash).returns([])
-    LDAPUser.select { |m| m.uid == 'mking' }.each do |user|
-      puts user.cn
-    end
-  end
-
-  xspecify "limit and conditions" do
-    hash = { :limit = 5, :filter = "(uid=mking)" }
-        LDAPUser.expects(:find).with(:all, hash).returns([])
-        LDAPUser.select { |m| m.uid == 'mking' }.first(5).each do |user|
-          puts user.cn
-        end
-  end
-
-  xspecify "limit and conditions and order" do
-    hash = { :limit = 5, :filter = "(uid=mking)", :sort_by = 'sn' }
-    LDAPUser.expects(:find).with(:all, hash).returns([])
-    LDAPUser.select { |m| m.uid == 'mking' }.sort_by { |m| m.sn }.first(5).each do |user|
-      puts user.cn
-    end
-  end
-
-  xspecify "limit and order" do
-    hash = { :limit = 5, :sort_by = 'sn' }
-    LDAPUser.expects(:find).with(:all, hash).returns([])
-    LDAPUser.sort_by { |m| m.sn }.first(5).each do |user|
-      puts user.name
-    end
-  end
-end
-
-context "Enumerable Methods" do
-  specify "map" do
-    hash = { :filter = "(uid=mking)" }
-    LDAPUser.expects(:find).with(:all, hash).returns([])
-    LDAPUser.select { |m| m.uid == 'mking' }.map { |u| u.name }
-  end
-
-  specify "each_with_index" do
-    hash = { :filter = "(uid=mking)" }
-    LDAPUser.expects(:find).with(:all, hash).returns([])
-    LDAPUser.select { |m| m.uid == 'mking' }.each_with_index do |user, i|
-      puts "#{i}: #{user.name}"
-    end
-  end
-
-  # specify "any?" do
-  #   LDAPUser.expects(:count).with(:conditions = "users.age  21").returns(1)
-  #   LDAPUser.any? { |u| u.age  21 }.should == true
-  # end
-
-#   specify "all?" do
-#     LDAPUser.expects(:count).at_least_once.returns(10, 20)
-#     LDAPUser.all? { |u| u.age  21 }.should == false
-# 
-#     LDAPUser.expects(:count).at_least_once.returns(10, 10)
-#     LDAPUser.all? { |u| u.age  21 }.should == true
-#   end
-# 
-#   specify "empty?" do
-#     LDAPUser.expects(:count).with(:conditions = "users.age  21").returns(1)
-#     LDAPUser.select { |u| u.age  21 }.empty?.should.equal false
-# 
-#     LDAPUser.expects(:count).with(:conditions = "users.age  21").returns(0)
-#     LDAPUser.select { |u| u.age  21 }.empty?.should.equal true
-#   end
-# 
-  specify "entries" do
-    LDAPUser.expects(:find).with(:all, {})
-    LDAPUser.entries
-
-    hash = { :filter = "(uid=mking)" }
-    LDAPUser.expects(:find).with(:all, hash).returns([])
-    LDAPUser.select { |m| m.uid == 'mking' }.entries
-  end
-
-  specify "to_a" do
-    LDAPUser.expects(:find).with(:all, {})
-    LDAPUser.to_a
-  end
-# 
-#   xspecify "each_slice" do
-#   end
-# 
-#   xspecify "max" do
-#   end
-# 
-#   xspecify "min" do
-#   end
-end</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activeldap/test/helper.rb</file_name>
					<diff>@@ -1,17 +0,0 @@
-%w( rubygems test/spec mocha redgreen English ).each { |f| require f }
-
-$LOAD_PATH.unshift *[ File.dirname(__FILE__) + '/../lib', File.dirname(__FILE__) + '/../../../lib' ]
-require 'ambition/adapters/active_ldap'
-
-ActiveLdap::Base.class_eval do
-  def self.find(*args)
-    'dummy find method'
-  end
-end
-
-class LDAPUser  ActiveLdap::Base
-  def self.table_name
-    # in real life would call the base class method on the ActiveLdap model class
-    'ou=people,dc=automatthew,dc=com'
-  end
-end</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activeldap/test/integration_test.rb</file_name>
					<diff>@@ -1,7 +0,0 @@
-require File.dirname(__FILE__) + '/helper'
-
-context "LDAP model after including LDAP Adapter" do
-  specify "should still have original find method" do
-    LDAPUser.find(:all).should == "dummy find method"
-  end
-end</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activeldap/test/select_test.rb</file_name>
					<diff>@@ -1,83 +0,0 @@
-require File.dirname(__FILE__) + '/helper'
-
-context "LDAP Adapter :: Select" do
-  context "Filter (using select)" do
-    specify "simple ==" do
-      filter = LDAPUser.select { |m| m.name == 'jon' }.to_s
-      filter.should == "(name=jon)"
-    end
-    
-    specify "simple !=" do
-      filter = LDAPUser.select { |m| m.name != 'jon' }.to_s
-      filter.should == "(!(name=jon))"
-    end
-
-    specify "simple == && ==" do
-      filter = LDAPUser.select { |m| m.name == 'jon' && m.age == 21 }.to_s
-      filter.should == "(&(name=jon)(age=21))"
-    end
-
-    specify "simple == || ==" do
-      filter = LDAPUser.select { |m| m.name == 'jon' || m.age == 21 }.to_s
-      filter.should == "(|(name=jon)(age=21))"
-    end
-    
-    specify "mixed && and ||" do
-      filter = LDAPUser.select { |m| m.name == 'jon' || m.age == 21 && m.password == 'pass' }.to_s
-      filter.should == "(|(name=jon)(&(age=21)(password=pass)))"
-    end
-
-    specify "grouped && and ||" do
-      filter = LDAPUser.select { |m| (m.name == 'jon' || m.name == 'rick') && m.age == 21 }.to_s
-      filter.should == "(&(|(name=jon)(name=rick))(age=21))"
-    end
-    
-    specify "simple /" do
-      # LDAP apparently only supports = and =
-      filter = LDAPUser.select { |m| m.age  21 }.to_s
-      filter.should == "(age=21)"
-
-      filter = LDAPUser.select { |m| m.age = 21 }.to_s
-      filter.should == "(age=21)"
-
-      filter = LDAPUser.select { |m| m.age  21 }.to_s
-      filter.should == "(age=21)"
-      
-      filter = LDAPUser.select { |m| m.age = 21 }.to_s
-      filter.should == "(age=21)"
-    end
-    
-    specify "array.include? item" do
-      filter = LDAPUser.select { |m| [1, 2, 3, 4].include? m.id }.to_s
-      # I'm not sure whether this is idiomatic, but it works.
-      filter.should == "(|(id=1)(id=2)(id=3)(id=4))"
-    end
-
-    specify "variable'd array.include? item" do
-      array = [1, 2, 3, 4]
-      filter = LDAPUser.select { |m| array.include? m.id }.to_s
-      filter.should == "(|(id=1)(id=2)(id=3)(id=4))"
-    end
-
-    specify "simple == with variables" do
-      me = 'chris'
-      filter = LDAPUser.select { |m| m.name == me }.to_s
-      filter.should == "(name=#{me})"
-    end
-    
-    specify "simple == with true" do
-      filter = LDAPUser.select { |m| m.disabled == true }.to_s
-      filter.should == "(disabled=TRUE)"
-    end
-    
-    xspecify "implicit true" do
-      filter = LDAPUser.select { |m| m.disabled }.to_s
-      filter.should == "(disabled=TRUE)"
-    end
-    
-    specify "predicate method" do
-      filter = LDAPUser.select { |m| m.disabled? }.to_s
-      filter.should == "(disabled=TRUE)"
-    end
-  end
-end</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activerecord/LICENSE</file_name>
					<diff>@@ -1,18 +0,0 @@
-Copyright (c) 2007 Chris Wanstrath
-
-Permission is hereby granted, free of charge, to any person obtaining a copy of 
-this software and associated documentation files (the "Software"), to deal in 
-the Software without restriction, including without limitation the rights to 
-use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of 
-the Software, and to permit persons to whom the Software is furnished to do so, 
-subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all 
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 
-FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR 
-COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 
-IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN 
-CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activerecord/Manifest</file_name>
					<diff>@@ -1,21 +0,0 @@
-lib/ambition/adapters/active_record/base.rb
-lib/ambition/adapters/active_record/query.rb
-lib/ambition/adapters/active_record/select.rb
-lib/ambition/adapters/active_record/slice.rb
-lib/ambition/adapters/active_record/sort.rb
-lib/ambition/adapters/active_record/statements.rb
-lib/ambition/adapters/active_record.rb
-test/benchmark.rb
-test/chaining_test.rb
-test/count_test.rb
-test/enumerable_test.rb
-test/helper.rb
-test/join_test.rb
-test/profiler.rb
-test/ruby_test.rb
-test/select_test.rb
-test/slice_test.rb
-test/sort_test.rb
-test/source_test.rb
-test/types_test.rb
-Manifest</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activerecord/README</file_name>
					<diff>@@ -1,234 +0,0 @@
-h2. An Ambitious ActiveRecord Adapter
-
-I could tell you all about how awesome the internals are, or 
-how fun it was to write, or how it'll make you rich and famous, 
-but instead I'm just going to show you some examples. 
-
-h2. Get It 
-
-@$ sudo gem install ambitious-activerecord@
-
-This will suck in the adapter and its dependencies (ActiveRecord & Ambition). 
-It's fully usable outside of Rails (I use it in a Camping app or two), as long
-as you're riding ActiveRecord.
-
-Now require it in your app:
-
-pre
-require 'rubygems'
-require 'ambition/adapters/activerecord'
-/pre
-
-h2. Examples
-
-Basically, you write your SQL in Ruby.  No, not in Ruby.  As Ruby.
-
-ruby
-User.select { |u| u.city == 'San Francisco' }.each do |user|
-  puts user.name
-end
-/ruby
-
-And that's it.
-
-The key is that queries aren't actually run until the data they represent is 
-requested. Usually this is done with what I call a kicker method. You can call them 
-that, too.
-
-Kicker methods are guys like @detect@, @each@, @each_with_index@, @map@, @entries@, 
-@to_a@, and @first@ (with no argument). Methods like @select@, @sort_by@, and @first@ 
-(with an argument) are not kicker methods and return a @Context@ object without running any SQL.
-
-Our @Context@ object has two useful methods: @to_s@ and @to_hash@.  With these,
-we can check out what exactly we're building.  Not everyone has @to_s@,
-though.  Mostly ignore these methods and treat everything like you normally
-would.
-
-See, @to_s@:
-
-ruby
- User.select { |m| m.name == 'jon' }.to_s
-= "SELECT * FROM users WHERE users.name = 'jon'"
-/ruby
-
-See, @to_hash@:
-
-ruby
- User.select { |m| m.name == 'jon' }.to_hash
-= { :conditions = "users.name = 'jon'" }
-/ruby
-
-h2. Equality - select { |u| u.field == 'bob' }
-
-ruby
-User.select { |m| m.name == 'jon' }
-"SELECT * FROM users WHERE users.name = 'jon'"
-
-User.select { |m| m.created_at  2.days.ago }
-"SELECT * FROM users WHERE users.created_at  '2007-09-26 20:37:47'"
-
-User.select { |m| m.name == 'jon' }
-"SELECT * FROM users WHERE users.name = 'jon'"
-
-User.select { |m| m.name != 'jon' }
-"SELECT * FROM users WHERE users.name  'jon'"
-
-User.select { |m| m.name == 'jon' && m.age == 21 }
-"SELECT * FROM users WHERE (users.name = 'jon' AND users.age = 21)"
-
-User.select { |m| m.name == 'jon' || m.age == 21 }
-"SELECT * FROM users WHERE (users.name = 'jon' OR users.age = 21)"
-  
-User.select { |m| m.name == 'jon' || m.age == 21 && m.password == 'pass' }
-"SELECT * FROM users WHERE 
- (users.name = 'jon' OR (users.age = 21 AND users.password = 'pass'))"
-
-User.select { |m| (m.name == 'jon' || m.name == 'rick') && m.age == 21 }
-"SELECT * FROM users WHERE 
- ((users.name = 'jon' OR users.name = 'rick') AND users.age = 21)"
-/ruby
-  
-h2. Associations - select { |u| u.field == 'bob' && u.association.field == 'bob@bob.com' }
-
-The @to_s@ method doesn't work on associations yet, but that's okay: they can 
-still query through ActiveRecord just fine.
-
-ruby
-User.select do |u| 
-  u.email == 'chris@ozmm.org' && u.profile.name == 'chris wanstrath' 
-end.map(&:title)
-
-"SELECT users.id AS t0_r0, ... FROM users 
- LEFT OUTER JOIN profiles ON profiles.user_id = users.id 
- WHERE ((users.email = 'chris@ozmm.org' AND profiles.name = 'chris wanstrath'))"
-/ruby
-
-h2. Comparisons - select { |u| u.age  21 }
-
-ruby
-User.select { |m| m.age  21 }
-"SELECT * FROM users WHERE users.age  21"
-
-User.select { |m| m.age  21 }.to_s
-"SELECT * FROM users WHERE users.age  21"
-
-User.select { |m| [1, 2, 3, 4].include? m.id }
-"SELECT * FROM users WHERE users.id IN (1, 2, 3, 4)"
-/ruby
-
-h2. LIKE and REGEXP (RLIKE) - select { |m| m.name =~ 'chris' }
-
-ruby
-User.select { |m| m.name =~ 'chris' }
-"SELECT * FROM users WHERE users.name LIKE 'chris'"
-
-User.select { |m| m.name =~ 'chri%' }
-"SELECT * FROM users WHERE users.name LIKE 'chri%'"
-
-User.select { |m| m.name !~ 'chris' }
-"SELECT * FROM users WHERE users.name NOT LIKE 'chris'"
-
-User.select { |m| !(m.name =~ 'chris') }
-"SELECT * FROM users WHERE users.name NOT LIKE 'chris'"
-
-User.select { |m| m.name =~ /chris/ }
-"SELECT * FROM users WHERE users.name REGEXP 'chris'"
-/ruby
-
-h2. #detect
-
-ruby
-User.detect { |m| m.name == 'chris' }
-"SELECT * FROM users WHERE users.name = 'chris' LIMIT 1"
-/ruby
-
-h2. LIMITs - first, first(x), [offset, limit], [range], slice
-
-ruby
-User.select { |m| m.name == 'jon' }.first
-"SELECT * FROM users WHERE users.name = 'jon' LIMIT 1"
-
-User.select { |m| m.name == 'jon' }.first(5)
-"SELECT * FROM users WHERE users.name = 'jon' LIMIT 5"
-
-User.select { |m| m.name == 'jon' }[10, 20]
-"SELECT * FROM users WHERE users.name = 'jon' LIMIT 10, 20"
-
-User.select { |m| m.name == 'jon' }[10..20]
-"SELECT * FROM users WHERE users.name = 'jon' LIMIT 10, 10"
-/ruby
-
-h2. ORDER - sort_by { |u| u.field }
-
-ruby
-User.select { |m| m.name == 'jon' }.sort_by { |m| m.name }
-"SELECT * FROM users WHERE users.name = 'jon' ORDER BY users.name"
-
-User.select { |m| m.name == 'jon' }.sort_by { |m| [ m.name,  m.age ] }
-"SELECT * FROM users WHERE users.name = 'jon' ORDER BY users.name, users.age"
-
-User.select { |m| m.name == 'jon' }.sort_by { |m| [ m.name,  -m.age ] }
-"SELECT * FROM users WHERE users.name = 'jon' 
- ORDER BY users.name, users.age DESC"
-
-User.select { |m| m.name == 'jon' }.sort_by { |m| [ -m.name,  -m.age ] }
-"SELECT * FROM users WHERE users.name = 'jon' 
- ORDER BY users.name DESC, users.age DESC"
-
-User.select { |m| m.name == 'jon' }.sort_by { |m| -m.age }
-"SELECT * FROM users WHERE users.name = 'jon' ORDER BY users.age DESC"
-
-User.select { |m| m.name == 'jon' }.sort_by { |m| -m.profiles.title }
-"SELECT users.id AS t0_r0, ... FROM users 
- LEFT OUTER JOIN profiles ON profiles.user_id = users.id 
- WHERE (users.name = 'jon') ORDER BY profiles.title DESC"
-
-User.select { |m| m.name == 'jon' }.sort_by { rand }
-"SELECT * FROM users WHERE users.name = 'jon' ORDER BY RAND()"
-/ruby
-
-h2. COUNT - select { |u| u.name == 'jon' }.size
-
-ruby
-User.select { |m| m.name == 'jon' }.size
-"SELECT count(*) AS count_all FROM users WHERE (users.name = 'jon')"
-
- User.select { |m| m.name == 'jon' }.size
-= 21
-/ruby
-
-h2. Other Enumerables
-
-These methods perform COUNT() operations rather than loading your array into memory.  They're all 
-kickers.
-  
-ruby  
-User.any? { |m| m.name == 'jon' }
-User.all? { |m| m.name == 'jon' }
-User.select { |m| m.name == 'jon' }.empty?
-/ruby
-
-h2. More Sugar
-
-The @downcase@ and @upcase@ methods will map to LOWER() and UPPER(), respectively.
-
-ruby
- User.select { |m| m.name.downcase =~ 'jon%' }.to_s
-= "SELECT * FROM users WHERE LOWER(users.name) LIKE 'jon%'"
-/ruby
-
-h2. Quoting
-
-Columns and values will be quoted using ActiveRecord's quote_column_name and quote methods, if
-possible.
-
-h2. SELECT * FROM bugs 
-
-Found a bug?  Sweet.  Add it at "the Lighthouse":http://err.lighthouseapp.com/projects/466-plugins/tickets/new.
-
-More information on Ambition:
-
-  * "http://ambition.rubyforge.org":http://ambition.rubyforge.org
-  * "http://groups.google.com/group/ambition-rb/":http://groups.google.com/group/ambition-rb/
-
-- Chris Wanstrath [ chris@ozmm.org ]</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activerecord/Rakefile</file_name>
					<diff>@@ -1,39 +0,0 @@
-require 'rake'
-
-Version = '0.1.2'
-
-begin
-  require 'rubygems'
-  gem 'echoe', '=2.7'
-  ENV['RUBY_FLAGS'] = ""
-  require 'echoe'
-
-  Echoe.new('ambitious-activerecord') do |p|
-    p.dependencies   'activerecord =1.15.0'
-    p.summary        = "An ambitious adapter for ActiveRecord"
-    p.author         = 'Chris Wanstrath'
-    p.email          = "chris@ozmm.org"
-
-    p.project        = 'ambition'
-    p.url            = "http://ambition.rubyforge.org/"
-    p.test_pattern   = 'test/*_test.rb'
-    p.version        = Version
-    p.dependencies   'ambition =0.5.1'
-  end
-
-rescue LoadError 
-  puts "Not doing any of the Echoe gemmy stuff, because you don't have the specified gem versions"
-
-  require 'rake/testtask'
-  Rake::TestTask.new do |t|
-    t.pattern = "test/*_test.rb"
-  end
-end
-
-desc 'Install as a gem'
-task :install_gem do
-  puts `rake manifest package && gem install pkg/ambitious-activerecord-#{Version}.gem`
-end
-
-task :default = :test 
-</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activerecord/lib/ambition/adapters/active_record.rb</file_name>
					<diff>@@ -1,11 +0,0 @@
-require 'ambition'
-require 'active_record'
-require 'ambition/adapters/active_record/query'
-require 'ambition/adapters/active_record/base'
-require 'ambition/adapters/active_record/select'
-require 'ambition/adapters/active_record/sort'
-require 'ambition/adapters/active_record/slice'
-require 'ambition/adapters/active_record/statements'
-
-ActiveRecord::Base.extend Ambition::API
-ActiveRecord::Base.ambition_adapter = Ambition::Adapters::ActiveRecord</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activerecord/lib/ambition/adapters/active_record/base.rb</file_name>
					<diff>@@ -1,57 +0,0 @@
-require 'active_record/connection_adapters/abstract/quoting'
-
-module Ambition
-  module Adapters
-    module ActiveRecord
-      class Base
-        include ::ActiveRecord::ConnectionAdapters::Quoting
-
-        def sanitize(value)
-          if value.is_a? Array
-            return value.map { |v| sanitize(v) }.join(', ')
-          end
-
-          case value
-          when true,  'true'  
-            '1'
-          when false, 'false' 
-            '0'
-          when Regexp
-            "'#{value.source}'"
-          else 
-            if active_connection?
-              ::ActiveRecord::Base.connection.quote(value) 
-            else
-              quote(value)
-            end
-          end
-        rescue
-          "'#{value}'"
-        end
-
-        def quote_column_name(value)
-          if active_connection?
-            ::ActiveRecord::Base.connection.quote_column_name(value) 
-          else
-            value.to_s
-          end
-        end
-
-        def active_connection?
-          ::ActiveRecord::Base.active_connection_name
-        end
-
-        def dbadapter_name
-          ::ActiveRecord::Base.connection.adapter_name
-        rescue ::ActiveRecord::ConnectionNotEstablished
-          'Abstract'
-        end
-
-        def statement(*args)
-          @statement_instance ||= DatabaseStatements.const_get(dbadapter_name).new
-          @statement_instance.send(*args)
-        end
-      end
-    end
-  end
-end</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activerecord/lib/ambition/adapters/active_record/query.rb</file_name>
					<diff>@@ -1,57 +0,0 @@
-module Ambition
-  module Adapters
-    module ActiveRecord
-      class Query
-        @@select = 'SELECT * FROM %s %s'
-
-        def kick
-          owner.find(:all, to_hash)
-        end
-
-        def size
-          owner.count(to_hash)
-        end
-        alias_method :length, :size
-
-        def to_hash
-          hash = {}
-
-          unless (where = clauses[:select]).blank?
-            hash[:conditions] = Array(where)
-            hash[:conditions] *= ' AND '
-          end
-
-          if order = clauses[:sort]
-            hash[:order] = order.join(', ')
-          end
-
-          if Array(clauses[:slice]).last =~ /LIMIT (\d+)/
-            hash[:limit] = $1.to_i
-          end
-
-          if Array(clauses[:slice]).last =~ /OFFSET (\d+)/
-            hash[:offset] = $1.to_i
-          end
-
-          hash[:include] = stash[:include] if stash[:include]
-
-          hash
-        end
-
-        def to_s
-          hash = to_hash
-
-          raise "Sorry, I can't construct SQL with complex joins (yet)" unless hash[:include].blank?
-
-          sql = []
-          sql  "WHERE #{hash[:conditions]}" unless hash[:conditions].blank?
-          sql  "ORDER BY #{hash[:order]}"   unless hash[:order].blank?
-          sql  clauses[:slice].last         unless hash[:slice].blank?
-
-          @@select % [ owner.table_name, sql.join(' ') ]
-        end
-        alias_method :to_sql, :to_s
-      end
-    end
-  end
-end</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activerecord/lib/ambition/adapters/active_record/select.rb</file_name>
					<diff>@@ -1,99 +0,0 @@
-module Ambition
-  module Adapters
-    module ActiveRecord
-      class Select  Base
-        def call(method)
-          "#{owner.table_name}.#{quote_column_name method}"
-        end
-
-        def chained_call(*methods)
-          if reflection = owner.reflections[methods.first]
-            stash[:include] ||= []
-            stash[:include]  methods.first
-            "#{reflection.table_name}.#{quote_column_name methods.last}"
-          elsif respond_to? methods[1]
-            send(methods[1], methods.first)
-          else
-            raise "I don't understand: #{methods.inspect}"
-          end
-        end
-
-        def both(left, right)
-          "(#{left} AND #{right})"
-        end
-
-        def either(left, right)
-          "(#{left} OR #{right})"
-        end
-
-        def ==(left, right)
-          if right.nil?
-            "#{left} IS NULL"
-          else
-            "#{left} = #{sanitize right}"
-          end
-        end
-
-        # !=
-        def not_equal(left, right)
-          if right.nil?
-            "#{left} IS NOT NULL"
-          else
-            "#{left}  #{sanitize right}"
-          end
-        end
-
-        def =~(left, right)
-          if right.is_a? Regexp
-            "#{left} #{statement(:regexp, right)} #{sanitize right}"
-          else
-            "#{left} LIKE #{sanitize right}"
-          end
-        end
-
-        # !~
-        def not_regexp(left, right)
-          if right.is_a? Regexp
-            "#{left} #{statement(:not_regexp, right)} #{sanitize right}"
-          else
-            "#{left} NOT LIKE #{sanitize right}"
-          end
-        end
-
-        def (left, right)
-          "#{left}  #{sanitize right}"
-        end
-
-        def (left, right)
-          "#{left}  #{sanitize right}"
-        end
-
-        def =(left, right)
-          "#{left} = #{sanitize right}"
-        end
-
-        def =(left, right)
-          "#{left} = #{sanitize right}"
-        end
-
-        def include?(left, right)
-          left = left.map { |element| sanitize element }.join(', ')
-          "#{right} IN (#{left})"
-        end
-
-        def nil?(column)
-          left = "#{owner.table_name}.#{quote_column_name column}"
-          negated? ? not_equal(left, nil) : self.==(left, nil)
-        end
-
-        def downcase(column)
-          "LOWER(#{owner.table_name}.#{quote_column_name column})"
-        end
-
-        def upcase(column)
-          "UPPER(#{owner.table_name}.#{quote_column_name column})"
-        end
-      end
-    end
-  end
-end</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activerecord/lib/ambition/adapters/active_record/slice.rb</file_name>
					<diff>@@ -1,19 +0,0 @@
-module Ambition
-  module Adapters
-    module ActiveRecord
-      class Slice  Base
-        def slice(start, length=nil)
-          if start.is_a? Range
-            length  = start.end
-            length -= 1 if start.exclude_end?
-            start = start.first - 1
-            length -= start
-          end
-          out  = "LIMIT #{length} "
-          out  "OFFSET #{start}" if start.to_i.nonzero?
-          out
-        end
-      end
-    end
-  end
-end</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activerecord/lib/ambition/adapters/active_record/sort.rb</file_name>
					<diff>@@ -1,43 +0,0 @@
-module Ambition
-  module Adapters
-    module ActiveRecord
-      class Sort  Base
-        def sort_by(method)
-          "#{owner.table_name}.#{quote_column_name method}" 
-        end
-
-        def reverse_sort_by(method)
-          "#{owner.table_name}.#{quote_column_name method} DESC" 
-        end
-
-        def chained_sort_by(receiver, method)
-          if reflection = owner.reflections[receiver]
-            stash[:include] ||= []
-            stash[:include]  receiver
-            "#{reflection.table_name}.#{quote_column_name method}"
-          else 
-            raise [ receiver, method ].inspect
-          end
-        end
-
-        def chained_reverse_sort_by(receiver, method)
-          if reflection = owner.reflections[receiver]
-            stash[:include] ||= []
-            stash[:include]  receiver
-            "#{reflection.table_name}.#{quote_column_name method} DESC"
-          else 
-            raise [ receiver, method ].inspect
-          end
-        end
-
-        def to_proc(symbol)
-          "#{owner.table_name}.#{symbol}"
-        end
-
-        def rand
-          'RAND()'
-        end
-      end
-    end
-  end
-end</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activerecord/lib/ambition/adapters/active_record/statements.rb</file_name>
					<diff>@@ -1,39 +0,0 @@
-module Ambition
-  module Adapters
-    module ActiveRecord
-      module DatabaseStatements
-        def self.const_missing(*args)
-          Abstract
-        end
-
-        class Abstract
-          def regexp(regexp)
-            'REGEXP'
-          end
-
-          def not_regexp(regexp)
-            'NOT REGEXP'
-          end
-        end
-
-        class PostgreSQL  Abstract
-          def regexp(regexp)
-            if regexp.options == 1
-              '~*'
-            else
-              '~'
-            end
-          end
-
-          def not_regexp(regexp)
-            if regexp.options == 1
-              '!~*'
-            else
-              '!~'
-            end
-          end
-        end
-      end
-    end
-  end
-end</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activerecord/test/benchmark.rb</file_name>
					<diff>@@ -1,69 +0,0 @@
-unless defined? Test
-  $:.unshift File.dirname(__FILE__) + '/../../../lib'
-  %w( rubygems ambition/adapters/active_record benchmark ).each { |f| require f }
-
-  class User  ActiveRecord::Base
-    def self.reflections
-      return @reflections if @reflections
-      @reflections = {}
-      @reflections[:ideas]    = Reflection.new(:has_many,   'user_id',     :ideas,   'ideas')
-      @reflections[:invites]  = Reflection.new(:has_many,   'referrer_id', :invites, 'invites')
-      @reflections[:profile]  = Reflection.new(:has_one,    'user_id',     :profile, 'profiles')
-      @reflections[:account]  = Reflection.new(:belongs_to, 'account_id',  :account, 'accounts')
-      @reflections
-    end
-
-    def self.table_name
-      'users'
-    end
-  end
-
-  class Reflection  Struct.new(:macro, :primary_key_name, :name, :table_name)
-  end
-
-  Times = 10000
-
-  Benchmark.bm(30) do |x|
-    x.report 'simple select' do
-      Times.times do
-        User.select { |u| u.id == 20 }.to_hash
-      end
-    end
-
-    x.report 'simple select w/ eval' do
-      Times.times do
-        User.select { |u| u.created_at == Time.now }.to_hash
-      end
-    end
-
-    x.report 'dual select' do
-      Times.times do
-        User.select { |u| u.id == 20 && u.age  20 }.to_hash
-      end
-    end
-
-    x.report 'join select' do
-      Times.times do
-        User.select { |u| u.id == 20 && u.ideas.name =~ /stuff/ }.to_hash
-      end
-    end
-
-    x.report 'dual select w/ sort' do
-      Times.times do
-        User.select { |u| u.id == 20 && u.age  20 }.sort_by { |u| u.id }.to_hash
-      end
-    end
-
-    x.report 'dual select w/ sort & first' do
-      Times.times do
-        User.select { |u| u.id == 20 && u.age  20 }.sort_by { |u| u.id }.first(20).to_hash
-      end
-    end
-
-    x.report "it's complicated" do
-      Times.times do
-        User.select { |u| (u.id == 20 && u.age  20) || u.profile.name == 'Jon' }.sort_by { |u| [u.id, -u.name] }.first(20).to_hash
-      end
-    end
-  end
-end</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activerecord/test/chaining_test.rb</file_name>
					<diff>@@ -1,36 +0,0 @@
-require File.dirname(__FILE__) + '/helper'
-
-context "ActiveRecord Adapter" do
-  context "Chaining" do
-    specify "should join selects with AND" do
-      sql = User.select { |m| m.name == 'jon' }
-      sql = sql.select { |m| m.age == 22 }
-      sql.to_s.should == "SELECT * FROM users WHERE users.name = 'jon' AND users.age = 22"
-    end
-
-    specify "should join sort_bys with a comma" do
-      sql = User.select { |m| m.name == 'jon' }
-      sql = sql.sort_by { |m| m.name }
-      sql = sql.sort_by { |m| m.age }
-      sql.to_s.should == "SELECT * FROM users WHERE users.name = 'jon' ORDER BY users.name, users.age"
-    end
-
-    specify "should join selects and sorts intelligently" do
-      sql = User.select { |m| m.name == 'jon' }
-      sql = sql.select { |m| m.age == 22 }
-      sql = sql.sort_by { |m| -m.name }
-      sql = sql.sort_by { |m| m.age }
-      sql.to_s.should == "SELECT * FROM users WHERE users.name = 'jon' AND users.age = 22 ORDER BY users.name DESC, users.age"
-    end
-
-    specify "should join lots of selects and sorts intelligently" do
-      sql = User.select { |m| m.name == 'jon' }
-      sql = sql.select { |m| m.age == 22 }
-      sql = sql.sort_by { |m| m.name }
-      sql = sql.select { |m| m.power == true }
-      sql = sql.sort_by { |m| m.email }
-      sql = sql.select { |m| m.admin == true && m.email == 'chris@ozmm.org' }
-      sql.to_s.should == "SELECT * FROM users WHERE users.name = 'jon' AND users.age = 22 AND users.power = 1 AND (users.admin = 1 AND users.email = 'chris@ozmm.org') ORDER BY users.name, users.email"
-    end
-  end
-end</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activerecord/test/count_test.rb</file_name>
					<diff>@@ -1,19 +0,0 @@
-require File.dirname(__FILE__) + '/helper'
-
-context "ActiveRecord Adapter" do
-  context "Count" do
-    setup do
-      hash = { :conditions = "users.name = 'jon'" }
-      User.expects(:count).with(hash)
-      @sql = User.select { |m| m.name == 'jon' }
-    end
-
-    specify "size" do
-      @sql.size
-    end
-
-    specify "length" do
-      @sql.length
-    end
-  end
-end</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activerecord/test/enumerable_test.rb</file_name>
					<diff>@@ -1,88 +0,0 @@
-require File.dirname(__FILE__) + '/helper'
-
-context "ActiveRecord Adapter" do
-  context "Each" do
-    specify "simple ==" do
-      hash = { :conditions = "users.age = 21" }
-      User.expects(:find).with(:all, hash).returns([])
-      User.select { |m| m.age == 21 }.each do |user|
-        puts user.name
-      end
-    end
-
-    specify "limit and conditions" do
-      hash = { :limit = 5, :conditions = "users.age = 21" }
-      User.expects(:find).with(:all, hash).returns([])
-      User.select { |m| m.age == 21 }.first(5).each do |user|
-        puts user.name
-      end
-    end
-
-    specify "limit and conditions and order" do
-      hash = { :limit = 5, :conditions = "users.age = 21", :order = 'users.name' }
-      User.expects(:find).with(:all, hash).returns([])
-      User.select { |m| m.age == 21 }.sort_by { |m| m.name }.first(5).each do |user|
-        puts user.name
-      end
-    end
-
-    specify "limit and order" do
-      hash = { :limit = 5, :order = 'users.name' }
-      User.expects(:find).with(:all, hash).returns([])
-      User.sort_by { |m| m.name }.first(5).each do |user|
-        puts user.name
-      end
-    end
-  end
-
-  context "Enumerable Methods" do
-    specify "map" do
-      hash = { :conditions = "users.age = 21" }
-      User.expects(:find).with(:all, hash).returns([])
-      User.select { |m| m.age == 21 }.map { |u| u.name }
-    end
-
-    specify "each_with_index" do
-      hash = { :conditions = "users.age = 21" }
-      User.expects(:find).with(:all, hash).returns([])
-      User.select { |m| m.age == 21 }.each_with_index do |user, i|
-        puts "#{i}: #{user.name}"
-      end
-    end
-
-    specify "any?" do
-      User.expects(:count).with(:conditions = "users.age  21").returns(1)
-      User.any? { |u| u.age  21 }.should == true
-    end
-
-    specify "all?" do
-      User.expects(:count).at_least_once.returns(10, 20)
-      User.all? { |u| u.age  21 }.should == false
-
-      User.expects(:count).at_least_once.returns(10, 10)
-      User.all? { |u| u.age  21 }.should == true
-    end
-
-    specify "empty?" do
-      User.expects(:count).with(:conditions = "users.age  21").returns(1)
-      User.select { |u| u.age  21 }.empty?.should.equal false
-
-      User.expects(:count).with(:conditions = "users.age  21").returns(0)
-      User.select { |u| u.age  21 }.empty?.should.equal true
-    end
-
-    specify "entries" do
-      User.expects(:find).with(:all, {})
-      User.entries
-
-      hash = { :conditions = "users.age = 21" }
-      User.expects(:find).with(:all, hash).returns([])
-      User.select { |m| m.age == 21 }.entries
-    end
-
-    specify "to_a" do
-      User.expects(:find).with(:all, {})
-      User.to_a
-    end
-  end
-end</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activerecord/test/helper.rb</file_name>
					<diff>@@ -1,47 +0,0 @@
-%w( rubygems test/spec mocha redgreen English ).each { |f| require f }
-
-$LOAD_PATH.unshift *[ File.dirname(__FILE__) + '/../lib', File.dirname(__FILE__) + '/../../../lib' ]
-require 'ambition/adapters/active_record'
-
-class User  ActiveRecord::Base 
-  def self.reflections
-    return @reflections if @reflections
-    @reflections = {}
-    @reflections[:ideas]    = Reflection.new(:has_many,   'user_id',     :ideas,   'ideas')
-    @reflections[:invites]  = Reflection.new(:has_many,   'referrer_id', :invites, 'invites')
-    @reflections[:profile]  = Reflection.new(:has_one,    'user_id',     :profile, 'profiles')
-    @reflections[:account]  = Reflection.new(:belongs_to, 'account_id',  :account, 'accounts')
-    @reflections
-  end
-
-  def self.table_name
-    'users'
-  end
-end
-
-class Reflection  Struct.new(:macro, :primary_key_name, :name, :table_name)
-end
-
-module ActiveRecord
-  module ConnectionAdapters
-    class MysqlAdapter  
-      def initialize(*args)
-        super
-      end
-
-      def connect(*args)
-        true
-      end
-    end
-
-    class PostgreSQLAdapter  
-      def connect(*args)
-        true
-      end
-      class PGError; end
-    end
-
-    class FakeAdapter  AbstractAdapter
-    end
-  end
-end</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activerecord/test/join_test.rb</file_name>
					<diff>@@ -1,62 +0,0 @@
-require File.dirname(__FILE__) + '/helper'
-
-context "ActiveRecord Adapter" do
-  context "Joins" do
-    specify "simple == on an association" do
-      sql = User.select { |m| m.account.email == 'chris@ozmm.org' }
-      sql.to_hash.should ==  { 
-        :conditions = "accounts.email = 'chris@ozmm.org'", 
-        :include = [:account] 
-      }
-    end
-
-    specify "simple mixed == on an association" do
-      sql = User.select { |m| m.name == 'chris' && m.account.email == 'chris@ozmm.org' }
-      sql.to_hash.should ==  { 
-        :conditions = "(users.name = 'chris' AND accounts.email = 'chris@ozmm.org')", 
-        :include = [:account] 
-      }
-    end
-
-    specify "multiple associations" do
-      sql = User.select { |m| m.ideas.title == 'New Freezer' || m.invites.email == 'pj@hyett.com' }
-      sql.to_hash.should ==  { 
-        :conditions = "(ideas.title = 'New Freezer' OR invites.email = 'pj@hyett.com')",
-        :include = [:ideas, :invites]
-      }
-    end
-
-    specify "belongs_to" do
-      sql = User.select { |m| m.account.id  20 }
-      sql.to_hash.should ==  { 
-        :conditions = "accounts.id  20",
-        :include    = [:account]
-      }
-    end
-
-    specify "complex joins have no to_s" do
-      sql = User.select { |m| m.account.id  20 }
-      should.raise { sql.to_s }
-    end
-
-    specify "non-existant associations" do
-      should.raise { User.select { |m| m.liquor.brand == 'Jack' } }
-    end
-
-    specify "in order" do
-      sql = User.sort_by { |m| m.ideas.title }
-      sql.to_hash.should ==  { 
-        :order   = "ideas.title",
-        :include = [:ideas]
-      }
-    end
-
-    specify "in a more complex order" do
-      sql = User.sort_by { |m| [ m.ideas.title, -m.invites.email ] }
-      sql.to_hash.should ==  { 
-        :order   = "ideas.title, invites.email DESC",
-        :include = [:ideas, :invites]
-      }
-    end
-  end
-end</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activerecord/test/profiler.rb</file_name>
					<diff>@@ -1,36 +0,0 @@
-$:.unshift File.dirname(__FILE__) + '/../../../lib'
-require 'rubygems'
-require 'ambition'
-require 'ambition/adapters/active_record'
-require 'ruby-prof'
-
-class User  ActiveRecord::Base
-  def self.reflections
-    return @reflections if @reflections
-    @reflections = {}
-    @reflections[:ideas]    = Reflection.new(:has_many,   'user_id',     :ideas,   'ideas')
-    @reflections[:invites]  = Reflection.new(:has_many,   'referrer_id', :invites, 'invites')
-    @reflections[:profile]  = Reflection.new(:has_one,    'user_id',     :profile, 'profiles')
-    @reflections[:account]  = Reflection.new(:belongs_to, 'account_id',  :account, 'accounts')
-    @reflections
-  end
-
-  def self.table_name
-    'users'
-  end
-end
-
-class Reflection  Struct.new(:macro, :primary_key_name, :name, :table_name)
-end
-
-result = RubyProf.profile do
-  1000.times do
-    User.select { |u| (u.id == 20 && u.age  20) || u.profile.name == 'Jon' }.sort_by { |u| [u.id, -u.name] }.first(20).to_hash
-  end
-end
-
-printer = RubyProf::FlatPrinter.new(result)
-#printer = RubyProf::GraphPrinter.new(result)
-printer.print(STDOUT, 0) 
-
-puts User.select { |u| (u.id == 20 && u.age  20) || u.profile.name == 'Jon' }.sort_by { |u| [u.id, -u.name] }.first(20).to_hash.inspect</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activerecord/test/ruby_test.rb</file_name>
					<diff>@@ -1,11 +0,0 @@
-require File.dirname(__FILE__) + '/helper'
-
-context "ActiveRecord Adapter" do
-  context "Inline Ruby" do
-    xspecify "should know what to return" do
-      name = 'David'
-      sql = User.select { |u| name.nil? || u.name == name }.to_s
-      sql.should == "SELECT * FROM users WHERE (users.name = 'David')"
-    end
-  end
-end</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activerecord/test/select_test.rb</file_name>
					<diff>@@ -1,259 +0,0 @@
-require File.dirname(__FILE__) + '/helper'
-
-context "ActiveRecord Adapter" do
-  context "Select" do
-    specify "simple ==" do
-      sql = User.select { |m| m.name == 'jon' }.to_s
-      sql.should == "SELECT * FROM users WHERE users.name = 'jon'"
-    end
-
-    specify "simple !=" do
-      sql = User.select { |m| m.name != 'jon' }.to_s
-      sql.should == "SELECT * FROM users WHERE users.name  'jon'"
-    end
-
-    specify "simple == && ==" do
-      sql = User.select { |m| m.name == 'jon' && m.age == 21 }.to_s
-      sql.should == "SELECT * FROM users WHERE (users.name = 'jon' AND users.age = 21)"
-    end
-
-    specify "simple == || ==" do
-      sql = User.select { |m| m.name == 'jon' || m.age == 21 }.to_s
-      sql.should == "SELECT * FROM users WHERE (users.name = 'jon' OR users.age = 21)"
-    end
-
-    specify "mixed && and ||" do
-      sql = User.select { |m| m.name == 'jon' || m.age == 21 && m.password == 'pass' }.to_s
-      sql.should == "SELECT * FROM users WHERE (users.name = 'jon' OR (users.age = 21 AND users.password = 'pass'))"
-    end
-
-    specify "grouped && and ||" do
-      sql = User.select { |m| (m.name == 'jon' || m.name == 'rick') && m.age == 21 }.to_s
-      sql.should == "SELECT * FROM users WHERE ((users.name = 'jon' OR users.name = 'rick') AND users.age = 21)"
-    end
-
-    specify "simple /" do
-      sql = User.select { |m| m.age  21 }.to_s
-      sql.should == "SELECT * FROM users WHERE users.age  21"
-
-      sql = User.select { |m| m.age = 21 }.to_s
-      sql.should == "SELECT * FROM users WHERE users.age = 21"
-
-      sql = User.select { |m| m.age  21 }.to_s
-      sql.should == "SELECT * FROM users WHERE users.age  21"
-    end
-
-    specify "array.include? item" do
-      sql = User.select { |m| [1, 2, 3, 4].include? m.id }.to_s
-      sql.should == "SELECT * FROM users WHERE users.id IN (1, 2, 3, 4)"
-    end
-
-    specify "variable'd array.include? item" do
-      array = [1, 2, 3, 4]
-      sql = User.select { |m| array.include? m.id }.to_s
-      sql.should == "SELECT * FROM users WHERE users.id IN (1, 2, 3, 4)"
-    end
-
-    specify "simple == with variables" do
-      me = 'chris'
-      sql = User.select { |m| m.name == me }.to_s
-      sql.should == "SELECT * FROM users WHERE users.name = '#{me}'"
-    end
-
-    specify "simple == with method arguments" do
-      def test_it(name)
-        sql = User.select { |m| m.name == name }.to_s
-        sql.should == "SELECT * FROM users WHERE users.name = '#{name}'"
-      end
-
-      test_it('chris')
-    end
-
-    specify "simple == with instance variables" do
-      @me = 'chris'
-      sql = User.select { |m| m.name == @me }.to_s
-      sql.should == "SELECT * FROM users WHERE users.name = '#{@me}'"
-    end
-
-    specify "simple == with instance variable method call" do
-      require 'ostruct'
-      @person = OpenStruct.new(:name = 'chris')
-
-      sql = User.select { |m| m.name == @person.name }.to_s
-      sql.should == "SELECT * FROM users WHERE users.name = '#{@person.name}'"
-    end
-
-    specify "simple == with global variables" do
-      $my_name = 'boston'
-      sql = User.select { |m| m.name == $my_name }.to_s
-      sql.should == "SELECT * FROM users WHERE users.name = '#{$my_name}'"
-    end
-
-    specify "simple == with method call" do
-      def band
-        'megadeth'
-      end
-
-      sql = User.select { |m| m.name == band }.to_s
-      sql.should == "SELECT * FROM users WHERE users.name = '#{band}'"
-    end
-
-    specify "simple =~ with string" do
-      sql = User.select { |m| m.name =~ 'chris' }.to_s
-      sql.should == "SELECT * FROM users WHERE users.name LIKE 'chris'"
-
-      sql = User.select { |m| m.name =~ 'chri%' }.to_s
-      sql.should == "SELECT * FROM users WHERE users.name LIKE 'chri%'"
-    end
-
-    specify "simple !~ with string" do
-      sql = User.select { |m| m.name !~ 'chris' }.to_s
-      sql.should == "SELECT * FROM users WHERE users.name NOT LIKE 'chris'"
-
-      sql = User.select { |m| !(m.name =~ 'chris') }.to_s
-      sql.should == "SELECT * FROM users WHERE users.name NOT LIKE 'chris'"
-    end
-
-    specify "simple =~ with regexp" do
-      sql = User.select { |m| m.name =~ /chris/ }.to_s
-      sql.should == "SELECT * FROM users WHERE users.name REGEXP 'chris'"
-    end
-
-    specify "simple =~ with regexp flags" do
-      sql = User.select { |m| m.name =~ /chris/i }.to_s
-      sql.should == "SELECT * FROM users WHERE users.name REGEXP 'chris'"
-    end
-
-    specify "simple LOWER()" do
-      sql = User.select { |m| m.name.downcase =~ 'chris%' }.to_s
-      sql.should == "SELECT * FROM users WHERE LOWER(users.name) LIKE 'chris%'"
-    end
-
-    specify "simple UPPER()" do
-      sql = User.select { |m| m.name.upcase =~ 'chris%' }.to_s
-      sql.should == "SELECT * FROM users WHERE UPPER(users.name) LIKE 'chris%'"
-    end
-
-    specify "undefined equality symbol" do
-      should.raise { User.select { |m| m.name =* /chris/ }.to_s }
-    end
-
-    specify "block variable / assigning variable conflict" do
-      m = User.select { |m| m.name == 'chris' }.to_s
-      m.should == "SELECT * FROM users WHERE users.name = 'chris'"
-    end
-    
-    specify "simple == with inline ruby" do
-      sql = User.select { |m| m.created_at == 2.days.ago.to_s(:db) }.to_s
-      sql.should == "SELECT * FROM users WHERE users.created_at = '#{2.days.ago.to_s(:db)}'"
-    end
-
-    specify "deep chains" do
-      should.raise do
-        User.select { |m| m.created_at.something.else.perhaps }.to_s
-      end
-    end
-
-    specify "inspect" do
-      User.select { |u| u.name }.inspect.should.match %r(call #to_s or #to_hash)
-    end
-  end
-
-  context "Detect" do
-    specify "simple ==" do
-      User.expects(:select).returns(mock(:first = true))
-      User.detect { |m| m.name == 'chris' }
-    end
-
-    specify "nothing found" do
-      User.expects(:select).returns(mock(:first = nil))
-      User.detect { |m| m.name == 'chris' }.should.be.nil
-    end
-  end
-
-  xcontext "[]" do
-    specify "finds a single row" do
-      User.expects(:find).with(1)
-      User[1]
-    end
-  end
-
-  context "PostgreSQL specific"  do
-    setup do
-      ActiveRecord::Base.connection = ActiveRecord::ConnectionAdapters::PostgreSQLAdapter.new 'fake_connection', 'fake_logger'
-    end
-
-    teardown do
-      ActiveRecord::Base.remove_connection
-    end
-
-    specify "quoting of column name" do
-      me = 'chris'
-      sql = User.select { |m| m.name == me }.to_s
-      sql.should == %(SELECT * FROM users WHERE users."name" = '#{me}')
-    end
-
-    specify "simple =~ with regexp" do
-      sql = User.select { |m| m.name =~ /chris/ }.to_s
-      sql.should == %(SELECT * FROM users WHERE users."name" ~ 'chris')
-    end
-
-    specify "insensitive =~" do
-      sql = User.select { |m| m.name =~ /chris/i }.to_s
-      sql.should == %(SELECT * FROM users WHERE users."name" ~* 'chris')
-    end
-
-    specify "negated =~" do
-      sql = User.select { |m| m.name !~ /chris/ }.to_s
-      sql.should == %(SELECT * FROM users WHERE users."name" !~ 'chris')
-    end
-
-    specify "negated insensitive =~" do
-      sql = User.select { |m| m.name !~ /chris/i }.to_s
-      sql.should == %(SELECT * FROM users WHERE users."name" !~* 'chris')
-    end
-  end
-
-  context "MySQL specific" do
-    setup do
-      ActiveRecord::Base.connection = ActiveRecord::ConnectionAdapters::MysqlAdapter.new('connection', 'logger')
-    end
-
-    teardown do
-      ActiveRecord::Base.connection = ActiveRecord::ConnectionAdapters::FakeAdapter.new('connection', 'logger')
-    end
-
-    specify "quoting of column name" do
-      me = 'chris'
-      sql = User.select { |m| m.name == me }.to_s
-      sql.should == "SELECT * FROM users WHERE users.`name` = '#{me}'"
-    end
-
-    specify "simple =~ with regexp" do
-      sql = User.select { |m| m.name =~ /chris/ }.to_s
-      sql.should == "SELECT * FROM users WHERE users.`name` REGEXP 'chris'"
-    end
-
-    specify "negated =~" do
-      sql = User.select { |m| m.name !~ 'chris' }.to_s
-      sql.should == "SELECT * FROM users WHERE users.`name` NOT LIKE 'chris'"
-    end
-
-    specify "negated =~ with regexp" do
-      sql = User.select { |m| m.name !~ /chris/ }.to_s
-      sql.should == "SELECT * FROM users WHERE users.`name` NOT REGEXP 'chris'"
-    end
-  end
-
-  context "Adapter without overrides" do
-    setup do
-      ActiveRecord::Base.connection = ActiveRecord::ConnectionAdapters::FakeAdapter.new('connection', 'logger')
-    end
-
-    specify "quoting of column name" do
-      me = 'chris'
-      sql = User.select { |m| m.name == me }.to_s
-      sql.should == "SELECT * FROM users WHERE users.name = '#{me}'"
-    end
-  end
-end</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activerecord/test/slice_test.rb</file_name>
					<diff>@@ -1,43 +0,0 @@
-require File.dirname(__FILE__) + '/helper'
-
-context "ActiveRecord Adapter" do
-  context "Slice" do
-    setup do
-      @sql = User.select { |m| m.name == 'jon' }
-    end
-
-    specify "first" do
-      conditions = { :conditions = "users.name = 'jon'", :limit = 1 }
-      User.expects(:find).with(:all, conditions)
-      @sql.first
-    end
-
-    specify "first with argument" do
-      conditions = { :conditions = "users.name = 'jon'", :limit = 5 }
-      User.expects(:find).with(:all, conditions)
-      @sql.first(5).entries
-    end
-    
-    specify "[] with two elements" do
-      conditions = { :conditions = "users.name = 'jon'", :limit = 20, :offset = 10 }
-      User.expects(:find).with(:all, conditions)
-      @sql[10, 20].entries
-
-      conditions = { :conditions = "users.name = 'jon'", :limit = 20, :offset = 20 }
-      User.expects(:find).with(:all, conditions)
-      @sql[20, 20].entries
-    end
-    
-    specify "slice is an alias of []" do
-      conditions = { :conditions = "users.name = 'jon'", :limit = 20, :offset = 10 }
-      User.expects(:find).with(:all, conditions)
-      @sql.slice(10, 20).entries
-    end
-    
-    specify "[] with range" do
-      conditions = { :conditions = "users.name = 'jon'", :limit = 10, :offset = 10 }
-      User.expects(:find).with(:all, conditions)
-      @sql[11..20].entries
-    end
-  end
-end</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activerecord/test/sort_test.rb</file_name>
					<diff>@@ -1,54 +0,0 @@
-require File.dirname(__FILE__) + '/helper'
-
-context "ActiveRecord Adapter" do
-  context "Sort" do
-    setup do
-      @sql = User.select { |m| m.name == 'jon' }
-    end
-
-    specify "simple order" do
-      string = @sql.sort_by { |m| m.name }.to_s
-      string.should == "SELECT * FROM users WHERE users.name = 'jon' ORDER BY users.name"
-    end
-
-    specify "simple combined order" do
-      string = @sql.sort_by { |m| [ m.name,  m.age ] }.to_s
-      string.should == "SELECT * FROM users WHERE users.name = 'jon' ORDER BY users.name, users.age"
-    end
-
-    specify "simple combined order with single reverse" do
-      string = @sql.sort_by { |m| [ m.name,  -m.age ] }.to_s
-      string.should == "SELECT * FROM users WHERE users.name = 'jon' ORDER BY users.name, users.age DESC"
-    end
-
-    specify "simple combined order with two reverses" do
-      string = @sql.sort_by { |m| [ -m.name,  -m.age ] }.to_s
-      string.should == "SELECT * FROM users WHERE users.name = 'jon' ORDER BY users.name DESC, users.age DESC"
-    end
-
-    specify "reverse order with -" do
-      string = @sql.sort_by { |m| -m.age }.to_s
-      string.should == "SELECT * FROM users WHERE users.name = 'jon' ORDER BY users.age DESC"
-    end
-
-    xspecify "reverse order with #reverse" do
-      # TODO: not implemented
-      string = @sql.sort_by { |m| m.age }.reverse.to_s
-      string.should == "SELECT * FROM users WHERE users.name = 'jon' ORDER BY users.age DESC"
-    end
-
-    specify "random order" do
-      string = @sql.sort_by { rand }.to_s
-      string.should == "SELECT * FROM users WHERE users.name = 'jon' ORDER BY RAND()"
-    end
-    
-    specify "non-existent method to sort by" do
-      should.raise(NoMethodError) { @sql.sort_by { foo }.to_s }
-    end
-
-    specify "Symbol#to_proc" do
-      string = User.sort_by(&:name).to_s
-      string.should == "SELECT * FROM users ORDER BY users.name"
-    end
-  end
-end</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activerecord/test/source_test.rb</file_name>
					<diff>@@ -1,43 +0,0 @@
-require File.dirname(__FILE__) + '/helper'
-require 'ostruct' 
-
-context "Setting the ambition_source" do
-  setup do
-#    @users = [
-#      OpenStruct.new(:name = 'Chris', :age = 22),
-#      OpenStruct.new(:name = 'PJ',    :age = 24),
-#      OpenStruct.new(:name = 'Kevin', :age = 23),
-#      OpenStruct.new(:name = '_why',  :age = 65)
-#    ]
-#    User.ambition_source = @users
-  end
-
-  teardown do
-#    User.ambition_source = nil
-  end
-
-  xspecify "should run all selects /  detects against that collection" do
-    User.detect { |u| u.name == 'Chris' }.should == @users.first
-  end
-
-  xspecify "should run all sorts against that collection" do
-    User.sort_by { |u| -u.age }.entries.should == @users.sort_by { |u| -u.age }
-  end
-
-  xspecify "should chain successfully" do
-    User.select { |u| u.age  22 }.sort_by { |u| -u.age }.entries.should == [ @users[3], @users[1], @users[2] ]
-  end
-
-  xspecify "should be able to revert to normal" do
-    block = proc { User.select { |m| m.name == 'PJ' }.first }
-
-    User.expects(:find).never
-    block.call.should == @users[1]
-
-    conditions = { :conditions = "users.name = 'PJ'", :limit = 1 }
-    User.expects(:find).with(:first, conditions)
-
-    User.ambition_source = nil
-    block.call
-  end
-end</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activerecord/test/types_test.rb</file_name>
					<diff>@@ -1,69 +0,0 @@
-require File.dirname(__FILE__) + '/helper'
-
-##
-# Once dynamically, once hardcoded
-context "Different types" do
-  types_hash = {
-        'string' = "'string'",
-         :symbol = "'--- :symbol\n'",
-               1 = '1',
-             1.2 = '1.2',
-            true = '1',
-           false = '0',
-        Time.now = "'#{Time.now.to_s(:db)}'",
-    DateTime.now = "'#{DateTime.now.to_s(:db)}'",
-      Date.today = "'#{Date.today.to_s(:db)}'"
-  }
-
-  types_hash.each do |type, translation|
-    specify "simple using #{type}" do
-      sql = User.select { |m| m.name == type }.to_s
-      sql.should == "SELECT * FROM users WHERE users.name = #{translation}"
-    end
-  end
-
-  specify "float" do
-    sql = User.select { |m| m.name == 1.2 }.to_s
-    sql.should == "SELECT * FROM users WHERE users.name = 1.2"
-  end
-  
-  specify "integer" do
-    sql = User.select { |m| m.name == 1 }.to_s
-    sql.should == "SELECT * FROM users WHERE users.name = 1"
-  end
-  
-  specify "true" do
-    sql = User.select { |m| m.name == true }.to_s
-    sql.should == "SELECT * FROM users WHERE users.name = 1"
-  end
-  
-  specify "false" do
-    sql = User.select { |m| m.name == false }.to_s
-    sql.should == "SELECT * FROM users WHERE users.name = 0"
-  end
-
-  specify "nil" do
-    sql = User.select { |m| m.name == nil }.to_s
-    sql.should == "SELECT * FROM users WHERE users.name IS NULL"
-  end
-
-  specify "not nil" do
-    sql = User.select { |m| m.name != nil }.to_s
-    sql.should == "SELECT * FROM users WHERE users.name IS NOT NULL"
-  end
-
-  specify "nil?" do
-    sql = User.select { |m| m.name.nil? }.to_s
-    sql.should == "SELECT * FROM users WHERE users.name IS NULL"
-  end
-
-  specify "!nil?" do
-    sql = User.select { |m| !m.name.nil? }.to_s
-    sql.should == "SELECT * FROM users WHERE users.name IS NOT NULL"
-  end
-
-  specify "Time" do
-    sql = User.select { |m| m.name == Time.now }.to_s
-    sql.should == "SELECT * FROM users WHERE users.name = '#{Time.now.to_s(:db)}'"
-  end
-end</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>828a22d86f92fda6aa82a420c7a86f77e02d6aa0</sha>
			<message>bump version</message>
			<author_name>Chris Wanstrath</author_name>
			<author_date>2008-04-26T09:07:36Z</author_date>
			<author_email>chris@ozmm.org</author_email>
			<committer_name>Chris Wanstrath</committer_name>
			<committer_date>2008-04-26T09:07:36Z</committer_date>
			<committer_email>chris@ozmm.org</committer_email>
			<files>
				<file>
					<file_name>Rakefile</file_name>
					<diff>@@ -2,7 +2,7 @@ require 'rake'
 require 'rake/testtask'
 require 'rake/rdoctask'
 
-Version = '0.5.2'
+Version = '0.5.3'
 
 module Rake::TaskManager
   def delete_task(task_class, *args, &block)</diff>
				</file>
				<file>
					<file_name>adapters/ambitious_activerecord/Rakefile</file_name>
					<diff>@@ -1,6 +1,6 @@
 require 'rake'
 
-Version = '0.1.1'
+Version = '0.1.2'
 
 begin
   require 'rubygems'</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>ceecabd0836d6f2d354724e80f353ad5f73ce2f8</sha>
			<message>ensure rubygems is loaded before loading parse tree</message>
			<author_name>Chris Wanstrath</author_name>
			<author_date>2008-04-24T19:55:19Z</author_date>
			<author_email>chris@ozmm.org</author_email>
			<committer_name>Chris Wanstrath</committer_name>
			<committer_date>2008-04-24T19:55:19Z</committer_date>
			<committer_email>chris@ozmm.org</committer_email>
			<files>
				<file>
					<file_name>lib/ambition/sexp_translator.rb</file_name>
					<diff>@@ -1,3 +1,4 @@
+require 'rubygems'
 require 'parse_tree'
 
 module Ambition #:nodoc:</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>953bb677652228a1e5310e2a2a3941674de52323</sha>
			<message>two pointless tweaks</message>
			<author_name>Chris Wanstrath</author_name>
			<author_date>2008-04-24T19:52:10Z</author_date>
			<author_email>chris@ozmm.org</author_email>
			<committer_name>Chris Wanstrath</committer_name>
			<committer_date>2008-04-24T19:52:10Z</committer_date>
			<committer_email>chris@ozmm.org</committer_email>
			<files>
				<file>
					<file_name>lib/ambition/processors/base.rb</file_name>
					<diff>@@ -10,18 +10,13 @@ def process_proc(exp)
       end
 
       def process_dasgn_curr(exp)
-        @receiver = exp.first
-        @receiver.to_s
+        (@receiver = exp.first).to_s
       end
       alias_method :process_dasgn, :process_dasgn_curr
 
       def process_array(exp)
         # Branch on whether this is straight Ruby or a real array
-        if ruby = rubify(exp)
-          ruby
-        else
-          exp.map { |m| process(m) }
-        end
+        rubify(exp) || exp.map { |m| process(m) }
       end
 
       def process_str(exp)
@@ -102,6 +97,7 @@ def translator
       def self.translator(context, name = nil)
         # Grok the adapter name
         name   ||= self.name.split('::').last
+
         # Get the module for it
         klass    = context.owner.ambition_adapter.const_get(name)
         instance = klass.new</diff>
				</file>
			</files>
		</commit>
		<commit>
			<sha>2b3240813f21d2f339e29bd9410e447c1a9b8771</sha>
			<message>fix breakage probably introduced by the new(er) method missing magic</message>
			<author_name>Chris Wanstrath</author_name>
			<author_date>2008-04-24T19:46:29Z</author_date>
			<author_email>chris@ozmm.org</author_email>
			<committer_name>Chris Wanstrath</committer_name>
			<committer_date>2008-04-24T19:46:29Z</committer_date>
			<committer_email>chris@ozmm.org</committer_email>
